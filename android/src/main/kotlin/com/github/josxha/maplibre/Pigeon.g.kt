// Autogenerated from Pigeon (v22.4.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")


import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Influences the y direction of the tile coordinates. */
enum class TileScheme(val raw: Int) {
  /** Slippy map tilenames scheme. */
  XYZ(0),
  /** OSGeo spec scheme. */
  TMS(1);

  companion object {
    fun ofRaw(raw: Int): TileScheme? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The encoding used by this source. Mapbox Terrain RGB is used by default. */
enum class RasterDemEncoding(val raw: Int) {
  /** Terrarium format PNG tiles. */
  TERRARIUM(0),
  /** Mapbox Terrain RGB tiles. */
  MAPBOX(1),
  /**
   * Decodes tiles using the redFactor, blueFactor, greenFactor, baseShift
   * parameters.
   */
  CUSTOM(2);

  companion object {
    fun ofRaw(raw: Int): RasterDemEncoding? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * A longitude/latitude coordinate object.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LngLat (
  /** The longitude */
  val lng: Double,
  /** The latitude */
  val lat: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LngLat {
      val lng = pigeonVar_list[0] as Double
      val lat = pigeonVar_list[1] as Double
      return LngLat(lng, lat)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      lng,
      lat,
    )
  }
}

/**
 * A pixel location / location on the device screen.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ScreenLocation (
  /** The x coordinate */
  val x: Double,
  /** The y coordinate */
  val y: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ScreenLocation {
      val x = pigeonVar_list[0] as Double
      val y = pigeonVar_list[1] as Double
      return ScreenLocation(x, y)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      x,
      y,
    )
  }
}

/**
 * The current position of the map camera.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MapCamera (
  val center: LngLat,
  val zoom: Double,
  val tilt: Double,
  val bearing: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MapCamera {
      val center = pigeonVar_list[0] as LngLat
      val zoom = pigeonVar_list[1] as Double
      val tilt = pigeonVar_list[2] as Double
      val bearing = pigeonVar_list[3] as Double
      return MapCamera(center, zoom, tilt, bearing)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      center,
      zoom,
      tilt,
      bearing,
    )
  }
}

/**
 * LatLng bound object
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LngLatBounds (
  val longitudeWest: Double,
  val longitudeEast: Double,
  val latitudeSouth: Double,
  val latitudeNorth: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LngLatBounds {
      val longitudeWest = pigeonVar_list[0] as Double
      val longitudeEast = pigeonVar_list[1] as Double
      val latitudeSouth = pigeonVar_list[2] as Double
      val latitudeNorth = pigeonVar_list[3] as Double
      return LngLatBounds(longitudeWest, longitudeEast, latitudeSouth, latitudeNorth)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      longitudeWest,
      longitudeEast,
      latitudeSouth,
      latitudeNorth,
    )
  }
}
private open class PigeonPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          TileScheme.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RasterDemEncoding.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LngLat.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenLocation.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapCamera.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LngLatBounds.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is TileScheme -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is RasterDemEncoding -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is LngLat -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is ScreenLocation -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is MapCamera -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is LngLatBounds -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

