import 'dart:convert';
import 'dart:io';

/// Generates static style expression bindings (CaseExpression, LetExpression, ...)
/// from the MapLibre style spec. Run with:
///   dart run tool/expressions.dart specUri
Future<void> main(List<String> args) async {
  final specUri = args.isNotEmpty
      ? Uri.parse(args.first)
      : Uri.parse(
          'https://unpkg.com/@maplibre/maplibre-gl-style-spec@24.4.1/dist/latest.json',
        );

  final spec = await _loadSpec(specUri);
  final expressions = _parseExpressions(spec)
    ..sort((a, b) => a.name.compareTo(b.name));

  final output = _resolveOutputFile();
  await _writeExpressionsFile(output, specUri, expressions);
  await _formatDart(output);

  stdout.writeln(
    'Generated ${expressions.length} expression classes -> ${output.path}',
  );
}

Future<Map<String, dynamic>> _loadSpec(Uri uri) async {
  if (uri.isScheme('file')) {
    final file = File(uri.toFilePath());
    if (!file.existsSync()) {
      throw FileSystemException('Spec file not found', file.path);
    }
    return json.decode(await file.readAsString()) as Map<String, dynamic>;
  }

  final client = HttpClient();
  final request = await client.getUrl(uri);
  final response = await request.close();
  final body = await response.transform(utf8.decoder).join();

  if (response.statusCode != HttpStatus.ok) {
    throw HttpException(
      'Failed to download spec (${response.statusCode})',
      uri: uri,
    );
  }

  return json.decode(body) as Map<String, dynamic>;
}

List<_ExpressionDef> _parseExpressions(Map<String, dynamic> spec) {
  final expressionSection = spec['expression_name'] as Map<String, dynamic>?;
  final values = expressionSection?['values'] as Map<String, dynamic>?;
  if (values == null) {
    throw StateError('expression_name.values not found in spec');
  }
  return values.entries
      .map(
        (entry) => _ExpressionDef(
          name: entry.key,
          doc: (entry.value as Map<String, dynamic>)['doc']?.toString(),
        ),
      )
      .toList();
}

Future<void> _writeExpressionsFile(
  File output,
  Uri specUri,
  List<_ExpressionDef> expressions,
) async {
  final buffer = StringBuffer()
    ..writeln('// GENERATED CODE - DO NOT MODIFY BY HAND.')
    ..writeln('// Generated by tool/expressions.dart from $specUri')
    ..writeln()
    ..writeln("import 'dart:convert';")
    ..writeln()
    ..writeln(
      '/// Base sealed class for MapLibre style expressions that serialize to JSON arrays.',
    )
    ..writeln('sealed class StyleExpression {')
    ..writeln('  const StyleExpression();')
    ..writeln('  List<Object?> toJson();')
    ..writeln('  @override')
    ..writeln('  String toString() => jsonEncode(toJson());')
    ..writeln('}')
    ..writeln()
    ..writeln('/// All supported expression operator names.')
    ..writeln('const expressionNames = <String>[');

  for (final expression in expressions) {
    buffer.writeln("  '${_dartString(expression.name)}',");
  }

  buffer
    ..writeln('];')
    ..writeln();

  for (final expression in expressions) {
    final className = _classNameFor(expression.name);
    final doc = expression.doc?.trim();
    if (doc != null && doc.isNotEmpty) {
      buffer.writeln('/// ${_docComment(doc)}');
    }
    buffer
      ..writeln('class $className extends StyleExpression {')
      ..writeln('  /// Creates a $className expression.')
      ..writeln('  const $className([this.args = const []]);')
      ..writeln(
        "  /// Expression operator name: '${_dartString(expression.name)}'.",
      )
      ..writeln(
        "  static const String operatorName = '${_dartString(expression.name)}';",
      )
      ..writeln(
        '  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.',
      )
      ..writeln('  final List<Object?> args;')
      ..writeln('  @override')
      ..writeln('  List<Object?> toJson() => [operatorName, ...args];')
      ..writeln('}')
      ..writeln();
  }

  await output.writeAsString(buffer.toString());
}

String _classNameFor(String operatorName) {
  const symbolMap = {
    '!': 'Not',
    '!=': 'NotEqual',
    '%': 'Mod',
    '*': 'Multiply',
    '+': 'Add',
    '-': 'Subtract',
    '/': 'Divide',
    '<': 'LessThan',
    '<=': 'LessThanOrEqual',
    '==': 'Equal',
    '>': 'GreaterThan',
    '>=': 'GreaterThanOrEqual',
    '^': 'Power',
  };

  final mapped = symbolMap[operatorName];
  if (mapped != null) {
    return '${mapped}Expression';
  }

  final parts = operatorName.split(RegExp('[^a-zA-Z0-9]+'));
  final capitalized = parts
      .where((p) => p.isNotEmpty)
      .map((p) => p[0].toUpperCase() + p.substring(1))
      .join();
  return '${capitalized}Expression';
}

String _dartString(String value) =>
    value.replaceAll(r'\', r'\\').replaceAll("'", r"\'");

String _docComment(String value) =>
    _dartString(value).replaceAll('\n', '\n/// ');

File _resolveOutputFile() {
  final scriptDir = File.fromUri(Platform.script).parent;
  final root = scriptDir.parent;
  final output = File(
    '${root.path}${Platform.pathSeparator}lib${Platform.pathSeparator}src${Platform.pathSeparator}expressions.dart',
  );
  output.parent.createSync(recursive: true);
  return output;
}

Future<void> _formatDart(File file) async {
  final result = await Process.run('dart', ['format', file.path]);
  if (result.exitCode != 0) {
    stderr.writeln('dart format failed: ${result.stderr}');
  }
}

class _ExpressionDef {
  _ExpressionDef({required this.name, this.doc});
  final String name;
  final String? doc;
}
