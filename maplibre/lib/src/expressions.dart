// GENERATED CODE - DO NOT MODIFY BY HAND.
// Generated by tool/expressions.dart from https://unpkg.com/@maplibre/maplibre-gl-style-spec@24.4.1/dist/latest.json

import 'dart:convert';

/// Base sealed class for MapLibre style expressions that serialize to JSON arrays.
sealed class StyleExpression {
  const StyleExpression();
  List<Object?> toJson();
  @override
  String toString() => jsonEncode(toJson());
}

/// All supported expression operator names.
const expressionNames = <String>[
  '!',
  '!=',
  '%',
  '*',
  '+',
  '-',
  '/',
  '<',
  '<=',
  '==',
  '>',
  '>=',
  '^',
  'abs',
  'accumulated',
  'acos',
  'all',
  'any',
  'array',
  'asin',
  'at',
  'atan',
  'boolean',
  'case',
  'ceil',
  'coalesce',
  'collator',
  'concat',
  'cos',
  'distance',
  'downcase',
  'e',
  'elevation',
  'feature-state',
  'floor',
  'format',
  'geometry-type',
  'get',
  'global-state',
  'has',
  'heatmap-density',
  'id',
  'image',
  'in',
  'index-of',
  'interpolate',
  'interpolate-hcl',
  'interpolate-lab',
  'is-supported-script',
  'length',
  'let',
  'line-progress',
  'literal',
  'ln',
  'ln2',
  'log10',
  'log2',
  'match',
  'max',
  'min',
  'number',
  'number-format',
  'object',
  'pi',
  'properties',
  'resolved-locale',
  'rgb',
  'rgba',
  'round',
  'sin',
  'slice',
  'sqrt',
  'step',
  'string',
  'tan',
  'to-boolean',
  'to-color',
  'to-number',
  'to-rgba',
  'to-string',
  'typeof',
  'upcase',
  'var',
  'within',
  'zoom',
];

/// Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.
///
///  - [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/create-and-style-clusters/)
class NotExpression extends StyleExpression {
  /// Creates a NotExpression expression.
  const NotExpression([this.args = const []]);

  /// Expression operator name: '!'.
  static const String operatorName = '!';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/display-html-clusters-with-custom-properties/)
class NotEqualExpression extends StyleExpression {
  /// Creates a NotEqualExpression expression.
  const NotEqualExpression([this.args = const []]);

  /// Expression operator name: '!='.
  static const String operatorName = '!=';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the remainder after integer division of the first input by the second.
class ModExpression extends StyleExpression {
  /// Creates a ModExpression expression.
  const ModExpression([this.args = const []]);

  /// Expression operator name: '%'.
  static const String operatorName = '%';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the product of the inputs.
class MultiplyExpression extends StyleExpression {
  /// Creates a MultiplyExpression expression.
  const MultiplyExpression([this.args = const []]);

  /// Expression operator name: '*'.
  static const String operatorName = '*';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the sum of the inputs.
class AddExpression extends StyleExpression {
  /// Creates a AddExpression expression.
  const AddExpression([this.args = const []]);

  /// Expression operator name: '+'.
  static const String operatorName = '+';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.
class SubtractExpression extends StyleExpression {
  /// Creates a SubtractExpression expression.
  const SubtractExpression([this.args = const []]);

  /// Expression operator name: '-'.
  static const String operatorName = '-';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the result of floating point division of the first input by the second.
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class DivideExpression extends StyleExpression {
  /// Creates a DivideExpression expression.
  const DivideExpression([this.args = const []]);

  /// Expression operator name: '/'.
  static const String operatorName = '/';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/display-html-clusters-with-custom-properties/)
class LessThanExpression extends StyleExpression {
  /// Creates a LessThanExpression expression.
  const LessThanExpression([this.args = const []]);

  /// Expression operator name: '<'.
  static const String operatorName = '<';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
class LessThanOrEqualExpression extends StyleExpression {
  /// Creates a LessThanOrEqualExpression expression.
  const LessThanOrEqualExpression([this.args = const []]);

  /// Expression operator name: '<='.
  static const String operatorName = '<=';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
///
///  - [Add multiple geometries from one GeoJSON source](https://maplibre.org/maplibre-gl-js/docs/examples/multiple-geometries/)
///
///  - [Create a time slider](https://maplibre.org/maplibre-gl-js/docs/examples/timeline-animation/)
///
///  - [Display buildings in 3D](https://maplibre.org/maplibre-gl-js/docs/examples/display-buildings-in-3d/)
///
///  - [Filter symbols by toggling a list](https://maplibre.org/maplibre-gl-js/docs/examples/filter-symbols-by-toggling-a-list/)
class EqualExpression extends StyleExpression {
  /// Creates a EqualExpression expression.
  const EqualExpression([this.args = const []]);

  /// Expression operator name: '=='.
  static const String operatorName = '==';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
class GreaterThanExpression extends StyleExpression {
  /// Creates a GreaterThanExpression expression.
  const GreaterThanExpression([this.args = const []]);

  /// Expression operator name: '>'.
  static const String operatorName = '>';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/display-html-clusters-with-custom-properties/)
class GreaterThanOrEqualExpression extends StyleExpression {
  /// Creates a GreaterThanOrEqualExpression expression.
  const GreaterThanOrEqualExpression([this.args = const []]);

  /// Expression operator name: '>='.
  static const String operatorName = '>=';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the result of raising the first input to the power specified by the second.
class PowerExpression extends StyleExpression {
  /// Creates a PowerExpression expression.
  const PowerExpression([this.args = const []]);

  /// Expression operator name: '^'.
  static const String operatorName = '^';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the absolute value of the input.
class AbsExpression extends StyleExpression {
  /// Creates a AbsExpression expression.
  const AbsExpression([this.args = const []]);

  /// Expression operator name: 'abs'.
  static const String operatorName = 'abs';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.
class AccumulatedExpression extends StyleExpression {
  /// Creates a AccumulatedExpression expression.
  const AccumulatedExpression([this.args = const []]);

  /// Expression operator name: 'accumulated'.
  static const String operatorName = 'accumulated';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the arccosine of the input.
class AcosExpression extends StyleExpression {
  /// Creates a AcosExpression expression.
  const AcosExpression([this.args = const []]);

  /// Expression operator name: 'acos'.
  static const String operatorName = 'acos';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/display-html-clusters-with-custom-properties/)
class AllExpression extends StyleExpression {
  /// Creates a AllExpression expression.
  const AllExpression([this.args = const []]);

  /// Expression operator name: 'all'.
  static const String operatorName = 'all';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.
class AnyExpression extends StyleExpression {
  /// Creates a AnyExpression expression.
  const AnyExpression([this.args = const []]);

  /// Expression operator name: 'any'.
  static const String operatorName = 'any';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Asserts that the input is an array (optionally with a specific item type and length). If, when the input expression is evaluated, it is not of the asserted type or length, then this assertion will cause the whole expression to be aborted.
class ArrayExpression extends StyleExpression {
  /// Creates a ArrayExpression expression.
  const ArrayExpression([this.args = const []]);

  /// Expression operator name: 'array'.
  static const String operatorName = 'array';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the arcsine of the input.
class AsinExpression extends StyleExpression {
  /// Creates a AsinExpression expression.
  const AsinExpression([this.args = const []]);

  /// Expression operator name: 'asin'.
  static const String operatorName = 'asin';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Retrieves an item from an array.
class AtExpression extends StyleExpression {
  /// Creates a AtExpression expression.
  const AtExpression([this.args = const []]);

  /// Expression operator name: 'at'.
  static const String operatorName = 'at';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the arctangent of the input.
class AtanExpression extends StyleExpression {
  /// Creates a AtanExpression expression.
  const AtanExpression([this.args = const []]);

  /// Expression operator name: 'atan'.
  static const String operatorName = 'atan';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.
///
///  - [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/create-a-hover-effect/)
class BooleanExpression extends StyleExpression {
  /// Creates a BooleanExpression expression.
  const BooleanExpression([this.args = const []]);

  /// Expression operator name: 'boolean'.
  static const String operatorName = 'boolean';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.
///
///  - [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/create-a-hover-effect/)
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/display-html-clusters-with-custom-properties/)
class CaseExpression extends StyleExpression {
  /// Creates a CaseExpression expression.
  const CaseExpression([this.args = const []]);

  /// Expression operator name: 'case'.
  static const String operatorName = 'case';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the smallest integer that is greater than or equal to the input.
class CeilExpression extends StyleExpression {
  /// Creates a CeilExpression expression.
  const CeilExpression([this.args = const []]);

  /// Expression operator name: 'ceil'.
  static const String operatorName = 'ceil';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Evaluates each expression in turn until the first non-null value is obtained, and returns that value.
///
///  - [Use a fallback image](https://maplibre.org/maplibre-gl-js/docs/examples/use-a-fallback-image/)
class CoalesceExpression extends StyleExpression {
  /// Creates a CoalesceExpression expression.
  const CoalesceExpression([this.args = const []]);

  /// Expression operator name: 'coalesce'.
  static const String operatorName = 'coalesce';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns a `collator` for use in locale-dependent comparison operations. Use `resolved-locale` to test the results of locale fallback behavior.
class CollatorExpression extends StyleExpression {
  /// Creates a CollatorExpression expression.
  const CollatorExpression([this.args = const []]);

  /// Expression operator name: 'collator'.
  static const String operatorName = 'collator';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.
///
///  - [Add a generated icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-a-generated-icon-to-the-map/)
///
///  - [Create a time slider](https://maplibre.org/maplibre-gl-js/docs/examples/create-a-time-slider/)
///
///  - [Use a fallback image](https://maplibre.org/maplibre-gl-js/docs/examples/fallback-image/)
///
///  - [Variable label placement](https://maplibre.org/maplibre-gl-js/docs/examples/variable-label-placement/)
class ConcatExpression extends StyleExpression {
  /// Creates a ConcatExpression expression.
  const ConcatExpression([this.args = const []]);

  /// Expression operator name: 'concat'.
  static const String operatorName = 'concat';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the cosine of the input.
class CosExpression extends StyleExpression {
  /// Creates a CosExpression expression.
  const CosExpression([this.args = const []]);

  /// Expression operator name: 'cos'.
  static const String operatorName = 'cos';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.
class DistanceExpression extends StyleExpression {
  /// Creates a DistanceExpression expression.
  const DistanceExpression([this.args = const []]);

  /// Expression operator name: 'distance'.
  static const String operatorName = 'distance';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.
///
///  - [Change the case of labels](https://maplibre.org/maplibre-gl-js/docs/examples/change-case-of-labels/)
class DowncaseExpression extends StyleExpression {
  /// Creates a DowncaseExpression expression.
  const DowncaseExpression([this.args = const []]);

  /// Expression operator name: 'downcase'.
  static const String operatorName = 'downcase';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the mathematical constant e.
class EExpression extends StyleExpression {
  /// Creates a EExpression expression.
  const EExpression([this.args = const []]);

  /// Expression operator name: 'e'.
  static const String operatorName = 'e';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Gets the elevation of a pixel (in meters above the vertical datum reference of the `raster-dem` tiles) from a `raster-dem` source. Can only be used in the `color-relief-color` property of a `color-relief` layer.
class ElevationExpression extends StyleExpression {
  /// Creates a ElevationExpression expression.
  const ElevationExpression([this.args = const []]);

  /// Expression operator name: 'elevation'.
  static const String operatorName = 'elevation';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Retrieves a property value from the current feature\'s state. Returns null if the requested property is not present on the feature\'s state. A feature\'s state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. When `source.promoteId` is not provided, features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. When `source.promoteId` is provided, features are identified by their `promoteId` property, which may be a number, string, or any primitive data type. Note that ["feature-state"] can only be used with paint properties that support data-driven styling.
///
///  - [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/create-a-hover-effect/)
class FeatureStateExpression extends StyleExpression {
  /// Creates a FeatureStateExpression expression.
  const FeatureStateExpression([this.args = const []]);

  /// Expression operator name: 'feature-state'.
  static const String operatorName = 'feature-state';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the largest integer that is less than or equal to the input.
class FloorExpression extends StyleExpression {
  /// Creates a FloorExpression expression.
  const FloorExpression([this.args = const []]);

  /// Expression operator name: 'floor'.
  static const String operatorName = 'floor';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`\'image\'`](#image) expression. Strings may be followed by a style override object.
///
///  - [Change the case of labels](https://maplibre.org/maplibre-gl-js/docs/examples/change-case-of-labels/)
///
///  - [Display and style rich text labels](https://maplibre.org/maplibre-gl-js/docs/examples/display-and-style-rich-text-labels/)
class FormatExpression extends StyleExpression {
  /// Creates a FormatExpression expression.
  const FormatExpression([this.args = const []]);

  /// Expression operator name: 'format'.
  static const String operatorName = 'format';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the feature\'s simple geometry type: `Point`, `LineString`, or `Polygon`. `MultiPoint`, `MultiLineString`, and `MultiPolygon` are returned as `Point`, `LineString`, and `Polygon`, respectively.
class GeometryTypeExpression extends StyleExpression {
  /// Creates a GeometryTypeExpression expression.
  const GeometryTypeExpression([this.args = const []]);

  /// Expression operator name: 'geometry-type'.
  static const String operatorName = 'geometry-type';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Retrieves a property value from the current feature\'s properties, or from another object if a second argument is provided. Returns null if the requested property is missing.
///
///  - [Change the case of labels](https://maplibre.org/maplibre-gl-js/docs/examples/change-case-of-labels/)
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/display-html-clusters-with-custom-properties/)
///
///  - [Extrude polygons for 3D indoor mapping](https://maplibre.org/maplibre-gl-js/docs/examples/extrude-polygons-for-3d-indoor-mapping/)
class GetExpression extends StyleExpression {
  /// Creates a GetExpression expression.
  const GetExpression([this.args = const []]);

  /// Expression operator name: 'get'.
  static const String operatorName = 'get';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Retrieves a property value from global state that can be set with platform-specific APIs. Defaults can be provided using the [`state`](https://maplibre.org/maplibre-style-spec/root/#state) root property. Returns `null` if no value nor default value is set for the retrieved property.
class GlobalStateExpression extends StyleExpression {
  /// Creates a GlobalStateExpression expression.
  const GlobalStateExpression([this.args = const []]);

  /// Expression operator name: 'global-state'.
  static const String operatorName = 'global-state';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Tests for the presence of a property value in the current feature\'s properties, or from another object if a second argument is provided.
///
///  - [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/create-and-style-clusters/)
class HasExpression extends StyleExpression {
  /// Creates a HasExpression expression.
  const HasExpression([this.args = const []]);

  /// Expression operator name: 'has'.
  static const String operatorName = 'has';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.
class HeatmapDensityExpression extends StyleExpression {
  /// Creates a HeatmapDensityExpression expression.
  const HeatmapDensityExpression([this.args = const []]);

  /// Expression operator name: 'heatmap-density'.
  static const String operatorName = 'heatmap-density';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Gets the feature\'s id, if it has one.
class IdExpression extends StyleExpression {
  /// Creates a IdExpression expression.
  const IdExpression([this.args = const []]);

  /// Expression operator name: 'id'.
  static const String operatorName = 'id';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.
///
///  - [Use a fallback image](https://maplibre.org/maplibre-gl-js/docs/examples/use-a-fallback-image/)
class ImageExpression extends StyleExpression {
  /// Creates a ImageExpression expression.
  const ImageExpression([this.args = const []]);

  /// Expression operator name: 'image'.
  static const String operatorName = 'image';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Determines whether an item exists in an array or a substring exists in a string.
///
///  - [Measure distances](https://maplibre.org/maplibre-gl-js/docs/examples/measure-distances/)
class InExpression extends StyleExpression {
  /// Creates a InExpression expression.
  const InExpression([this.args = const []]);

  /// Expression operator name: 'in'.
  static const String operatorName = 'in';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search. In a string, a UTF-16 surrogate pair counts as a single position.
class IndexOfExpression extends StyleExpression {
  /// Creates a IndexOfExpression expression.
  const IndexOfExpression([this.args = const []]);

  /// Expression operator name: 'index-of'.
  static const String operatorName = 'index-of';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). The `input` may be any numeric expression (e.g., `["get", "population"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, `color`, `array<color>`, or `projection`.
///
///  - [Animate map camera around a point](https://maplibre.org/maplibre-gl-js/docs/examples/animate-camera-around-point/)
///
///  - [Change building color based on zoom level](https://maplibre.org/maplibre-gl-js/docs/examples/change-building-color-based-on-zoom-level/)
///
///  - [Create a heatmap layer](https://maplibre.org/maplibre-gl-js/docs/examples/heatmap-layer/)
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class InterpolateExpression extends StyleExpression {
  /// Creates a InterpolateExpression expression.
  const InterpolateExpression([this.args = const []]);

  /// Expression operator name: 'interpolate'.
  static const String operatorName = 'interpolate';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). Works like `interpolate`, but the output type must be `color` or `array<color>`, and the interpolation is performed in the Hue-Chroma-Luminance color space.
class InterpolateHclExpression extends StyleExpression {
  /// Creates a InterpolateHclExpression expression.
  const InterpolateHclExpression([this.args = const []]);

  /// Expression operator name: 'interpolate-hcl'.
  static const String operatorName = 'interpolate-hcl';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). Works like `interpolate`, but the output type must be `color` or `array<color>`, and the interpolation is performed in the CIELAB color space.
class InterpolateLabExpression extends StyleExpression {
  /// Creates a InterpolateLabExpression expression.
  const InterpolateLabExpression([this.args = const []]);

  /// Expression operator name: 'interpolate-lab'.
  static const String operatorName = 'interpolate-lab';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the `mapbox-gl-rtl-text` plugin is not in use in MapLibre GL JS).
class IsSupportedScriptExpression extends StyleExpression {
  /// Creates a IsSupportedScriptExpression expression.
  const IsSupportedScriptExpression([this.args = const []]);

  /// Expression operator name: 'is-supported-script'.
  static const String operatorName = 'is-supported-script';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Gets the length of an array or string. In a string, a UTF-16 surrogate pair counts as a single position.
class LengthExpression extends StyleExpression {
  /// Creates a LengthExpression expression.
  const LengthExpression([this.args = const []]);

  /// Expression operator name: 'length'.
  static const String operatorName = 'length';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Binds expressions to named variables, which can then be referenced in the result expression using `["var", "variable_name"]`.
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class LetExpression extends StyleExpression {
  /// Creates a LetExpression expression.
  const LetExpression([this.args = const []]);

  /// Expression operator name: 'let'.
  static const String operatorName = 'let';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Gets the progress along a gradient line. Can only be used in the `line-gradient` property.
class LineProgressExpression extends StyleExpression {
  /// Creates a LineProgressExpression expression.
  const LineProgressExpression([this.args = const []]);

  /// Expression operator name: 'line-progress'.
  static const String operatorName = 'line-progress';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Provides a literal array or object value.
///
///  - [Display and style rich text labels](https://maplibre.org/maplibre-gl-js/docs/examples/display-and-style-rich-text-labels/)
class LiteralExpression extends StyleExpression {
  /// Creates a LiteralExpression expression.
  const LiteralExpression([this.args = const []]);

  /// Expression operator name: 'literal'.
  static const String operatorName = 'literal';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the natural logarithm of the input.
class LnExpression extends StyleExpression {
  /// Creates a LnExpression expression.
  const LnExpression([this.args = const []]);

  /// Expression operator name: 'ln'.
  static const String operatorName = 'ln';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the mathematical constant ln(2).
class Ln2Expression extends StyleExpression {
  /// Creates a Ln2Expression expression.
  const Ln2Expression([this.args = const []]);

  /// Expression operator name: 'ln2'.
  static const String operatorName = 'ln2';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the base-ten logarithm of the input.
class Log10Expression extends StyleExpression {
  /// Creates a Log10Expression expression.
  const Log10Expression([this.args = const []]);

  /// Expression operator name: 'log10'.
  static const String operatorName = 'log10';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the base-two logarithm of the input.
class Log2Expression extends StyleExpression {
  /// Creates a Log2Expression expression.
  const Log2Expression([this.args = const []]);

  /// Expression operator name: 'log2'.
  static const String operatorName = 'log2';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Selects the output whose label value matches the input value, or the fallback value if no match is found. The input can be any expression (e.g. `["get", "building_type"]`). Each label must be either:
///
///  - a single literal value; or
///
///  - an array of literal values, whose values must be all strings or all numbers (e.g. `[100, 101]` or `["c", "b"]`). The input matches if any of the values in the array matches, similar to the `"in"` operator.
///
/// Each label must be unique. If the input type does not match the type of the labels, the result will be the fallback value.
class MatchExpression extends StyleExpression {
  /// Creates a MatchExpression expression.
  const MatchExpression([this.args = const []]);

  /// Expression operator name: 'match'.
  static const String operatorName = 'match';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the maximum value of the inputs.
class MaxExpression extends StyleExpression {
  /// Creates a MaxExpression expression.
  const MaxExpression([this.args = const []]);

  /// Expression operator name: 'max'.
  static const String operatorName = 'max';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the minimum value of the inputs.
class MinExpression extends StyleExpression {
  /// Creates a MinExpression expression.
  const MinExpression([this.args = const []]);

  /// Expression operator name: 'min'.
  static const String operatorName = 'min';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.
class NumberExpression extends StyleExpression {
  /// Creates a NumberExpression expression.
  const NumberExpression([this.args = const []]);

  /// Expression operator name: 'number'.
  static const String operatorName = 'number';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Converts the input number into a string representation using the provided format_options.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/display-html-clusters-with-custom-properties/)
class NumberFormatExpression extends StyleExpression {
  /// Creates a NumberFormatExpression expression.
  const NumberFormatExpression([this.args = const []]);

  /// Expression operator name: 'number-format'.
  static const String operatorName = 'number-format';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.
class ObjectExpression extends StyleExpression {
  /// Creates a ObjectExpression expression.
  const ObjectExpression([this.args = const []]);

  /// Expression operator name: 'object'.
  static const String operatorName = 'object';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the mathematical constant pi.
class PiExpression extends StyleExpression {
  /// Creates a PiExpression expression.
  const PiExpression([this.args = const []]);

  /// Expression operator name: 'pi'.
  static const String operatorName = 'pi';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Gets the feature properties object.  Note that in some cases, it may be more efficient to use ["get", "property_name"] directly.
class PropertiesExpression extends StyleExpression {
  /// Creates a PropertiesExpression expression.
  const PropertiesExpression([this.args = const []]);

  /// Expression operator name: 'properties'.
  static const String operatorName = 'properties';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.
class ResolvedLocaleExpression extends StyleExpression {
  /// Creates a ResolvedLocaleExpression expression.
  const ResolvedLocaleExpression([this.args = const []]);

  /// Expression operator name: 'resolved-locale'.
  static const String operatorName = 'resolved-locale';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.
class RgbExpression extends StyleExpression {
  /// Creates a RgbExpression expression.
  const RgbExpression([this.args = const []]);

  /// Expression operator name: 'rgb'.
  static const String operatorName = 'rgb';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between zero and one. If any component is out of range, the expression is an error.
class RgbaExpression extends StyleExpression {
  /// Creates a RgbaExpression expression.
  const RgbaExpression([this.args = const []]);

  /// Expression operator name: 'rgba'.
  static const String operatorName = 'rgba';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `["round", -1.5]` evaluates to -2.
class RoundExpression extends StyleExpression {
  /// Creates a RoundExpression expression.
  const RoundExpression([this.args = const []]);

  /// Expression operator name: 'round'.
  static const String operatorName = 'round';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the sine of the input.
class SinExpression extends StyleExpression {
  /// Creates a SinExpression expression.
  const SinExpression([this.args = const []]);

  /// Expression operator name: 'sin'.
  static const String operatorName = 'sin';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns a subarray from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index. In a string, a UTF-16 surrogate pair counts as a single position.
class SliceExpression extends StyleExpression {
  /// Creates a SliceExpression expression.
  const SliceExpression([this.args = const []]);

  /// Expression operator name: 'slice'.
  static const String operatorName = 'slice';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the square root of the input.
class SqrtExpression extends StyleExpression {
  /// Creates a SqrtExpression expression.
  const SqrtExpression([this.args = const []]);

  /// Expression operator name: 'sqrt'.
  static const String operatorName = 'sqrt';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values ("stops"). The `input` may be any numeric expression (e.g., `["get", "population"]`). Stop inputs must be numeric literals in strictly ascending order.
///
/// Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.
///
///  - [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/create-and-style-clusters/)
class StepExpression extends StyleExpression {
  /// Creates a StepExpression expression.
  const StepExpression([this.args = const []]);

  /// Expression operator name: 'step'.
  static const String operatorName = 'step';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.
class StringExpression extends StyleExpression {
  /// Creates a StringExpression expression.
  const StringExpression([this.args = const []]);

  /// Expression operator name: 'string'.
  static const String operatorName = 'string';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the tangent of the input.
class TanExpression extends StyleExpression {
  /// Creates a TanExpression expression.
  const TanExpression([this.args = const []]);

  /// Expression operator name: 'tan'.
  static const String operatorName = 'tan';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Converts the input value to a boolean. The result is `false` when the input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.
class ToBooleanExpression extends StyleExpression {
  /// Creates a ToBooleanExpression expression.
  const ToBooleanExpression([this.args = const []]);

  /// Expression operator name: 'to-boolean'.
  static const String operatorName = 'to-boolean';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class ToColorExpression extends StyleExpression {
  /// Creates a ToColorExpression expression.
  const ToColorExpression([this.args = const []]);

  /// Expression operator name: 'to-color'.
  static const String operatorName = 'to-color';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the ["ToNumber Applied to the String Type" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.
class ToNumberExpression extends StyleExpression {
  /// Creates a ToNumberExpression expression.
  const ToNumberExpression([this.args = const []]);

  /// Expression operator name: 'to-number'.
  static const String operatorName = 'to-number';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns a four-element array containing the input color\'s red, green, blue, and alpha components, in that order.
class ToRgbaExpression extends StyleExpression {
  /// Creates a ToRgbaExpression expression.
  const ToRgbaExpression([this.args = const []]);

  /// Expression operator name: 'to-rgba'.
  static const String operatorName = 'to-rgba';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Converts the input value to a string. If the input is `null`, the result is `""`. If the input is a boolean, the result is `"true"` or `"false"`. If the input is a number, it is converted to a string as specified by the ["NumberToString" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `"rgba(r,g,b,a)"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.
///
///  - [Create a time slider](https://maplibre.org/maplibre-gl-js/docs/examples/create-a-time-slider/)
class ToStringExpression extends StyleExpression {
  /// Creates a ToStringExpression expression.
  const ToStringExpression([this.args = const []]);

  /// Expression operator name: 'to-string'.
  static const String operatorName = 'to-string';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns a string describing the type of the given value.
class TypeofExpression extends StyleExpression {
  /// Creates a TypeofExpression expression.
  const TypeofExpression([this.args = const []]);

  /// Expression operator name: 'typeof'.
  static const String operatorName = 'typeof';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.
///
///  - [Change the case of labels](https://maplibre.org/maplibre-gl-js/docs/examples/change-case-of-labels/)
class UpcaseExpression extends StyleExpression {
  /// Creates a UpcaseExpression expression.
  const UpcaseExpression([this.args = const []]);

  /// Expression operator name: 'upcase'.
  static const String operatorName = 'upcase';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// References variable bound using `let`.
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class VarExpression extends StyleExpression {
  /// Creates a VarExpression expression.
  const VarExpression([this.args = const []]);

  /// Expression operator name: 'var'.
  static const String operatorName = 'var';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:
///
/// - `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.
///
/// - `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line\'s endpoint is on the boundary.
class WithinExpression extends StyleExpression {
  /// Creates a WithinExpression expression.
  const WithinExpression([this.args = const []]);

  /// Expression operator name: 'within'.
  static const String operatorName = 'within';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}

/// Gets the current zoom level.  Note that in style layout and paint properties, ["zoom"] may only appear as the input to a top-level "step" or "interpolate" expression.
class ZoomExpression extends StyleExpression {
  /// Creates a ZoomExpression expression.
  const ZoomExpression([this.args = const []]);

  /// Expression operator name: 'zoom'.
  static const String operatorName = 'zoom';

  /// Arguments for this expression. Values must be JSON-serializable or nested [StyleExpression]s.
  final List<Object?> args;
  @override
  List<Object?> toJson() => [operatorName, ...args];
}
