// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: type=lint

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `android.graphics.BitmapFactory$Options`
class BitmapFactory$Options extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<BitmapFactory$Options> $type;

  @jni$_.internal
  BitmapFactory$Options.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/BitmapFactory$Options',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BitmapFactory$Options?> nullableType =
      $BitmapFactory$Options$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BitmapFactory$Options> type =
      $BitmapFactory$Options$Type$();
  static final _id_inBitmap = _class.instanceFieldId(
    r'inBitmap',
    r'Landroid/graphics/Bitmap;',
  );

  /// from: `public android.graphics.Bitmap inBitmap`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get inBitmap =>
      _id_inBitmap.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.graphics.Bitmap inBitmap`
  /// The returned object must be released after use, by calling the [release] method.
  set inBitmap(jni$_.JObject? value) =>
      _id_inBitmap.set(this, const jni$_.$JObject$NullableType$(), value);

  static final _id_inDensity = _class.instanceFieldId(
    r'inDensity',
    r'I',
  );

  /// from: `public int inDensity`
  int get inDensity => _id_inDensity.get(this, const jni$_.jintType());

  /// from: `public int inDensity`
  set inDensity(int value) =>
      _id_inDensity.set(this, const jni$_.jintType(), value);

  static final _id_inDither = _class.instanceFieldId(
    r'inDither',
    r'Z',
  );

  /// from: `public boolean inDither`
  bool get inDither => _id_inDither.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inDither`
  set inDither(bool value) =>
      _id_inDither.set(this, const jni$_.jbooleanType(), value);

  static final _id_inInputShareable = _class.instanceFieldId(
    r'inInputShareable',
    r'Z',
  );

  /// from: `public boolean inInputShareable`
  bool get inInputShareable =>
      _id_inInputShareable.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inInputShareable`
  set inInputShareable(bool value) =>
      _id_inInputShareable.set(this, const jni$_.jbooleanType(), value);

  static final _id_inJustDecodeBounds = _class.instanceFieldId(
    r'inJustDecodeBounds',
    r'Z',
  );

  /// from: `public boolean inJustDecodeBounds`
  bool get inJustDecodeBounds =>
      _id_inJustDecodeBounds.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inJustDecodeBounds`
  set inJustDecodeBounds(bool value) =>
      _id_inJustDecodeBounds.set(this, const jni$_.jbooleanType(), value);

  static final _id_inMutable = _class.instanceFieldId(
    r'inMutable',
    r'Z',
  );

  /// from: `public boolean inMutable`
  bool get inMutable => _id_inMutable.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inMutable`
  set inMutable(bool value) =>
      _id_inMutable.set(this, const jni$_.jbooleanType(), value);

  static final _id_inPreferQualityOverSpeed = _class.instanceFieldId(
    r'inPreferQualityOverSpeed',
    r'Z',
  );

  /// from: `public boolean inPreferQualityOverSpeed`
  bool get inPreferQualityOverSpeed =>
      _id_inPreferQualityOverSpeed.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inPreferQualityOverSpeed`
  set inPreferQualityOverSpeed(bool value) =>
      _id_inPreferQualityOverSpeed.set(this, const jni$_.jbooleanType(), value);

  static final _id_inPreferredColorSpace = _class.instanceFieldId(
    r'inPreferredColorSpace',
    r'Landroid/graphics/ColorSpace;',
  );

  /// from: `public android.graphics.ColorSpace inPreferredColorSpace`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get inPreferredColorSpace =>
      _id_inPreferredColorSpace.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.graphics.ColorSpace inPreferredColorSpace`
  /// The returned object must be released after use, by calling the [release] method.
  set inPreferredColorSpace(jni$_.JObject? value) => _id_inPreferredColorSpace
      .set(this, const jni$_.$JObject$NullableType$(), value);

  static final _id_inPreferredConfig = _class.instanceFieldId(
    r'inPreferredConfig',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `public android.graphics.Bitmap$Config inPreferredConfig`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get inPreferredConfig =>
      _id_inPreferredConfig.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.graphics.Bitmap$Config inPreferredConfig`
  /// The returned object must be released after use, by calling the [release] method.
  set inPreferredConfig(jni$_.JObject? value) => _id_inPreferredConfig.set(
    this,
    const jni$_.$JObject$NullableType$(),
    value,
  );

  static final _id_inPremultiplied = _class.instanceFieldId(
    r'inPremultiplied',
    r'Z',
  );

  /// from: `public boolean inPremultiplied`
  bool get inPremultiplied =>
      _id_inPremultiplied.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inPremultiplied`
  set inPremultiplied(bool value) =>
      _id_inPremultiplied.set(this, const jni$_.jbooleanType(), value);

  static final _id_inPurgeable = _class.instanceFieldId(
    r'inPurgeable',
    r'Z',
  );

  /// from: `public boolean inPurgeable`
  bool get inPurgeable => _id_inPurgeable.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inPurgeable`
  set inPurgeable(bool value) =>
      _id_inPurgeable.set(this, const jni$_.jbooleanType(), value);

  static final _id_inSampleSize = _class.instanceFieldId(
    r'inSampleSize',
    r'I',
  );

  /// from: `public int inSampleSize`
  int get inSampleSize => _id_inSampleSize.get(this, const jni$_.jintType());

  /// from: `public int inSampleSize`
  set inSampleSize(int value) =>
      _id_inSampleSize.set(this, const jni$_.jintType(), value);

  static final _id_inScaled = _class.instanceFieldId(
    r'inScaled',
    r'Z',
  );

  /// from: `public boolean inScaled`
  bool get inScaled => _id_inScaled.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inScaled`
  set inScaled(bool value) =>
      _id_inScaled.set(this, const jni$_.jbooleanType(), value);

  static final _id_inScreenDensity = _class.instanceFieldId(
    r'inScreenDensity',
    r'I',
  );

  /// from: `public int inScreenDensity`
  int get inScreenDensity =>
      _id_inScreenDensity.get(this, const jni$_.jintType());

  /// from: `public int inScreenDensity`
  set inScreenDensity(int value) =>
      _id_inScreenDensity.set(this, const jni$_.jintType(), value);

  static final _id_inTargetDensity = _class.instanceFieldId(
    r'inTargetDensity',
    r'I',
  );

  /// from: `public int inTargetDensity`
  int get inTargetDensity =>
      _id_inTargetDensity.get(this, const jni$_.jintType());

  /// from: `public int inTargetDensity`
  set inTargetDensity(int value) =>
      _id_inTargetDensity.set(this, const jni$_.jintType(), value);

  static final _id_inTempStorage = _class.instanceFieldId(
    r'inTempStorage',
    r'[B',
  );

  /// from: `public byte[] inTempStorage`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? get inTempStorage =>
      _id_inTempStorage.get(this, const jni$_.$JByteArray$NullableType$());

  /// from: `public byte[] inTempStorage`
  /// The returned object must be released after use, by calling the [release] method.
  set inTempStorage(jni$_.JByteArray? value) => _id_inTempStorage.set(
    this,
    const jni$_.$JByteArray$NullableType$(),
    value,
  );

  static final _id_mCancel = _class.instanceFieldId(
    r'mCancel',
    r'Z',
  );

  /// from: `public boolean mCancel`
  bool get mCancel => _id_mCancel.get(this, const jni$_.jbooleanType());

  /// from: `public boolean mCancel`
  set mCancel(bool value) =>
      _id_mCancel.set(this, const jni$_.jbooleanType(), value);

  static final _id_outColorSpace = _class.instanceFieldId(
    r'outColorSpace',
    r'Landroid/graphics/ColorSpace;',
  );

  /// from: `public android.graphics.ColorSpace outColorSpace`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get outColorSpace =>
      _id_outColorSpace.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.graphics.ColorSpace outColorSpace`
  /// The returned object must be released after use, by calling the [release] method.
  set outColorSpace(jni$_.JObject? value) =>
      _id_outColorSpace.set(this, const jni$_.$JObject$NullableType$(), value);

  static final _id_outConfig = _class.instanceFieldId(
    r'outConfig',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `public android.graphics.Bitmap$Config outConfig`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get outConfig =>
      _id_outConfig.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.graphics.Bitmap$Config outConfig`
  /// The returned object must be released after use, by calling the [release] method.
  set outConfig(jni$_.JObject? value) =>
      _id_outConfig.set(this, const jni$_.$JObject$NullableType$(), value);

  static final _id_outHeight = _class.instanceFieldId(
    r'outHeight',
    r'I',
  );

  /// from: `public int outHeight`
  int get outHeight => _id_outHeight.get(this, const jni$_.jintType());

  /// from: `public int outHeight`
  set outHeight(int value) =>
      _id_outHeight.set(this, const jni$_.jintType(), value);

  static final _id_outMimeType = _class.instanceFieldId(
    r'outMimeType',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String outMimeType`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get outMimeType =>
      _id_outMimeType.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String outMimeType`
  /// The returned object must be released after use, by calling the [release] method.
  set outMimeType(jni$_.JString? value) =>
      _id_outMimeType.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_outWidth = _class.instanceFieldId(
    r'outWidth',
    r'I',
  );

  /// from: `public int outWidth`
  int get outWidth => _id_outWidth.get(this, const jni$_.jintType());

  /// from: `public int outWidth`
  set outWidth(int value) =>
      _id_outWidth.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BitmapFactory$Options() {
    return BitmapFactory$Options.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_requestCancelDecode = _class.instanceMethodId(
    r'requestCancelDecode',
    r'()V',
  );

  static final _requestCancelDecode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void requestCancelDecode()`
  void requestCancelDecode() {
    _requestCancelDecode(
      reference.pointer,
      _id_requestCancelDecode as jni$_.JMethodIDPtr,
    ).check();
  }
}

final class $BitmapFactory$Options$NullableType$
    extends jni$_.JType<BitmapFactory$Options?> {
  @jni$_.internal
  const $BitmapFactory$Options$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/BitmapFactory$Options;';

  @jni$_.internal
  @core$_.override
  BitmapFactory$Options? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : BitmapFactory$Options.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<BitmapFactory$Options?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BitmapFactory$Options$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory$Options$NullableType$) &&
        other is $BitmapFactory$Options$NullableType$;
  }
}

final class $BitmapFactory$Options$Type$
    extends jni$_.JType<BitmapFactory$Options> {
  @jni$_.internal
  const $BitmapFactory$Options$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/BitmapFactory$Options;';

  @jni$_.internal
  @core$_.override
  BitmapFactory$Options fromReference(jni$_.JReference reference) =>
      BitmapFactory$Options.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<BitmapFactory$Options?> get nullableType =>
      const $BitmapFactory$Options$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BitmapFactory$Options$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory$Options$Type$) &&
        other is $BitmapFactory$Options$Type$;
  }
}

/// from: `android.graphics.BitmapFactory`
class BitmapFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<BitmapFactory> $type;

  @jni$_.internal
  BitmapFactory.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/BitmapFactory');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BitmapFactory?> nullableType =
      $BitmapFactory$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BitmapFactory> type = $BitmapFactory$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BitmapFactory() {
    return BitmapFactory.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_decodeByteArray = _class.staticMethodId(
    r'decodeByteArray',
    r'([BII)Landroid/graphics/Bitmap;',
  );

  static final _decodeByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeByteArray(byte[] bs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeByteArray(
    jni$_.JByteArray? bs,
    int i,
    int i1,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _decodeByteArray(
      _class.reference.pointer,
      _id_decodeByteArray as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeByteArray$1 = _class.staticMethodId(
    r'decodeByteArray',
    r'([BIILandroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeByteArray$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeByteArray(byte[] bs, int i, int i1, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeByteArray$1(
    jni$_.JByteArray? bs,
    int i,
    int i1,
    BitmapFactory$Options? options,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeByteArray$1(
      _class.reference.pointer,
      _id_decodeByteArray$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
      _$options.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeFile = _class.staticMethodId(
    r'decodeFile',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap;',
  );

  static final _decodeFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeFile(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeFile(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _decodeFile(
      _class.reference.pointer,
      _id_decodeFile as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeFile$1 = _class.staticMethodId(
    r'decodeFile',
    r'(Ljava/lang/String;Landroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeFile$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeFile(java.lang.String string, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeFile$1(
    jni$_.JString? string,
    BitmapFactory$Options? options,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeFile$1(
      _class.reference.pointer,
      _id_decodeFile$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$options.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeFileDescriptor = _class.staticMethodId(
    r'decodeFileDescriptor',
    r'(Ljava/io/FileDescriptor;)Landroid/graphics/Bitmap;',
  );

  static final _decodeFileDescriptor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeFileDescriptor(
    jni$_.JObject? fileDescriptor,
  ) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return _decodeFileDescriptor(
      _class.reference.pointer,
      _id_decodeFileDescriptor as jni$_.JMethodIDPtr,
      _$fileDescriptor.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeFileDescriptor$1 = _class.staticMethodId(
    r'decodeFileDescriptor',
    r'(Ljava/io/FileDescriptor;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeFileDescriptor$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fileDescriptor, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeFileDescriptor$1(
    jni$_.JObject? fileDescriptor,
    jni$_.JObject? rect,
    BitmapFactory$Options? options,
  ) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeFileDescriptor$1(
      _class.reference.pointer,
      _id_decodeFileDescriptor$1 as jni$_.JMethodIDPtr,
      _$fileDescriptor.pointer,
      _$rect.pointer,
      _$options.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeResource = _class.staticMethodId(
    r'decodeResource',
    r'(Landroid/content/res/Resources;I)Landroid/graphics/Bitmap;',
  );

  static final _decodeResource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeResource(android.content.res.Resources resources, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeResource(
    jni$_.JObject? resources,
    int i,
  ) {
    final _$resources = resources?.reference ?? jni$_.jNullReference;
    return _decodeResource(
      _class.reference.pointer,
      _id_decodeResource as jni$_.JMethodIDPtr,
      _$resources.pointer,
      i,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeResource$1 = _class.staticMethodId(
    r'decodeResource',
    r'(Landroid/content/res/Resources;ILandroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeResource$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeResource(android.content.res.Resources resources, int i, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeResource$1(
    jni$_.JObject? resources,
    int i,
    BitmapFactory$Options? options,
  ) {
    final _$resources = resources?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeResource$1(
      _class.reference.pointer,
      _id_decodeResource$1 as jni$_.JMethodIDPtr,
      _$resources.pointer,
      i,
      _$options.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeResourceStream = _class.staticMethodId(
    r'decodeResourceStream',
    r'(Landroid/content/res/Resources;Landroid/util/TypedValue;Ljava/io/InputStream;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeResourceStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeResourceStream(android.content.res.Resources resources, android.util.TypedValue typedValue, java.io.InputStream inputStream, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeResourceStream(
    jni$_.JObject? resources,
    jni$_.JObject? typedValue,
    jni$_.JObject? inputStream,
    jni$_.JObject? rect,
    BitmapFactory$Options? options,
  ) {
    final _$resources = resources?.reference ?? jni$_.jNullReference;
    final _$typedValue = typedValue?.reference ?? jni$_.jNullReference;
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeResourceStream(
      _class.reference.pointer,
      _id_decodeResourceStream as jni$_.JMethodIDPtr,
      _$resources.pointer,
      _$typedValue.pointer,
      _$inputStream.pointer,
      _$rect.pointer,
      _$options.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeStream = _class.staticMethodId(
    r'decodeStream',
    r'(Ljava/io/InputStream;)Landroid/graphics/Bitmap;',
  );

  static final _decodeStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeStream(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeStream(
    jni$_.JObject? inputStream,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return _decodeStream(
      _class.reference.pointer,
      _id_decodeStream as jni$_.JMethodIDPtr,
      _$inputStream.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_decodeStream$1 = _class.staticMethodId(
    r'decodeStream',
    r'(Ljava/io/InputStream;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeStream$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeStream(java.io.InputStream inputStream, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? decodeStream$1(
    jni$_.JObject? inputStream,
    jni$_.JObject? rect,
    BitmapFactory$Options? options,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeStream$1(
      _class.reference.pointer,
      _id_decodeStream$1 as jni$_.JMethodIDPtr,
      _$inputStream.pointer,
      _$rect.pointer,
      _$options.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }
}

final class $BitmapFactory$NullableType$ extends jni$_.JType<BitmapFactory?> {
  @jni$_.internal
  const $BitmapFactory$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/BitmapFactory;';

  @jni$_.internal
  @core$_.override
  BitmapFactory? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : BitmapFactory.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<BitmapFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BitmapFactory$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory$NullableType$) &&
        other is $BitmapFactory$NullableType$;
  }
}

final class $BitmapFactory$Type$ extends jni$_.JType<BitmapFactory> {
  @jni$_.internal
  const $BitmapFactory$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/BitmapFactory;';

  @jni$_.internal
  @core$_.override
  BitmapFactory fromReference(jni$_.JReference reference) =>
      BitmapFactory.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<BitmapFactory?> get nullableType =>
      const $BitmapFactory$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BitmapFactory$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory$Type$) &&
        other is $BitmapFactory$Type$;
  }
}
