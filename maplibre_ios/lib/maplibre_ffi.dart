// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element, unused_field, return_of_invalid_type, void_checks, annotate_overrides, no_leading_underscores_for_local_identifiers, library_private_types_in_public_api
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_wjovn7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_wjvic9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

final class CGPoint extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

final class CGSize extends ffi.Struct {
  @ffi.Double()
  external double width;

  @ffi.Double()
  external double height;
}

final class CGRect extends ffi.Struct {
  external CGPoint origin;

  external CGSize size;
}

final class CGAffineTransform extends ffi.Struct {
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;
}

final class _NSZone extends ffi.Opaque {}

enum NSQualityOfService {
  NSQualityOfServiceUserInteractive(33),
  NSQualityOfServiceUserInitiated(25),
  NSQualityOfServiceUtility(17),
  NSQualityOfServiceBackground(9),
  NSQualityOfServiceDefault(-1);

  final int value;
  const NSQualityOfService(this.value);

  static NSQualityOfService fromValue(int value) => switch (value) {
        33 => NSQualityOfServiceUserInteractive,
        25 => NSQualityOfServiceUserInitiated,
        17 => NSQualityOfServiceUtility,
        9 => NSQualityOfServiceBackground,
        -1 => NSQualityOfServiceDefault,
        _ =>
          throw ArgumentError("Unknown value for NSQualityOfService: $value"),
      };
}

/// WARNING: NSProgress is a stub. To generate bindings for this class, include
/// NSProgress in your config's objc-interfaces list.
///
/// NSProgress
class NSProgress extends objc.NSObject {
  NSProgress._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSProgress] that points to the same underlying object as [other].
  NSProgress.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSProgress] that wraps the given raw object pointer.
  NSProgress.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function()>>()
        .asFunction<void Function()>()();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_fnPtrCallable = ffi.Pointer
        .fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_fnPtrTrampoline)
    .cast();
void _ObjCBlock_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    (objc.getBlockClosure(block) as void Function())();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_closureCallable = ffi.Pointer
        .fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_closureTrampoline)
    .cast();
void _ObjCBlock_ffiVoid_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) {
  (objc.getBlockClosure(block) as void Function())();
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_listenerTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function()>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr) =>
      objc.ObjCBlock<ffi.Void Function()>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(void Function() fn) =>
      objc.ObjCBlock<ffi.Void Function()>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_closureCallable, () => fn()),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function()> listener(void Function() fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_listenerCallable.nativeFunction.cast(), () => fn());
    final wrapper = _MapLibreFFi_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

ffi.Pointer<objc.ObjCBlockImpl>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCBlockImpl> Function(
                        ffi.Pointer<objc.ObjCObject> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCBlockImpl> Function(
                    ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCBlockImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCBlockImpl>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCBlockImpl>
            Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCBlockImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>`.
abstract final class ObjCBlock_NSProgressUnpublishingHandler_NSProgress {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.ObjCBlock<ffi.Void Function()>? Function(
                  NSProgress)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCBlockImpl> Function(
                          ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
          objc.newPointerBlock(
              _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)> fromFunction(
          objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress) fn) =>
      objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
          objc.newClosureBlock(
              _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) =>
                  fn(NSProgress.castFromPointer(arg0, retain: true, release: true))
                      ?.ref
                      .retainAndAutorelease() ??
                  ffi.nullptr),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>`.
extension ObjCBlock_NSProgressUnpublishingHandler_NSProgress_CallExtension
    on objc
    .ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)> {
  objc.ObjCBlock<ffi.Void Function()>? call(NSProgress arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCBlockImpl> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : ObjCBlock_ffiVoid.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true);
}

/// WARNING: NSBundle is a stub. To generate bindings for this class, include
/// NSBundle in your config's objc-interfaces list.
///
/// NSBundle
class NSBundle extends objc.NSObject {
  NSBundle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSBundle] that points to the same underlying object as [other].
  NSBundle.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSBundle] that wraps the given raw object pointer.
  NSBundle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum NSAttributedStringEnumerationOptions {
  NSAttributedStringEnumerationReverse(2),
  NSAttributedStringEnumerationLongestEffectiveRangeNotRequired(1048576);

  final int value;
  const NSAttributedStringEnumerationOptions(this.value);

  static NSAttributedStringEnumerationOptions fromValue(int value) =>
      switch (value) {
        2 => NSAttributedStringEnumerationReverse,
        1048576 =>
          NSAttributedStringEnumerationLongestEffectiveRangeNotRequired,
        _ => throw ArgumentError(
            "Unknown value for NSAttributedStringEnumerationOptions: $value"),
      };
}

enum NSAttributedStringMarkdownParsingFailurePolicy {
  NSAttributedStringMarkdownParsingFailureReturnError(0),
  NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible(1);

  final int value;
  const NSAttributedStringMarkdownParsingFailurePolicy(this.value);

  static NSAttributedStringMarkdownParsingFailurePolicy fromValue(int value) =>
      switch (value) {
        0 => NSAttributedStringMarkdownParsingFailureReturnError,
        1 =>
          NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible,
        _ => throw ArgumentError(
            "Unknown value for NSAttributedStringMarkdownParsingFailurePolicy: $value"),
      };
}

enum NSAttributedStringMarkdownInterpretedSyntax {
  NSAttributedStringMarkdownInterpretedSyntaxFull(0),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnly(1),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace(2);

  final int value;
  const NSAttributedStringMarkdownInterpretedSyntax(this.value);

  static NSAttributedStringMarkdownInterpretedSyntax fromValue(int value) =>
      switch (value) {
        0 => NSAttributedStringMarkdownInterpretedSyntaxFull,
        1 => NSAttributedStringMarkdownInterpretedSyntaxInlineOnly,
        2 =>
          NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace,
        _ => throw ArgumentError(
            "Unknown value for NSAttributedStringMarkdownInterpretedSyntax: $value"),
      };
}

enum NSAttributedStringFormattingOptions {
  NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging(1),
  NSAttributedStringFormattingApplyReplacementIndexAttribute(2);

  final int value;
  const NSAttributedStringFormattingOptions(this.value);

  static NSAttributedStringFormattingOptions fromValue(int value) =>
      switch (value) {
        1 => NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging,
        2 => NSAttributedStringFormattingApplyReplacementIndexAttribute,
        _ => throw ArgumentError(
            "Unknown value for NSAttributedStringFormattingOptions: $value"),
      };
}

final class __IOSurface extends ffi.Opaque {}

enum NSRectEdge {
  NSRectEdgeMinX(0),
  NSRectEdgeMinY(1),
  NSRectEdgeMaxX(2),
  NSRectEdgeMaxY(3);

  static const NSMinXEdge = NSRectEdgeMinX;
  static const NSMinYEdge = NSRectEdgeMinY;
  static const NSMaxXEdge = NSRectEdgeMaxX;
  static const NSMaxYEdge = NSRectEdgeMaxY;

  final int value;
  const NSRectEdge(this.value);

  static NSRectEdge fromValue(int value) => switch (value) {
        0 => NSRectEdgeMinX,
        1 => NSRectEdgeMinY,
        2 => NSRectEdgeMaxX,
        3 => NSRectEdgeMaxY,
        _ => throw ArgumentError("Unknown value for NSRectEdge: $value"),
      };

  @override
  String toString() {
    if (this == NSRectEdgeMinX)
      return "NSRectEdge.NSRectEdgeMinX, NSRectEdge.NSMinXEdge";
    if (this == NSRectEdgeMinY)
      return "NSRectEdge.NSRectEdgeMinY, NSRectEdge.NSMinYEdge";
    if (this == NSRectEdgeMaxX)
      return "NSRectEdge.NSRectEdgeMaxX, NSRectEdge.NSMaxXEdge";
    if (this == NSRectEdgeMaxY)
      return "NSRectEdge.NSRectEdgeMaxY, NSRectEdge.NSMaxYEdge";
    return super.toString();
  }
}

final class NSEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double left;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double right;
}

enum NSAlignmentOptions {
  NSAlignMinXInward(1),
  NSAlignMinYInward(2),
  NSAlignMaxXInward(4),
  NSAlignMaxYInward(8),
  NSAlignWidthInward(16),
  NSAlignHeightInward(32),
  NSAlignMinXOutward(256),
  NSAlignMinYOutward(512),
  NSAlignMaxXOutward(1024),
  NSAlignMaxYOutward(2048),
  NSAlignWidthOutward(4096),
  NSAlignHeightOutward(8192),
  NSAlignMinXNearest(65536),
  NSAlignMinYNearest(131072),
  NSAlignMaxXNearest(262144),
  NSAlignMaxYNearest(524288),
  NSAlignWidthNearest(1048576),
  NSAlignHeightNearest(2097152),
  NSAlignRectFlipped(-9223372036854775808),
  NSAlignAllEdgesInward(15),
  NSAlignAllEdgesOutward(3840),
  NSAlignAllEdgesNearest(983040);

  final int value;
  const NSAlignmentOptions(this.value);

  static NSAlignmentOptions fromValue(int value) => switch (value) {
        1 => NSAlignMinXInward,
        2 => NSAlignMinYInward,
        4 => NSAlignMaxXInward,
        8 => NSAlignMaxYInward,
        16 => NSAlignWidthInward,
        32 => NSAlignHeightInward,
        256 => NSAlignMinXOutward,
        512 => NSAlignMinYOutward,
        1024 => NSAlignMaxXOutward,
        2048 => NSAlignMaxYOutward,
        4096 => NSAlignWidthOutward,
        8192 => NSAlignHeightOutward,
        65536 => NSAlignMinXNearest,
        131072 => NSAlignMinYNearest,
        262144 => NSAlignMaxXNearest,
        524288 => NSAlignMaxYNearest,
        1048576 => NSAlignWidthNearest,
        2097152 => NSAlignHeightNearest,
        -9223372036854775808 => NSAlignRectFlipped,
        15 => NSAlignAllEdgesInward,
        3840 => NSAlignAllEdgesOutward,
        983040 => NSAlignAllEdgesNearest,
        _ =>
          throw ArgumentError("Unknown value for NSAlignmentOptions: $value"),
      };
}

enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow(-8),
  NSOperationQueuePriorityLow(-4),
  NSOperationQueuePriorityNormal(0),
  NSOperationQueuePriorityHigh(4),
  NSOperationQueuePriorityVeryHigh(8);

  final int value;
  const NSOperationQueuePriority(this.value);

  static NSOperationQueuePriority fromValue(int value) => switch (value) {
        -8 => NSOperationQueuePriorityVeryLow,
        -4 => NSOperationQueuePriorityLow,
        0 => NSOperationQueuePriorityNormal,
        4 => NSOperationQueuePriorityHigh,
        8 => NSOperationQueuePriorityVeryHigh,
        _ => throw ArgumentError(
            "Unknown value for NSOperationQueuePriority: $value"),
      };
}

final class OpaqueAEDataStorageType extends ffi.Opaque {}

@ffi.Packed(2)
final class AEDesc extends ffi.Struct {
  @ffi.UnsignedInt()
  external int descriptorType;

  external ffi.Pointer<ffi.Pointer<OpaqueAEDataStorageType>> dataHandle;
}

final class OpaqueIconRef extends ffi.Opaque {}

/// WARNING: NSPredicate is a stub. To generate bindings for this class, include
/// NSPredicate in your config's objc-interfaces list.
///
/// NSPredicate
class NSPredicate extends objc.NSObject {
  NSPredicate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSPredicate] that points to the same underlying object as [other].
  NSPredicate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSPredicate] that wraps the given raw object pointer.
  NSPredicate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum NSExpressionType {
  NSConstantValueExpressionType(0),
  NSEvaluatedObjectExpressionType(1),
  NSVariableExpressionType(2),
  NSKeyPathExpressionType(3),
  NSFunctionExpressionType(4),
  NSUnionSetExpressionType(5),
  NSIntersectSetExpressionType(6),
  NSMinusSetExpressionType(7),
  NSSubqueryExpressionType(13),
  NSAggregateExpressionType(14),
  NSAnyKeyExpressionType(15),
  NSBlockExpressionType(19),
  NSConditionalExpressionType(20);

  final int value;
  const NSExpressionType(this.value);

  static NSExpressionType fromValue(int value) => switch (value) {
        0 => NSConstantValueExpressionType,
        1 => NSEvaluatedObjectExpressionType,
        2 => NSVariableExpressionType,
        3 => NSKeyPathExpressionType,
        4 => NSFunctionExpressionType,
        5 => NSUnionSetExpressionType,
        6 => NSIntersectSetExpressionType,
        7 => NSMinusSetExpressionType,
        13 => NSSubqueryExpressionType,
        14 => NSAggregateExpressionType,
        15 => NSAnyKeyExpressionType,
        19 => NSBlockExpressionType,
        20 => NSConditionalExpressionType,
        _ => throw ArgumentError("Unknown value for NSExpressionType: $value"),
      };
}

late final _class_NSExpression = objc.getClass("NSExpression");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_69e0x1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_zoomLevelVariableExpression =
    objc.registerName("zoomLevelVariableExpression");
final _objc_msgSend_1x359cv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_heatmapDensityVariableExpression =
    objc.registerName("heatmapDensityVariableExpression");
late final _sel_lineProgressVariableExpression =
    objc.registerName("lineProgressVariableExpression");
late final _sel_geometryTypeVariableExpression =
    objc.registerName("geometryTypeVariableExpression");
late final _sel_featureIdentifierVariableExpression =
    objc.registerName("featureIdentifierVariableExpression");
late final _sel_featureAccumulatedVariableExpression =
    objc.registerName("featureAccumulatedVariableExpression");
late final _sel_featureAttributesVariableExpression =
    objc.registerName("featureAttributesVariableExpression");
late final _sel_featurePropertiesVariableExpression =
    objc.registerName("featurePropertiesVariableExpression");
late final _sel_mgl_jsonExpressionObject =
    objc.registerName("mgl_jsonExpressionObject");
late final _sel_mgl_expressionLocalizedIntoLocale_ =
    objc.registerName("mgl_expressionLocalizedIntoLocale:");
final _objc_msgSend_62nh5j = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// Methods for creating expressions that use Mapbox-specific functionality and for
/// converting to and from the JSON format defined in the
/// <a href="https://maplibre.org/maplibre-style-spec/expressions/">MapLibre Style Spec</a>.
extension MLNAdditions on NSExpression {
  /// `NSExpression` variable that corresponds to the
  /// <a href="https://maplibre.org/maplibre-style-spec/expressions/#zoom"><code>zoom</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getZoomLevelVariableExpression() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_zoomLevelVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a
  /// href="https://maplibre.org/maplibre-style-spec/expressions/#heatmap-density"><code>heatmap-density</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getHeatmapDensityVariableExpression() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_heatmapDensityVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a
  /// href="https://maplibre.org/maplibre-style-spec/expressions/#line-progress"><code>line-progress</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getLineProgressVariableExpression() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_lineProgressVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a
  /// href="https://maplibre.org/maplibre-style-spec/expressions/#geometry-type"><code>geometry-type</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getGeometryTypeVariableExpression() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_geometryTypeVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a href="https://maplibre.org/maplibre-style-spec/expressions/#id"><code>id</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureIdentifierVariableExpression() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_featureIdentifierVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a href="https://docs.mapbox.com/mapbox-gl-js/style-spec/#accumulated"><code>id</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureAccumulatedVariableExpression() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_featureAccumulatedVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a
  /// href="https://maplibre.org/maplibre-style-spec/expressions/#properties"><code>properties</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureAttributesVariableExpression() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_featureAttributesVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// featurePropertiesVariableExpression
  static NSExpression getFeaturePropertiesVariableExpression() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_featurePropertiesVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// An equivalent Foundation object that can be serialized as JSON.
  ///
  /// The Foundation object conforms to the
  /// [MapLibre Style Spec](https://maplibre.org/maplibre-style-spec/expressions/).
  /// See the
  /// “[Information for Style Authors](../for-style-authors.html#setting-attribute-values)”
  /// guide for a correspondence of operators and types between the style
  /// specification and the `NSExpression` representation used by this SDK.
  ///
  /// You can use `NSJSONSerialization` to serialize the Foundation object as data to
  /// write to a file.
  objc.ObjCObjectBase get mgl_jsonExpressionObject {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_mgl_jsonExpressionObject);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a copy of the receiver localized into the given locale.
  ///
  /// This method assumes the receiver refers to the feature attributes that are
  /// available in vector tiles supplied by the
  /// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets-v8/#overview">Mapbox Streets
  /// source</a>. On iOS, the user can set the system’s preferred language in Settings, General Settings,
  /// Language & Region. On macOS, the user can set the system’s preferred language in the Language &
  /// Region pane of System Preferences.
  ///
  /// @param locale The locale into which labels should be localized. To use the
  /// system’s preferred language, if supported, specify `nil`. To use the local
  /// language, specify a locale with the identifier `mul`.
  NSExpression mgl_expressionLocalizedIntoLocale_(objc.NSLocale? locale) {
    final _ret = _objc_msgSend_62nh5j(
        this.ref.pointer,
        _sel_mgl_expressionLocalizedIntoLocale_,
        locale?.ref.pointer ?? ffi.nullptr);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_expressionWithFormat_argumentArray_ =
    objc.registerName("expressionWithFormat:argumentArray:");
final _objc_msgSend_rsfdlh = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_expressionWithFormat_ =
    objc.registerName("expressionWithFormat:");
late final _sel_expressionForConstantValue_ =
    objc.registerName("expressionForConstantValue:");
late final _sel_expressionForEvaluatedObject =
    objc.registerName("expressionForEvaluatedObject");
late final _sel_expressionForVariable_ =
    objc.registerName("expressionForVariable:");
late final _sel_expressionForKeyPath_ =
    objc.registerName("expressionForKeyPath:");
late final _sel_expressionForFunction_arguments_ =
    objc.registerName("expressionForFunction:arguments:");
late final _sel_expressionForAggregate_ =
    objc.registerName("expressionForAggregate:");
late final _sel_expressionForUnionSet_with_ =
    objc.registerName("expressionForUnionSet:with:");
late final _sel_expressionForIntersectSet_with_ =
    objc.registerName("expressionForIntersectSet:with:");
late final _sel_expressionForMinusSet_with_ =
    objc.registerName("expressionForMinusSet:with:");
late final _sel_expressionForSubquery_usingIteratorVariable_predicate_ =
    objc.registerName("expressionForSubquery:usingIteratorVariable:predicate:");
final _objc_msgSend_582s3n = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_expressionForFunction_selectorName_arguments_ =
    objc.registerName("expressionForFunction:selectorName:arguments:");
late final _sel_expressionForAnyKey = objc.registerName("expressionForAnyKey");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?, objc.NSArray, objc.NSMutableDictionary?)>`.
abstract final class ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?,
              objc.NSArray, objc.NSMutableDictionary?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCObject>?,
                      objc.NSArray,
                      objc.NSMutableDictionary?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?,
              objc.NSArray, objc.NSMutableDictionary?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCObject>?,
                      objc.NSArray,
                      objc.NSMutableDictionary?)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?, objc.NSArray, objc.NSMutableDictionary?)>
      fromFunction(objc.ObjCObjectBase Function(objc.ObjCObjectBase?, objc.NSArray, objc.NSMutableDictionary?) fn) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?, objc.NSArray, objc.NSMutableDictionary?)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                          arg0.address == 0 ? null : objc.ObjCObjectBase(arg0, retain: true, release: true),
                          objc.NSArray.castFromPointer(arg1, retain: true, release: true),
                          arg2.address == 0 ? null : objc.NSMutableDictionary.castFromPointer(arg2, retain: true, release: true))
                      .ref
                      .retainAndAutorelease()),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?, objc.NSArray, objc.NSMutableDictionary?)>`.
extension ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?,
            objc.NSArray, objc.NSMutableDictionary?)> {
  objc.ObjCObjectBase call(objc.ObjCObjectBase? arg0, objc.NSArray arg1, objc.NSMutableDictionary? arg2) =>
      objc.ObjCObjectBase(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<objc.ObjCObject> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer,
              arg0?.ref.pointer ?? ffi.nullptr,
              arg1.ref.pointer,
              arg2?.ref.pointer ?? ffi.nullptr),
          retain: true,
          release: true);
}

late final _sel_expressionForBlock_arguments_ =
    objc.registerName("expressionForBlock:arguments:");
final _objc_msgSend_1autorq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_expressionForConditional_trueExpression_falseExpression_ = objc
    .registerName("expressionForConditional:trueExpression:falseExpression:");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_initWithExpressionType_ =
    objc.registerName("initWithExpressionType:");
final _objc_msgSend_3sjlfq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            instancetype Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>, objc.NSCoder)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                      ffi.Pointer<ffi.Void>, objc.NSCoder)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(
          Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true))
                      ?.ref
                      .retainAndReturnPointer() ??
                  ffi.nullptr),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
            ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true);
}

late final _sel_expressionType = objc.registerName("expressionType");
final _objc_msgSend_1ts4niw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_constantValue = objc.registerName("constantValue");
late final _sel_keyPath = objc.registerName("keyPath");
late final _sel_function = objc.registerName("function");
late final _sel_variable = objc.registerName("variable");
late final _sel_operand = objc.registerName("operand");
late final _sel_arguments = objc.registerName("arguments");
late final _sel_collection = objc.registerName("collection");
late final _sel_predicate = objc.registerName("predicate");
late final _sel_leftExpression = objc.registerName("leftExpression");
late final _sel_rightExpression = objc.registerName("rightExpression");
late final _sel_trueExpression = objc.registerName("trueExpression");
late final _sel_falseExpression = objc.registerName("falseExpression");
late final _sel_expressionBlock = objc.registerName("expressionBlock");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_expressionValueWithObject_context_ =
    objc.registerName("expressionValueWithObject:context:");
late final _sel_allowEvaluation = objc.registerName("allowEvaluation");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_hzlb60 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<_NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<_NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
instancetype _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<instancetype Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_instancetype_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease()),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_instancetype_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");
late final _sel_supportsSecureCoding =
    objc.registerName("supportsSecureCoding");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
bool _ObjCBlock_bool_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_bool_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0)),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_1jdvcbf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(
                          arg0,
                          objc.NSCoder.castFromPointer(arg1,
                              retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)));
    final wrapper = _MapLibreFFi_wrapListenerBlock_wjovn7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_mgl_expressionForConditional_trueExpression_falseExpresssion_ =
    objc.registerName(
        "mgl_expressionForConditional:trueExpression:falseExpresssion:");
late final _sel_mgl_expressionForSteppingExpression_fromExpression_stops_ = objc
    .registerName("mgl_expressionForSteppingExpression:fromExpression:stops:");
late final _sel_mgl_expressionForInterpolatingExpression_withCurveType_parameters_stops_ =
    objc.registerName(
        "mgl_expressionForInterpolatingExpression:withCurveType:parameters:stops:");
final _objc_msgSend_1ghpoap = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_mgl_expressionForMatchingExpression_inDictionary_defaultExpression_ =
    objc.registerName(
        "mgl_expressionForMatchingExpression:inDictionary:defaultExpression:");
late final _sel_mgl_expressionForAttributedExpressions_ =
    objc.registerName("mgl_expressionForAttributedExpressions:");
late final _sel_mgl_expressionByAppendingExpression_ =
    objc.registerName("mgl_expressionByAppendingExpression:");
late final _sel_expressionWithMLNJSONObject_ =
    objc.registerName("expressionWithMLNJSONObject:");

/// NSExpression
class NSExpression extends objc.NSObject {
  NSExpression._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSExpression] that points to the same underlying object as [other].
  NSExpression.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSExpression] that wraps the given raw object pointer.
  NSExpression.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSExpression].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSExpression);
  }

  /// expressionWithFormat:argumentArray:
  static NSExpression expressionWithFormat_argumentArray_(
      objc.NSString expressionFormat, objc.NSArray arguments) {
    final _ret = _objc_msgSend_rsfdlh(
        _class_NSExpression,
        _sel_expressionWithFormat_argumentArray_,
        expressionFormat.ref.pointer,
        arguments.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionWithFormat:
  static NSExpression expressionWithFormat_(objc.NSString expressionFormat) {
    final _ret = _objc_msgSend_62nh5j(_class_NSExpression,
        _sel_expressionWithFormat_, expressionFormat.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForConstantValue:
  static NSExpression expressionForConstantValue_(objc.ObjCObjectBase? obj) {
    final _ret = _objc_msgSend_62nh5j(_class_NSExpression,
        _sel_expressionForConstantValue_, obj?.ref.pointer ?? ffi.nullptr);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForEvaluatedObject
  static NSExpression expressionForEvaluatedObject() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSExpression, _sel_expressionForEvaluatedObject);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForVariable:
  static NSExpression expressionForVariable_(objc.NSString string) {
    final _ret = _objc_msgSend_62nh5j(
        _class_NSExpression, _sel_expressionForVariable_, string.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForKeyPath:
  static NSExpression expressionForKeyPath_(objc.NSString keyPath) {
    final _ret = _objc_msgSend_62nh5j(
        _class_NSExpression, _sel_expressionForKeyPath_, keyPath.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForFunction:arguments:
  static NSExpression expressionForFunction_arguments_(
      objc.NSString name, objc.NSArray parameters) {
    final _ret = _objc_msgSend_rsfdlh(
        _class_NSExpression,
        _sel_expressionForFunction_arguments_,
        name.ref.pointer,
        parameters.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForAggregate:
  static NSExpression expressionForAggregate_(objc.NSArray subexpressions) {
    final _ret = _objc_msgSend_62nh5j(_class_NSExpression,
        _sel_expressionForAggregate_, subexpressions.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForUnionSet:with:
  static NSExpression expressionForUnionSet_with_(
      NSExpression left, NSExpression right) {
    final _ret = _objc_msgSend_rsfdlh(_class_NSExpression,
        _sel_expressionForUnionSet_with_, left.ref.pointer, right.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForIntersectSet:with:
  static NSExpression expressionForIntersectSet_with_(
      NSExpression left, NSExpression right) {
    final _ret = _objc_msgSend_rsfdlh(
        _class_NSExpression,
        _sel_expressionForIntersectSet_with_,
        left.ref.pointer,
        right.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForMinusSet:with:
  static NSExpression expressionForMinusSet_with_(
      NSExpression left, NSExpression right) {
    final _ret = _objc_msgSend_rsfdlh(_class_NSExpression,
        _sel_expressionForMinusSet_with_, left.ref.pointer, right.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForSubquery:usingIteratorVariable:predicate:
  static NSExpression expressionForSubquery_usingIteratorVariable_predicate_(
      NSExpression expression, objc.NSString variable, NSPredicate predicate) {
    final _ret = _objc_msgSend_582s3n(
        _class_NSExpression,
        _sel_expressionForSubquery_usingIteratorVariable_predicate_,
        expression.ref.pointer,
        variable.ref.pointer,
        predicate.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForFunction:selectorName:arguments:
  static NSExpression expressionForFunction_selectorName_arguments_(
      NSExpression target, objc.NSString name, objc.NSArray? parameters) {
    final _ret = _objc_msgSend_582s3n(
        _class_NSExpression,
        _sel_expressionForFunction_selectorName_arguments_,
        target.ref.pointer,
        name.ref.pointer,
        parameters?.ref.pointer ?? ffi.nullptr);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForAnyKey
  static NSExpression expressionForAnyKey() {
    final _ret =
        _objc_msgSend_1x359cv(_class_NSExpression, _sel_expressionForAnyKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForBlock:arguments:
  static NSExpression expressionForBlock_arguments_(
      objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>?,
                  objc.NSArray,
                  objc.NSMutableDictionary?)>
          block,
      objc.NSArray? arguments) {
    final _ret = _objc_msgSend_1autorq(
        _class_NSExpression,
        _sel_expressionForBlock_arguments_,
        block.ref.pointer,
        arguments?.ref.pointer ?? ffi.nullptr);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForConditional:trueExpression:falseExpression:
  static NSExpression expressionForConditional_trueExpression_falseExpression_(
      NSPredicate predicate,
      NSExpression trueExpression,
      NSExpression falseExpression) {
    final _ret = _objc_msgSend_582s3n(
        _class_NSExpression,
        _sel_expressionForConditional_trueExpression_falseExpression_,
        predicate.ref.pointer,
        trueExpression.ref.pointer,
        falseExpression.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithExpressionType:
  NSExpression initWithExpressionType_(NSExpressionType type) {
    final _ret = _objc_msgSend_3sjlfq(this.ref.retainAndReturnPointer(),
        _sel_initWithExpressionType_, type.value);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSExpression? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// expressionType
  NSExpressionType get expressionType {
    final _ret = _objc_msgSend_1ts4niw(this.ref.pointer, _sel_expressionType);
    return NSExpressionType.fromValue(_ret);
  }

  /// constantValue
  objc.ObjCObjectBase? get constantValue {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_constantValue);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// keyPath
  objc.NSString get keyPath {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_keyPath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// function
  objc.NSString get function {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_function);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// variable
  objc.NSString get variable {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_variable);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// operand
  NSExpression get operand {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_operand);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// arguments
  objc.NSArray? get arguments {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_arguments);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// collection
  objc.ObjCObjectBase get collection {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_collection);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// predicate
  NSPredicate get predicate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_predicate);
    return NSPredicate.castFromPointer(_ret, retain: true, release: true);
  }

  /// leftExpression
  NSExpression get leftExpression {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_leftExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// rightExpression
  NSExpression get rightExpression {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_rightExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// trueExpression
  NSExpression get trueExpression {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_trueExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// falseExpression
  NSExpression get falseExpression {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_falseExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionBlock
  objc.ObjCBlock<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?,
          objc.NSArray, objc.NSMutableDictionary?)> get expressionBlock {
    final _ret = _objc_msgSend_uwvaik(this.ref.pointer, _sel_expressionBlock);
    return ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary
        .castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionValueWithObject:context:
  objc.ObjCObjectBase? expressionValueWithObject_context_(
      objc.ObjCObjectBase? object, objc.NSMutableDictionary? context) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.pointer,
        _sel_expressionValueWithObject_context_,
        object?.ref.pointer ?? ffi.nullptr,
        context?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// allowEvaluation
  void allowEvaluation() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_allowEvaluation);
  }

  /// init
  NSExpression init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSExpression new1() {
    final _ret = _objc_msgSend_1x359cv(_class_NSExpression, _sel_new);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSExpression allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_NSExpression, _sel_allocWithZone_, zone);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSExpression alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_NSExpression, _sel_alloc);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSExpression self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSExpression retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSExpression autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSExpression, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// Returns a conditional function expression specifying the string predicate, and
  /// expressions for each condition.
  ///
  /// @param conditionPredicate The predicate to get evaluated.
  /// @param trueExpression The expression for conditions equal to true.
  /// @param falseExpression The expression for conditions equal to false.
  static NSExpression
      mgl_expressionForConditional_trueExpression_falseExpresssion_(
          NSPredicate conditionPredicate,
          NSExpression trueExpression,
          NSExpression falseExpression) {
    final _ret = _objc_msgSend_582s3n(
        _class_NSExpression,
        _sel_mgl_expressionForConditional_trueExpression_falseExpresssion_,
        conditionPredicate.ref.pointer,
        trueExpression.ref.pointer,
        falseExpression.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a step function expression specifying the stepping, from expression
  /// and stops.
  ///
  /// @param steppingExpression The stepping expression.
  /// @param minimumExpression The expression which could be a constant or function expression.
  /// @param stops The stops must be an `NSDictionary` constant `NSExpression`.
  ///
  /// #### Related examples
  /// TODO: Data-driven circles
  /// TODO: Cluster point data
  /// TODO: Use images to cluster point data
  /// Learn how to use this expression to style a map layer based on an attribute value.
  static NSExpression mgl_expressionForSteppingExpression_fromExpression_stops_(
      NSExpression steppingExpression,
      NSExpression minimumExpression,
      NSExpression stops) {
    final _ret = _objc_msgSend_582s3n(
        _class_NSExpression,
        _sel_mgl_expressionForSteppingExpression_fromExpression_stops_,
        steppingExpression.ref.pointer,
        minimumExpression.ref.pointer,
        stops.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an interpolated function expression specifying the function operator, curve type,
  /// parameters and steps.
  ///
  /// @param inputExpression The interpolating expression input.
  /// @param curveType The curve type could be ``MLNExpressionInterpolationModeLinear``,
  /// ``MLNExpressionInterpolationModeExponential`` and
  /// ``MLNExpressionInterpolationModeCubicBezier``.
  /// @param parameters The parameters expression.
  /// @param stops The stops expression.
  ///
  /// #### Related examples
  /// TODO: Create a heatmap layer, learn how to style an ``MLNHeatmapStyleLayer``
  /// based on zoom level and point density with this expression.
  static NSExpression
      mgl_expressionForInterpolatingExpression_withCurveType_parameters_stops_(
          NSExpression inputExpression,
          objc.NSString curveType,
          NSExpression? parameters,
          NSExpression stops) {
    final _ret = _objc_msgSend_1ghpoap(
        _class_NSExpression,
        _sel_mgl_expressionForInterpolatingExpression_withCurveType_parameters_stops_,
        inputExpression.ref.pointer,
        curveType.ref.pointer,
        parameters?.ref.pointer ?? ffi.nullptr,
        stops.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a match function expression specifying the input, matching values,
  /// and default value.
  ///
  /// @param inputExpression The matching expression.
  /// @param matchedExpressions The matched values expression dictionary must be condition : value.
  /// @param defaultExpression The defaultValue expression to be used in case there is no match.
  static NSExpression
      mgl_expressionForMatchingExpression_inDictionary_defaultExpression_(
          NSExpression inputExpression,
          objc.NSDictionary matchedExpressions,
          NSExpression defaultExpression) {
    final _ret = _objc_msgSend_582s3n(
        _class_NSExpression,
        _sel_mgl_expressionForMatchingExpression_inDictionary_defaultExpression_,
        inputExpression.ref.pointer,
        matchedExpressions.ref.pointer,
        defaultExpression.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an attributed function expression specifying an ``MLNAttributedExpression`` constant
  /// expression array.
  ///
  /// @param attributedExpressions The ``MLNAttributedExpression`` constant expression array.
  static NSExpression mgl_expressionForAttributedExpressions_(
      objc.NSArray attributedExpressions) {
    final _ret = _objc_msgSend_62nh5j(
        _class_NSExpression,
        _sel_mgl_expressionForAttributedExpressions_,
        attributedExpressions.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a constant expression appending the passed expression.
  ///
  /// > Note: Both the receiver and the given expression must be an `NSString` constant
  /// expression type; otherwise, an exception is rised.
  ///
  /// @param expression The expression to append to the receiver.
  NSExpression mgl_expressionByAppendingExpression_(NSExpression expression) {
    final _ret = _objc_msgSend_62nh5j(this.ref.pointer,
        _sel_mgl_expressionByAppendingExpression_, expression.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an expression equivalent to the given Foundation object deserialized
  /// from JSON data.
  ///
  /// The Foundation object is interpreted according to the
  /// [MapLibre Style Spec](https://maplibre.org/maplibre-style-spec/expressions/).
  /// See the
  /// “[Information for Style Authors](../for-style-authors.html#setting-attribute-values)”
  /// guide for a correspondence of operators and types between the style
  /// specification and the `NSExpression` representation used by this SDK.
  ///
  /// @param object A Foundation object deserialized from JSON data, for example
  /// using `NSJSONSerialization`.
  /// @return An initialized expression equivalent to `object`, suitable for use as
  /// the value of a style layer attribute.
  static NSExpression expressionWithMLNJSONObject_(objc.ObjCObjectBase object) {
    final _ret = _objc_msgSend_62nh5j(_class_NSExpression,
        _sel_expressionWithMLNJSONObject_, object.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }
}

enum NSFileWrapperReadingOptions {
  NSFileWrapperReadingImmediate(1),
  NSFileWrapperReadingWithoutMapping(2);

  final int value;
  const NSFileWrapperReadingOptions(this.value);

  static NSFileWrapperReadingOptions fromValue(int value) => switch (value) {
        1 => NSFileWrapperReadingImmediate,
        2 => NSFileWrapperReadingWithoutMapping,
        _ => throw ArgumentError(
            "Unknown value for NSFileWrapperReadingOptions: $value"),
      };
}

enum NSFileWrapperWritingOptions {
  NSFileWrapperWritingAtomic(1),
  NSFileWrapperWritingWithNameUpdating(2);

  final int value;
  const NSFileWrapperWritingOptions(this.value);

  static NSFileWrapperWritingOptions fromValue(int value) => switch (value) {
        1 => NSFileWrapperWritingAtomic,
        2 => NSFileWrapperWritingWithNameUpdating,
        _ => throw ArgumentError(
            "Unknown value for NSFileWrapperWritingOptions: $value"),
      };
}

final class NSAffineTransformStruct extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double tX;

  @ffi.Double()
  external double tY;
}

enum NSAppleEventSendOptions {
  NSAppleEventSendNoReply(1),
  NSAppleEventSendQueueReply(2),
  NSAppleEventSendWaitForReply(3),
  NSAppleEventSendNeverInteract(16),
  NSAppleEventSendCanInteract(32),
  NSAppleEventSendAlwaysInteract(48),
  NSAppleEventSendCanSwitchLayer(64),
  NSAppleEventSendDontRecord(4096),
  NSAppleEventSendDontExecute(8192),
  NSAppleEventSendDontAnnotate(65536),
  NSAppleEventSendDefaultOptions(35);

  final int value;
  const NSAppleEventSendOptions(this.value);

  static NSAppleEventSendOptions fromValue(int value) => switch (value) {
        1 => NSAppleEventSendNoReply,
        2 => NSAppleEventSendQueueReply,
        3 => NSAppleEventSendWaitForReply,
        16 => NSAppleEventSendNeverInteract,
        32 => NSAppleEventSendCanInteract,
        48 => NSAppleEventSendAlwaysInteract,
        64 => NSAppleEventSendCanSwitchLayer,
        4096 => NSAppleEventSendDontRecord,
        8192 => NSAppleEventSendDontExecute,
        65536 => NSAppleEventSendDontAnnotate,
        35 => NSAppleEventSendDefaultOptions,
        _ => throw ArgumentError(
            "Unknown value for NSAppleEventSendOptions: $value"),
      };
}

enum NSSaveOptions {
  NSSaveOptionsYes(0),
  NSSaveOptionsNo(1),
  NSSaveOptionsAsk(2);

  final int value;
  const NSSaveOptions(this.value);

  static NSSaveOptions fromValue(int value) => switch (value) {
        0 => NSSaveOptionsYes,
        1 => NSSaveOptionsNo,
        2 => NSSaveOptionsAsk,
        _ => throw ArgumentError("Unknown value for NSSaveOptions: $value"),
      };
}

late final _class_MapLibreRegistry =
    objc.getClass("maplibre_ios.MapLibreRegistry");
late final _sel_getMapWithViewId_ = objc.registerName("getMapWithViewId:");
final _objc_msgSend_r25hnf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int64)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_activity = objc.registerName("activity");
late final _sel_setActivity_ = objc.registerName("setActivity:");
late final _sel_context = objc.registerName("context");
late final _sel_setContext_ = objc.registerName("setContext:");

/// MapLibreRegistry
class MapLibreRegistry extends objc.NSObject {
  MapLibreRegistry._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MapLibreRegistry] that points to the same underlying object as [other].
  MapLibreRegistry.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MapLibreRegistry] that wraps the given raw object pointer.
  MapLibreRegistry.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MapLibreRegistry].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MapLibreRegistry);
  }

  /// getMapWithViewId:
  static objc.ObjCObjectBase? getMapWithViewId_(int viewId) {
    final _ret = _objc_msgSend_r25hnf(
        _class_MapLibreRegistry, _sel_getMapWithViewId_, viewId);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// activity
  static objc.ObjCObjectBase? getActivity() {
    final _ret = _objc_msgSend_1x359cv(_class_MapLibreRegistry, _sel_activity);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setActivity:
  static void setActivity(objc.ObjCObjectBase? value) {
    return _objc_msgSend_1jdvcbf(_class_MapLibreRegistry, _sel_setActivity_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// context
  static objc.ObjCObjectBase? getContext() {
    final _ret = _objc_msgSend_1x359cv(_class_MapLibreRegistry, _sel_context);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setContext:
  static void setContext(objc.ObjCObjectBase? value) {
    return _objc_msgSend_1jdvcbf(_class_MapLibreRegistry, _sel_setContext_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  MapLibreRegistry init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MapLibreRegistry.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MapLibreRegistry new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MapLibreRegistry, _sel_new);
    return MapLibreRegistry.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MapLibreRegistry allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MapLibreRegistry, _sel_allocWithZone_, zone);
    return MapLibreRegistry.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MapLibreRegistry alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MapLibreRegistry, _sel_alloc);
    return MapLibreRegistry.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MapLibreRegistry self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MapLibreRegistry.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MapLibreRegistry retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MapLibreRegistry.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MapLibreRegistry autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MapLibreRegistry.castFromPointer(_ret, retain: true, release: true);
  }
}

final class CGContext extends ffi.Opaque {}

final class CGColor extends ffi.Opaque {}

final class CGColorSpace extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGPath extends ffi.Opaque {}

final class CGLayer extends ffi.Opaque {}

final class __CGEvent extends ffi.Opaque {}

/// Options for enabling debugging features in an ``MLNMapView`` instance.
enum MLNMapDebugMaskOptions {
  /// Edges of tile boundaries are shown as thick, red lines to help diagnose
  /// tile clipping issues.
  MLNMapDebugTileBoundariesMask(2),

  /// Each tile shows its tile coordinate (x/y/z) in the upper-left corner.
  MLNMapDebugTileInfoMask(4),

  /// Each tile shows a timestamp indicating when it was loaded.
  MLNMapDebugTimestampsMask(8),

  /// Edges of glyphs and symbols are shown as faint, green lines to help
  /// diagnose collision and label placement issues.
  MLNMapDebugCollisionBoxesMask(16),

  /// Each drawing operation is replaced by a translucent fill. Overlapping
  /// drawing operations appear more prominent to help diagnose overdrawing.
  /// > Note: This option does nothing in Release builds of the SDK.
  MLNMapDebugOverdrawVisualizationMask(32),

  /// The stencil buffer is shown instead of the color buffer.
  /// > Note: This option does nothing in Release builds of the SDK.
  MLNMapDebugStencilBufferMask(64),

  /// The depth buffer is shown instead of the color buffer.
  /// > Note: This option does nothing in Release builds of the SDK.
  MLNMapDebugDepthBufferMask(128);

  final int value;
  const MLNMapDebugMaskOptions(this.value);

  static MLNMapDebugMaskOptions fromValue(int value) => switch (value) {
        2 => MLNMapDebugTileBoundariesMask,
        4 => MLNMapDebugTileInfoMask,
        8 => MLNMapDebugTimestampsMask,
        16 => MLNMapDebugCollisionBoxesMask,
        32 => MLNMapDebugOverdrawVisualizationMask,
        64 => MLNMapDebugStencilBufferMask,
        128 => MLNMapDebugDepthBufferMask,
        _ => throw ArgumentError(
            "Unknown value for MLNMapDebugMaskOptions: $value"),
      };
}

/// A structure containing information about a transition.
final class MLNTransition extends ffi.Struct {
  /// The amount of time the animation should take, not including the delay.
  @ffi.Double()
  external double duration;

  /// The amount of time in seconds to wait before beginning the animation.
  @ffi.Double()
  external double delay;
}

/// Constants indicating the visibility of different map ornaments.
enum MLNOrnamentVisibility {
  /// A constant indicating that the ornament adapts to the current map state.
  MLNOrnamentVisibilityAdaptive(0),

  /// A constant indicating that the ornament is always hidden.
  MLNOrnamentVisibilityHidden(1),

  /// A constant indicating that the ornament is always visible.
  MLNOrnamentVisibilityVisible(2);

  final int value;
  const MLNOrnamentVisibility(this.value);

  static MLNOrnamentVisibility fromValue(int value) => switch (value) {
        0 => MLNOrnamentVisibilityAdaptive,
        1 => MLNOrnamentVisibilityHidden,
        2 => MLNOrnamentVisibilityVisible,
        _ => throw ArgumentError(
            "Unknown value for MLNOrnamentVisibility: $value"),
      };
}

/// WARNING: MLNCompassButton is a stub. To generate bindings for this class, include
/// MLNCompassButton in your config's objc-interfaces list.
///
/// A specialized view that displays the current compass heading for its associated map.
class MLNCompassButton extends objc.ObjCObjectBase {
  MLNCompassButton._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNCompassButton] that points to the same underlying object as [other].
  MLNCompassButton.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNCompassButton] that wraps the given raw object pointer.
  MLNCompassButton.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

final class CLLocationCoordinate2D extends ffi.Struct {
  @ffi.Double()
  external double latitude;

  @ffi.Double()
  external double longitude;
}

/// A rectangular area as measured on a two-dimensional map projection.
final class MLNCoordinateBounds extends ffi.Struct {
  /// Coordinate at the southwest corner.
  external CLLocationCoordinate2D sw;

  /// Coordinate at the northeast corner.
  external CLLocationCoordinate2D ne;
}

/// A quadrilateral area as measured on a two-dimensional map projection.
/// ``MLNCoordinateQuad`` differs from ``MLNCoordinateQuad`` in that it allows
/// representation of non-axis aligned bounds and non-rectangular quadrilaterals.
/// The coordinates are described in counter clockwise order from top left.
final class MLNCoordinateQuad extends ffi.Struct {
  /// Coordinate at the top left corner.
  external CLLocationCoordinate2D topLeft;

  /// Coordinate at the bottom left corner.
  external CLLocationCoordinate2D bottomLeft;

  /// Coordinate at the bottom right corner.
  external CLLocationCoordinate2D bottomRight;

  /// Coordinate at the top right corner.
  external CLLocationCoordinate2D topRight;
}

late final _class_MLNMapCamera = objc.getClass("MapLibre.MLNMapCamera");
late final _sel_centerCoordinate = objc.registerName("centerCoordinate");
final _objc_msgSend_18o5nok = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CLLocationCoordinate2D Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_18o5nokStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CLLocationCoordinate2D>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCenterCoordinate_ =
    objc.registerName("setCenterCoordinate:");
final _objc_msgSend_1zv0am = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>();
late final _sel_heading = objc.registerName("heading");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setHeading_ = objc.registerName("setHeading:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_pitch = objc.registerName("pitch");
late final _sel_setPitch_ = objc.registerName("setPitch:");
late final _sel_altitude = objc.registerName("altitude");
late final _sel_setAltitude_ = objc.registerName("setAltitude:");
late final _sel_viewingDistance = objc.registerName("viewingDistance");
late final _sel_setViewingDistance_ = objc.registerName("setViewingDistance:");
late final _sel_camera = objc.registerName("camera");
late final _sel_cameraLookingAtCenterCoordinate_fromEyeCoordinate_eyeAltitude_ =
    objc.registerName(
        "cameraLookingAtCenterCoordinate:fromEyeCoordinate:eyeAltitude:");
final _objc_msgSend_15ghv6w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                CLLocationCoordinate2D,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            CLLocationCoordinate2D,
            double)>();
late final _sel_cameraLookingAtCenterCoordinate_acrossDistance_pitch_heading_ =
    objc.registerName(
        "cameraLookingAtCenterCoordinate:acrossDistance:pitch:heading:");
final _objc_msgSend_em17dp = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Double,
                ffi.Double,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            double,
            double,
            double)>();
late final _sel_cameraLookingAtCenterCoordinate_altitude_pitch_heading_ = objc
    .registerName("cameraLookingAtCenterCoordinate:altitude:pitch:heading:");
late final _sel_cameraLookingAtCenterCoordinate_fromDistance_pitch_heading_ =
    objc.registerName(
        "cameraLookingAtCenterCoordinate:fromDistance:pitch:heading:");
late final _sel_isEqualToMapCamera_ = objc.registerName("isEqualToMapCamera:");

/// An ``MLNMapCamera`` object represents a viewpoint from which the user observes
/// some point on an ``MLNMapView``.
///
/// #### Related examples
/// - <doc:BlockingGesturesExample>: learn how to use the
/// ``MLNMapViewDelegate/mapView:shouldChangeFromCamera:toCamera:`` method of ``MLNMapViewDelegate`` to
/// restrict panning.
/// - *TODO:* Camera animation, learn how to create a camera that rotates
/// around a central point.
class MLNMapCamera extends objc.NSObject {
  MLNMapCamera._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMapCamera] that points to the same underlying object as [other].
  MLNMapCamera.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMapCamera] that wraps the given raw object pointer.
  MLNMapCamera.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMapCamera].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapCamera);
  }

  /// Coordinate at the center of the map view.
  CLLocationCoordinate2D get centerCoordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(
            _ptr, this.ref.pointer, _sel_centerCoordinate)
        : _ptr.ref =
            _objc_msgSend_18o5nok(this.ref.pointer, _sel_centerCoordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// Coordinate at the center of the map view.
  set centerCoordinate(CLLocationCoordinate2D value) {
    return _objc_msgSend_1zv0am(
        this.ref.pointer, _sel_setCenterCoordinate_, value);
  }

  /// Heading measured in degrees clockwise from true north.
  double get heading {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_heading)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_heading);
  }

  /// Heading measured in degrees clockwise from true north.
  set heading(double value) {
    return _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setHeading_, value);
  }

  /// Pitch toward the horizon measured in degrees, with 0 degrees resulting in a
  /// two-dimensional map.
  double get pitch {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_pitch)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_pitch);
  }

  /// Pitch toward the horizon measured in degrees, with 0 degrees resulting in a
  /// two-dimensional map.
  set pitch(double value) {
    return _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setPitch_, value);
  }

  /// The altitude (measured in meters) above the map at which the camera is
  /// situated.
  ///
  /// The altitude is the distance from the viewpoint to the map, perpendicular to
  /// the map plane. This property does not account for physical elevation.
  ///
  /// This property’s value may be less than that of the ``viewingDistance`` property.
  /// Setting this property automatically updates the ``viewingDistance`` property
  /// based on the ``pitch`` property’s current value.
  double get altitude {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_altitude)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_altitude);
  }

  /// The altitude (measured in meters) above the map at which the camera is
  /// situated.
  ///
  /// The altitude is the distance from the viewpoint to the map, perpendicular to
  /// the map plane. This property does not account for physical elevation.
  ///
  /// This property’s value may be less than that of the ``viewingDistance`` property.
  /// Setting this property automatically updates the ``viewingDistance`` property
  /// based on the ``pitch`` property’s current value.
  set altitude(double value) {
    return _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setAltitude_, value);
  }

  /// The straight-line distance from the viewpoint to the ``centerCoordinate``.
  ///
  /// Setting this property automatically updates the ``altitude`` property based on
  /// the ``pitch`` property’s current value.
  double get viewingDistance {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_viewingDistance)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_viewingDistance);
  }

  /// The straight-line distance from the viewpoint to the ``centerCoordinate``.
  ///
  /// Setting this property automatically updates the ``altitude`` property based on
  /// the ``pitch`` property’s current value.
  set viewingDistance(double value) {
    return _objc_msgSend_hwm8nu(
        this.ref.pointer, _sel_setViewingDistance_, value);
  }

  /// Returns a new camera with all properties set to 0.
  static MLNMapCamera camera() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNMapCamera, _sel_camera);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new camera based on information about the camera’s viewpoint
  /// and focus point.
  ///
  /// @param centerCoordinate The geographic coordinate on which the map should be
  /// centered.
  /// @param eyeCoordinate The geometric coordinate at which the camera should be
  /// situated.
  /// @param eyeAltitude The altitude (measured in meters) above the map at which the
  /// camera should be situated. The altitude may be less than the distance from
  /// the camera’s viewpoint to the camera’s focus point.
  static MLNMapCamera
      cameraLookingAtCenterCoordinate_fromEyeCoordinate_eyeAltitude_(
          CLLocationCoordinate2D centerCoordinate,
          CLLocationCoordinate2D eyeCoordinate,
          double eyeAltitude) {
    final _ret = _objc_msgSend_15ghv6w(
        _class_MLNMapCamera,
        _sel_cameraLookingAtCenterCoordinate_fromEyeCoordinate_eyeAltitude_,
        centerCoordinate,
        eyeCoordinate,
        eyeAltitude);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new camera with the given distance, pitch, and heading.
  ///
  /// This method interprets the distance as a straight-line distance from the
  /// viewpoint to the center coordinate. To specify the altitude of the viewpoint,
  /// use the ``cameraLookingAtCenterCoordinate:altitude:pitch:heading:`` method.
  ///
  /// @param centerCoordinate The geographic coordinate on which the map should be
  /// centered.
  /// @param distance The straight-line distance from the viewpoint to the
  /// ``centerCoordinate``.
  /// @param pitch The viewing angle of the camera, measured in degrees. A value of
  /// `0` results in a camera pointed straight down at the map. Angles greater
  /// than `0` result in a camera angled toward the horizon.
  /// @param heading The camera’s heading, measured in degrees clockwise from true
  /// north. A value of `0` means that the top edge of the map view corresponds to
  /// true north. The value `90` means the top of the map is pointing due east.
  /// The value `180` means the top of the map points due south, and so on.
  static MLNMapCamera
      cameraLookingAtCenterCoordinate_acrossDistance_pitch_heading_(
          CLLocationCoordinate2D centerCoordinate,
          double distance,
          double pitch,
          double heading) {
    final _ret = _objc_msgSend_em17dp(
        _class_MLNMapCamera,
        _sel_cameraLookingAtCenterCoordinate_acrossDistance_pitch_heading_,
        centerCoordinate,
        distance,
        pitch,
        heading);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new camera with the given altitude, pitch, and heading.
  ///
  /// @param centerCoordinate The geographic coordinate on which the map should be
  /// centered.
  /// @param altitude The altitude (measured in meters) above the map at which the
  /// camera should be situated. The altitude may be less than the distance from
  /// the camera’s viewpoint to the camera’s focus point.
  /// @param pitch The viewing angle of the camera, measured in degrees. A value of
  /// `0` results in a camera pointed straight down at the map. Angles greater
  /// than `0` result in a camera angled toward the horizon.
  /// @param heading The camera’s heading, measured in degrees clockwise from true
  /// north. A value of `0` means that the top edge of the map view corresponds to
  /// true north. The value `90` means the top of the map is pointing due east.
  /// The value `180` means the top of the map points due south, and so on.
  static MLNMapCamera cameraLookingAtCenterCoordinate_altitude_pitch_heading_(
      CLLocationCoordinate2D centerCoordinate,
      double altitude,
      double pitch,
      double heading) {
    final _ret = _objc_msgSend_em17dp(
        _class_MLNMapCamera,
        _sel_cameraLookingAtCenterCoordinate_altitude_pitch_heading_,
        centerCoordinate,
        altitude,
        pitch,
        heading);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// > This initializer incorrectly interprets the `distance` parameter. To
  /// specify the straight-line distance from the viewpoint to ``centerCoordinate``,
  /// use the ``cameraLookingAtCenterCoordinate:acrossDistance:pitch:heading:``
  /// method. To specify the altitude of the viewpoint, use the
  /// ``cameraLookingAtCenterCoordinate:altitude:pitch:heading:`` method, which has
  /// the same behavior as this initializer.
  static MLNMapCamera
      cameraLookingAtCenterCoordinate_fromDistance_pitch_heading_(
          CLLocationCoordinate2D centerCoordinate,
          double distance,
          double pitch,
          double heading) {
    final _ret = _objc_msgSend_em17dp(
        _class_MLNMapCamera,
        _sel_cameraLookingAtCenterCoordinate_fromDistance_pitch_heading_,
        centerCoordinate,
        distance,
        pitch,
        heading);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a Boolean value indicating whether the given camera is functionally
  /// equivalent to the receiver.
  ///
  /// Unlike `isEqual:`, this method returns `YES` if the difference between the
  /// coordinates, altitudes, pitches, or headings of the two camera objects is
  /// negligible.
  ///
  /// @param otherCamera The camera with which to compare the receiver.
  /// @return A Boolean value indicating whether the two cameras are functionally
  /// equivalent.
  bool isEqualToMapCamera_(MLNMapCamera otherCamera) {
    return _objc_msgSend_69e0x1(
        this.ref.pointer, _sel_isEqualToMapCamera_, otherCamera.ref.pointer);
  }

  /// init
  MLNMapCamera init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMapCamera new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNMapCamera, _sel_new);
    return MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMapCamera allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_MLNMapCamera, _sel_allocWithZone_, zone);
    return MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMapCamera alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNMapCamera, _sel_alloc);
    return MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNMapCamera self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNMapCamera retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNMapCamera autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNMapCamera, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  MLNMapCamera? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_MLNStyleLayer = objc.getClass("MLNStyleLayer");
late final _sel_identifier = objc.registerName("identifier");
late final _sel_isVisible = objc.registerName("isVisible");
late final _sel_setVisible_ = objc.registerName("setVisible:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_maximumZoomLevel = objc.registerName("maximumZoomLevel");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setMaximumZoomLevel_ =
    objc.registerName("setMaximumZoomLevel:");
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Float)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_minimumZoomLevel = objc.registerName("minimumZoomLevel");
late final _sel_setMinimumZoomLevel_ =
    objc.registerName("setMinimumZoomLevel:");

/// ``MLNStyleLayer`` is an abstract base class for style layers. A style layer
/// manages the layout and appearance of content at a specific z-index in a style.
/// An ``MLNStyle`` object consists of one or more ``MLNStyle`` objects.
///
/// Each style layer defined by the style JSON file is represented at runtime by an
/// ``MLNStyleLayer`` object, which you can use to refine the map’s appearance. You
/// can also add and remove style layers dynamically.
///
/// Create instances of ``MLNBackgroundStyleLayer`` and the concrete subclasses of
/// ``MLNForegroundStyleLayer`` in order to use ``MLNForegroundStyleLayer``'s properties and methods.
/// You do not create instances of ``MLNStyleLayer`` directly, and do not
/// create your own subclasses of this class.
///
/// Do not add ``MLNStyleLayer`` objects to the `style` property of a ``MLNStyleLayer`` before
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` is called.
class MLNStyleLayer extends objc.NSObject {
  MLNStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNStyleLayer] that points to the same underlying object as [other].
  MLNStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNStyleLayer] that wraps the given raw object pointer.
  MLNStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNStyleLayer);
  }

  /// init
  MLNStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNStyleLayer.castFromPointer(_ret, retain: false, release: true);
  }

  /// A string that uniquely identifies the style layer in the style to which it is
  /// added.
  objc.NSString get identifier {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_identifier);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Whether this layer is displayed. A value of `NO` hides the layer.
  ///
  /// #### Related examples
  /// TODO: Show and hide a layer, learn how to toggle an ``MLNStyleLayer``
  /// object's visibility.
  bool get visible {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isVisible);
  }

  /// Whether this layer is displayed. A value of `NO` hides the layer.
  ///
  /// #### Related examples
  /// TODO: Show and hide a layer, learn how to toggle an ``MLNStyleLayer``
  /// object's visibility.
  set visible(bool value) {
    return _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setVisible_, value);
  }

  /// The maximum zoom level at which the layer gets parsed and appears. This value is a floating-point
  /// number.
  double get maximumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(this.ref.pointer, _sel_maximumZoomLevel)
        : _objc_msgSend_2cgrxl(this.ref.pointer, _sel_maximumZoomLevel);
  }

  /// The maximum zoom level at which the layer gets parsed and appears. This value is a floating-point
  /// number.
  set maximumZoomLevel(double value) {
    return _objc_msgSend_v5hmet(
        this.ref.pointer, _sel_setMaximumZoomLevel_, value);
  }

  /// The minimum zoom level at which the layer gets parsed and appears. This value is a floating-point
  /// number.
  double get minimumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(this.ref.pointer, _sel_minimumZoomLevel)
        : _objc_msgSend_2cgrxl(this.ref.pointer, _sel_minimumZoomLevel);
  }

  /// The minimum zoom level at which the layer gets parsed and appears. This value is a floating-point
  /// number.
  set minimumZoomLevel(double value) {
    return _objc_msgSend_v5hmet(
        this.ref.pointer, _sel_setMinimumZoomLevel_, value);
  }

  /// new
  static MLNStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNStyleLayer, _sel_new);
    return MLNStyleLayer.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_MLNStyleLayer, _sel_allocWithZone_, zone);
    return MLNStyleLayer.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNStyleLayer alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNStyleLayer, _sel_alloc);
    return MLNStyleLayer.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }
}

/// WARNING: MLNDefaultStyle is a stub. To generate bindings for this class, include
/// MLNDefaultStyle in your config's objc-interfaces list.
///
/// The ``MLNDefaultStyle`` defines the predefined vendor style
class MLNDefaultStyle extends objc.NSObject {
  MLNDefaultStyle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNDefaultStyle] that points to the same underlying object as [other].
  MLNDefaultStyle.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNDefaultStyle] that wraps the given raw object pointer.
  MLNDefaultStyle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_MLNStyle = objc.getClass("MLNStyle");
late final _sel_predefinedStyles = objc.registerName("predefinedStyles");
late final _sel_defaultStyle = objc.registerName("defaultStyle");
late final _sel_defaultStyleURL = objc.registerName("defaultStyleURL");
late final _sel_predefinedStyle_ = objc.registerName("predefinedStyle:");
late final _sel_name = objc.registerName("name");
late final _sel_sources = objc.registerName("sources");
late final _sel_setSources_ = objc.registerName("setSources:");
late final _sel_transition = objc.registerName("transition");
final _objc_msgSend_1i0p3hy = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNTransition Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        MLNTransition Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1i0p3hyStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNTransition>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<MLNTransition>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTransition_ = objc.registerName("setTransition:");
final _objc_msgSend_z7lywk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNTransition)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNTransition)>();
late final _sel_performsPlacementTransitions =
    objc.registerName("performsPlacementTransitions");
late final _sel_setPerformsPlacementTransitions_ =
    objc.registerName("setPerformsPlacementTransitions:");
late final _class_MLNSource = objc.getClass("MLNSource");
late final _sel_initWithIdentifier_ = objc.registerName("initWithIdentifier:");
late final _sel_setIdentifier_ = objc.registerName("setIdentifier:");

/// MLNSource
class MLNSource extends objc.NSObject {
  MLNSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNSource] that points to the same underlying object as [other].
  MLNSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNSource] that wraps the given raw object pointer.
  MLNSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNSource);
  }

  /// init
  MLNSource init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// A string that uniquely identifies the source in the style to which it is added.
  objc.NSString get identifier {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_identifier);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// A string that uniquely identifies the source in the style to which it is added.
  set identifier(objc.NSString value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIdentifier_, value.ref.pointer);
  }

  /// new
  static MLNSource new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNSource, _sel_new);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNSource allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_MLNSource, _sel_allocWithZone_, zone);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNSource alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNSource, _sel_alloc);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNSource self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNSource retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNSource autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNSource.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_sourceWithIdentifier_ =
    objc.registerName("sourceWithIdentifier:");
late final _sel_addSource_ = objc.registerName("addSource:");
late final _sel_removeSource_ = objc.registerName("removeSource:");
late final _sel_removeSource_error_ = objc.registerName("removeSource:error:");
final _objc_msgSend_blqzg8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_layers = objc.registerName("layers");
late final _sel_setLayers_ = objc.registerName("setLayers:");
late final _sel_layerWithIdentifier_ =
    objc.registerName("layerWithIdentifier:");
late final _sel_addLayer_ = objc.registerName("addLayer:");
late final _sel_insertLayer_atIndex_ =
    objc.registerName("insertLayer:atIndex:");
final _objc_msgSend_10i1axw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_insertLayer_belowLayer_ =
    objc.registerName("insertLayer:belowLayer:");
final _objc_msgSend_wjvic9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_insertLayer_aboveLayer_ =
    objc.registerName("insertLayer:aboveLayer:");
late final _sel_removeLayer_ = objc.registerName("removeLayer:");
late final _class_NSImage = objc.getClass("NSImage");

///
extension on NSImage {}

///
extension unnamed on NSImage {}

late final _sel_imageUnfilteredFileTypes =
    objc.registerName("imageUnfilteredFileTypes");
late final _sel_imageUnfilteredPasteboardTypes =
    objc.registerName("imageUnfilteredPasteboardTypes");
late final _sel_imageFileTypes = objc.registerName("imageFileTypes");
late final _sel_imagePasteboardTypes =
    objc.registerName("imagePasteboardTypes");

/// WARNING: NSImageRep is a stub. To generate bindings for this class, include
/// NSImageRep in your config's objc-interfaces list.
///
/// NSImageRep
class NSImageRep extends objc.NSObject {
  NSImageRep._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSImageRep] that points to the same underlying object as [other].
  NSImageRep.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSImageRep] that wraps the given raw object pointer.
  NSImageRep.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_bestRepresentationForDevice_ =
    objc.registerName("bestRepresentationForDevice:");
late final _sel_lockFocus = objc.registerName("lockFocus");
late final _sel_lockFocusFlipped_ = objc.registerName("lockFocusFlipped:");
late final _sel_unlockFocus = objc.registerName("unlockFocus");
late final _sel_setFlipped_ = objc.registerName("setFlipped:");
late final _sel_isFlipped = objc.registerName("isFlipped");
late final _sel_setScalesWhenResized_ =
    objc.registerName("setScalesWhenResized:");
late final _sel_scalesWhenResized = objc.registerName("scalesWhenResized");
late final _sel_setDataRetained_ = objc.registerName("setDataRetained:");
late final _sel_isDataRetained = objc.registerName("isDataRetained");
late final _sel_setCachedSeparately_ =
    objc.registerName("setCachedSeparately:");
late final _sel_isCachedSeparately = objc.registerName("isCachedSeparately");
late final _sel_setCacheDepthMatchesImageDepth_ =
    objc.registerName("setCacheDepthMatchesImageDepth:");
late final _sel_cacheDepthMatchesImageDepth =
    objc.registerName("cacheDepthMatchesImageDepth");
late final _sel_dissolveToPoint_fraction_ =
    objc.registerName("dissolveToPoint:fraction:");
final _objc_msgSend_1lkz44l = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, double)>();
late final _sel_dissolveToPoint_fromRect_fraction_ =
    objc.registerName("dissolveToPoint:fromRect:fraction:");
final _objc_msgSend_93gyx4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect, double)>();

enum NSCompositingOperation {
  NSCompositingOperationClear(0),
  NSCompositingOperationCopy(1),
  NSCompositingOperationSourceOver(2),
  NSCompositingOperationSourceIn(3),
  NSCompositingOperationSourceOut(4),
  NSCompositingOperationSourceAtop(5),
  NSCompositingOperationDestinationOver(6),
  NSCompositingOperationDestinationIn(7),
  NSCompositingOperationDestinationOut(8),
  NSCompositingOperationDestinationAtop(9),
  NSCompositingOperationXOR(10),
  NSCompositingOperationPlusDarker(11),
  NSCompositingOperationHighlight(12),
  NSCompositingOperationPlusLighter(13),
  NSCompositingOperationMultiply(14),
  NSCompositingOperationScreen(15),
  NSCompositingOperationOverlay(16),
  NSCompositingOperationDarken(17),
  NSCompositingOperationLighten(18),
  NSCompositingOperationColorDodge(19),
  NSCompositingOperationColorBurn(20),
  NSCompositingOperationSoftLight(21),
  NSCompositingOperationHardLight(22),
  NSCompositingOperationDifference(23),
  NSCompositingOperationExclusion(24),
  NSCompositingOperationHue(25),
  NSCompositingOperationSaturation(26),
  NSCompositingOperationColor(27),
  NSCompositingOperationLuminosity(28);

  final int value;
  const NSCompositingOperation(this.value);

  static NSCompositingOperation fromValue(int value) => switch (value) {
        0 => NSCompositingOperationClear,
        1 => NSCompositingOperationCopy,
        2 => NSCompositingOperationSourceOver,
        3 => NSCompositingOperationSourceIn,
        4 => NSCompositingOperationSourceOut,
        5 => NSCompositingOperationSourceAtop,
        6 => NSCompositingOperationDestinationOver,
        7 => NSCompositingOperationDestinationIn,
        8 => NSCompositingOperationDestinationOut,
        9 => NSCompositingOperationDestinationAtop,
        10 => NSCompositingOperationXOR,
        11 => NSCompositingOperationPlusDarker,
        12 => NSCompositingOperationHighlight,
        13 => NSCompositingOperationPlusLighter,
        14 => NSCompositingOperationMultiply,
        15 => NSCompositingOperationScreen,
        16 => NSCompositingOperationOverlay,
        17 => NSCompositingOperationDarken,
        18 => NSCompositingOperationLighten,
        19 => NSCompositingOperationColorDodge,
        20 => NSCompositingOperationColorBurn,
        21 => NSCompositingOperationSoftLight,
        22 => NSCompositingOperationHardLight,
        23 => NSCompositingOperationDifference,
        24 => NSCompositingOperationExclusion,
        25 => NSCompositingOperationHue,
        26 => NSCompositingOperationSaturation,
        27 => NSCompositingOperationColor,
        28 => NSCompositingOperationLuminosity,
        _ => throw ArgumentError(
            "Unknown value for NSCompositingOperation: $value"),
      };
}

late final _sel_compositeToPoint_operation_ =
    objc.registerName("compositeToPoint:operation:");
final _objc_msgSend_tutwec = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, int)>();
late final _sel_compositeToPoint_fromRect_operation_ =
    objc.registerName("compositeToPoint:fromRect:operation:");
final _objc_msgSend_bjle81 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                CGRect,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect, int)>();
late final _sel_compositeToPoint_operation_fraction_ =
    objc.registerName("compositeToPoint:operation:fraction:");
final _objc_msgSend_16t8gcf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                ffi.UnsignedLong,
                ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, int, double)>();
late final _sel_compositeToPoint_fromRect_operation_fraction_ =
    objc.registerName("compositeToPoint:fromRect:operation:fraction:");
final _objc_msgSend_1xnlu4e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                CGRect,
                ffi.UnsignedLong,
                ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint, CGRect, int, double)>();
late final _sel_lockFocusOnRepresentation_ =
    objc.registerName("lockFocusOnRepresentation:");
late final _sel_cancelIncrementalLoad =
    objc.registerName("cancelIncrementalLoad");

/// Deprecated
extension Deprecated on NSImage {
  /// imageUnfilteredFileTypes
  static objc.NSArray imageUnfilteredFileTypes() {
    final _ret =
        _objc_msgSend_1x359cv(_class_NSImage, _sel_imageUnfilteredFileTypes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageUnfilteredPasteboardTypes
  static objc.NSArray imageUnfilteredPasteboardTypes() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSImage, _sel_imageUnfilteredPasteboardTypes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageFileTypes
  static objc.NSArray imageFileTypes() {
    final _ret = _objc_msgSend_1x359cv(_class_NSImage, _sel_imageFileTypes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// imagePasteboardTypes
  static objc.NSArray imagePasteboardTypes() {
    final _ret =
        _objc_msgSend_1x359cv(_class_NSImage, _sel_imagePasteboardTypes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// bestRepresentationForDevice:
  NSImageRep bestRepresentationForDevice_(objc.NSDictionary deviceDescription) {
    final _ret = _objc_msgSend_62nh5j(this.ref.pointer,
        _sel_bestRepresentationForDevice_, deviceDescription.ref.pointer);
    return NSImageRep.castFromPointer(_ret, retain: true, release: true);
  }

  /// lockFocus
  void lockFocus() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_lockFocus);
  }

  /// lockFocusFlipped:
  void lockFocusFlipped_(bool flipped) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_lockFocusFlipped_, flipped);
  }

  /// unlockFocus
  void unlockFocus() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_unlockFocus);
  }

  /// setFlipped:
  void setFlipped_(bool flag) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setFlipped_, flag);
  }

  /// isFlipped
  bool isFlipped() {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFlipped);
  }

  /// setScalesWhenResized:
  void setScalesWhenResized_(bool flag) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setScalesWhenResized_, flag);
  }

  /// scalesWhenResized
  bool scalesWhenResized() {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_scalesWhenResized);
  }

  /// setDataRetained:
  void setDataRetained_(bool flag) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDataRetained_, flag);
  }

  /// isDataRetained
  bool isDataRetained() {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDataRetained);
  }

  /// setCachedSeparately:
  void setCachedSeparately_(bool flag) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setCachedSeparately_, flag);
  }

  /// isCachedSeparately
  bool isCachedSeparately() {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isCachedSeparately);
  }

  /// setCacheDepthMatchesImageDepth:
  void setCacheDepthMatchesImageDepth_(bool flag) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setCacheDepthMatchesImageDepth_, flag);
  }

  /// cacheDepthMatchesImageDepth
  bool cacheDepthMatchesImageDepth() {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_cacheDepthMatchesImageDepth);
  }

  /// dissolveToPoint:fraction:
  void dissolveToPoint_fraction_(CGPoint point, double fraction) {
    _objc_msgSend_1lkz44l(
        this.ref.pointer, _sel_dissolveToPoint_fraction_, point, fraction);
  }

  /// dissolveToPoint:fromRect:fraction:
  void dissolveToPoint_fromRect_fraction_(
      CGPoint point, CGRect rect, double fraction) {
    _objc_msgSend_93gyx4(this.ref.pointer,
        _sel_dissolveToPoint_fromRect_fraction_, point, rect, fraction);
  }

  /// compositeToPoint:operation:
  void compositeToPoint_operation_(
      CGPoint point, NSCompositingOperation operation) {
    _objc_msgSend_tutwec(this.ref.pointer, _sel_compositeToPoint_operation_,
        point, operation.value);
  }

  /// compositeToPoint:fromRect:operation:
  void compositeToPoint_fromRect_operation_(
      CGPoint point, CGRect rect, NSCompositingOperation operation) {
    _objc_msgSend_bjle81(
        this.ref.pointer,
        _sel_compositeToPoint_fromRect_operation_,
        point,
        rect,
        operation.value);
  }

  /// compositeToPoint:operation:fraction:
  void compositeToPoint_operation_fraction_(
      CGPoint point, NSCompositingOperation operation, double fraction) {
    _objc_msgSend_16t8gcf(
        this.ref.pointer,
        _sel_compositeToPoint_operation_fraction_,
        point,
        operation.value,
        fraction);
  }

  /// compositeToPoint:fromRect:operation:fraction:
  void compositeToPoint_fromRect_operation_fraction_(CGPoint point, CGRect rect,
      NSCompositingOperation operation, double fraction) {
    _objc_msgSend_1xnlu4e(
        this.ref.pointer,
        _sel_compositeToPoint_fromRect_operation_fraction_,
        point,
        rect,
        operation.value,
        fraction);
  }

  /// lockFocusOnRepresentation:
  void lockFocusOnRepresentation_(NSImageRep imageRepresentation) {
    _objc_msgSend_1jdvcbf(this.ref.pointer, _sel_lockFocusOnRepresentation_,
        imageRepresentation.ref.pointer);
  }

  /// cancelIncrementalLoad
  void cancelIncrementalLoad() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cancelIncrementalLoad);
  }
}

late final _sel_imageNamed_ = objc.registerName("imageNamed:");
late final _sel_imageWithSystemSymbolName_accessibilityDescription_ =
    objc.registerName("imageWithSystemSymbolName:accessibilityDescription:");
late final _sel_imageWithSystemSymbolName_variableValue_accessibilityDescription_ =
    objc.registerName(
        "imageWithSystemSymbolName:variableValue:accessibilityDescription:");
final _objc_msgSend_45qm9k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_imageWithSymbolName_variableValue_ =
    objc.registerName("imageWithSymbolName:variableValue:");
final _objc_msgSend_1cw9ptg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double)>();
late final _sel_imageWithSymbolName_bundle_variableValue_ =
    objc.registerName("imageWithSymbolName:bundle:variableValue:");
final _objc_msgSend_1xdeq9e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            double)>();
late final _sel_initWithSize_ = objc.registerName("initWithSize:");
final _objc_msgSend_1lqhnuf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGSize)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGSize)>();
late final _sel_initWithData_ = objc.registerName("initWithData:");
late final _sel_initWithContentsOfFile_ =
    objc.registerName("initWithContentsOfFile:");
late final _sel_initWithContentsOfURL_ =
    objc.registerName("initWithContentsOfURL:");
late final _sel_initByReferencingFile_ =
    objc.registerName("initByReferencingFile:");
late final _sel_initByReferencingURL_ =
    objc.registerName("initByReferencingURL:");

/// WARNING: NSPasteboard is a stub. To generate bindings for this class, include
/// NSPasteboard in your config's objc-interfaces list.
///
/// NSPasteboard
class NSPasteboard extends objc.NSObject {
  NSPasteboard._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSPasteboard] that points to the same underlying object as [other].
  NSPasteboard.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSPasteboard] that wraps the given raw object pointer.
  NSPasteboard.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_initWithPasteboard_ = objc.registerName("initWithPasteboard:");
late final _sel_initWithDataIgnoringOrientation_ =
    objc.registerName("initWithDataIgnoringOrientation:");
bool _ObjCBlock_bool_NSRect_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, CGRect arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Bool Function(CGRect arg0)>>()
        .asFunction<bool Function(CGRect)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_NSRect_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, CGRect)>(
            _ObjCBlock_bool_NSRect_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_NSRect_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, CGRect arg0) =>
    (objc.getBlockClosure(block) as bool Function(CGRect))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_NSRect_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, CGRect)>(
            _ObjCBlock_bool_NSRect_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(CGRect)>`.
abstract final class ObjCBlock_bool_NSRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(CGRect)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(CGRect)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(CGRect)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(CGRect arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(CGRect)>(
          objc.newPointerBlock(
              _ObjCBlock_bool_NSRect_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(CGRect)> fromFunction(
          bool Function(CGRect) fn) =>
      objc.ObjCBlock<ffi.Bool Function(CGRect)>(
          objc.newClosureBlock(_ObjCBlock_bool_NSRect_closureCallable,
              (CGRect arg0) => fn(arg0)),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(CGRect)>`.
extension ObjCBlock_bool_NSRect_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(CGRect)> {
  bool call(CGRect arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block, CGRect arg0)>>()
          .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl>, CGRect)>()(
      ref.pointer, arg0);
}

late final _sel_imageWithSize_flipped_drawingHandler_ =
    objc.registerName("imageWithSize:flipped:drawingHandler:");
final _objc_msgSend_1tpk6hs = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGSize,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGSize,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_size = objc.registerName("size");
final _objc_msgSend_1vdfken = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGSize Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGSize Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGSize>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGSize>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSize_ = objc.registerName("setSize:");
final _objc_msgSend_13lgpwz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGSize)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGSize)>();
late final _sel_setName_ = objc.registerName("setName:");

/// WARNING: NSColor is a stub. To generate bindings for this class, include
/// NSColor in your config's objc-interfaces list.
///
/// NSColor
class NSColor extends objc.NSObject {
  NSColor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSColor] that points to the same underlying object as [other].
  NSColor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSColor] that wraps the given raw object pointer.
  NSColor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_backgroundColor = objc.registerName("backgroundColor");
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
late final _sel_usesEPSOnResolutionMismatch =
    objc.registerName("usesEPSOnResolutionMismatch");
late final _sel_setUsesEPSOnResolutionMismatch_ =
    objc.registerName("setUsesEPSOnResolutionMismatch:");
late final _sel_prefersColorMatch = objc.registerName("prefersColorMatch");
late final _sel_setPrefersColorMatch_ =
    objc.registerName("setPrefersColorMatch:");
late final _sel_matchesOnMultipleResolution =
    objc.registerName("matchesOnMultipleResolution");
late final _sel_setMatchesOnMultipleResolution_ =
    objc.registerName("setMatchesOnMultipleResolution:");
late final _sel_matchesOnlyOnBestFittingAxis =
    objc.registerName("matchesOnlyOnBestFittingAxis");
late final _sel_setMatchesOnlyOnBestFittingAxis_ =
    objc.registerName("setMatchesOnlyOnBestFittingAxis:");
late final _sel_drawAtPoint_fromRect_operation_fraction_ =
    objc.registerName("drawAtPoint:fromRect:operation:fraction:");
late final _sel_drawInRect_fromRect_operation_fraction_ =
    objc.registerName("drawInRect:fromRect:operation:fraction:");
final _objc_msgSend_bfgdl2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                CGRect,
                ffi.UnsignedLong,
                ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect, CGRect, int, double)>();
late final _sel_drawInRect_fromRect_operation_fraction_respectFlipped_hints_ =
    objc.registerName(
        "drawInRect:fromRect:operation:fraction:respectFlipped:hints:");
final _objc_msgSend_15kvw22 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                CGRect,
                ffi.UnsignedLong,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            CGRect,
            int,
            double,
            bool,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_drawRepresentation_inRect_ =
    objc.registerName("drawRepresentation:inRect:");
final _objc_msgSend_1xapbuq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect)>();
late final _sel_drawInRect_ = objc.registerName("drawInRect:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_recache = objc.registerName("recache");
late final _sel_TIFFRepresentation = objc.registerName("TIFFRepresentation");

enum NSTIFFCompression {
  NSTIFFCompressionNone(1),
  NSTIFFCompressionCCITTFAX3(3),
  NSTIFFCompressionCCITTFAX4(4),
  NSTIFFCompressionLZW(5),
  NSTIFFCompressionJPEG(6),
  NSTIFFCompressionNEXT(32766),
  NSTIFFCompressionPackBits(32773),
  NSTIFFCompressionOldJPEG(32865);

  final int value;
  const NSTIFFCompression(this.value);

  static NSTIFFCompression fromValue(int value) => switch (value) {
        1 => NSTIFFCompressionNone,
        3 => NSTIFFCompressionCCITTFAX3,
        4 => NSTIFFCompressionCCITTFAX4,
        5 => NSTIFFCompressionLZW,
        6 => NSTIFFCompressionJPEG,
        32766 => NSTIFFCompressionNEXT,
        32773 => NSTIFFCompressionPackBits,
        32865 => NSTIFFCompressionOldJPEG,
        _ => throw ArgumentError("Unknown value for NSTIFFCompression: $value"),
      };
}

late final _sel_TIFFRepresentationUsingCompression_factor_ =
    objc.registerName("TIFFRepresentationUsingCompression:factor:");
final _objc_msgSend_1rtefkt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Float)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, double)>();
late final _sel_representations = objc.registerName("representations");
late final _sel_addRepresentations_ = objc.registerName("addRepresentations:");
late final _sel_addRepresentation_ = objc.registerName("addRepresentation:");
late final _sel_removeRepresentation_ =
    objc.registerName("removeRepresentation:");
late final _sel_isValid = objc.registerName("isValid");
late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
late final _sel_imageTypes = objc.registerName("imageTypes");
late final _sel_imageUnfilteredTypes =
    objc.registerName("imageUnfilteredTypes");
late final _sel_canInitWithPasteboard_ =
    objc.registerName("canInitWithPasteboard:");

enum NSImageCacheMode {
  NSImageCacheDefault(0),
  NSImageCacheAlways(1),
  NSImageCacheBySize(2),
  NSImageCacheNever(3);

  final int value;
  const NSImageCacheMode(this.value);

  static NSImageCacheMode fromValue(int value) => switch (value) {
        0 => NSImageCacheDefault,
        1 => NSImageCacheAlways,
        2 => NSImageCacheBySize,
        3 => NSImageCacheNever,
        _ => throw ArgumentError("Unknown value for NSImageCacheMode: $value"),
      };
}

late final _sel_cacheMode = objc.registerName("cacheMode");
final _objc_msgSend_1d4tuvg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCacheMode_ = objc.registerName("setCacheMode:");
final _objc_msgSend_14xnhaq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_alignmentRect = objc.registerName("alignmentRect");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGRect Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAlignmentRect_ = objc.registerName("setAlignmentRect:");
late final _sel_isTemplate = objc.registerName("isTemplate");
late final _sel_setTemplate_ = objc.registerName("setTemplate:");
late final _sel_accessibilityDescription =
    objc.registerName("accessibilityDescription");
late final _sel_setAccessibilityDescription_ =
    objc.registerName("setAccessibilityDescription:");
late final _sel_initWithCGImage_size_ =
    objc.registerName("initWithCGImage:size:");
final _objc_msgSend_1fhqq4v = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CGImage>,
                CGSize)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGImage>, CGSize)>();

/// WARNING: NSGraphicsContext is a stub. To generate bindings for this class, include
/// NSGraphicsContext in your config's objc-interfaces list.
///
/// NSGraphicsContext
class NSGraphicsContext extends objc.NSObject {
  NSGraphicsContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSGraphicsContext] that points to the same underlying object as [other].
  NSGraphicsContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSGraphicsContext] that wraps the given raw object pointer.
  NSGraphicsContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_CGImageForProposedRect_context_hints_ =
    objc.registerName("CGImageForProposedRect:context:hints:");
final _objc_msgSend_sazjlq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<CGImage> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<CGImage> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_bestRepresentationForRect_context_hints_ =
    objc.registerName("bestRepresentationForRect:context:hints:");
final _objc_msgSend_1hrqp72 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_hitTestRect_withImageDestinationRect_context_hints_flipped_ =
    objc.registerName(
        "hitTestRect:withImageDestinationRect:context:hints:flipped:");
final _objc_msgSend_jjj6g9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                CGRect,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            CGRect,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_recommendedLayerContentsScale_ =
    objc.registerName("recommendedLayerContentsScale:");
final _objc_msgSend_1tczmpv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
final _objc_msgSend_1tczmpvFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_layerContentsForContentsScale_ =
    objc.registerName("layerContentsForContentsScale:");
final _objc_msgSend_1x911p2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_capInsets = objc.registerName("capInsets");
final _objc_msgSend_sl0cgw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSEdgeInsets Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        NSEdgeInsets Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_sl0cgwStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<NSEdgeInsets>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<NSEdgeInsets>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCapInsets_ = objc.registerName("setCapInsets:");
final _objc_msgSend_1ug163q = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSEdgeInsets)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, NSEdgeInsets)>();

enum NSImageResizingMode {
  NSImageResizingModeTile(0),
  NSImageResizingModeStretch(1);

  final int value;
  const NSImageResizingMode(this.value);

  static NSImageResizingMode fromValue(int value) => switch (value) {
        0 => NSImageResizingModeTile,
        1 => NSImageResizingModeStretch,
        _ =>
          throw ArgumentError("Unknown value for NSImageResizingMode: $value"),
      };
}

late final _sel_resizingMode = objc.registerName("resizingMode");
final _objc_msgSend_q65rpn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setResizingMode_ = objc.registerName("setResizingMode:");
final _objc_msgSend_197i80f = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// WARNING: NSImageSymbolConfiguration is a stub. To generate bindings for this class, include
/// NSImageSymbolConfiguration in your config's objc-interfaces list.
///
/// NSImageSymbolConfiguration
class NSImageSymbolConfiguration extends objc.NSObject {
  NSImageSymbolConfiguration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSImageSymbolConfiguration] that points to the same underlying object as [other].
  NSImageSymbolConfiguration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSImageSymbolConfiguration] that wraps the given raw object pointer.
  NSImageSymbolConfiguration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_imageWithSymbolConfiguration_ =
    objc.registerName("imageWithSymbolConfiguration:");
late final _sel_symbolConfiguration = objc.registerName("symbolConfiguration");
late final _sel_imageWithLocale_ = objc.registerName("imageWithLocale:");
late final _sel_locale = objc.registerName("locale");
late final _sel_readableTypesForPasteboard_ =
    objc.registerName("readableTypesForPasteboard:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSArray_ffiVoid_NSPasteboard_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_NSPasteboard_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSArray_ffiVoid_NSPasteboard_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSArray_ffiVoid_NSPasteboard_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_NSPasteboard_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSArray_ffiVoid_NSPasteboard_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_NSPasteboard {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.NSArray Function(ffi.Pointer<ffi.Void>,
                  NSPasteboard)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard)>(
          objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_NSPasteboard_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard)> fromFunction(
          objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard) fn) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard)>(
          objc.newClosureBlock(
              _ObjCBlock_NSArray_ffiVoid_NSPasteboard_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, NSPasteboard.castFromPointer(arg1, retain: true, release: true))
                      .ref
                      .retainAndAutorelease()),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard)>`.
extension ObjCBlock_NSArray_ffiVoid_NSPasteboard_CallExtension on objc
    .ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, NSPasteboard)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0, NSPasteboard arg1) =>
      objc.NSArray.castFromPointer(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true);
}

enum NSPasteboardReadingOptions {
  NSPasteboardReadingAsData(0),
  NSPasteboardReadingAsString(1),
  NSPasteboardReadingAsPropertyList(2),
  NSPasteboardReadingAsKeyedArchive(4);

  final int value;
  const NSPasteboardReadingOptions(this.value);

  static NSPasteboardReadingOptions fromValue(int value) => switch (value) {
        0 => NSPasteboardReadingAsData,
        1 => NSPasteboardReadingAsString,
        2 => NSPasteboardReadingAsPropertyList,
        4 => NSPasteboardReadingAsKeyedArchive,
        _ => throw ArgumentError(
            "Unknown value for NSPasteboardReadingOptions: $value"),
      };
}

late final _sel_readingOptionsForType_pasteboard_ =
    objc.registerName("readingOptionsForType:pasteboard:");
final _objc_msgSend_tx5oy3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
int _ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>`.
abstract final class ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString,
                  NSPasteboard)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.UnsignedLong Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>(
          objc.newPointerBlock(_ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)> fromFunction(
          NSPasteboardReadingOptions Function(
                  ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)
              fn) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>(
          objc.newClosureBlock(
              _ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2) =>
                  fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true), NSPasteboard.castFromPointer(arg2, retain: true, release: true)).value),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>`.
extension ObjCBlock_NSPasteboardReadingOptions_ffiVoid_NSPasteboardType_NSPasteboard_CallExtension
    on objc.ObjCBlock<
        ffi.UnsignedLong Function(
            ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)> {
  NSPasteboardReadingOptions call(
          ffi.Pointer<ffi.Void> arg0, objc.NSString arg1, NSPasteboard arg2) =>
      NSPasteboardReadingOptions.fromValue(ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.UnsignedLong Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  int Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer));
}

late final _sel_initWithPasteboardPropertyList_ofType_ =
    objc.registerName("initWithPasteboardPropertyList:ofType:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              objc.NSString)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      objc.NSString)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>
      fromFunction(objc.ObjCObjectBase? Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase, objc.NSString) fn) =>
          objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(arg0, objc.ObjCObjectBase(arg1, retain: true, release: true), objc.NSString.castFromPointer(arg2, retain: true, release: true))
                          ?.ref
                          .retainAndReturnPointer() ??
                      ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.NSString)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_objcObjCObject_NSPasteboardType_CallExtension
    on objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSString)> {
  objc.ObjCObjectBase? call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase arg1, objc.NSString arg2) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>)>()
                  (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
                  .address ==
              0
          ? null
          : objc.ObjCObjectBase(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>().asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer), retain: false, release: true);
}

late final _sel_writableTypesForPasteboard_ =
    objc.registerName("writableTypesForPasteboard:");

enum NSPasteboardWritingOptions {
  NSPasteboardWritingPromised(512);

  final int value;
  const NSPasteboardWritingOptions(this.value);

  static NSPasteboardWritingOptions fromValue(int value) => switch (value) {
        512 => NSPasteboardWritingPromised,
        _ => throw ArgumentError(
            "Unknown value for NSPasteboardWritingOptions: $value"),
      };
}

late final _sel_writingOptionsForType_pasteboard_ =
    objc.registerName("writingOptionsForType:pasteboard:");
final _objc_msgSend_t9c00r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
int _ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>`.
abstract final class ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString,
                  NSPasteboard)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.UnsignedLong Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>(
          objc.newPointerBlock(_ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)> fromFunction(
          NSPasteboardWritingOptions Function(
                  ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)
              fn) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>(
          objc.newClosureBlock(
              _ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2) =>
                  fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true), NSPasteboard.castFromPointer(arg2, retain: true, release: true)).value),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)>`.
extension ObjCBlock_NSPasteboardWritingOptions_ffiVoid_NSPasteboardType_NSPasteboard_CallExtension
    on objc.ObjCBlock<
        ffi.UnsignedLong Function(
            ffi.Pointer<ffi.Void>, objc.NSString, NSPasteboard)> {
  NSPasteboardWritingOptions call(
          ffi.Pointer<ffi.Void> arg0, objc.NSString arg1, NSPasteboard arg2) =>
      NSPasteboardWritingOptions.fromValue(ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.UnsignedLong Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  int Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer));
}

late final _sel_pasteboardPropertyListForType_ =
    objc.registerName("pasteboardPropertyListForType:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      fromFunction(objc.ObjCObjectBase? Function(ffi.Pointer<ffi.Void>, objc.NSString) fn) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_NSAnimatablePropertyKey_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.ObjCObjectBase? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
                  (ref.pointer, arg0, arg1.ref.pointer)
                  .address ==
              0
          ? null
          : objc.ObjCObjectBase(
              ref.pointer.ref.invoke
                  .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
              retain: true,
              release: true);
}

late final _sel_readableTypeIdentifiersForItemProvider =
    objc.registerName("readableTypeIdentifiersForItemProvider");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSArray_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSArray Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSArray_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease()),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_objectWithItemProviderData_typeIdentifier_error_ =
    objc.registerName("objectWithItemProviderData:typeIdentifier:error:");
final _objc_msgSend_bo6ep4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
instancetype
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        instancetype Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>()
                .asFunction<
                    instancetype Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()(
            arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
            _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
            _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>,
              objc.NSData,
              objc.NSString,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject>? Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSData,
                  objc.NSString,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>,
                      objc.NSData,
                      objc.NSString,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
              objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>) fn) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
                      fn(arg0, objc.NSData.castFromPointer(arg1, retain: true, release: true), objc.NSString.castFromPointer(arg2, retain: true, release: true), arg3)?.ref.retainAndAutorelease() ??
                      ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSData,
            objc.NSString,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSData arg1, objc.NSString arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>()
              .asFunction<
                  instancetype Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()
              (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>().asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3),
          retain: true,
          release: true);
}

late final _sel_writableTypeIdentifiersForItemProvider =
    objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ =
    objc.registerName(
        "itemProviderVisibilityForRepresentationWithTypeIdentifier:");
final _objc_msgSend_96wwe1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Long Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Long Function(ffi.Pointer<ffi.Void>,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newPointerBlock(
              _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(
          objc.NSItemProviderRepresentationVisibility Function(
                  ffi.Pointer<ffi.Void>, objc.NSString)
              fn) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newClosureBlock(
              _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true))
                      .value),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.NSItemProviderRepresentationVisibility call(
          ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      objc.NSItemProviderRepresentationVisibility.fromValue(ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Long Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer));
}

void _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(
          void Function(objc.NSData?, objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSData_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSData.castFromPointer(arg0,
                          retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      listener(void Function(objc.NSData?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final wrapper = _MapLibreFFi_wrapListenerBlock_wjvic9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
      arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ =
    objc.registerName(
        "loadDataWithTypeIdentifier:forItemProviderCompletionHandler:");
final _objc_msgSend_o4sqyk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
              objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
                      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
              objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>> ptr) =>
          objc.ObjCBlock<
                  NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
                      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(
              objc.newPointerBlock(_ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      fromFunction(NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>) fn) =>
          objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
                      fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true), ObjCBlock_ffiVoid_NSData_NSError.castFromPointer(arg2, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_CallExtension
    on objc.ObjCBlock<
        NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
            objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> {
  NSProgress? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCBlockImpl>)>()
                  (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
                  .address ==
              0
          ? null
          : NSProgress.castFromPointer(
              ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>().asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCBlockImpl>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
              retain: true,
              release: true);
}

late final _sel_initWithIconRef_ = objc.registerName("initWithIconRef:");
final _objc_msgSend_4uw50h = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<OpaqueIconRef>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<OpaqueIconRef>)>();

/// NSImage
class NSImage extends objc.NSObject {
  NSImage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSImage] that points to the same underlying object as [other].
  NSImage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSImage] that wraps the given raw object pointer.
  NSImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSImage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSImage);
  }

  /// imageNamed:
  static NSImage? imageNamed_(objc.NSString name) {
    final _ret = _objc_msgSend_62nh5j(
        _class_NSImage, _sel_imageNamed_, name.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithSystemSymbolName:accessibilityDescription:
  static NSImage? imageWithSystemSymbolName_accessibilityDescription_(
      objc.NSString name, objc.NSString? description) {
    final _ret = _objc_msgSend_rsfdlh(
        _class_NSImage,
        _sel_imageWithSystemSymbolName_accessibilityDescription_,
        name.ref.pointer,
        description?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithSystemSymbolName:variableValue:accessibilityDescription:
  static NSImage?
      imageWithSystemSymbolName_variableValue_accessibilityDescription_(
          objc.NSString name, double value, objc.NSString? description) {
    final _ret = _objc_msgSend_45qm9k(
        _class_NSImage,
        _sel_imageWithSystemSymbolName_variableValue_accessibilityDescription_,
        name.ref.pointer,
        value,
        description?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithSymbolName:variableValue:
  static NSImage? imageWithSymbolName_variableValue_(
      objc.NSString name, double value) {
    final _ret = _objc_msgSend_1cw9ptg(_class_NSImage,
        _sel_imageWithSymbolName_variableValue_, name.ref.pointer, value);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithSymbolName:bundle:variableValue:
  static NSImage? imageWithSymbolName_bundle_variableValue_(
      objc.NSString name, NSBundle? bundle, double value) {
    final _ret = _objc_msgSend_1xdeq9e(
        _class_NSImage,
        _sel_imageWithSymbolName_bundle_variableValue_,
        name.ref.pointer,
        bundle?.ref.pointer ?? ffi.nullptr,
        value);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithSize:
  NSImage initWithSize_(CGSize size) {
    final _ret = _objc_msgSend_1lqhnuf(
        this.ref.retainAndReturnPointer(), _sel_initWithSize_, size);
    return NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSImage? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithData:
  NSImage? initWithData_(objc.NSData data) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithData_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:
  NSImage? initWithContentsOfFile_(objc.NSString fileName) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_, fileName.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  NSImage? initWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initByReferencingFile:
  NSImage? initByReferencingFile_(objc.NSString fileName) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initByReferencingFile_, fileName.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initByReferencingURL:
  NSImage initByReferencingURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initByReferencingURL_, url.ref.pointer);
    return NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithPasteboard:
  NSImage? initWithPasteboard_(NSPasteboard pasteboard) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithPasteboard_, pasteboard.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithDataIgnoringOrientation:
  NSImage? initWithDataIgnoringOrientation_(objc.NSData data) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithDataIgnoringOrientation_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// imageWithSize:flipped:drawingHandler:
  static NSImage imageWithSize_flipped_drawingHandler_(
      CGSize size,
      bool drawingHandlerShouldBeCalledWithFlippedContext,
      objc.ObjCBlock<ffi.Bool Function(CGRect)> drawingHandler) {
    final _ret = _objc_msgSend_1tpk6hs(
        _class_NSImage,
        _sel_imageWithSize_flipped_drawingHandler_,
        size,
        drawingHandlerShouldBeCalledWithFlippedContext,
        drawingHandler.ref.pointer);
    return NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// size
  CGSize get size {
    final _ptr = pkg_ffi.calloc<CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(_ptr, this.ref.pointer, _sel_size)
        : _ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_size);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGSize>(_finalizable);
  }

  /// setSize:
  set size(CGSize value) {
    return _objc_msgSend_13lgpwz(this.ref.pointer, _sel_setSize_, value);
  }

  /// setName:
  bool setName_(objc.NSString? string) {
    return _objc_msgSend_69e0x1(
        this.ref.pointer, _sel_setName_, string?.ref.pointer ?? ffi.nullptr);
  }

  /// name
  objc.NSString? name() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_name);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// backgroundColor
  NSColor get backgroundColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_backgroundColor);
    return NSColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackgroundColor:
  set backgroundColor(NSColor value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setBackgroundColor_, value.ref.pointer);
  }

  /// usesEPSOnResolutionMismatch
  bool get usesEPSOnResolutionMismatch {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_usesEPSOnResolutionMismatch);
  }

  /// setUsesEPSOnResolutionMismatch:
  set usesEPSOnResolutionMismatch(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setUsesEPSOnResolutionMismatch_, value);
  }

  /// prefersColorMatch
  bool get prefersColorMatch {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefersColorMatch);
  }

  /// setPrefersColorMatch:
  set prefersColorMatch(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPrefersColorMatch_, value);
  }

  /// matchesOnMultipleResolution
  bool get matchesOnMultipleResolution {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_matchesOnMultipleResolution);
  }

  /// setMatchesOnMultipleResolution:
  set matchesOnMultipleResolution(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setMatchesOnMultipleResolution_, value);
  }

  /// matchesOnlyOnBestFittingAxis
  bool get matchesOnlyOnBestFittingAxis {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_matchesOnlyOnBestFittingAxis);
  }

  /// setMatchesOnlyOnBestFittingAxis:
  set matchesOnlyOnBestFittingAxis(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setMatchesOnlyOnBestFittingAxis_, value);
  }

  /// drawAtPoint:fromRect:operation:fraction:
  void drawAtPoint_fromRect_operation_fraction_(
      CGPoint point, CGRect fromRect, NSCompositingOperation op, double delta) {
    _objc_msgSend_1xnlu4e(
        this.ref.pointer,
        _sel_drawAtPoint_fromRect_operation_fraction_,
        point,
        fromRect,
        op.value,
        delta);
  }

  /// drawInRect:fromRect:operation:fraction:
  void drawInRect_fromRect_operation_fraction_(
      CGRect rect, CGRect fromRect, NSCompositingOperation op, double delta) {
    _objc_msgSend_bfgdl2(
        this.ref.pointer,
        _sel_drawInRect_fromRect_operation_fraction_,
        rect,
        fromRect,
        op.value,
        delta);
  }

  /// drawInRect:fromRect:operation:fraction:respectFlipped:hints:
  void drawInRect_fromRect_operation_fraction_respectFlipped_hints_(
      CGRect dstSpacePortionRect,
      CGRect srcSpacePortionRect,
      NSCompositingOperation op,
      double requestedAlpha,
      bool respectContextIsFlipped,
      objc.NSDictionary? hints) {
    _objc_msgSend_15kvw22(
        this.ref.pointer,
        _sel_drawInRect_fromRect_operation_fraction_respectFlipped_hints_,
        dstSpacePortionRect,
        srcSpacePortionRect,
        op.value,
        requestedAlpha,
        respectContextIsFlipped,
        hints?.ref.pointer ?? ffi.nullptr);
  }

  /// drawRepresentation:inRect:
  bool drawRepresentation_inRect_(NSImageRep imageRep, CGRect rect) {
    return _objc_msgSend_1xapbuq(this.ref.pointer,
        _sel_drawRepresentation_inRect_, imageRep.ref.pointer, rect);
  }

  /// drawInRect:
  void drawInRect_(CGRect rect) {
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_drawInRect_, rect);
  }

  /// recache
  void recache() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_recache);
  }

  /// TIFFRepresentation
  objc.NSData? get TIFFRepresentation {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_TIFFRepresentation);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// TIFFRepresentationUsingCompression:factor:
  objc.NSData? TIFFRepresentationUsingCompression_factor_(
      NSTIFFCompression comp, double factor) {
    final _ret = _objc_msgSend_1rtefkt(this.ref.pointer,
        _sel_TIFFRepresentationUsingCompression_factor_, comp.value, factor);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// representations
  objc.NSArray get representations {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_representations);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// addRepresentations:
  void addRepresentations_(objc.NSArray imageReps) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_addRepresentations_, imageReps.ref.pointer);
  }

  /// addRepresentation:
  void addRepresentation_(NSImageRep imageRep) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_addRepresentation_, imageRep.ref.pointer);
  }

  /// removeRepresentation:
  void removeRepresentation_(NSImageRep imageRep) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_removeRepresentation_, imageRep.ref.pointer);
  }

  /// isValid
  bool get valid {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isValid);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// imageTypes
  static objc.NSArray getImageTypes() {
    final _ret = _objc_msgSend_1x359cv(_class_NSImage, _sel_imageTypes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageUnfilteredTypes
  static objc.NSArray getImageUnfilteredTypes() {
    final _ret =
        _objc_msgSend_1x359cv(_class_NSImage, _sel_imageUnfilteredTypes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// canInitWithPasteboard:
  static bool canInitWithPasteboard_(NSPasteboard pasteboard) {
    return _objc_msgSend_69e0x1(
        _class_NSImage, _sel_canInitWithPasteboard_, pasteboard.ref.pointer);
  }

  /// cacheMode
  NSImageCacheMode get cacheMode {
    final _ret = _objc_msgSend_1d4tuvg(this.ref.pointer, _sel_cacheMode);
    return NSImageCacheMode.fromValue(_ret);
  }

  /// setCacheMode:
  set cacheMode(NSImageCacheMode value) {
    return _objc_msgSend_14xnhaq(
        this.ref.pointer, _sel_setCacheMode_, value.value);
  }

  /// alignmentRect
  CGRect get alignmentRect {
    final _ptr = pkg_ffi.calloc<CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_alignmentRect)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_alignmentRect);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGRect>(_finalizable);
  }

  /// setAlignmentRect:
  set alignmentRect(CGRect value) {
    return _objc_msgSend_1okkq16(
        this.ref.pointer, _sel_setAlignmentRect_, value);
  }

  /// isTemplate
  bool get template {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTemplate);
  }

  /// setTemplate:
  set template(bool value) {
    return _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setTemplate_, value);
  }

  /// accessibilityDescription
  objc.NSString? get accessibilityDescription {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_accessibilityDescription);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAccessibilityDescription:
  set accessibilityDescription(objc.NSString? value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer,
        _sel_setAccessibilityDescription_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// initWithCGImage:size:
  NSImage initWithCGImage_size_(ffi.Pointer<CGImage> cgImage, CGSize size) {
    final _ret = _objc_msgSend_1fhqq4v(this.ref.retainAndReturnPointer(),
        _sel_initWithCGImage_size_, cgImage, size);
    return NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// CGImageForProposedRect:context:hints:
  ffi.Pointer<CGImage> CGImageForProposedRect_context_hints_(
      ffi.Pointer<CGRect> proposedDestRect,
      NSGraphicsContext? referenceContext,
      objc.NSDictionary? hints) {
    return _objc_msgSend_sazjlq(
        this.ref.pointer,
        _sel_CGImageForProposedRect_context_hints_,
        proposedDestRect,
        referenceContext?.ref.pointer ?? ffi.nullptr,
        hints?.ref.pointer ?? ffi.nullptr);
  }

  /// bestRepresentationForRect:context:hints:
  NSImageRep? bestRepresentationForRect_context_hints_(CGRect rect,
      NSGraphicsContext? referenceContext, objc.NSDictionary? hints) {
    final _ret = _objc_msgSend_1hrqp72(
        this.ref.pointer,
        _sel_bestRepresentationForRect_context_hints_,
        rect,
        referenceContext?.ref.pointer ?? ffi.nullptr,
        hints?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSImageRep.castFromPointer(_ret, retain: true, release: true);
  }

  /// hitTestRect:withImageDestinationRect:context:hints:flipped:
  bool hitTestRect_withImageDestinationRect_context_hints_flipped_(
      CGRect testRectDestSpace,
      CGRect imageRectDestSpace,
      NSGraphicsContext? context,
      objc.NSDictionary? hints,
      bool flipped) {
    return _objc_msgSend_jjj6g9(
        this.ref.pointer,
        _sel_hitTestRect_withImageDestinationRect_context_hints_flipped_,
        testRectDestSpace,
        imageRectDestSpace,
        context?.ref.pointer ?? ffi.nullptr,
        hints?.ref.pointer ?? ffi.nullptr,
        flipped);
  }

  /// recommendedLayerContentsScale:
  double recommendedLayerContentsScale_(double preferredContentsScale) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1tczmpvFpret(this.ref.pointer,
            _sel_recommendedLayerContentsScale_, preferredContentsScale)
        : _objc_msgSend_1tczmpv(this.ref.pointer,
            _sel_recommendedLayerContentsScale_, preferredContentsScale);
  }

  /// layerContentsForContentsScale:
  objc.ObjCObjectBase layerContentsForContentsScale_(
      double layerContentsScale) {
    final _ret = _objc_msgSend_1x911p2(this.ref.pointer,
        _sel_layerContentsForContentsScale_, layerContentsScale);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// capInsets
  NSEdgeInsets get capInsets {
    final _ptr = pkg_ffi.calloc<NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_sl0cgwStret(_ptr, this.ref.pointer, _sel_capInsets)
        : _ptr.ref = _objc_msgSend_sl0cgw(this.ref.pointer, _sel_capInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSEdgeInsets>(_finalizable);
  }

  /// setCapInsets:
  set capInsets(NSEdgeInsets value) {
    return _objc_msgSend_1ug163q(this.ref.pointer, _sel_setCapInsets_, value);
  }

  /// resizingMode
  NSImageResizingMode get resizingMode {
    final _ret = _objc_msgSend_q65rpn(this.ref.pointer, _sel_resizingMode);
    return NSImageResizingMode.fromValue(_ret);
  }

  /// setResizingMode:
  set resizingMode(NSImageResizingMode value) {
    return _objc_msgSend_197i80f(
        this.ref.pointer, _sel_setResizingMode_, value.value);
  }

  /// imageWithSymbolConfiguration:
  NSImage? imageWithSymbolConfiguration_(
      NSImageSymbolConfiguration configuration) {
    final _ret = _objc_msgSend_62nh5j(this.ref.pointer,
        _sel_imageWithSymbolConfiguration_, configuration.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// symbolConfiguration
  NSImageSymbolConfiguration get symbolConfiguration {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_symbolConfiguration);
    return NSImageSymbolConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// imageWithLocale:
  NSImage imageWithLocale_(objc.NSLocale? locale) {
    final _ret = _objc_msgSend_62nh5j(this.ref.pointer, _sel_imageWithLocale_,
        locale?.ref.pointer ?? ffi.nullptr);
    return NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// locale
  objc.NSLocale? get locale {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_locale);
    return _ret.address == 0
        ? null
        : objc.NSLocale.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSImage init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSImage new1() {
    final _ret = _objc_msgSend_1x359cv(_class_NSImage, _sel_new);
    return NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSImage allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_NSImage, _sel_allocWithZone_, zone);
    return NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSImage alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_NSImage, _sel_alloc);
    return NSImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSImage, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// readableTypesForPasteboard:
  static objc.NSArray readableTypesForPasteboard_(NSPasteboard pasteboard) {
    final _ret = _objc_msgSend_62nh5j(_class_NSImage,
        _sel_readableTypesForPasteboard_, pasteboard.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// readingOptionsForType:pasteboard:
  static NSPasteboardReadingOptions readingOptionsForType_pasteboard_(
      objc.NSString type, NSPasteboard pasteboard) {
    if (!objc.respondsToSelector(
        _class_NSImage, _sel_readingOptionsForType_pasteboard_)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSImage', 'readingOptionsForType:pasteboard:');
    }
    final _ret = _objc_msgSend_tx5oy3(
        _class_NSImage,
        _sel_readingOptionsForType_pasteboard_,
        type.ref.pointer,
        pasteboard.ref.pointer);
    return NSPasteboardReadingOptions.fromValue(_ret);
  }

  /// initWithPasteboardPropertyList:ofType:
  objc.ObjCObjectBase? initWithPasteboardPropertyList_ofType_(
      objc.ObjCObjectBase propertyList, objc.NSString type) {
    if (!objc.respondsToSelector(this.ref.retainAndReturnPointer(),
        _sel_initWithPasteboardPropertyList_ofType_)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSImage', 'initWithPasteboardPropertyList:ofType:');
    }
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithPasteboardPropertyList_ofType_,
        propertyList.ref.pointer,
        type.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// writableTypesForPasteboard:
  objc.NSArray writableTypesForPasteboard_(NSPasteboard pasteboard) {
    final _ret = _objc_msgSend_62nh5j(this.ref.pointer,
        _sel_writableTypesForPasteboard_, pasteboard.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writingOptionsForType:pasteboard:
  NSPasteboardWritingOptions writingOptionsForType_pasteboard_(
      objc.NSString type, NSPasteboard pasteboard) {
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_writingOptionsForType_pasteboard_)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSImage', 'writingOptionsForType:pasteboard:');
    }
    final _ret = _objc_msgSend_t9c00r(
        this.ref.pointer,
        _sel_writingOptionsForType_pasteboard_,
        type.ref.pointer,
        pasteboard.ref.pointer);
    return NSPasteboardWritingOptions.fromValue(_ret);
  }

  /// pasteboardPropertyListForType:
  objc.ObjCObjectBase? pasteboardPropertyListForType_(objc.NSString type) {
    final _ret = _objc_msgSend_62nh5j(this.ref.pointer,
        _sel_pasteboardPropertyListForType_, type.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSImage, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static NSImage? objectWithItemProviderData_typeIdentifier_error_(
      objc.NSData data,
      objc.NSString typeIdentifier,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> outError) {
    final _ret = _objc_msgSend_bo6ep4(
        _class_NSImage,
        _sel_objectWithItemProviderData_typeIdentifier_error_,
        data.ref.pointer,
        typeIdentifier.ref.pointer,
        outError);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider() {
    final _ret = _objc_msgSend_1x359cv(
        _class_NSImage, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider1 {
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSImage', 'writableTypeIdentifiersForItemProvider');
    }
    final _ret = _objc_msgSend_1x359cv(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier_(
          objc.NSString typeIdentifier) {
    if (!objc.respondsToSelector(_class_NSImage,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSImage',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_96wwe1(
        _class_NSImage,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier_1(
          objc.NSString typeIdentifier) {
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSImage',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_96wwe1(
        this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  NSProgress? loadDataWithTypeIdentifier_forItemProviderCompletionHandler_(
      objc.NSString typeIdentifier,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_o4sqyk(
        this.ref.pointer,
        _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        typeIdentifier.ref.pointer,
        completionHandler.ref.pointer);
    return _ret.address == 0
        ? null
        : NSProgress.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithIconRef:
  NSImage initWithIconRef_(ffi.Pointer<OpaqueIconRef> iconRef) {
    final _ret = _objc_msgSend_4uw50h(
        this.ref.retainAndReturnPointer(), _sel_initWithIconRef_, iconRef);
    return NSImage.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _sel_imageForName_ = objc.registerName("imageForName:");
late final _sel_setImage_forName_ = objc.registerName("setImage:forName:");
late final _sel_removeImageForName_ = objc.registerName("removeImageForName:");

/// WARNING: MLNLight is a stub. To generate bindings for this class, include
/// MLNLight in your config's objc-interfaces list.
///
/// MLNLight
class MLNLight extends objc.ObjCObjectBase {
  MLNLight._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNLight] that points to the same underlying object as [other].
  MLNLight.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNLight] that wraps the given raw object pointer.
  MLNLight.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_light = objc.registerName("light");
late final _sel_setLight_ = objc.registerName("setLight:");
late final _sel_localizeLabelsIntoLocale_ =
    objc.registerName("localizeLabelsIntoLocale:");

/// The proxy object for the current map style.
///
/// MLNStyle provides a set of convenience methods for changing default styles included
/// with MapLibre.
///
/// It is also possible to directly manipulate the current map style
/// via ``MLNMapView/style`` by updating the style's data sources or layers.
///
/// > Note: Wait until the map style has finished loading before modifying a map's
/// style via any of the ``MLNStyle`` instance methods below. You can use the
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
/// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` methods as indicators
/// that it's safe to modify the map's style.
class MLNStyle extends objc.NSObject {
  MLNStyle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNStyle] that points to the same underlying object as [other].
  MLNStyle.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNStyle] that wraps the given raw object pointer.
  MLNStyle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNStyle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNStyle);
  }

  /// Returns list of predefined styles
  static objc.NSArray predefinedStyles() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNStyle, _sel_predefinedStyles);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns default style
  static MLNDefaultStyle defaultStyle() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNStyle, _sel_defaultStyle);
    return MLNDefaultStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns default style as NSURL
  static objc.NSURL? defaultStyleURL() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNStyle, _sel_defaultStyleURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// Get predefined style by name
  ///
  /// @param withStyleName style name.
  static MLNDefaultStyle? predefinedStyle_(objc.NSString withStyleName) {
    final _ret = _objc_msgSend_62nh5j(
        _class_MLNStyle, _sel_predefinedStyle_, withStyleName.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNDefaultStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// The name of the style.
  ///
  /// You can customize the style’s name in Mapbox Studio.
  objc.NSString? get name {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_name);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// A set containing the style’s sources.
  objc.NSSet get sources {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_sources);
    return objc.NSSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// A set containing the style’s sources.
  set sources(objc.NSSet value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSources_, value.ref.pointer);
  }

  /// Values describing animated transitions to changes on a style's individual
  /// paint properties.
  MLNTransition get transition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(_ptr, this.ref.pointer, _sel_transition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_transition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// Values describing animated transitions to changes on a style's individual
  /// paint properties.
  set transition(MLNTransition value) {
    return _objc_msgSend_z7lywk(this.ref.pointer, _sel_setTransition_, value);
  }

  /// A boolean value indicating whether label placement transitions are enabled.
  ///
  /// The default value of this property is `YES`.
  bool get performsPlacementTransitions {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_performsPlacementTransitions);
  }

  /// A boolean value indicating whether label placement transitions are enabled.
  ///
  /// The default value of this property is `YES`.
  set performsPlacementTransitions(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPerformsPlacementTransitions_, value);
  }

  /// Returns a source with the given identifier in the current style.
  ///
  /// @return An instance of a concrete subclass of ``MLNSource`` associated with the
  /// given identifier, or `nil` if the current style contains no such source.
  MLNSource? sourceWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(
        this.ref.pointer, _sel_sourceWithIdentifier_, identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds a new source to the current style.
  ///
  /// > Note: Adding the same source instance more than once will result in a
  /// ``MLNRedundantSourceException``. Reusing the same source identifier, even with
  /// different source instances, will result in a
  /// ``MLNRedundantSourceIdentifierException``.
  ///
  /// > Note: Sources should be added in
  /// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
  /// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
  /// has loaded the style and is ready to accept a new source.
  ///
  /// @param source The source to add to the current style.
  void addSource_(MLNSource source) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_addSource_, source.ref.pointer);
  }

  /// Removes a source from the current style.
  ///
  /// @param source The source to remove from the current style.
  void removeSource_(MLNSource source) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_removeSource_, source.ref.pointer);
  }

  /// Removes a source from the current style.
  ///
  /// @param source The source to remove from the current style.
  /// @param outError Upon return, if an error has occurred, a pointer to an `NSError`
  /// object describing the error. Pass in `NULL` to ignore any error.
  ///
  /// @return `YES` if `source` was removed successfully. If `NO`, `outError` contains
  /// an `NSError` object describing the problem.
  bool removeSource_error_(
      MLNSource source, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> outError) {
    return _objc_msgSend_blqzg8(this.ref.pointer, _sel_removeSource_error_,
        source.ref.pointer, outError);
  }

  /// The layers included in the style, arranged according to their back-to-front
  /// ordering on the screen.
  objc.NSArray get layers {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_layers);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The layers included in the style, arranged according to their back-to-front
  /// ordering on the screen.
  set layers(objc.NSArray value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLayers_, value.ref.pointer);
  }

  /// Returns a style layer with the given identifier in the current style.
  ///
  /// @return An instance of a concrete subclass of ``MLNStyleLayer`` associated with
  /// the given identifier, or `nil` if the current style contains no such style
  /// layer.
  MLNStyleLayer? layerWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(
        this.ref.pointer, _sel_layerWithIdentifier_, identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds a new layer on top of existing layers.
  ///
  /// > Note: Adding the same layer instance more than once will result in a
  /// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
  /// different layer instances, will also result in an exception.
  ///
  /// > Note: Layers should be added in
  /// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
  /// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
  /// has loaded the style and is ready to accept a new layer.
  ///
  /// @param layer The layer object to add to the map view. This object must be an
  /// instance of a concrete subclass of ``MLNStyleLayer``.
  void addLayer_(MLNStyleLayer layer) {
    _objc_msgSend_1jdvcbf(this.ref.pointer, _sel_addLayer_, layer.ref.pointer);
  }

  /// Inserts a new layer into the style at the given index.
  ///
  /// > Note: Adding the same layer instance more than once will result in a
  /// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
  /// different layer instances, will also result in an exception.
  ///
  /// > Note: Layers should be added in
  /// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
  /// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
  /// has loaded the style and is ready to accept a new layer.
  ///
  /// @param layer The layer to insert.
  /// @param index The index at which to insert the layer. An index of 0 would send
  /// the layer to the back; an index equal to the number of objects in the
  /// `layers` property would bring the layer to the front.
  void insertLayer_atIndex_(MLNStyleLayer layer, int index) {
    _objc_msgSend_10i1axw(
        this.ref.pointer, _sel_insertLayer_atIndex_, layer.ref.pointer, index);
  }

  /// Inserts a new layer below another layer.
  ///
  /// > Note: Inserting the same layer instance more than once will result in a
  /// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
  /// different layer instances, will also result in an exception.
  ///
  /// @param layer The layer to insert.
  /// @param sibling An existing layer in the style.
  ///
  /// #### Related examples
  /// TODO: Add multiple shapes from a single shape source, learn how to
  /// add a layer to your map below an existing layer.
  void insertLayer_belowLayer_(MLNStyleLayer layer, MLNStyleLayer sibling) {
    _objc_msgSend_wjvic9(this.ref.pointer, _sel_insertLayer_belowLayer_,
        layer.ref.pointer, sibling.ref.pointer);
  }

  /// Inserts a new layer above another layer.
  ///
  /// > Note: Inserting the same layer instance more than once will result in a
  /// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
  /// different layer instances, will also result in an exception.
  ///
  /// @param layer The layer to insert.
  /// @param sibling An existing layer in the style.
  ///
  /// #### Related examples
  /// TODO: Add an image, learn how to add a layer to your map above an
  /// existing layer.
  void insertLayer_aboveLayer_(MLNStyleLayer layer, MLNStyleLayer sibling) {
    _objc_msgSend_wjvic9(this.ref.pointer, _sel_insertLayer_aboveLayer_,
        layer.ref.pointer, sibling.ref.pointer);
  }

  /// Removes a layer from the map view.
  ///
  /// @param layer The layer object to remove from the map view. This object
  /// must conform to the ``MLNStyleLayer`` protocol.
  void removeLayer_(MLNStyleLayer layer) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_removeLayer_, layer.ref.pointer);
  }

  /// Returns the image associated with the given name in the style.
  ///
  /// @param name The name associated with the image you want to obtain.
  /// @return The image associated with the given name, or `nil` if no image is
  /// associated with that name.
  NSImage? imageForName_(objc.NSString name) {
    final _ret = _objc_msgSend_62nh5j(
        this.ref.pointer, _sel_imageForName_, name.ref.pointer);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds or overrides an image used by the style’s layers.
  ///
  /// To use an image in a style layer, give it a unique name using this method, then
  /// set the `iconImageName` property of an ``MLNSymbolStyleLayer`` object to that
  /// name.
  ///
  /// @param image The image for the name.
  /// @param name The name of the image to set to the style.
  ///
  /// #### Related examples
  /// TODO: Use images to cluster point data
  /// TODO: Cluster point data
  /// Learn how to add images to your map using an ``MLNStyle`` object.
  void setImage_forName_(NSImage image, objc.NSString name) {
    _objc_msgSend_wjvic9(this.ref.pointer, _sel_setImage_forName_,
        image.ref.pointer, name.ref.pointer);
  }

  /// Removes a name and its associated image from the style.
  ///
  /// @param name The name of the image to remove.
  void removeImageForName_(objc.NSString name) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_removeImageForName_, name.ref.pointer);
  }

  /// Provides global light source for the style.
  MLNLight get light {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_light);
    return MLNLight.castFromPointer(_ret, retain: true, release: true);
  }

  /// Provides global light source for the style.
  set light(MLNLight value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLight_, value.ref.pointer);
  }

  /// Attempts to localize labels in the style into the given locale.
  ///
  /// This method automatically modifies the text property of any symbol style layer
  /// in the style whose source is the
  /// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets-v8/#overview">Mapbox Streets
  /// source</a>. On iOS, the user can set the system’s preferred language in Settings, General Settings,
  /// Language & Region. On macOS, the user can set the system’s preferred language in the Language &
  /// Region pane of System Preferences.
  ///
  /// @param locale The locale into which labels should be localized. To use the
  /// system’s preferred language, if supported, specify `nil`. To use the local
  /// language, specify a locale with the identifier `mul`.
  void localizeLabelsIntoLocale_(objc.NSLocale? locale) {
    _objc_msgSend_1jdvcbf(this.ref.pointer, _sel_localizeLabelsIntoLocale_,
        locale?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  MLNStyle init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNStyle new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNStyle, _sel_new);
    return MLNStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNStyle allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_MLNStyle, _sel_allocWithZone_, zone);
    return MLNStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNStyle alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNStyle, _sel_alloc);
    return MLNStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNStyle self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNStyle retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNStyle autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNStyle.castFromPointer(_ret, retain: true, release: true);
  }
}

/// The vertical alignment of an annotation within a map view. Used with
/// ``MLNMapView/userLocationVerticalAlignment``.
enum MLNAnnotationVerticalAlignment {
  /// Aligns the annotation vertically in the center of the map view.
  MLNAnnotationVerticalAlignmentCenter(0),

  /// Aligns the annotation vertically at the top of the map view.
  MLNAnnotationVerticalAlignmentTop(1),

  /// Aligns the annotation vertically at the bottom of the map view.
  MLNAnnotationVerticalAlignmentBottom(2);

  final int value;
  const MLNAnnotationVerticalAlignment(this.value);

  static MLNAnnotationVerticalAlignment fromValue(int value) => switch (value) {
        0 => MLNAnnotationVerticalAlignmentCenter,
        1 => MLNAnnotationVerticalAlignmentTop,
        2 => MLNAnnotationVerticalAlignmentBottom,
        _ => throw ArgumentError(
            "Unknown value for MLNAnnotationVerticalAlignment: $value"),
      };
}

/// The position of scale bar, compass, logo and attribution in a map view. Used with
/// ``MLNMapView/scaleBarPosition``,
/// ``MLNMapView/compassViewPosition``,
/// ``MLNMapView/logoViewPosition``,
/// ``MLNMapView/attributionButtonPosition``.
enum MLNOrnamentPosition {
  /// Place the ornament in the top left of the map view.
  MLNOrnamentPositionTopLeft(0),

  /// Place the ornament in the top right of the map view.
  MLNOrnamentPositionTopRight(1),

  /// Place the ornament in the bottom left of the map view.
  MLNOrnamentPositionBottomLeft(2),

  /// Place the ornament in the bottom right of the map view.
  MLNOrnamentPositionBottomRight(3);

  final int value;
  const MLNOrnamentPosition(this.value);

  static MLNOrnamentPosition fromValue(int value) => switch (value) {
        0 => MLNOrnamentPositionTopLeft,
        1 => MLNOrnamentPositionTopRight,
        2 => MLNOrnamentPositionBottomLeft,
        3 => MLNOrnamentPositionBottomRight,
        _ =>
          throw ArgumentError("Unknown value for MLNOrnamentPosition: $value"),
      };
}

/// The mode used to track the user location on the map. Used with
/// ``MLNMapView/userTrackingMode``.
///
/// #### Related examples
/// - TODO: Switch between user tracking modes</a> example to learn how to toggle modes and
/// how each mode behaves.
enum MLNUserTrackingMode {
  /// The map does not follow the user location.
  MLNUserTrackingModeNone(0),

  /// The map follows the user location. This tracking mode falls back
  /// to ``MLNUserTrackingMode/MLNUserTrackingModeNone`` if the user pans the map view.
  MLNUserTrackingModeFollow(1),

  /// The map follows the user location and rotates when the heading changes.
  /// The default user location annotation displays a fan-shaped indicator with
  /// the current heading. The heading indicator represents the direction the
  /// device is facing, which is sized according to the reported accuracy.
  ///
  /// This tracking mode is disabled if the user pans the map view, but
  /// remains enabled if the user zooms in. If the user rotates the map
  /// view, this tracking mode will fall back to ``MLNUserTrackingModeFollow``.
  MLNUserTrackingModeFollowWithHeading(2),

  /// The map follows the user location and rotates when the course changes.
  /// Course represents the direction in which the device is traveling.
  /// The default user location annotation shows a puck-shaped indicator
  /// that rotates as the course changes.
  ///
  /// This tracking mode is disabled if the user pans the map view, but
  /// remains enabled if the user zooms in. If the user rotates the map view,
  /// this tracking mode will fall back to ``MLNUserTrackingModeFollow``.
  MLNUserTrackingModeFollowWithCourse(3);

  final int value;
  const MLNUserTrackingMode(this.value);

  static MLNUserTrackingMode fromValue(int value) => switch (value) {
        0 => MLNUserTrackingModeNone,
        1 => MLNUserTrackingModeFollow,
        2 => MLNUserTrackingModeFollowWithHeading,
        3 => MLNUserTrackingModeFollowWithCourse,
        _ =>
          throw ArgumentError("Unknown value for MLNUserTrackingMode: $value"),
      };
}

enum MLNPanScrollingMode {
  /// The map allows the user to only scroll horizontally.
  MLNPanScrollingModeHorizontal(0),

  /// The map allows the user to only scroll vertically.
  MLNPanScrollingModeVertical(1),

  /// The map allows the user to scroll both horizontally and vertically.
  MLNPanScrollingModeDefault(2);

  final int value;
  const MLNPanScrollingMode(this.value);

  static MLNPanScrollingMode fromValue(int value) => switch (value) {
        0 => MLNPanScrollingModeHorizontal,
        1 => MLNPanScrollingModeVertical,
        2 => MLNPanScrollingModeDefault,
        _ =>
          throw ArgumentError("Unknown value for MLNPanScrollingMode: $value"),
      };
}

late final _class_MLNMapView = objc.getClass("MapLibre.MLNMapView");
late final _sel_initWithFrame_ = objc.registerName("initWithFrame:");
final _objc_msgSend_19adbty = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_initWithFrame_styleURL_ =
    objc.registerName("initWithFrame:styleURL:");
final _objc_msgSend_qsq5p6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_style = objc.registerName("style");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_MLNStyle_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_MLNStyle_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_MLNStyle_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_MLNStyle_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_MLNStyle_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_MLNStyle_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_MLNStyle_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_MLNStyle_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> fromFunction(
          MLNStyle? Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_MLNStyle_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) =>
                  fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_MLNStyle_ffiVoid_CallExtension
    on objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> {
  MLNStyle? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : MLNStyle.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_styleURL = objc.registerName("styleURL");
late final _sel_setStyleURL_ = objc.registerName("setStyleURL:");
late final _sel_reloadStyle_ = objc.registerName("reloadStyle:");
late final _sel_automaticallyAdjustsContentInset =
    objc.registerName("automaticallyAdjustsContentInset");
late final _sel_setAutomaticallyAdjustsContentInset_ =
    objc.registerName("setAutomaticallyAdjustsContentInset:");
late final _sel_showsScale = objc.registerName("showsScale");
late final _sel_setShowsScale_ = objc.registerName("setShowsScale:");

/// WARNING: MLNScaleBar is a stub. To generate bindings for this class, include
/// MLNScaleBar in your config's objc-interfaces list.
///
/// MLNScaleBar
class MLNScaleBar extends objc.ObjCObjectBase {
  MLNScaleBar._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNScaleBar] that points to the same underlying object as [other].
  MLNScaleBar.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNScaleBar] that wraps the given raw object pointer.
  MLNScaleBar.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_scaleBar = objc.registerName("scaleBar");
late final _sel_scaleBarShouldShowDarkStyles =
    objc.registerName("scaleBarShouldShowDarkStyles");
late final _sel_setScaleBarShouldShowDarkStyles_ =
    objc.registerName("setScaleBarShouldShowDarkStyles:");
late final _sel_scaleBarUsesMetricSystem =
    objc.registerName("scaleBarUsesMetricSystem");
late final _sel_setScaleBarUsesMetricSystem_ =
    objc.registerName("setScaleBarUsesMetricSystem:");
late final _sel_scaleBarPosition = objc.registerName("scaleBarPosition");
final _objc_msgSend_1c31cvt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setScaleBarPosition_ =
    objc.registerName("setScaleBarPosition:");
final _objc_msgSend_8fd115 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_scaleBarMargins = objc.registerName("scaleBarMargins");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGPoint Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGPoint Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setScaleBarMargins_ = objc.registerName("setScaleBarMargins:");
final _objc_msgSend_iy8iz6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint)>();
late final _sel_compassView = objc.registerName("compassView");
late final _sel_compassViewPosition = objc.registerName("compassViewPosition");
late final _sel_setCompassViewPosition_ =
    objc.registerName("setCompassViewPosition:");
late final _sel_compassViewMargins = objc.registerName("compassViewMargins");
late final _sel_setCompassViewMargins_ =
    objc.registerName("setCompassViewMargins:");
late final _sel_logoView = objc.registerName("logoView");
final _objc_msgSend_1p5sbp0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Int> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.Int> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_logoViewPosition = objc.registerName("logoViewPosition");
late final _sel_setLogoViewPosition_ =
    objc.registerName("setLogoViewPosition:");
late final _sel_logoViewMargins = objc.registerName("logoViewMargins");
late final _sel_setLogoViewMargins_ = objc.registerName("setLogoViewMargins:");
late final _sel_attributionButton = objc.registerName("attributionButton");
late final _sel_attributionButtonPosition =
    objc.registerName("attributionButtonPosition");
late final _sel_setAttributionButtonPosition_ =
    objc.registerName("setAttributionButtonPosition:");
late final _sel_attributionButtonMargins =
    objc.registerName("attributionButtonMargins");
late final _sel_setAttributionButtonMargins_ =
    objc.registerName("setAttributionButtonMargins:");
late final _sel_showAttribution_ = objc.registerName("showAttribution:");
late final _sel_preferredFramesPerSecond =
    objc.registerName("preferredFramesPerSecond");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPreferredFramesPerSecond_ =
    objc.registerName("setPreferredFramesPerSecond:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_prefetchesTiles = objc.registerName("prefetchesTiles");
late final _sel_setPrefetchesTiles_ = objc.registerName("setPrefetchesTiles:");
late final _sel_tileCacheEnabled = objc.registerName("tileCacheEnabled");
late final _sel_setTileCacheEnabled_ =
    objc.registerName("setTileCacheEnabled:");
late final _sel_locationManager = objc.registerName("locationManager");
late final _sel_setLocationManager_ = objc.registerName("setLocationManager:");
late final _sel_showsUserLocation = objc.registerName("showsUserLocation");
late final _sel_setShowsUserLocation_ =
    objc.registerName("setShowsUserLocation:");
late final _sel_shouldRequestAuthorizationToUseLocationServices =
    objc.registerName("shouldRequestAuthorizationToUseLocationServices");
late final _sel_setShouldRequestAuthorizationToUseLocationServices_ =
    objc.registerName("setShouldRequestAuthorizationToUseLocationServices:");
late final _sel_isUserLocationVisible =
    objc.registerName("isUserLocationVisible");

/// WARNING: MLNUserLocation is a stub. To generate bindings for this class, include
/// MLNUserLocation in your config's objc-interfaces list.
///
/// MLNUserLocation
class MLNUserLocation extends objc.ObjCObjectBase {
  MLNUserLocation._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNUserLocation] that points to the same underlying object as [other].
  MLNUserLocation.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNUserLocation] that wraps the given raw object pointer.
  MLNUserLocation.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_userLocation = objc.registerName("userLocation");
late final _sel_userTrackingMode = objc.registerName("userTrackingMode");
final _objc_msgSend_1swtepj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setUserTrackingMode_ =
    objc.registerName("setUserTrackingMode:");
final _objc_msgSend_xoapar = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setUserTrackingMode_animated_ =
    objc.registerName("setUserTrackingMode:animated:");
final _objc_msgSend_7oa3sf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_setUserTrackingMode_animated_completionHandler_ =
    objc.registerName("setUserTrackingMode:animated:completionHandler:");
final _objc_msgSend_1iu40ms = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_userLocationVerticalAlignment =
    objc.registerName("userLocationVerticalAlignment");
final _objc_msgSend_1m9zum6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setUserLocationVerticalAlignment_ =
    objc.registerName("setUserLocationVerticalAlignment:");
final _objc_msgSend_47doj4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setUserLocationVerticalAlignment_animated_ =
    objc.registerName("setUserLocationVerticalAlignment:animated:");
final _objc_msgSend_1qddrus = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_updateUserLocationAnnotationView =
    objc.registerName("updateUserLocationAnnotationView");
late final _sel_updateUserLocationAnnotationViewAnimatedWithDuration_ =
    objc.registerName("updateUserLocationAnnotationViewAnimatedWithDuration:");
late final _sel_showsUserHeadingIndicator =
    objc.registerName("showsUserHeadingIndicator");
late final _sel_setShowsUserHeadingIndicator_ =
    objc.registerName("setShowsUserHeadingIndicator:");
late final _sel_displayHeadingCalibration =
    objc.registerName("displayHeadingCalibration");
late final _sel_setDisplayHeadingCalibration_ =
    objc.registerName("setDisplayHeadingCalibration:");
late final _sel_targetCoordinate = objc.registerName("targetCoordinate");
late final _sel_setTargetCoordinate_ =
    objc.registerName("setTargetCoordinate:");
late final _sel_setTargetCoordinate_animated_ =
    objc.registerName("setTargetCoordinate:animated:");
final _objc_msgSend_o7hjv2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D, bool)>();
late final _sel_setTargetCoordinate_animated_completionHandler_ =
    objc.registerName("setTargetCoordinate:animated:completionHandler:");
final _objc_msgSend_1pbhom5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_isZoomEnabled = objc.registerName("isZoomEnabled");
late final _sel_setZoomEnabled_ = objc.registerName("setZoomEnabled:");
late final _sel_isScrollEnabled = objc.registerName("isScrollEnabled");
late final _sel_setScrollEnabled_ = objc.registerName("setScrollEnabled:");
late final _sel_panScrollingMode = objc.registerName("panScrollingMode");
final _objc_msgSend_1vb5jwj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPanScrollingMode_ =
    objc.registerName("setPanScrollingMode:");
final _objc_msgSend_k7jknj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isRotateEnabled = objc.registerName("isRotateEnabled");
late final _sel_setRotateEnabled_ = objc.registerName("setRotateEnabled:");
late final _sel_isPitchEnabled = objc.registerName("isPitchEnabled");
late final _sel_setPitchEnabled_ = objc.registerName("setPitchEnabled:");
late final _sel_anchorRotateOrZoomGesturesToCenterCoordinate =
    objc.registerName("anchorRotateOrZoomGesturesToCenterCoordinate");
late final _sel_setAnchorRotateOrZoomGesturesToCenterCoordinate_ =
    objc.registerName("setAnchorRotateOrZoomGesturesToCenterCoordinate:");
late final _sel_isHapticFeedbackEnabled =
    objc.registerName("isHapticFeedbackEnabled");
late final _sel_setHapticFeedbackEnabled_ =
    objc.registerName("setHapticFeedbackEnabled:");
late final _sel_decelerationRate = objc.registerName("decelerationRate");
late final _sel_setDecelerationRate_ =
    objc.registerName("setDecelerationRate:");
late final _sel_setCenterCoordinate_animated_ =
    objc.registerName("setCenterCoordinate:animated:");
late final _sel_setCenterCoordinate_zoomLevel_animated_ =
    objc.registerName("setCenterCoordinate:zoomLevel:animated:");
final _objc_msgSend_sbs4d5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Double,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            double,
            bool)>();
late final _sel_setCenterCoordinate_zoomLevel_direction_animated_ =
    objc.registerName("setCenterCoordinate:zoomLevel:direction:animated:");
final _objc_msgSend_3zczym = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Double,
                ffi.Double,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            double,
            double,
            bool)>();
late final _sel_setCenterCoordinate_zoomLevel_direction_animated_completionHandler_ =
    objc.registerName(
        "setCenterCoordinate:zoomLevel:direction:animated:completionHandler:");
final _objc_msgSend_d9pvdp = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Double,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            double,
            double,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_zoomLevel = objc.registerName("zoomLevel");
late final _sel_setZoomLevel_ = objc.registerName("setZoomLevel:");
late final _sel_setZoomLevel_animated_ =
    objc.registerName("setZoomLevel:animated:");
final _objc_msgSend_ghxo7e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double, bool)>();
late final _sel_direction = objc.registerName("direction");
late final _sel_setDirection_ = objc.registerName("setDirection:");
late final _sel_setDirection_animated_ =
    objc.registerName("setDirection:animated:");
late final _sel_minimumPitch = objc.registerName("minimumPitch");
late final _sel_setMinimumPitch_ = objc.registerName("setMinimumPitch:");
late final _sel_maximumPitch = objc.registerName("maximumPitch");
late final _sel_setMaximumPitch_ = objc.registerName("setMaximumPitch:");
late final _sel_resetNorth = objc.registerName("resetNorth");
late final _sel_resetPosition = objc.registerName("resetPosition");
late final _sel_visibleCoordinateBounds =
    objc.registerName("visibleCoordinateBounds");
final _objc_msgSend_ygoa6a = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNCoordinateBounds Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        MLNCoordinateBounds Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_ygoa6aStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNCoordinateBounds>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<MLNCoordinateBounds>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setVisibleCoordinateBounds_ =
    objc.registerName("setVisibleCoordinateBounds:");
final _objc_msgSend_9ay59k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>();
late final _sel_setVisibleCoordinateBounds_animated_ =
    objc.registerName("setVisibleCoordinateBounds:animated:");
final _objc_msgSend_148tmbg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds, bool)>();
late final _sel_setVisibleCoordinateBounds_edgePadding_animated_ =
    objc.registerName("setVisibleCoordinateBounds:edgePadding:animated:");
final _objc_msgSend_13x0pfk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_setVisibleCoordinateBounds_edgePadding_animated_completionHandler_ =
    objc.registerName(
        "setVisibleCoordinateBounds:edgePadding:animated:completionHandler:");
final _objc_msgSend_5ott2b = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_setVisibleCoordinates_count_edgePadding_animated_ =
    objc.registerName("setVisibleCoordinates:count:edgePadding:animated:");
final _objc_msgSend_9zf1tv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_setVisibleCoordinates_count_edgePadding_direction_duration_animationTimingFunction_completionHandler_ =
    objc.registerName(
        "setVisibleCoordinates:count:edgePadding:direction:duration:animationTimingFunction:completionHandler:");
final _objc_msgSend_g22jge = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            double,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_showAnnotations_animated_ =
    objc.registerName("showAnnotations:animated:");
final _objc_msgSend_gk45w7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_showAnnotations_edgePadding_animated_ =
    objc.registerName("showAnnotations:edgePadding:animated:");
final _objc_msgSend_k4ykup = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_showAnnotations_edgePadding_animated_completionHandler_ = objc
    .registerName("showAnnotations:edgePadding:animated:completionHandler:");
final _objc_msgSend_1xot3wa = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_setCamera_ = objc.registerName("setCamera:");
late final _sel_setCamera_animated_ = objc.registerName("setCamera:animated:");
late final _sel_setCamera_withDuration_animationTimingFunction_ =
    objc.registerName("setCamera:withDuration:animationTimingFunction:");
final _objc_msgSend_1rg1izw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setCamera_withDuration_animationTimingFunction_completionHandler_ =
    objc.registerName(
        "setCamera:withDuration:animationTimingFunction:completionHandler:");
final _objc_msgSend_vmwi8n = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_setCamera_withDuration_animationTimingFunction_edgePadding_completionHandler_ =
    objc.registerName(
        "setCamera:withDuration:animationTimingFunction:edgePadding:completionHandler:");
final _objc_msgSend_q6aes3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_flyToCamera_completionHandler_ =
    objc.registerName("flyToCamera:completionHandler:");
final _objc_msgSend_14pxqbs = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_flyToCamera_withDuration_completionHandler_ =
    objc.registerName("flyToCamera:withDuration:completionHandler:");
final _objc_msgSend_s4h8qz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_flyToCamera_withDuration_peakAltitude_completionHandler_ = objc
    .registerName("flyToCamera:withDuration:peakAltitude:completionHandler:");
final _objc_msgSend_1oun51c = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_flyToCamera_edgePadding_withDuration_completionHandler_ = objc
    .registerName("flyToCamera:edgePadding:withDuration:completionHandler:");
final _objc_msgSend_mqlsb9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_cameraThatFitsCoordinateBounds_ =
    objc.registerName("cameraThatFitsCoordinateBounds:");
final _objc_msgSend_3usbrg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>();
late final _sel_cameraThatFitsCoordinateBounds_edgePadding_ =
    objc.registerName("cameraThatFitsCoordinateBounds:edgePadding:");
final _objc_msgSend_1z0kiwg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_camera_fittingCoordinateBounds_edgePadding_ =
    objc.registerName("camera:fittingCoordinateBounds:edgePadding:");
final _objc_msgSend_1mt4adu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>)>();
late final _class_MLNShape = objc.getClass("MLNShape");
late final _sel_shapeWithData_encoding_error_ =
    objc.registerName("shapeWithData:encoding:error:");
final _objc_msgSend_94cet5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_title = objc.registerName("title");
late final _sel_setTitle_ = objc.registerName("setTitle:");
late final _sel_subtitle = objc.registerName("subtitle");
late final _sel_setSubtitle_ = objc.registerName("setSubtitle:");
late final _sel_toolTip = objc.registerName("toolTip");
late final _sel_setToolTip_ = objc.registerName("setToolTip:");
late final _sel_geoJSONDataUsingEncoding_ =
    objc.registerName("geoJSONDataUsingEncoding:");
final _objc_msgSend_1qrcblu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_coordinate = objc.registerName("coordinate");
CLLocationCoordinate2D
    _ObjCBlock_CLLocationCoordinate2D_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    CLLocationCoordinate2D Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CLLocationCoordinate2D_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                CLLocationCoordinate2D Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CLLocationCoordinate2D_ffiVoid_fnPtrTrampoline)
        .cast();
CLLocationCoordinate2D
    _ObjCBlock_CLLocationCoordinate2D_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as CLLocationCoordinate2D Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_CLLocationCoordinate2D_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                CLLocationCoordinate2D Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CLLocationCoordinate2D_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CLLocationCoordinate2D_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      CLLocationCoordinate2D Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_CLLocationCoordinate2D_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>
      fromFunction(CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<
                  CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_CLLocationCoordinate2D_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0)),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CLLocationCoordinate2D_ffiVoid_CallExtension
    on objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)> {
  CLLocationCoordinate2D call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  CLLocationCoordinate2D Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

/// MLNShape
class MLNShape extends objc.NSObject {
  MLNShape._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNShape] that points to the same underlying object as [other].
  MLNShape.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNShape] that wraps the given raw object pointer.
  MLNShape.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNShape].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShape);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData_encoding_error_(objc.NSData data, int encoding,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> outError) {
    final _ret = _objc_msgSend_94cet5(
        _class_MLNShape,
        _sel_shapeWithData_encoding_error_,
        data.ref.pointer,
        encoding,
        outError);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// The title of the shape annotation.
  ///
  /// The default value of this property is `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``. To name
  /// a shape used in a shape source, create an ``MLNFeature`` and add an attribute to
  /// the ``MLNFeature/attributes`` property.
  objc.NSString? get title {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The title of the shape annotation.
  ///
  /// The default value of this property is `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``. To name
  /// a shape used in a shape source, create an ``MLNFeature`` and add an attribute to
  /// the ``MLNFeature/attributes`` property.
  set title(objc.NSString? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The subtitle of the shape annotation. The default value of this property is
  /// `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``. To
  /// provide additional information about a shape used in a shape source, create an
  /// ``MLNFeature`` and add an attribute to the ``MLNFeature/attributes`` property.
  objc.NSString? get subtitle {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The subtitle of the shape annotation. The default value of this property is
  /// `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``. To
  /// provide additional information about a shape used in a shape source, create an
  /// ``MLNFeature`` and add an attribute to the ``MLNFeature/attributes`` property.
  set subtitle(objc.NSString? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSubtitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The tooltip of the shape annotation.
  ///
  /// The default value of this property is `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``.
  objc.NSString? get toolTip {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_toolTip);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The tooltip of the shape annotation.
  ///
  /// The default value of this property is `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``.
  set toolTip(objc.NSString? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setToolTip_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns the GeoJSON string representation of the shape encapsulated in a data
  /// object.
  ///
  /// @param encoding The string encoding to use.
  /// @return A data object containing the shape’s GeoJSON string representation.
  objc.NSData geoJSONDataUsingEncoding_(int encoding) {
    final _ret = _objc_msgSend_1qrcblu(
        this.ref.pointer, _sel_geoJSONDataUsingEncoding_, encoding);
    return objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNShape init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNShape new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNShape, _sel_new);
    return MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNShape allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_MLNShape, _sel_allocWithZone_, zone);
    return MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNShape alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNShape, _sel_alloc);
    return MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNShape self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNShape retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNShape autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNShape, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  MLNShape? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _sel_camera_fittingShape_edgePadding_ =
    objc.registerName("camera:fittingShape:edgePadding:");
late final _sel_cameraThatFitsShape_direction_edgePadding_ =
    objc.registerName("cameraThatFitsShape:direction:edgePadding:");
late final _sel_anchorPointForGesture_ =
    objc.registerName("anchorPointForGesture:");
final _objc_msgSend_11ku3hk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGPoint Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CGPoint Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_11ku3hkStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_contentInset = objc.registerName("contentInset");
final _objc_msgSend_13yqbb6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentInset_ = objc.registerName("setContentInset:");
final _objc_msgSend_9o8504 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_cameraEdgeInsets = objc.registerName("cameraEdgeInsets");
late final _sel_setContentInset_animated_ =
    objc.registerName("setContentInset:animated:");
late final _sel_setContentInset_animated_completionHandler_ =
    objc.registerName("setContentInset:animated:completionHandler:");
final _objc_msgSend_3br9h8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_convertPoint_toCoordinateFromView_ =
    objc.registerName("convertPoint:toCoordinateFromView:");
final _objc_msgSend_13n8ay5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CLLocationCoordinate2D Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CLLocationCoordinate2D Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_13n8ay5Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CLLocationCoordinate2D>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertCoordinate_toPointToView_ =
    objc.registerName("convertCoordinate:toPointToView:");
final _objc_msgSend_1a63hef = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGPoint Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CGPoint Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_1a63hefStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGPoint>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertRect_toCoordinateBoundsFromView_ =
    objc.registerName("convertRect:toCoordinateBoundsFromView:");
final _objc_msgSend_g6it35 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNCoordinateBounds Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        MLNCoordinateBounds Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_g6it35Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNCoordinateBounds>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<MLNCoordinateBounds>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertCoordinateBounds_toRectToView_ =
    objc.registerName("convertCoordinateBounds:toRectToView:");
final _objc_msgSend_1nli2vf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CGRect Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_1nli2vfStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_metersPerPointAtLatitude_ =
    objc.registerName("metersPerPointAtLatitude:");
late final _class_MLNMapProjection = objc.getClass("MLNMapProjection");
late final _sel_initWithMapView_ = objc.registerName("initWithMapView:");
late final _sel_setCamera_withEdgeInsets_ =
    objc.registerName("setCamera:withEdgeInsets:");
late final _sel_setVisibleCoordinateBounds_edgePadding_ =
    objc.registerName("setVisibleCoordinateBounds:edgePadding:");
final _objc_msgSend_1h22bw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertPoint_ = objc.registerName("convertPoint:");
final _objc_msgSend_zdqa7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint)>>()
    .asFunction<
        CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint)>();
final _objc_msgSend_zdqa7Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CLLocationCoordinate2D>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGPoint)>();
late final _sel_convertCoordinate_ = objc.registerName("convertCoordinate:");
final _objc_msgSend_p1qkdl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGPoint Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>>()
    .asFunction<
        CGPoint Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>();
final _objc_msgSend_p1qkdlStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D)>>()
    .asFunction<
        void Function(ffi.Pointer<CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>();
late final _sel_metersPerPoint = objc.registerName("metersPerPoint");

/// MLNMapProjection
class MLNMapProjection extends objc.NSObject {
  MLNMapProjection._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMapProjection] that points to the same underlying object as [other].
  MLNMapProjection.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMapProjection] that wraps the given raw object pointer.
  MLNMapProjection.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMapProjection].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapProjection);
  }

  /// Initializes and returns the new projection object with the current
  /// camera state from the provided map view.
  ///
  /// @param mapView The map view the camera state to use for the initialization.
  /// @return An initialized map projection.
  MLNMapProjection initWithMapView_(MLNMapView mapView) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithMapView_, mapView.ref.pointer);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// A camera representing the current projection state
  MLNMapCamera get camera {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_camera);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Change the projection state with camera and padding values.
  ///
  /// @param camera The new camera to be used in the projection calculation.
  /// @param insets The insets applied on top of the camera be used in the projection calculation.
  ///
  /// > Note: ``MLNMapView`` instance frame must not be changed since this projection is initialized,
  /// otherwise the calculation may be wrong.
  void setCamera_withEdgeInsets_(
      MLNMapCamera camera, objc.ObjCObjectBase insets) {
    _objc_msgSend_wjvic9(this.ref.pointer, _sel_setCamera_withEdgeInsets_,
        camera.ref.pointer, insets.ref.pointer);
  }

  /// Change the projection state to make the provided bounds visible with the specified inset.
  ///
  /// @param bounds The bounds that the viewport should fit.
  /// @param insets The insets applied on top of the viewport to be used in the projection calculation.
  ///
  /// > Note: ``MLNMapView`` instance frame must not be changed since this projection is initialized,
  /// otherwise the calculation may be wrong.
  void setVisibleCoordinateBounds_edgePadding_(
      MLNCoordinateBounds bounds, objc.ObjCObjectBase insets) {
    _objc_msgSend_1h22bw(
        this.ref.pointer,
        _sel_setVisibleCoordinateBounds_edgePadding_,
        bounds,
        insets.ref.pointer);
  }

  /// Converts a point in the coordinate system of the map view the projection
  /// was initialized with to the geographical coordinate.
  ///
  /// @param point The point to convert.
  /// @return The geographic coordinate at the given point.
  CLLocationCoordinate2D convertPoint_(CGPoint point) {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_zdqa7Stret(
            _ptr, this.ref.pointer, _sel_convertPoint_, point)
        : _ptr.ref =
            _objc_msgSend_zdqa7(this.ref.pointer, _sel_convertPoint_, point);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// Converts a geographic coordinate to a point in the map view's the projection
  /// was initialized with coordinate system.
  ///
  /// @param coordinate The geographic coordinate to convert.
  /// @return The point corresponding to the given geographic coordinate.
  CGPoint convertCoordinate_(CLLocationCoordinate2D coordinate) {
    final _ptr = pkg_ffi.calloc<CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_p1qkdlStret(
            _ptr, this.ref.pointer, _sel_convertCoordinate_, coordinate)
        : _ptr.ref = _objc_msgSend_p1qkdl(
            this.ref.pointer, _sel_convertCoordinate_, coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGPoint>(_finalizable);
  }

  /// The distance in meters spanned by a single point for the current camera.
  double get metersPerPoint {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_metersPerPoint)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_metersPerPoint);
  }

  /// init
  MLNMapProjection init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMapProjection new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNMapProjection, _sel_new);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMapProjection allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNMapProjection, _sel_allocWithZone_, zone);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMapProjection alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNMapProjection, _sel_alloc);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNMapProjection self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNMapProjection.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNMapProjection retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNMapProjection.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNMapProjection autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNMapProjection.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_mapProjection = objc.registerName("mapProjection");
late final _sel_annotations = objc.registerName("annotations");
late final _sel_addAnnotation_ = objc.registerName("addAnnotation:");
late final _sel_addAnnotations_ = objc.registerName("addAnnotations:");
late final _sel_removeAnnotation_ = objc.registerName("removeAnnotation:");
late final _sel_removeAnnotations_ = objc.registerName("removeAnnotations:");

/// WARNING: MLNAnnotationView is a stub. To generate bindings for this class, include
/// MLNAnnotationView in your config's objc-interfaces list.
///
/// MLNAnnotationView
class MLNAnnotationView extends objc.ObjCObjectBase {
  MLNAnnotationView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNAnnotationView] that points to the same underlying object as [other].
  MLNAnnotationView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNAnnotationView] that wraps the given raw object pointer.
  MLNAnnotationView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_viewForAnnotation_ = objc.registerName("viewForAnnotation:");

/// WARNING: MLNAnnotationImage is a stub. To generate bindings for this class, include
/// MLNAnnotationImage in your config's objc-interfaces list.
///
/// MLNAnnotationImage
class MLNAnnotationImage extends objc.ObjCObjectBase {
  MLNAnnotationImage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNAnnotationImage] that points to the same underlying object as [other].
  MLNAnnotationImage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNAnnotationImage] that wraps the given raw object pointer.
  MLNAnnotationImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_dequeueReusableAnnotationImageWithIdentifier_ =
    objc.registerName("dequeueReusableAnnotationImageWithIdentifier:");
late final _sel_dequeueReusableAnnotationViewWithIdentifier_ =
    objc.registerName("dequeueReusableAnnotationViewWithIdentifier:");
late final _sel_visibleAnnotations = objc.registerName("visibleAnnotations");
late final _sel_visibleAnnotationsInRect_ =
    objc.registerName("visibleAnnotationsInRect:");
late final _sel_selectedAnnotations = objc.registerName("selectedAnnotations");
late final _sel_setSelectedAnnotations_ =
    objc.registerName("setSelectedAnnotations:");
late final _sel_selectAnnotation_animated_ =
    objc.registerName("selectAnnotation:animated:");
late final _sel_selectAnnotation_animated_completionHandler_ =
    objc.registerName("selectAnnotation:animated:completionHandler:");
late final _sel_selectAnnotation_moveIntoView_animateSelection_completionHandler_ =
    objc.registerName(
        "selectAnnotation:moveIntoView:animateSelection:completionHandler:");
final _objc_msgSend_11qxhhc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_deselectAnnotation_animated_ =
    objc.registerName("deselectAnnotation:animated:");
late final _sel_overlays = objc.registerName("overlays");
late final _sel_addOverlay_ = objc.registerName("addOverlay:");
late final _sel_addOverlays_ = objc.registerName("addOverlays:");
late final _sel_removeOverlay_ = objc.registerName("removeOverlay:");
late final _sel_removeOverlays_ = objc.registerName("removeOverlays:");
late final _sel_visibleFeaturesAtPoint_ =
    objc.registerName("visibleFeaturesAtPoint:");
final _objc_msgSend_czt8e6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGPoint)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGPoint)>();
late final _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_ =
    objc.registerName("visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:");
final _objc_msgSend_b4j0k2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_predicate_ =
    objc.registerName(
        "visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:");
final _objc_msgSend_1htecti = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGPoint,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGPoint,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_visibleFeaturesInRect_ =
    objc.registerName("visibleFeaturesInRect:");
late final _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_ =
    objc.registerName("visibleFeaturesInRect:inStyleLayersWithIdentifiers:");
late final _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_predicate_ =
    objc.registerName(
        "visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:");
late final _sel_debugMask = objc.registerName("debugMask");
final _objc_msgSend_1kwkjor = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setDebugMask_ = objc.registerName("setDebugMask:");
final _objc_msgSend_pisvbv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// An interactive, customizable map view with an interface similar to the one
/// provided by Apple’s MapKit.
///
/// Using ``MLNMapView``, you can embed the map inside a view, allow users to
/// manipulate it with standard gestures, animate the map between different
/// viewpoints, and present information in the form of annotations and overlays.
///
/// The map view loads scalable vector tiles that conform to the
/// <a href="https://github.com/mapbox/vector-tile-spec">Mapbox Vector Tile Specification</a>.
/// It styles them with a style that conforms to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Spec</a>.
/// Such styles can be designed with
/// <a href="https://maplibre.org/maputnik/">Maputnik</a>.
///
///
/// Because ``MLNMapView`` loads asynchronously, several delegate methods are available
/// for receiving map-related updates. These methods can be used to ensure that certain operations
/// have completed before taking any additional actions. Information on these methods is located
/// in the ``MLNMapViewDelegate`` protocol documentation.
///
/// Adding your own gesture recognizer to ``MLNMapView`` will block the corresponding
/// gesture recognizer built into ``MLNMapView``. To avoid conflicts, define which
/// gesture takes precedence. For example, you can create your own
/// `UITapGestureRecognizer` that will be invoked only if the default ``MLNMapView``
/// tap gesture fails:
///
/// ```swift
/// let mapTapGestureRecognizer = UITapGestureRecognizer(target: self, action:
/// #selector(myCustomFunction)) for recognizer in mapView.gestureRecognizers! where recognizer is
/// UITapGestureRecognizer { mapTapGestureRecognizer.require(toFail: recognizer)
/// }
/// mapView.addGestureRecognizer(mapTapGestureRecognizer)
/// ```
///
/// > Note: You are responsible for getting permission to use the map data and for
/// ensuring that your use adheres to the relevant terms of use.
class MLNMapView extends objc.ObjCObjectBase {
  MLNMapView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNMapView] that points to the same underlying object as [other].
  MLNMapView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMapView] that wraps the given raw object pointer.
  MLNMapView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMapView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapView);
  }

  /// Initializes and returns a newly allocated map view with the specified frame
  /// and the default style.
  ///
  /// @param frame The frame for the view, measured in points.
  /// @return An initialized map view.
  MLNMapView initWithFrame_(CGRect frame) {
    final _ret = _objc_msgSend_19adbty(
        this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// Initializes and returns a newly allocated map view with the specified frame
  /// and style URL.
  ///
  /// @param frame The frame for the view, measured in points.
  /// @param styleURL URL of the map style to display. The URL may be a full HTTP
  /// or HTTPS URL, a canonical URL or a path to a local file relative
  /// to the application’s resource path. Specify `nil` for the default style.
  /// @return An initialized map view.
  ///
  /// #### Related examples
  ///
  /// - TODO: initialize an ``MLNMapView`` with a custom style
  /// - TODO: how to initialize an ``MLNMapView`` with a third-party tile source
  MLNMapView initWithFrame_styleURL_(CGRect frame, objc.NSURL? styleURL) {
    final _ret = _objc_msgSend_qsq5p6(
        this.ref.retainAndReturnPointer(),
        _sel_initWithFrame_styleURL_,
        frame,
        styleURL?.ref.pointer ?? ffi.nullptr);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// The receiver’s delegate.
  ///
  /// A map view sends messages to its delegate to notify it of changes to its
  /// contents or the viewpoint. The delegate also provides information about
  /// annotations displayed on the map, such as the styles to apply to individual
  /// annotations.
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// The receiver’s delegate.
  ///
  /// A map view sends messages to its delegate to notify it of changes to its
  /// contents or the viewpoint. The delegate also provides information about
  /// annotations displayed on the map, such as the styles to apply to individual
  /// annotations.
  set delegate(objc.ObjCObjectBase? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The style currently displayed in the receiver.
  MLNStyle? get style {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_style);
    return _ret.address == 0
        ? null
        : MLNStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL of the style currently displayed in the receiver.
  ///
  /// The URL may be a full HTTP or HTTPS URL, canonical URL, or
  /// a path to a local file relative to the application’s resource path.
  ///
  /// If you set this property to `nil`, the receiver will use the default style
  /// and this property will automatically be set to that style’s URL.
  ///
  /// If you want to modify the current style without replacing it outright, or if
  /// you want to introspect individual style attributes, use the `style` property.
  ///
  /// #### Related examples
  /// - TODO: change the style of a map at runtime.
  objc.NSURL get styleURL {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_styleURL);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL of the style currently displayed in the receiver.
  ///
  /// The URL may be a full HTTP or HTTPS URL, canonical URL, or
  /// a path to a local file relative to the application’s resource path.
  ///
  /// If you set this property to `nil`, the receiver will use the default style
  /// and this property will automatically be set to that style’s URL.
  ///
  /// If you want to modify the current style without replacing it outright, or if
  /// you want to introspect individual style attributes, use the `style` property.
  ///
  /// #### Related examples
  /// - TODO: change the style of a map at runtime.
  set styleURL(objc.NSURL value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setStyleURL_, value.ref.pointer);
  }

  /// Reloads the style.
  ///
  /// You do not normally need to call this method. The map view automatically
  /// responds to changes in network connectivity by reloading the style.
  ///
  /// This method does not bust the cache. Even if the style has recently changed on
  /// the server, calling this method does not necessarily ensure that the map view
  /// reflects those changes.
  void reloadStyle_(objc.ObjCObjectBase? sender) {
    _objc_msgSend_1jdvcbf(this.ref.pointer, _sel_reloadStyle_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// A boolean value that indicates if whether the map view should automatically
  /// adjust its content insets.
  ///
  /// When this property is set to `YES` the map automatically updates its
  /// `contentInset` property to account for any area not covered by navigation bars,
  /// tab bars, toolbars, and other ancestors that obscure the map view.
  bool get automaticallyAdjustsContentInset {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_automaticallyAdjustsContentInset);
  }

  /// A boolean value that indicates if whether the map view should automatically
  /// adjust its content insets.
  ///
  /// When this property is set to `YES` the map automatically updates its
  /// `contentInset` property to account for any area not covered by navigation bars,
  /// tab bars, toolbars, and other ancestors that obscure the map view.
  set automaticallyAdjustsContentInset(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAutomaticallyAdjustsContentInset_, value);
  }

  /// A Boolean value indicating whether the map may display scale information.
  ///
  /// The scale bar may not be shown at all zoom levels. The scale bar becomes visible
  /// when the maximum distance visible on the map view is less than 400 miles (800
  /// kilometers). The zoom level where this occurs depends on the latitude at the map
  /// view’s center coordinate, as well as the device screen width. At latitudes
  /// farther from the equator, the scale bar becomes visible at lower zoom levels.
  ///
  /// The unit of measurement is determined by the user's device locale.
  ///
  /// The view controlled by this property is available at `scaleBar`. The default value
  /// of this property is `NO`.
  bool get showsScale {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsScale);
  }

  /// A Boolean value indicating whether the map may display scale information.
  ///
  /// The scale bar may not be shown at all zoom levels. The scale bar becomes visible
  /// when the maximum distance visible on the map view is less than 400 miles (800
  /// kilometers). The zoom level where this occurs depends on the latitude at the map
  /// view’s center coordinate, as well as the device screen width. At latitudes
  /// farther from the equator, the scale bar becomes visible at lower zoom levels.
  ///
  /// The unit of measurement is determined by the user's device locale.
  ///
  /// The view controlled by this property is available at `scaleBar`. The default value
  /// of this property is `NO`.
  set showsScale(bool value) {
    return _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsScale_, value);
  }

  /// A control indicating the scale of the map. The scale bar is positioned in the
  /// upper-left corner. Enable the scale bar via `showsScale`.
  MLNScaleBar get scaleBar {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_scaleBar);
    return MLNScaleBar.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sets whether the scale uses styles that make it easier to read on a dark styled map
  bool get scaleBarShouldShowDarkStyles {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_scaleBarShouldShowDarkStyles);
  }

  /// Sets whether the scale uses styles that make it easier to read on a dark styled map
  set scaleBarShouldShowDarkStyles(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setScaleBarShouldShowDarkStyles_, value);
  }

  /// Sets whether the scale uses metric
  bool get scaleBarUsesMetricSystem {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_scaleBarUsesMetricSystem);
  }

  /// Sets whether the scale uses metric
  set scaleBarUsesMetricSystem(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setScaleBarUsesMetricSystem_, value);
  }

  /// The position of the scale bar. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionTopLeft``.
  MLNOrnamentPosition get scaleBarPosition {
    final _ret = _objc_msgSend_1c31cvt(this.ref.pointer, _sel_scaleBarPosition);
    return MLNOrnamentPosition.fromValue(_ret);
  }

  /// The position of the scale bar. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionTopLeft``.
  set scaleBarPosition(MLNOrnamentPosition value) {
    return _objc_msgSend_8fd115(
        this.ref.pointer, _sel_setScaleBarPosition_, value.value);
  }

  /// A `CGPoint` indicating the position offset of the scale bar.
  CGPoint get scaleBarMargins {
    final _ptr = pkg_ffi.calloc<CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_scaleBarMargins)
        : _ptr.ref =
            _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_scaleBarMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGPoint>(_finalizable);
  }

  /// A `CGPoint` indicating the position offset of the scale bar.
  set scaleBarMargins(CGPoint value) {
    return _objc_msgSend_iy8iz6(
        this.ref.pointer, _sel_setScaleBarMargins_, value);
  }

  /// A control indicating the map’s direction and allowing the user to manipulate
  /// the direction, positioned in the upper-right corner.
  MLNCompassButton get compassView {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_compassView);
    return MLNCompassButton.castFromPointer(_ret, retain: true, release: true);
  }

  /// The position of the compass view. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionTopRight``.
  MLNOrnamentPosition get compassViewPosition {
    final _ret =
        _objc_msgSend_1c31cvt(this.ref.pointer, _sel_compassViewPosition);
    return MLNOrnamentPosition.fromValue(_ret);
  }

  /// The position of the compass view. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionTopRight``.
  set compassViewPosition(MLNOrnamentPosition value) {
    return _objc_msgSend_8fd115(
        this.ref.pointer, _sel_setCompassViewPosition_, value.value);
  }

  /// A `CGPoint` indicating the position offset of the compass.
  CGPoint get compassViewMargins {
    final _ptr = pkg_ffi.calloc<CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_compassViewMargins)
        : _ptr.ref =
            _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_compassViewMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGPoint>(_finalizable);
  }

  /// A `CGPoint` indicating the position offset of the compass.
  set compassViewMargins(CGPoint value) {
    return _objc_msgSend_iy8iz6(
        this.ref.pointer, _sel_setCompassViewMargins_, value);
  }

  /// A logo, the MapLibre logo by default, positioned in the lower-left corner.
  /// You are not required to display this, but some vector-sources may require attribution.
  ffi.Pointer<ffi.Int> get logoView {
    return _objc_msgSend_1p5sbp0(this.ref.pointer, _sel_logoView);
  }

  /// The position of the logo view. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionBottomLeft``.
  MLNOrnamentPosition get logoViewPosition {
    final _ret = _objc_msgSend_1c31cvt(this.ref.pointer, _sel_logoViewPosition);
    return MLNOrnamentPosition.fromValue(_ret);
  }

  /// The position of the logo view. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionBottomLeft``.
  set logoViewPosition(MLNOrnamentPosition value) {
    return _objc_msgSend_8fd115(
        this.ref.pointer, _sel_setLogoViewPosition_, value.value);
  }

  /// A `CGPoint` indicating the position offset of the logo.
  CGPoint get logoViewMargins {
    final _ptr = pkg_ffi.calloc<CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_logoViewMargins)
        : _ptr.ref =
            _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_logoViewMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGPoint>(_finalizable);
  }

  /// A `CGPoint` indicating the position offset of the logo.
  set logoViewMargins(CGPoint value) {
    return _objc_msgSend_iy8iz6(
        this.ref.pointer, _sel_setLogoViewMargins_, value);
  }

  /// A view showing legally required copyright notices,
  /// positioned at the bottom-right of the map view.
  ///
  /// If you choose to reimplement this view, assign the `-showAttribution:` method
  /// as the action for your view to present the default notices and settings.
  ///
  /// > Note: Attribution is often required for many vector sources,
  /// OpenStreetMap data, or other data such as satellite or terrain
  /// data. If that applies to this map view, do not hide this view or remove
  /// any notices from it.
  ffi.Pointer<ffi.Int> get attributionButton {
    return _objc_msgSend_1p5sbp0(this.ref.pointer, _sel_attributionButton);
  }

  /// The position of the attribution button. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionBottomRight``.
  MLNOrnamentPosition get attributionButtonPosition {
    final _ret =
        _objc_msgSend_1c31cvt(this.ref.pointer, _sel_attributionButtonPosition);
    return MLNOrnamentPosition.fromValue(_ret);
  }

  /// The position of the attribution button. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionBottomRight``.
  set attributionButtonPosition(MLNOrnamentPosition value) {
    return _objc_msgSend_8fd115(
        this.ref.pointer, _sel_setAttributionButtonPosition_, value.value);
  }

  /// A `CGPoint` indicating the position offset of the attribution.
  CGPoint get attributionButtonMargins {
    final _ptr = pkg_ffi.calloc<CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_attributionButtonMargins)
        : _ptr.ref = _objc_msgSend_1uwdhlk(
            this.ref.pointer, _sel_attributionButtonMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGPoint>(_finalizable);
  }

  /// A `CGPoint` indicating the position offset of the attribution.
  set attributionButtonMargins(CGPoint value) {
    return _objc_msgSend_iy8iz6(
        this.ref.pointer, _sel_setAttributionButtonMargins_, value);
  }

  /// Show the attribution action sheet.
  ///
  /// This action is performed when the user taps on the attribution button provided
  /// by default via the `attributionButton` property. If you implement a custom
  /// attribution button, you should add this action to the button.
  void showAttribution_(objc.ObjCObjectBase sender) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_showAttribution_, sender.ref.pointer);
  }

  /// The preferred frame rate at which the map view is rendered.
  ///
  /// The default value for this property is
  /// ``MLNMapViewPreferredFramesPerSecondDefault``, which will adaptively set the
  /// preferred frame rate based on the capability of the user’s device to maintain
  /// a smooth experience.
  ///
  /// In addition to the provided ``MLNMapViewPreferredFramesPerSecond`` options, this
  /// property can be set to arbitrary integer values.
  ///
  /// @see `CADisplayLink.preferredFramesPerSecond`
  int get preferredFramesPerSecond {
    return _objc_msgSend_1hz7y9r(
        this.ref.pointer, _sel_preferredFramesPerSecond);
  }

  /// The preferred frame rate at which the map view is rendered.
  ///
  /// The default value for this property is
  /// ``MLNMapViewPreferredFramesPerSecondDefault``, which will adaptively set the
  /// preferred frame rate based on the capability of the user’s device to maintain
  /// a smooth experience.
  ///
  /// In addition to the provided ``MLNMapViewPreferredFramesPerSecond`` options, this
  /// property can be set to arbitrary integer values.
  ///
  /// @see `CADisplayLink.preferredFramesPerSecond`
  set preferredFramesPerSecond(int value) {
    return _objc_msgSend_4sp4xj(
        this.ref.pointer, _sel_setPreferredFramesPerSecond_, value);
  }

  /// A Boolean value indicating whether the map should prefetch tiles.
  ///
  /// When this property is set to `YES`, the map view prefetches tiles designed for
  /// a low zoom level and displays them until receiving more detailed tiles for the
  /// current zoom level. The prefetched tiles typically contain simplified versions
  /// of each shape, improving the map view’s perceived performance.
  ///
  /// The default value of this property is `YES`.
  bool get prefetchesTiles {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefetchesTiles);
  }

  /// A Boolean value indicating whether the map should prefetch tiles.
  ///
  /// When this property is set to `YES`, the map view prefetches tiles designed for
  /// a low zoom level and displays them until receiving more detailed tiles for the
  /// current zoom level. The prefetched tiles typically contain simplified versions
  /// of each shape, improving the map view’s perceived performance.
  ///
  /// The default value of this property is `YES`.
  set prefetchesTiles(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPrefetchesTiles_, value);
  }

  /// A Boolean value indicating whether the map may cache tiles for different zoom levels or not.
  ///
  /// When this property is set to `YES`,  the map view consumes more memory and
  /// provide a smoother user experience when zoom in/out.
  ///
  /// The default value of this property is `YES`.
  bool get tileCacheEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_tileCacheEnabled);
  }

  /// A Boolean value indicating whether the map may cache tiles for different zoom levels or not.
  ///
  /// When this property is set to `YES`,  the map view consumes more memory and
  /// provide a smoother user experience when zoom in/out.
  ///
  /// The default value of this property is `YES`.
  set tileCacheEnabled(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setTileCacheEnabled_, value);
  }

  /// The object that this map view uses to start and stop the delivery of
  /// location-related updates.
  ///
  /// To receive the current user location, implement the
  /// ``MLNMapViewDelegate/mapView:didUpdateUserLocation:`` and
  /// ``MLNMapViewDelegate/mapView:didFailToLocateUserWithError:`` methods.
  ///
  /// If setting this property to `nil` or if no custom manager is provided this
  /// property is set to the default location manager.
  ///
  /// ``MLNMapView`` uses a default location manager. If you want to substitute your
  /// own location manager, you should do so by setting this property before setting
  /// `showsUserLocation` to `YES`. To restore the default location manager,
  /// set this property to `nil`.
  objc.ObjCObjectBase get locationManager {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_locationManager);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// The object that this map view uses to start and stop the delivery of
  /// location-related updates.
  ///
  /// To receive the current user location, implement the
  /// ``MLNMapViewDelegate/mapView:didUpdateUserLocation:`` and
  /// ``MLNMapViewDelegate/mapView:didFailToLocateUserWithError:`` methods.
  ///
  /// If setting this property to `nil` or if no custom manager is provided this
  /// property is set to the default location manager.
  ///
  /// ``MLNMapView`` uses a default location manager. If you want to substitute your
  /// own location manager, you should do so by setting this property before setting
  /// `showsUserLocation` to `YES`. To restore the default location manager,
  /// set this property to `nil`.
  set locationManager(objc.ObjCObjectBase value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLocationManager_, value.ref.pointer);
  }

  /// A Boolean value indicating whether the map may display the user location.
  ///
  /// Setting this property to `YES` causes the map view to use the Core Location
  /// framework to find the current location. As long as this property is `YES`, the
  /// map view continues to track the user’s location and update it periodically.
  ///
  /// This property does not indicate whether the user’s position is actually visible
  /// on the map, only whether the map view is allowed to display it. To determine
  /// whether the user’s position is visible, use the `userLocationVisible` property.
  /// The default value of this property is `NO`.
  ///
  /// Your app must specify a value for `NSLocationWhenInUseUsageDescription` or
  /// `NSLocationAlwaysUsageDescription` in its `Info.plist` to satisfy the
  /// requirements of the underlying Core Location framework when enabling this
  /// property.
  ///
  /// If you implement a custom location manager, set the `locationManager` before
  /// calling `showsUserLocation`.
  bool get showsUserLocation {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsUserLocation);
  }

  /// A Boolean value indicating whether the map may display the user location.
  ///
  /// Setting this property to `YES` causes the map view to use the Core Location
  /// framework to find the current location. As long as this property is `YES`, the
  /// map view continues to track the user’s location and update it periodically.
  ///
  /// This property does not indicate whether the user’s position is actually visible
  /// on the map, only whether the map view is allowed to display it. To determine
  /// whether the user’s position is visible, use the `userLocationVisible` property.
  /// The default value of this property is `NO`.
  ///
  /// Your app must specify a value for `NSLocationWhenInUseUsageDescription` or
  /// `NSLocationAlwaysUsageDescription` in its `Info.plist` to satisfy the
  /// requirements of the underlying Core Location framework when enabling this
  /// property.
  ///
  /// If you implement a custom location manager, set the `locationManager` before
  /// calling `showsUserLocation`.
  set showsUserLocation(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setShowsUserLocation_, value);
  }

  /// A Boolean value indicating whether the map may request authorization to use location services.
  ///
  /// Setting this property to `YES` causes the map view to use the Core Location
  /// framework to request authorization when authorizationStatus == kCLAuthorizationStatusNotDetermined.
  ///
  /// The default value of this property is `YES`.
  bool get shouldRequestAuthorizationToUseLocationServices {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_shouldRequestAuthorizationToUseLocationServices);
  }

  /// A Boolean value indicating whether the map may request authorization to use location services.
  ///
  /// Setting this property to `YES` causes the map view to use the Core Location
  /// framework to request authorization when authorizationStatus == kCLAuthorizationStatusNotDetermined.
  ///
  /// The default value of this property is `YES`.
  set shouldRequestAuthorizationToUseLocationServices(bool value) {
    return _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setShouldRequestAuthorizationToUseLocationServices_, value);
  }

  /// A Boolean value indicating whether the device’s current location is visible in
  /// the map view.
  ///
  /// Use `showsUserLocation` to control the visibility of the on-screen user
  /// location annotation.
  bool get userLocationVisible {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isUserLocationVisible);
  }

  /// Returns the annotation object indicating the user’s current location.
  MLNUserLocation? get userLocation {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_userLocation);
    return _ret.address == 0
        ? null
        : MLNUserLocation.castFromPointer(_ret, retain: true, release: true);
  }

  /// The mode used to track the user location. The default value is
  /// ``MLNUserTrackingMode/MLNUserTrackingModeNone``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setUserTrackingMode:animated:` method instead.
  ///
  /// #### Related examples
  /// - TODO: Customize the user location annotation and learn how to customize the
  /// default user location annotation shown by ``MLNUserTrackingMode``.
  MLNUserTrackingMode get userTrackingMode {
    final _ret = _objc_msgSend_1swtepj(this.ref.pointer, _sel_userTrackingMode);
    return MLNUserTrackingMode.fromValue(_ret);
  }

  /// The mode used to track the user location. The default value is
  /// ``MLNUserTrackingMode/MLNUserTrackingModeNone``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setUserTrackingMode:animated:` method instead.
  ///
  /// #### Related examples
  /// - TODO: Customize the user location annotation and learn how to customize the
  /// default user location annotation shown by ``MLNUserTrackingMode``.
  set userTrackingMode(MLNUserTrackingMode value) {
    return _objc_msgSend_xoapar(
        this.ref.pointer, _sel_setUserTrackingMode_, value.value);
  }

  /// Deprecated. Sets the mode used to track the user location, with an optional transition.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-setUserTrackingMode:animated:completionHandler:` method.
  ///
  /// @param mode The mode used to track the user location.
  /// @param animated If `YES`, there is an animated transition from the current
  /// viewport to a viewport that results from the change to `mode`. If `NO`, the
  /// map view instantaneously changes to the new viewport. This parameter only
  /// affects the initial transition; subsequent changes to the user location or
  /// heading are always animated.
  void setUserTrackingMode_animated_(MLNUserTrackingMode mode, bool animated) {
    _objc_msgSend_7oa3sf(this.ref.pointer, _sel_setUserTrackingMode_animated_,
        mode.value, animated);
  }

  /// Sets the mode used to track the user location, with an optional transition and
  /// completion handler.
  ///
  /// @param mode The mode used to track the user location.
  /// @param animated If `YES`, there is an animated transition from the current
  /// viewport to a viewport that results from the change to `mode`. If `NO`, the
  /// map view instantaneously changes to the new viewport. This parameter only
  /// affects the initial transition; subsequent changes to the user location or
  /// heading are always animated.
  /// @param completion The block executed after the animation finishes.
  void setUserTrackingMode_animated_completionHandler_(MLNUserTrackingMode mode,
      bool animated, objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_1iu40ms(
        this.ref.pointer,
        _sel_setUserTrackingMode_animated_completionHandler_,
        mode.value,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// The vertical alignment of the user location annotation within the receiver. The
  /// default value is ``MLNAnnotationVerticalAlignment/MLNAnnotationVerticalAlignmentCenter``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setUserLocationVerticalAlignment:animated:` method instead.
  MLNAnnotationVerticalAlignment get userLocationVerticalAlignment {
    final _ret = _objc_msgSend_1m9zum6(
        this.ref.pointer, _sel_userLocationVerticalAlignment);
    return MLNAnnotationVerticalAlignment.fromValue(_ret);
  }

  /// The vertical alignment of the user location annotation within the receiver. The
  /// default value is ``MLNAnnotationVerticalAlignment/MLNAnnotationVerticalAlignmentCenter``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setUserLocationVerticalAlignment:animated:` method instead.
  set userLocationVerticalAlignment(MLNAnnotationVerticalAlignment value) {
    return _objc_msgSend_47doj4(
        this.ref.pointer, _sel_setUserLocationVerticalAlignment_, value.value);
  }

  /// Sets the vertical alignment of the user location annotation within the
  /// receiver, with an optional transition.
  ///
  /// @param alignment The vertical alignment of the user location annotation.
  /// @param animated If `YES`, the user location annotation animates to its new
  /// position within the map view. If `NO`, the user location annotation
  /// instantaneously moves to its new position.
  void setUserLocationVerticalAlignment_animated_(
      MLNAnnotationVerticalAlignment alignment, bool animated) {
    _objc_msgSend_1qddrus(
        this.ref.pointer,
        _sel_setUserLocationVerticalAlignment_animated_,
        alignment.value,
        animated);
  }

  /// Updates the position of the user location annotation view by retreiving the user's last
  /// known location.
  void updateUserLocationAnnotationView() {
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_updateUserLocationAnnotationView);
  }

  /// Updates the position of the user location annotation view by retreiving the user's last
  /// known location with a specified duration.
  /// @param duration The duration to animate the change in seconds.
  void updateUserLocationAnnotationViewAnimatedWithDuration_(double duration) {
    _objc_msgSend_hwm8nu(this.ref.pointer,
        _sel_updateUserLocationAnnotationViewAnimatedWithDuration_, duration);
  }

  /// A Boolean value indicating whether the user location annotation may display a
  /// permanent heading indicator.
  ///
  /// Setting this property to `YES` causes the default user location annotation to
  /// appear and always show an arrow-shaped heading indicator, if heading is
  /// available. This property does not rotate the map; for that, see
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading``.
  ///
  /// This property has no effect when ``userTrackingMode`` is
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading`` or
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// The default value of this property is `NO`.
  bool get showsUserHeadingIndicator {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_showsUserHeadingIndicator);
  }

  /// A Boolean value indicating whether the user location annotation may display a
  /// permanent heading indicator.
  ///
  /// Setting this property to `YES` causes the default user location annotation to
  /// appear and always show an arrow-shaped heading indicator, if heading is
  /// available. This property does not rotate the map; for that, see
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading``.
  ///
  /// This property has no effect when ``userTrackingMode`` is
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading`` or
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// The default value of this property is `NO`.
  set showsUserHeadingIndicator(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setShowsUserHeadingIndicator_, value);
  }

  /// Whether the map view should display a heading calibration alert when necessary.
  /// The default value is `YES`.
  bool get displayHeadingCalibration {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_displayHeadingCalibration);
  }

  /// Whether the map view should display a heading calibration alert when necessary.
  /// The default value is `YES`.
  set displayHeadingCalibration(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setDisplayHeadingCalibration_, value);
  }

  /// The geographic coordinate that is the subject of observation as the user
  /// location is being tracked.
  ///
  /// By default, this property is set to an invalid coordinate, indicating that
  /// there is no target. In course tracking mode, the target forms one of two foci
  /// in the viewport, the other being the user location annotation. Typically, this
  /// property is set to a destination or waypoint in a real-time navigation scene.
  /// As the user annotation moves toward the target, the map automatically zooms in
  /// to fit both foci optimally within the viewport.
  ///
  /// This property has no effect if the `userTrackingMode` property is set to a
  /// value other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setTargetCoordinate:animated:` method instead.
  CLLocationCoordinate2D get targetCoordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(
            _ptr, this.ref.pointer, _sel_targetCoordinate)
        : _ptr.ref =
            _objc_msgSend_18o5nok(this.ref.pointer, _sel_targetCoordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The geographic coordinate that is the subject of observation as the user
  /// location is being tracked.
  ///
  /// By default, this property is set to an invalid coordinate, indicating that
  /// there is no target. In course tracking mode, the target forms one of two foci
  /// in the viewport, the other being the user location annotation. Typically, this
  /// property is set to a destination or waypoint in a real-time navigation scene.
  /// As the user annotation moves toward the target, the map automatically zooms in
  /// to fit both foci optimally within the viewport.
  ///
  /// This property has no effect if the `userTrackingMode` property is set to a
  /// value other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setTargetCoordinate:animated:` method instead.
  set targetCoordinate(CLLocationCoordinate2D value) {
    return _objc_msgSend_1zv0am(
        this.ref.pointer, _sel_setTargetCoordinate_, value);
  }

  /// Deprecated. Sets the geographic coordinate that is the subject of observation as
  /// the user location is being tracked, with an optional transition animation.
  ///
  /// By default, the target coordinate is set to an invalid coordinate, indicating
  /// that there is no target. In course tracking mode, the target forms one of two
  /// foci in the viewport, the other being the user location annotation. Typically,
  /// the target is set to a destination or waypoint in a real-time navigation scene.
  /// As the user annotation moves toward the target, the map automatically zooms in
  /// to fit both foci optimally within the viewport.
  ///
  /// This method has no effect if the `userTrackingMode` property is set to a value
  /// other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-setTargetCoordinate:animated:completionHandler:` method.
  ///
  /// @param targetCoordinate The target coordinate to fit within the viewport.
  /// @param animated If `YES`, the map animates to fit the target within the map
  /// view. If `NO`, the map fits the target instantaneously.
  void setTargetCoordinate_animated_(
      CLLocationCoordinate2D targetCoordinate, bool animated) {
    _objc_msgSend_o7hjv2(this.ref.pointer, _sel_setTargetCoordinate_animated_,
        targetCoordinate, animated);
  }

  /// Sets the geographic coordinate that is the subject of observation as the user
  /// location is being tracked, with an optional transition animation and completion
  /// handler.
  ///
  /// By default, the target coordinate is set to an invalid coordinate, indicating
  /// that there is no target. In course tracking mode, the target forms one of two
  /// foci in the viewport, the other being the user location annotation. Typically,
  /// the target is set to a destination or waypoint in a real-time navigation scene.
  /// As the user annotation moves toward the target, the map automatically zooms in
  /// to fit both foci optimally within the viewport.
  ///
  /// This method has no effect if the `userTrackingMode` property is set to a value
  /// other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// @param targetCoordinate The target coordinate to fit within the viewport.
  /// @param animated If `YES`, the map animates to fit the target within the map
  /// view. If `NO`, the map fits the target instantaneously.
  /// @param completion The block executed after the animation finishes.
  void setTargetCoordinate_animated_completionHandler_(
      CLLocationCoordinate2D targetCoordinate,
      bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_1pbhom5(
        this.ref.pointer,
        _sel_setTargetCoordinate_animated_completionHandler_,
        targetCoordinate,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// A Boolean value that determines whether the user may zoom the map in and
  /// out, changing the zoom level.
  ///
  /// When this property is set to `YES`, the default, the user may zoom the map
  /// in and out by pinching two fingers or by double tapping, holding, and moving
  /// the finger up and down.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the map zoom
  /// programmatically.
  bool get zoomEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isZoomEnabled);
  }

  /// A Boolean value that determines whether the user may zoom the map in and
  /// out, changing the zoom level.
  ///
  /// When this property is set to `YES`, the default, the user may zoom the map
  /// in and out by pinching two fingers or by double tapping, holding, and moving
  /// the finger up and down.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the map zoom
  /// programmatically.
  set zoomEnabled(bool value) {
    return _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setZoomEnabled_, value);
  }

  /// A Boolean value that determines whether the user may scroll around the map,
  /// changing the center coordinate.
  ///
  /// When this property is set to `YES`, the default, the user may scroll the map
  /// by dragging or swiping with one finger.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the map location
  /// programmatically.
  bool get scrollEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isScrollEnabled);
  }

  /// A Boolean value that determines whether the user may scroll around the map,
  /// changing the center coordinate.
  ///
  /// When this property is set to `YES`, the default, the user may scroll the map
  /// by dragging or swiping with one finger.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the map location
  /// programmatically.
  set scrollEnabled(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setScrollEnabled_, value);
  }

  /// The scrolling mode the user is allowed to use to interact with the map.
  ///
  /// `MLNPanScrollingModeHorizontal` only allows the user to scroll horizontally on the map,
  /// restricting a user's ability to scroll vertically.
  /// `MLNPanScrollingModeVertical` only allows the user to scroll vertically on the map,
  /// restricting a user's ability to scroll horizontally.
  /// ``MLNPanScrollingMode/MLNPanScrollingModeDefault`` allows the user to scroll both horizontally and
  /// vertically on the map.
  ///
  /// By default, this property is set to ``MLNPanScrollingMode/MLNPanScrollingModeDefault``.
  MLNPanScrollingMode get panScrollingMode {
    final _ret = _objc_msgSend_1vb5jwj(this.ref.pointer, _sel_panScrollingMode);
    return MLNPanScrollingMode.fromValue(_ret);
  }

  /// The scrolling mode the user is allowed to use to interact with the map.
  ///
  /// `MLNPanScrollingModeHorizontal` only allows the user to scroll horizontally on the map,
  /// restricting a user's ability to scroll vertically.
  /// `MLNPanScrollingModeVertical` only allows the user to scroll vertically on the map,
  /// restricting a user's ability to scroll horizontally.
  /// ``MLNPanScrollingMode/MLNPanScrollingModeDefault`` allows the user to scroll both horizontally and
  /// vertically on the map.
  ///
  /// By default, this property is set to ``MLNPanScrollingMode/MLNPanScrollingModeDefault``.
  set panScrollingMode(MLNPanScrollingMode value) {
    return _objc_msgSend_k7jknj(
        this.ref.pointer, _sel_setPanScrollingMode_, value.value);
  }

  /// A Boolean value that determines whether the user may rotate the map,
  /// changing the direction.
  ///
  /// When this property is set to `YES`, the default, the user may rotate the map
  /// by moving two fingers in a circular motion.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still rotate the map
  /// programmatically.
  bool get rotateEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isRotateEnabled);
  }

  /// A Boolean value that determines whether the user may rotate the map,
  /// changing the direction.
  ///
  /// When this property is set to `YES`, the default, the user may rotate the map
  /// by moving two fingers in a circular motion.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still rotate the map
  /// programmatically.
  set rotateEnabled(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setRotateEnabled_, value);
  }

  /// A Boolean value that determines whether the user may change the pitch (tilt) of
  /// the map.
  ///
  /// When this property is set to `YES`, the default, the user may tilt the map by
  /// vertically dragging two fingers.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the pitch of the map
  /// programmatically.
  ///
  /// The default value of this property is `YES`.
  bool get pitchEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isPitchEnabled);
  }

  /// A Boolean value that determines whether the user may change the pitch (tilt) of
  /// the map.
  ///
  /// When this property is set to `YES`, the default, the user may tilt the map by
  /// vertically dragging two fingers.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the pitch of the map
  /// programmatically.
  ///
  /// The default value of this property is `YES`.
  set pitchEnabled(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPitchEnabled_, value);
  }

  /// A Boolean value that determines whether gestures are anchored to the center coordinate of the map
  /// while rotating or zooming. Default value is set to NO.
  bool get anchorRotateOrZoomGesturesToCenterCoordinate {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_anchorRotateOrZoomGesturesToCenterCoordinate);
  }

  /// A Boolean value that determines whether gestures are anchored to the center coordinate of the map
  /// while rotating or zooming. Default value is set to NO.
  set anchorRotateOrZoomGesturesToCenterCoordinate(bool value) {
    return _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setAnchorRotateOrZoomGesturesToCenterCoordinate_, value);
  }

  /// A Boolean value that determines whether the user will receive haptic feedback
  /// for certain interactions with the map.
  ///
  /// When this property is set to `YES`, the default, a `UIImpactFeedbackStyleLight`
  /// haptic feedback event be played when the user rotates the map to due north
  /// (0°).
  ///
  /// This feature requires a device that supports haptic feedback, running iOS 10 or
  /// newer.
  bool get hapticFeedbackEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHapticFeedbackEnabled);
  }

  /// A Boolean value that determines whether the user will receive haptic feedback
  /// for certain interactions with the map.
  ///
  /// When this property is set to `YES`, the default, a `UIImpactFeedbackStyleLight`
  /// haptic feedback event be played when the user rotates the map to due north
  /// (0°).
  ///
  /// This feature requires a device that supports haptic feedback, running iOS 10 or
  /// newer.
  set hapticFeedbackEnabled(bool value) {
    return _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setHapticFeedbackEnabled_, value);
  }

  /// A floating-point value that determines the rate of deceleration after the user
  /// lifts their finger.
  ///
  /// Your application can use the ``MLNMapViewDecelerationRateNormal`` and
  /// ``MLNMapViewDecelerationRateFast`` constants as reference points for reasonable
  /// deceleration rates. ``MLNMapViewDecelerationRateImmediate`` can be used to
  /// disable deceleration entirely.
  double get decelerationRate {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_decelerationRate)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_decelerationRate);
  }

  /// A floating-point value that determines the rate of deceleration after the user
  /// lifts their finger.
  ///
  /// Your application can use the ``MLNMapViewDecelerationRateNormal`` and
  /// ``MLNMapViewDecelerationRateFast`` constants as reference points for reasonable
  /// deceleration rates. ``MLNMapViewDecelerationRateImmediate`` can be used to
  /// disable deceleration entirely.
  set decelerationRate(double value) {
    return _objc_msgSend_hwm8nu(
        this.ref.pointer, _sel_setDecelerationRate_, value);
  }

  /// The geographic coordinate at the center of the map view.
  ///
  /// Changing the value of this property centers the map on the new coordinate
  /// without changing the current zoom level.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setCenterCoordinate:animated:` method
  /// instead.
  CLLocationCoordinate2D get centerCoordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(
            _ptr, this.ref.pointer, _sel_centerCoordinate)
        : _ptr.ref =
            _objc_msgSend_18o5nok(this.ref.pointer, _sel_centerCoordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The geographic coordinate at the center of the map view.
  ///
  /// Changing the value of this property centers the map on the new coordinate
  /// without changing the current zoom level.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setCenterCoordinate:animated:` method
  /// instead.
  set centerCoordinate(CLLocationCoordinate2D value) {
    return _objc_msgSend_1zv0am(
        this.ref.pointer, _sel_setCenterCoordinate_, value);
  }

  /// Changes the center coordinate of the map and optionally animates the change.
  ///
  /// Changing the center coordinate centers the map on the new coordinate without
  /// changing the current zoom level. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param coordinate The new center coordinate for the map.
  /// @param animated Specify `YES` if you want the map view to scroll to the new
  /// location or `NO` if you want the map to display the new location
  /// immediately.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate_animated_(
      CLLocationCoordinate2D coordinate, bool animated) {
    _objc_msgSend_o7hjv2(this.ref.pointer, _sel_setCenterCoordinate_animated_,
        coordinate, animated);
  }

  /// Changes the center coordinate and zoom level of the map and optionally animates
  /// the change. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param centerCoordinate The new center coordinate for the map.
  /// @param zoomLevel The new zoom level for the map.
  /// @param animated Specify `YES` if you want the map view to animate scrolling and
  /// zooming to the new location or `NO` if you want the map to display the new
  /// location immediately.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate_zoomLevel_animated_(
      CLLocationCoordinate2D centerCoordinate,
      double zoomLevel,
      bool animated) {
    _objc_msgSend_sbs4d5(
        this.ref.pointer,
        _sel_setCenterCoordinate_zoomLevel_animated_,
        centerCoordinate,
        zoomLevel,
        animated);
  }

  /// Changes the center coordinate, zoom level, and direction of the map and
  /// optionally animates the change. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param centerCoordinate The new center coordinate for the map.
  /// @param zoomLevel The new zoom level for the map.
  /// @param direction The new direction for the map, measured in degrees relative to
  /// true north. A negative value leaves the map’s direction unchanged.
  /// @param animated Specify `YES` if you want the map view to animate scrolling,
  /// zooming, and rotating to the new location or `NO` if you want the map to
  /// display the new location immediately.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate_zoomLevel_direction_animated_(
      CLLocationCoordinate2D centerCoordinate,
      double zoomLevel,
      double direction,
      bool animated) {
    _objc_msgSend_3zczym(
        this.ref.pointer,
        _sel_setCenterCoordinate_zoomLevel_direction_animated_,
        centerCoordinate,
        zoomLevel,
        direction,
        animated);
  }

  /// Changes the center coordinate, zoom level, and direction of the map, calling a
  /// completion handler at the end of an optional animation. For animated changes,
  /// wait until the map view has finished loading before calling this method.
  ///
  /// @param centerCoordinate The new center coordinate for the map.
  /// @param zoomLevel The new zoom level for the map.
  /// @param direction The new direction for the map, measured in degrees relative to
  /// true north. A negative value leaves the map’s direction unchanged.
  /// @param animated Specify `YES` if you want the map view to animate scrolling,
  /// zooming, and rotating to the new location or `NO` if you want the map to
  /// display the new location immediately.
  /// @param completion The block executed after the animation finishes.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate_zoomLevel_direction_animated_completionHandler_(
      CLLocationCoordinate2D centerCoordinate,
      double zoomLevel,
      double direction,
      bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_d9pvdp(
        this.ref.pointer,
        _sel_setCenterCoordinate_zoomLevel_direction_animated_completionHandler_,
        centerCoordinate,
        zoomLevel,
        direction,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// The zoom level of the receiver.
  ///
  /// In addition to affecting the visual size and detail of features on the map,
  /// the zoom level affects the size of the vector tiles that are loaded. At zoom
  /// level 0, each tile covers the entire world map; at zoom level 1, it covers ¼
  /// of the world; at zoom level 2, <sup>1</sup>⁄<sub>16</sub> of the world, and
  /// so on.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setZoomLevel:animated:` method instead.
  double get zoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_zoomLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_zoomLevel);
  }

  /// The zoom level of the receiver.
  ///
  /// In addition to affecting the visual size and detail of features on the map,
  /// the zoom level affects the size of the vector tiles that are loaded. At zoom
  /// level 0, each tile covers the entire world map; at zoom level 1, it covers ¼
  /// of the world; at zoom level 2, <sup>1</sup>⁄<sub>16</sub> of the world, and
  /// so on.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setZoomLevel:animated:` method instead.
  set zoomLevel(double value) {
    return _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setZoomLevel_, value);
  }

  /// Changes the zoom level of the map and optionally animates the change.
  ///
  /// Changing the zoom level scales the map without changing the current center
  /// coordinate.
  ///
  /// @param zoomLevel The new zoom level for the map.
  /// @param animated Specify `YES` if you want the map view to animate the change
  /// to the new zoom level or `NO` if you want the map to display the new
  /// zoom level immediately.
  void setZoomLevel_animated_(double zoomLevel, bool animated) {
    _objc_msgSend_ghxo7e(
        this.ref.pointer, _sel_setZoomLevel_animated_, zoomLevel, animated);
  }

  /// The minimum zoom level at which the map can be shown.
  ///
  /// Depending on the map view’s aspect ratio, the map view may be prevented
  /// from reaching the minimum zoom level, in order to keep the map from
  /// repeating within the current viewport.
  ///
  /// If the value of this property is greater than that of the
  /// maximumZoomLevel property, the behavior is undefined.
  ///
  /// The default minimumZoomLevel is 0.
  double get minimumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumZoomLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumZoomLevel);
  }

  /// The minimum zoom level at which the map can be shown.
  ///
  /// Depending on the map view’s aspect ratio, the map view may be prevented
  /// from reaching the minimum zoom level, in order to keep the map from
  /// repeating within the current viewport.
  ///
  /// If the value of this property is greater than that of the
  /// maximumZoomLevel property, the behavior is undefined.
  ///
  /// The default minimumZoomLevel is 0.
  set minimumZoomLevel(double value) {
    return _objc_msgSend_hwm8nu(
        this.ref.pointer, _sel_setMinimumZoomLevel_, value);
  }

  /// The maximum zoom level the map can be shown at.
  ///
  /// If the value of this property is smaller than that of the
  /// minimumZoomLevel property, the behavior is undefined.
  ///
  /// The default maximumZoomLevel is 22. The upper bound for this property
  /// is 25.5.
  double get maximumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_maximumZoomLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_maximumZoomLevel);
  }

  /// The maximum zoom level the map can be shown at.
  ///
  /// If the value of this property is smaller than that of the
  /// minimumZoomLevel property, the behavior is undefined.
  ///
  /// The default maximumZoomLevel is 22. The upper bound for this property
  /// is 25.5.
  set maximumZoomLevel(double value) {
    return _objc_msgSend_hwm8nu(
        this.ref.pointer, _sel_setMaximumZoomLevel_, value);
  }

  /// The heading of the map, measured in degrees clockwise from true north.
  ///
  /// The value `0` means that the top edge of the map view corresponds to true
  /// north. The value `90` means the top of the map is pointing due east. The
  /// value `180` means the top of the map points due south, and so on.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setDirection:animated:` method instead.
  double get direction {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_direction)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_direction);
  }

  /// The heading of the map, measured in degrees clockwise from true north.
  ///
  /// The value `0` means that the top edge of the map view corresponds to true
  /// north. The value `90` means the top of the map is pointing due east. The
  /// value `180` means the top of the map points due south, and so on.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setDirection:animated:` method instead.
  set direction(double value) {
    return _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setDirection_, value);
  }

  /// Changes the heading of the map and optionally animates the change.
  ///
  /// @param direction The heading of the map, measured in degrees clockwise from
  /// true north.
  /// @param animated Specify `YES` if you want the map view to animate the change
  /// to the new heading or `NO` if you want the map to display the new
  /// heading immediately.
  ///
  /// Changing the heading rotates the map without changing the current center
  /// coordinate or zoom level.
  void setDirection_animated_(double direction, bool animated) {
    _objc_msgSend_ghxo7e(
        this.ref.pointer, _sel_setDirection_animated_, direction, animated);
  }

  /// The minimum pitch of the map’s camera toward the horizon measured in degrees.
  ///
  /// If the value of this property is greater than that of the `maximumPitch`
  /// property, the behavior is undefined. The pitch may not be less than 0
  /// regardless of this property.
  ///
  /// The default value of this property is 0 degrees, allowing the map to appear
  /// two-dimensional.
  double get minimumPitch {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumPitch)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumPitch);
  }

  /// The minimum pitch of the map’s camera toward the horizon measured in degrees.
  ///
  /// If the value of this property is greater than that of the `maximumPitch`
  /// property, the behavior is undefined. The pitch may not be less than 0
  /// regardless of this property.
  ///
  /// The default value of this property is 0 degrees, allowing the map to appear
  /// two-dimensional.
  set minimumPitch(double value) {
    return _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumPitch_, value);
  }

  /// The maximum pitch of the map’s camera toward the horizon measured in degrees.
  ///
  /// If the value of this property is smaller than that of the `minimumPitch`
  /// property, the behavior is undefined. The pitch may not exceed 60 degrees
  /// regardless of this property.
  ///
  /// The default value of this property is 60 degrees.
  double get maximumPitch {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_maximumPitch)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_maximumPitch);
  }

  /// The maximum pitch of the map’s camera toward the horizon measured in degrees.
  ///
  /// If the value of this property is smaller than that of the `minimumPitch`
  /// property, the behavior is undefined. The pitch may not exceed 60 degrees
  /// regardless of this property.
  ///
  /// The default value of this property is 60 degrees.
  set maximumPitch(double value) {
    return _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMaximumPitch_, value);
  }

  /// Resets the map rotation to a northern heading — a `direction` of `0` degrees.
  void resetNorth() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resetNorth);
  }

  /// Resets the map to the current style’s default viewport.
  ///
  /// If the style doesn’t specify a default viewport, the map resets to a minimum
  /// zoom level, a center coordinate of (0, 0), and a northern heading.
  void resetPosition() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resetPosition);
  }

  /// The coordinate bounds visible in the receiver’s viewport.
  ///
  /// Changing the value of this property updates the receiver immediately. If you
  /// want to animate the change, call `-setVisibleCoordinateBounds:animated:`
  /// instead.
  ///
  /// If a longitude is less than −180 degrees or greater than 180 degrees, the
  /// visible bounds straddles the antimeridian or international date line. For
  /// example, if both Tokyo and San Francisco are visible, the visible bounds might
  /// extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  MLNCoordinateBounds get visibleCoordinateBounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(
            _ptr, this.ref.pointer, _sel_visibleCoordinateBounds)
        : _ptr.ref = _objc_msgSend_ygoa6a(
            this.ref.pointer, _sel_visibleCoordinateBounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// The coordinate bounds visible in the receiver’s viewport.
  ///
  /// Changing the value of this property updates the receiver immediately. If you
  /// want to animate the change, call `-setVisibleCoordinateBounds:animated:`
  /// instead.
  ///
  /// If a longitude is less than −180 degrees or greater than 180 degrees, the
  /// visible bounds straddles the antimeridian or international date line. For
  /// example, if both Tokyo and San Francisco are visible, the visible bounds might
  /// extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  set visibleCoordinateBounds(MLNCoordinateBounds value) {
    return _objc_msgSend_9ay59k(
        this.ref.pointer, _sel_setVisibleCoordinateBounds_, value);
  }

  /// Changes the receiver’s viewport to fit the given coordinate bounds,
  /// optionally animating the change.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible bounds to extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  ///
  /// @param bounds The bounds that the viewport will show in its entirety.
  /// @param animated Specify `YES` to animate the change by smoothly scrolling
  /// and zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinateBounds_animated_(
      MLNCoordinateBounds bounds, bool animated) {
    _objc_msgSend_148tmbg(this.ref.pointer,
        _sel_setVisibleCoordinateBounds_animated_, bounds, animated);
  }

  /// Deprecated. Changes the receiver’s viewport to fit the given coordinate bounds with
  /// some additional padding on each side.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible bounds to extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-setVisibleCoordinateBounds:edgePadding:animated:completionHandler:` method.
  ///
  /// @param bounds The bounds that the viewport will show in its entirety.
  /// @param insets The minimum padding (in screen points) that will be visible
  /// around the given coordinate bounds.
  /// @param animated Specify `YES` to animate the change by smoothly scrolling and
  /// zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinateBounds_edgePadding_animated_(
      MLNCoordinateBounds bounds, objc.ObjCObjectBase insets, bool animated) {
    _objc_msgSend_13x0pfk(
        this.ref.pointer,
        _sel_setVisibleCoordinateBounds_edgePadding_animated_,
        bounds,
        insets.ref.pointer,
        animated);
  }

  /// Changes the receiver’s viewport to fit the given coordinate bounds with some
  /// additional padding on each side, optionally calling a completion handler.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible bounds to extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  ///
  /// @param bounds The bounds that the viewport will show in its entirety.
  /// @param insets The minimum padding (in screen points) that will be visible
  /// around the given coordinate bounds.
  /// @param animated Specify `YES` to animate the change by smoothly scrolling and
  /// zooming or `NO` to immediately display the given bounds.
  /// @param completion The block executed after the animation finishes.
  void setVisibleCoordinateBounds_edgePadding_animated_completionHandler_(
      MLNCoordinateBounds bounds,
      objc.ObjCObjectBase insets,
      bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_5ott2b(
        this.ref.pointer,
        _sel_setVisibleCoordinateBounds_edgePadding_animated_completionHandler_,
        bounds,
        insets.ref.pointer,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Changes the receiver’s viewport to fit all of the given coordinates with some
  /// additional padding on each side.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible coordinates to (35.68476, −220.24257) and (37.78428, −122.41310).
  ///
  /// @param coordinates The coordinates that the viewport will show.
  /// @param count The number of coordinates. This number must not be greater than
  /// the number of elements in `coordinates`.
  /// @param insets The minimum padding (in screen points) that will be visible
  /// around the given coordinate bounds.
  /// @param animated Specify `YES` to animate the change by smoothly scrolling and
  /// zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinates_count_edgePadding_animated_(
      ffi.Pointer<CLLocationCoordinate2D> coordinates,
      int count,
      objc.ObjCObjectBase insets,
      bool animated) {
    _objc_msgSend_9zf1tv(
        this.ref.pointer,
        _sel_setVisibleCoordinates_count_edgePadding_animated_,
        coordinates,
        count,
        insets.ref.pointer,
        animated);
  }

  /// Changes the receiver’s viewport to fit all of the given coordinates with some
  /// additional padding on each side, optionally calling a completion handler.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible coordinates to (35.68476, −220.24257) and (37.78428, −122.41310).
  ///
  /// @param coordinates The coordinates that the viewport will show.
  /// @param count The number of coordinates. This number must not be greater than
  /// the number of elements in `coordinates`.
  /// @param insets The minimum padding (in screen points) that will be visible
  /// around the given coordinate bounds.
  /// @param direction The direction to rotate the map to, measured in degrees
  /// relative to true north. A negative value leaves the map’s direction
  /// unchanged.
  /// @param duration The duration to animate the change in seconds.
  /// @param function The timing function to animate the change.
  /// @param completion The block executed after the animation finishes.
  void
      setVisibleCoordinates_count_edgePadding_direction_duration_animationTimingFunction_completionHandler_(
          ffi.Pointer<CLLocationCoordinate2D> coordinates,
          int count,
          objc.ObjCObjectBase insets,
          double direction,
          double duration,
          objc.ObjCObjectBase function,
          objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_g22jge(
        this.ref.pointer,
        _sel_setVisibleCoordinates_count_edgePadding_direction_duration_animationTimingFunction_completionHandler_,
        coordinates,
        count,
        insets.ref.pointer,
        direction,
        duration,
        function.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Sets the visible region so that the map displays the specified annotations.
  ///
  /// Calling this method updates the value in the `visibleCoordinateBounds` property
  /// and potentially other properties to reflect the new map region. A small amount
  /// of padding is reserved around the edges of the map view. To specify a different
  /// amount of padding, use the `-showAnnotations:edgePadding:animated:` method.
  ///
  /// @param annotations The annotations that you want to be visible in the map.
  /// @param animated `YES` if you want the map region change to be animated, or `NO`
  /// if you want the map to display the new region immediately without animations.
  void showAnnotations_animated_(objc.NSArray annotations, bool animated) {
    _objc_msgSend_gk45w7(this.ref.pointer, _sel_showAnnotations_animated_,
        annotations.ref.pointer, animated);
  }

  /// Deprecated. Sets the visible region so that the map displays the specified
  /// annotations with the specified amount of padding on each side.
  ///
  /// Calling this method updates the value in the `visibleCoordinateBounds` property
  /// and potentially other properties to reflect the new map region.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-showAnnotations:edgePadding:animated:completionHandler:` method.
  ///
  /// @param annotations The annotations that you want to be visible in the map.
  /// @param insets The minimum padding (in screen points) around the edges of the
  /// map view to keep clear of annotations.
  /// @param animated `YES` if you want the map region change to be animated, or `NO`
  /// if you want the map to display the new region immediately without animations.
  void showAnnotations_edgePadding_animated_(
      objc.NSArray annotations, objc.ObjCObjectBase insets, bool animated) {
    _objc_msgSend_k4ykup(
        this.ref.pointer,
        _sel_showAnnotations_edgePadding_animated_,
        annotations.ref.pointer,
        insets.ref.pointer,
        animated);
  }

  /// Sets the visible region so that the map displays the specified annotations with
  /// the specified amount of padding on each side and an optional completion
  /// handler.
  ///
  /// Calling this method updates the value in the `visibleCoordinateBounds` property
  /// and potentially other properties to reflect the new map region.
  ///
  /// @param annotations The annotations that you want to be visible in the map.
  /// @param insets The minimum padding (in screen points) around the edges of the
  /// map view to keep clear of annotations.
  /// @param animated `YES` if you want the map region change to be animated, or `NO`
  /// if you want the map to display the new region immediately without animations.
  /// @param completion The block executed after the animation finishes.
  void showAnnotations_edgePadding_animated_completionHandler_(
      objc.NSArray annotations,
      objc.ObjCObjectBase insets,
      bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_1xot3wa(
        this.ref.pointer,
        _sel_showAnnotations_edgePadding_animated_completionHandler_,
        annotations.ref.pointer,
        insets.ref.pointer,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// A camera representing the current viewpoint of the map.
  MLNMapCamera get camera {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_camera);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// A camera representing the current viewpoint of the map.
  set camera(MLNMapCamera value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCamera_, value.ref.pointer);
  }

  /// Moves the viewpoint to a different location with respect to the map with an
  /// optional transition animation. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param camera The new viewpoint.
  /// @param animated Specify `YES` if you want the map view to animate the change to
  /// the new viewpoint or `NO` if you want the map to display the new viewpoint
  /// immediately.
  ///
  /// #### Related examples
  /// - TODO: Camera animation: learn how to trigger an animation that rotates around a central point.
  void setCamera_animated_(MLNMapCamera camera, bool animated) {
    _objc_msgSend_gk45w7(this.ref.pointer, _sel_setCamera_animated_,
        camera.ref.pointer, animated);
  }

  /// Moves the viewpoint to a different location with respect to the map with an
  /// optional transition duration and timing function. For animated changes, wait
  /// until the map view has finished loading before calling this method.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously.
  /// @param function A timing function used for the animation. Set this parameter to
  /// `nil` for a transition that matches most system animations. If the duration
  /// is `0`, this parameter is ignored.
  ///
  /// #### Related examples
  /// - TODO: Camera animation: learn how to create a timed animation that
  /// rotates around a central point for a specific duration.
  void setCamera_withDuration_animationTimingFunction_(
      MLNMapCamera camera, double duration, objc.ObjCObjectBase function) {
    _objc_msgSend_1rg1izw(
        this.ref.pointer,
        _sel_setCamera_withDuration_animationTimingFunction_,
        camera.ref.pointer,
        duration,
        function.ref.pointer);
  }

  /// Moves the viewpoint to a different location with respect to the map with an
  /// optional transition duration and timing function. For animated changes, wait
  /// until the map view has finished loading before calling this method.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously.
  /// @param function A timing function used for the animation. Set this parameter to
  /// `nil` for a transition that matches most system animations. If the duration
  /// is `0`, this parameter is ignored.
  /// @param completion The block to execute after the animation finishes.
  void setCamera_withDuration_animationTimingFunction_completionHandler_(
      MLNMapCamera camera,
      double duration,
      objc.ObjCObjectBase function,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_vmwi8n(
        this.ref.pointer,
        _sel_setCamera_withDuration_animationTimingFunction_completionHandler_,
        camera.ref.pointer,
        duration,
        function.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location with respect to the map with an
  /// optional transition duration and timing function, and optionally some additional
  /// padding on each side. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously.
  /// @param function A timing function used for the animation. Set this parameter to
  /// `nil` for a transition that matches most system animations. If the duration
  /// is `0`, this parameter is ignored.
  /// @param edgePadding The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @param completion The block to execute after the animation finishes.
  void
      setCamera_withDuration_animationTimingFunction_edgePadding_completionHandler_(
          MLNMapCamera camera,
          double duration,
          objc.ObjCObjectBase function,
          objc.ObjCObjectBase edgePadding,
          objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_q6aes3(
        this.ref.pointer,
        _sel_setCamera_withDuration_animationTimingFunction_edgePadding_completionHandler_,
        camera.ref.pointer,
        duration,
        function.ref.pointer,
        edgePadding.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location using a transition animation that
  /// evokes powered flight and a default duration based on the length of the flight
  /// path.
  ///
  /// The transition animation seamlessly incorporates zooming and panning to help
  /// the user find his or her bearings even after traversing a great distance.
  ///
  /// @param camera The new viewpoint.
  /// @param completion The block to execute after the animation finishes.
  void flyToCamera_completionHandler_(
      MLNMapCamera camera, objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_14pxqbs(this.ref.pointer, _sel_flyToCamera_completionHandler_,
        camera.ref.pointer, completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location using a transition animation that
  /// evokes powered flight and an optional transition duration.
  ///
  /// The transition animation seamlessly incorporates zooming and panning to help
  /// the user find his or her bearings even after traversing a great distance.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously. Specify a negative value to use the default duration, which
  /// is based on the length of the flight path.
  /// @param completion The block to execute after the animation finishes.
  void flyToCamera_withDuration_completionHandler_(MLNMapCamera camera,
      double duration, objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_s4h8qz(
        this.ref.pointer,
        _sel_flyToCamera_withDuration_completionHandler_,
        camera.ref.pointer,
        duration,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location using a transition animation that
  /// evokes powered flight and an optional transition duration and peak altitude.
  ///
  /// The transition animation seamlessly incorporates zooming and panning to help
  /// the user find his or her bearings even after traversing a great distance.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously. Specify a negative value to use the default duration, which
  /// is based on the length of the flight path.
  /// @param peakAltitude The altitude, measured in meters, at the midpoint of the
  /// animation. The value of this parameter is ignored if it is negative or if
  /// the animation transition resulting from a similar call to
  /// `-setCamera:animated:` would have a midpoint at a higher altitude.
  /// @param completion The block to execute after the animation finishes.
  void flyToCamera_withDuration_peakAltitude_completionHandler_(
      MLNMapCamera camera,
      double duration,
      double peakAltitude,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_1oun51c(
        this.ref.pointer,
        _sel_flyToCamera_withDuration_peakAltitude_completionHandler_,
        camera.ref.pointer,
        duration,
        peakAltitude,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location using a transition animation that
  /// evokes powered flight.
  ///
  /// The transition animation seamlessly incorporates zooming and panning to help
  /// the user find his or her bearings even after traversing a great distance.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously. Specify a negative value to use the default duration, which
  /// is based on the length of the flight path.
  /// @param edgePadding The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @param completion The block to execute after the animation finishes.
  void flyToCamera_edgePadding_withDuration_completionHandler_(
      MLNMapCamera camera,
      objc.ObjCObjectBase insets,
      double duration,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_mqlsb9(
        this.ref.pointer,
        _sel_flyToCamera_edgePadding_withDuration_completionHandler_,
        camera.ref.pointer,
        insets.ref.pointer,
        duration,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns the camera that best fits the given coordinate bounds.
  ///
  /// @param bounds The coordinate bounds to fit to the receiver’s viewport.
  /// @return A camera object centered on the same location as the coordinate
  /// bounds with zoom level as high (close to the ground) as possible while still
  /// including the entire coordinate bounds. The camera object uses the current
  /// direction and pitch.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsCoordinateBounds_(MLNCoordinateBounds bounds) {
    final _ret = _objc_msgSend_3usbrg(
        this.ref.pointer, _sel_cameraThatFitsCoordinateBounds_, bounds);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the camera that best fits the given coordinate bounds with some
  /// additional padding on each side.
  ///
  /// @param bounds The coordinate bounds to fit to the receiver’s viewport.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @return A camera object centered on the same location as the coordinate bounds
  /// with zoom level as high (close to the ground) as possible while still
  /// including the entire coordinate bounds. The camera object uses the current
  /// direction and pitch.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsCoordinateBounds_edgePadding_(
      MLNCoordinateBounds bounds, objc.ObjCObjectBase insets) {
    final _ret = _objc_msgSend_1z0kiwg(
        this.ref.pointer,
        _sel_cameraThatFitsCoordinateBounds_edgePadding_,
        bounds,
        insets.ref.pointer);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the camera that best fits the given coordinate bounds with some
  /// additional padding on each side, matching an existing camera as much as
  /// possible.
  ///
  /// @param camera The camera that the return camera should adhere to. All values
  /// on this camera will be manipulated except for pitch and direction.
  /// @param bounds The coordinate bounds to fit to the receiver’s viewport.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @return A camera object centered on the same location as the coordinate bounds
  /// with zoom level as high (close to the ground) as possible while still
  /// including the entire coordinate bounds. The initial camera's pitch and
  /// direction will be honored.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera camera_fittingCoordinateBounds_edgePadding_(MLNMapCamera camera,
      MLNCoordinateBounds bounds, objc.ObjCObjectBase insets) {
    final _ret = _objc_msgSend_1mt4adu(
        this.ref.pointer,
        _sel_camera_fittingCoordinateBounds_edgePadding_,
        camera.ref.pointer,
        bounds,
        insets.ref.pointer);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the camera that best fits the given shape with some additional padding
  /// on each side, matching an existing camera as much as possible.
  ///
  /// @param camera The camera that the return camera should adhere to. All values
  /// on this camera will be manipulated except for pitch and direction.
  /// @param shape The shape to fit to the receiver’s viewport.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @return A camera object centered on the shape's center with zoom level as high
  /// (close to the ground) as possible while still including the entire shape.
  /// The initial camera's pitch and direction will be honored.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera camera_fittingShape_edgePadding_(
      MLNMapCamera camera, MLNShape shape, objc.ObjCObjectBase insets) {
    final _ret = _objc_msgSend_582s3n(
        this.ref.pointer,
        _sel_camera_fittingShape_edgePadding_,
        camera.ref.pointer,
        shape.ref.pointer,
        insets.ref.pointer);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the camera that best fits the given shape with some additional padding
  /// on each side while looking in the specified direction.
  ///
  /// @param shape The shape to fit to the receiver’s viewport.
  /// @param direction The direction of the viewport, measured in degrees clockwise
  /// from true north.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @return A camera object centered on the shape's center with zoom level as high
  /// (close to the ground) as possible while still including the entire shape.
  /// The camera object uses the current pitch.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsShape_direction_edgePadding_(
      MLNShape shape, double direction, objc.ObjCObjectBase insets) {
    final _ret = _objc_msgSend_45qm9k(
        this.ref.pointer,
        _sel_cameraThatFitsShape_direction_edgePadding_,
        shape.ref.pointer,
        direction,
        insets.ref.pointer);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the point in this view’s coordinate system on which to “anchor” in
  /// response to a user-initiated gesture.
  ///
  /// For example, a pinch-to-zoom gesture would anchor the map at the midpoint of
  /// the pinch.
  ///
  /// If the ``userTrackingMode`` property is not ``MLNUserTrackingMode/MLNUserTrackingModeNone``, the
  /// user annotation is used as the anchor point.
  ///
  /// Subclasses may override this method to provide specialized behavior - for
  /// example, anchoring on the map’s center point to provide a "locked" zooming
  /// mode.
  ///
  /// @param gesture An anchorable user gesture.
  /// @return The point on which to anchor in response to the gesture.
  CGPoint anchorPointForGesture_(objc.ObjCObjectBase gesture) {
    final _ptr = pkg_ffi.calloc<CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_11ku3hkStret(_ptr, this.ref.pointer,
            _sel_anchorPointForGesture_, gesture.ref.pointer)
        : _ptr.ref = _objc_msgSend_11ku3hk(
            this.ref.pointer, _sel_anchorPointForGesture_, gesture.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGPoint>(_finalizable);
  }

  /// The distance from the edges of the map view’s frame to the edges of the map
  /// view’s logical viewport.
  ///
  /// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
  /// properties such as `centerCoordinate` assume a viewport that matches the map
  /// view’s frame. Otherwise, those properties are inset, excluding part of the
  /// frame from the viewport. For instance, if the only the top edge is inset, the
  /// map center is effectively shifted downward.
  ///
  /// When the map view’s superview is an instance of `UIViewController` whose
  /// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
  /// property may be overridden at any time.
  ///
  /// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
  /// use the map view’s property ``MLNMapView/automaticallyAdjustsContentInset``instead.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setContentInset:animated:completionHandler:`
  /// method instead.
  int get contentInset {
    return _objc_msgSend_13yqbb6(this.ref.pointer, _sel_contentInset);
  }

  /// The distance from the edges of the map view’s frame to the edges of the map
  /// view’s logical viewport.
  ///
  /// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
  /// properties such as `centerCoordinate` assume a viewport that matches the map
  /// view’s frame. Otherwise, those properties are inset, excluding part of the
  /// frame from the viewport. For instance, if the only the top edge is inset, the
  /// map center is effectively shifted downward.
  ///
  /// When the map view’s superview is an instance of `UIViewController` whose
  /// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
  /// property may be overridden at any time.
  ///
  /// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
  /// use the map view’s property ``MLNMapView/automaticallyAdjustsContentInset``instead.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setContentInset:animated:completionHandler:`
  /// method instead.
  set contentInset(int value) {
    return _objc_msgSend_9o8504(this.ref.pointer, _sel_setContentInset_, value);
  }

  /// The current edge insets of the current map view’s camera.
  ///
  /// Camera edge insets are formed as accumulation of map view's content insets
  /// and the edge padding passed to the method like `seCamera:...edgePadding:`,
  /// `setVisibleCoordinates:...edgePadding:`, `showAnnotations:...edgePadding:` etc.
  ///
  /// The camera edge insets influences the `centerCoordinate` of the viewport.
  /// This value is read-only, in order to apply paddings,  use either persistent
  /// `contentInset`, either transient `edgePadding` parameter of the `set...` methods.
  int get cameraEdgeInsets {
    return _objc_msgSend_13yqbb6(this.ref.pointer, _sel_cameraEdgeInsets);
  }

  /// Deprecated. Sets the distance from the edges of the map view’s frame to the edges
  /// of the map view’s logical viewport with an optional transition animation.
  ///
  /// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
  /// properties such as `centerCoordinate` assume a viewport that matches the map
  /// view’s frame. Otherwise, those properties are inset, excluding part of the
  /// frame from the viewport. For instance, if the only the top edge is inset, the
  /// map center is effectively shifted downward.
  ///
  /// When the map view’s superview is an instance of `UIViewController` whose
  /// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
  /// property may be overridden at any time.
  ///
  /// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
  /// use the map view’s property ``MLNMapView/automaticallyAdjustsContentInset``instead.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-setContentInset:animated:completionHandler:` method.
  ///
  /// @param contentInset The new values to inset the content by.
  /// @param animated Specify `YES` if you want the map view to animate the change to
  /// the content inset or `NO` if you want the map to inset the content
  /// immediately.
  void setContentInset_animated_(
      objc.ObjCObjectBase contentInset, bool animated) {
    _objc_msgSend_gk45w7(this.ref.pointer, _sel_setContentInset_animated_,
        contentInset.ref.pointer, animated);
  }

  /// Sets the distance from the edges of the map view’s frame to the edges of the
  /// map view’s logical viewport with an optional transition animation and
  /// completion handler.
  ///
  /// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
  /// properties such as `centerCoordinate` assume a viewport that matches the map
  /// view’s frame. Otherwise, those properties are inset, excluding part of the
  /// frame from the viewport. For instance, if the only the top edge is inset, the
  /// map center is effectively shifted downward.
  ///
  /// When the map view’s superview is an instance of `UIViewController` whose
  /// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
  /// property may be overridden at any time.
  ///
  /// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
  /// use the map view’s property ``MLNMapView/automaticallyAdjustsContentInset``instead.
  ///
  /// @param contentInset The new values to inset the content by.
  /// @param animated Specify `YES` if you want the map view to animate the change to
  /// the content inset or `NO` if you want the map to inset the content
  /// immediately.
  /// @param completion The block executed after the animation finishes.
  void setContentInset_animated_completionHandler_(
      objc.ObjCObjectBase contentInset,
      bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_3br9h8(
        this.ref.pointer,
        _sel_setContentInset_animated_completionHandler_,
        contentInset.ref.pointer,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Converts a point in the given view’s coordinate system to a geographic
  /// coordinate.
  ///
  /// @param point The point to convert.
  /// @param view The view in whose coordinate system the point is expressed.
  /// @return The geographic coordinate at the given point.
  ///
  /// #### Related examples
  /// - TODO: Point conversion example to learn how to convert a `CGPoint` to a map coordinate.
  CLLocationCoordinate2D convertPoint_toCoordinateFromView_(
      CGPoint point, objc.ObjCObjectBase view) {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_13n8ay5Stret(_ptr, this.ref.pointer,
            _sel_convertPoint_toCoordinateFromView_, point, view.ref.pointer)
        : _ptr.ref = _objc_msgSend_13n8ay5(this.ref.pointer,
            _sel_convertPoint_toCoordinateFromView_, point, view.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// Converts a geographic coordinate to a point in the given view’s coordinate
  /// system.
  ///
  /// @param coordinate The geographic coordinate to convert.
  /// @param view The view in whose coordinate system the returned point should be
  /// expressed. If this parameter is `nil`, the returned point is expressed
  /// in the window’s coordinate system. If `view` is not `nil`, it must
  /// belong to the same window as the map view.
  /// @return The point (in the appropriate view or window coordinate system)
  /// corresponding to the given geographic coordinate.
  ///
  /// #### Related examples
  /// - TODO: Point conversion: learn how to convert a map coordinate to a `CGPoint` object.
  CGPoint convertCoordinate_toPointToView_(
      CLLocationCoordinate2D coordinate, objc.ObjCObjectBase view) {
    final _ptr = pkg_ffi.calloc<CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1a63hefStret(_ptr, this.ref.pointer,
            _sel_convertCoordinate_toPointToView_, coordinate, view.ref.pointer)
        : _ptr.ref = _objc_msgSend_1a63hef(
            this.ref.pointer,
            _sel_convertCoordinate_toPointToView_,
            coordinate,
            view.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGPoint>(_finalizable);
  }

  /// Converts a rectangle in the given view’s coordinate system to a geographic
  /// bounding box.
  ///
  /// If the returned coordinate bounds contains a longitude is less than −180 degrees
  /// or greater than 180 degrees, the bounding box straddles the antimeridian or
  /// international date line.
  ///
  /// @param rect The rectangle to convert.
  /// @param view The view in whose coordinate system the rectangle is expressed.
  /// @return The geographic bounding box coextensive with the given rectangle.
  MLNCoordinateBounds convertRect_toCoordinateBoundsFromView_(
      CGRect rect, objc.ObjCObjectBase view) {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_g6it35Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_toCoordinateBoundsFromView_,
            rect,
            view.ref.pointer)
        : _ptr.ref = _objc_msgSend_g6it35(
            this.ref.pointer,
            _sel_convertRect_toCoordinateBoundsFromView_,
            rect,
            view.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// Converts a geographic bounding box to a rectangle in the given view’s
  /// coordinate system.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible bounds to extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  ///
  /// @param bounds The geographic bounding box to convert.
  /// @param view The view in whose coordinate system the returned rectangle should
  /// be expressed. If this parameter is `nil`, the returned rectangle is
  /// expressed in the window’s coordinate system. If `view` is not `nil`, it must
  /// belong to the same window as the map view.
  CGRect convertCoordinateBounds_toRectToView_(
      MLNCoordinateBounds bounds, objc.ObjCObjectBase view) {
    final _ptr = pkg_ffi.calloc<CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1nli2vfStret(
            _ptr,
            this.ref.pointer,
            _sel_convertCoordinateBounds_toRectToView_,
            bounds,
            view.ref.pointer)
        : _ptr.ref = _objc_msgSend_1nli2vf(
            this.ref.pointer,
            _sel_convertCoordinateBounds_toRectToView_,
            bounds,
            view.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGRect>(_finalizable);
  }

  /// Returns the distance spanned by one point in the map view’s coordinate system
  /// at the given latitude and current zoom level.
  ///
  /// The distance between points decreases as the latitude approaches the poles.
  /// This relationship parallels the relationship between longitudinal coordinates
  /// at different latitudes.
  ///
  /// @param latitude The latitude of the geographic coordinate represented by the
  /// point.
  /// @return The distance in meters spanned by a single point.
  double metersPerPointAtLatitude_(double latitude) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1tczmpvFpret(
            this.ref.pointer, _sel_metersPerPointAtLatitude_, latitude)
        : _objc_msgSend_1tczmpv(
            this.ref.pointer, _sel_metersPerPointAtLatitude_, latitude);
  }

  /// Returns the new map projection instance initialized with the map view,
  /// i.e. with the current camera state.
  MLNMapProjection mapProjection() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_mapProjection);
    return MLNMapProjection.castFromPointer(_ret, retain: true, release: true);
  }

  /// The complete list of annotations associated with the receiver. (read-only)
  ///
  /// The objects in this array must adopt the ``MLNAnnotation`` protocol. If no
  /// annotations are associated with the map view, the value of this property is
  /// `nil`.
  objc.NSArray? get annotations {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_annotations);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds an annotation to the map view.
  ///
  /// > Note: ``MLNMultiPolyline``, ``MLNMultiPolyline``, ``MLNMultiPolyline``, and
  /// ``MLNPointCollection`` objects cannot be added to the map view at this time.
  /// Any multipoint, multipolyline, multipolygon, shape or point collection
  /// object that is specified is silently ignored.
  ///
  /// @param annotation The annotation object to add to the receiver. This object
  /// must conform to the ``MLNAnnotation`` protocol. The map view retains the
  /// annotation object.
  ///
  /// #### Related examples
  /// - TODO: add a line annotation from GeoJSON.
  /// - TODO: add an annotation to an ``MLNMapView`` object.
  void addAnnotation_(objc.ObjCObjectBase annotation) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_addAnnotation_, annotation.ref.pointer);
  }

  /// Adds an array of annotations to the map view.
  ///
  /// > Note: ``MLNMultiPolyline``, ``MLNMultiPolyline``, and ``MLNMultiPolyline`` objects
  /// cannot be added to the map view at this time. Nor can ``MLNMultiPoint``
  /// objects that are not instances of ``MLNPolyline`` or ``MLNPolyline``. Any
  /// multipoint, multipolyline, multipolygon, or shape collection objects that
  /// are specified are silently ignored.
  ///
  /// @param annotations An array of annotation objects. Each object in the array
  /// must conform to the ``MLNAnnotation`` protocol. The map view retains each
  /// individual annotation object.
  void addAnnotations_(objc.NSArray annotations) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_addAnnotations_, annotations.ref.pointer);
  }

  /// Removes an annotation from the map view, deselecting it if it is selected.
  ///
  /// Removing an annotation object dissociates it from the map view entirely,
  /// preventing it from being displayed on the map. Thus you would typically call
  /// this method only when you want to hide or delete a given annotation.
  ///
  /// @param annotation The annotation object to remove. This object must conform
  /// to the ``MLNAnnotation`` protocol
  void removeAnnotation_(objc.ObjCObjectBase annotation) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_removeAnnotation_, annotation.ref.pointer);
  }

  /// Removes an array of annotations from the map view, deselecting any selected
  /// annotations in the array.
  ///
  /// Removing annotation objects dissociates them from the map view entirely,
  /// preventing them from being displayed on the map. Thus you would typically
  /// call this method only when you want to hide or delete the given annotations.
  ///
  /// @param annotations The array of annotation objects to remove. Objects in the
  /// array must conform to the ``MLNAnnotation`` protocol.
  void removeAnnotations_(objc.NSArray annotations) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_removeAnnotations_, annotations.ref.pointer);
  }

  /// Returns an ``MLNAnnotationView`` if the given annotation is currently associated
  /// with a view, otherwise nil.
  ///
  /// @param annotation The annotation associated with the view.
  /// Annotation must conform to the ``MLNAnnotation`` protocol.
  MLNAnnotationView? viewForAnnotation_(objc.ObjCObjectBase annotation) {
    final _ret = _objc_msgSend_62nh5j(
        this.ref.pointer, _sel_viewForAnnotation_, annotation.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNAnnotationView.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a reusable annotation image object associated with its identifier.
  ///
  /// For performance reasons, you should generally reuse ``MLNAnnotationImage``
  /// objects for identical-looking annotations in your map views. Dequeueing
  /// saves time and memory during performance-critical operations such as
  /// scrolling.
  ///
  /// @param identifier A string identifying the annotation image to be reused.
  /// This string is the same one you specify when initially returning the
  /// annotation image object using the `-mapView:imageForAnnotation:` method.
  /// @return An annotation image object with the given identifier, or `nil` if no
  /// such object exists in the reuse queue.
  ///
  /// #### Related examples
  /// - TODO: Add annotation views and images: learn how to most efficiently
  /// reuse an ``MLNAnnotationImage``.
  MLNAnnotationImage? dequeueReusableAnnotationImageWithIdentifier_(
      objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(
        this.ref.pointer,
        _sel_dequeueReusableAnnotationImageWithIdentifier_,
        identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNAnnotationImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a reusable annotation view object associated with its identifier.
  ///
  /// For performance reasons, you should generally reuse ``MLNAnnotationView``
  /// objects for identical-looking annotations in your map views. Dequeueing
  /// saves time and memory during performance-critical operations such as
  /// scrolling.
  ///
  /// @param identifier A string identifying the annotation view to be reused.
  /// This string is the same one you specify when initially returning the
  /// annotation view object using the `-mapView:viewForAnnotation:` method.
  /// @return An annotation view object with the given identifier, or `nil` if no
  /// such object exists in the reuse queue.
  MLNAnnotationView? dequeueReusableAnnotationViewWithIdentifier_(
      objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(
        this.ref.pointer,
        _sel_dequeueReusableAnnotationViewWithIdentifier_,
        identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNAnnotationView.castFromPointer(_ret, retain: true, release: true);
  }

  /// The complete list of annotations associated with the receiver that are
  /// currently visible.
  ///
  /// The objects in this array must adopt the ``MLNAnnotation`` protocol. If no
  /// annotations are associated with the map view or if no annotations associated
  /// with the map view are currently visible, the value of this property is `nil`.
  objc.NSArray? get visibleAnnotations {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_visibleAnnotations);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the list of annotations associated with the receiver that intersect with
  /// the given rectangle.
  ///
  /// @param rect A rectangle expressed in the map view’s coordinate system.
  /// @return An array of objects that adopt the ``MLNAnnotation`` protocol or `nil` if
  /// no annotations associated with the map view are currently visible in the
  /// rectangle.
  objc.NSArray? visibleAnnotationsInRect_(CGRect rect) {
    final _ret = _objc_msgSend_19adbty(
        this.ref.pointer, _sel_visibleAnnotationsInRect_, rect);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The currently selected annotations.
  ///
  /// Assigning a new array to this property selects only the first annotation in
  /// the array.
  ///
  /// If the annotation is of type ``MLNPointAnnotation`` and is offscreen, the camera
  /// will animate to bring the annotation and its callout just on screen. If you
  /// need finer control, consider using `-selectAnnotation:animated:`.
  ///
  /// > Note: In versions prior to `4.0.0` if the annotation was offscreen it was not
  /// selected.
  objc.NSArray get selectedAnnotations {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_selectedAnnotations);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The currently selected annotations.
  ///
  /// Assigning a new array to this property selects only the first annotation in
  /// the array.
  ///
  /// If the annotation is of type ``MLNPointAnnotation`` and is offscreen, the camera
  /// will animate to bring the annotation and its callout just on screen. If you
  /// need finer control, consider using `-selectAnnotation:animated:`.
  ///
  /// > Note: In versions prior to `4.0.0` if the annotation was offscreen it was not
  /// selected.
  set selectedAnnotations(objc.NSArray value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSelectedAnnotations_, value.ref.pointer);
  }

  /// Deprecated. Selects an annotation and displays its callout view.
  ///
  /// The `animated` parameter determines whether the selection is animated including whether the map is
  /// panned to bring the annotation into view, specifically:
  ///
  /// | `animated` parameter | Effect |
  /// |------------------|--------|
  /// | `NO`             | The annotation is selected, and the callout is presented. However the map is
  /// not panned to bring the annotation or callout into view. The presentation of the callout is NOT
  /// animated. | | `YES`            | The annotation is selected, and the callout is presented. If the
  /// annotation is not visible (or is partially visible) *and* is of type ``MLNPointAnnotation``, the
  /// map is panned so that the annotation and its callout are brought into view. The annotation is *not*
  /// centered within the viewport. |
  ///
  /// Note that a selection initiated by a single tap gesture is always animated.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-selectAnnotation:animated:completionHandler:` method.
  ///
  /// @param annotation The annotation object to select.
  /// @param animated If `YES`, the annotation and callout view are animated on-screen.
  ///
  /// > Note: In versions prior to `4.0.0` selecting an offscreen annotation did not
  /// change the camera.
  void selectAnnotation_animated_(
      objc.ObjCObjectBase annotation, bool animated) {
    _objc_msgSend_gk45w7(this.ref.pointer, _sel_selectAnnotation_animated_,
        annotation.ref.pointer, animated);
  }

  /// Selects an annotation and displays its callout view with an optional completion
  /// handler.
  ///
  /// The `animated` parameter determines whether the selection is animated including whether the map is
  /// panned to bring the annotation into view, specifically:
  ///
  /// | `animated` parameter | Effect |
  /// |------------------|--------|
  /// | `NO`             | The annotation is selected, and the callout is presented. However the map is
  /// not panned to bring the annotation or callout into view. The presentation of the callout is NOT
  /// animated. | | `YES`            | The annotation is selected, and the callout is presented. If the
  /// annotation is not visible (or is partially visible) *and* is of type ``MLNPointAnnotation``, the
  /// map is panned so that the annotation and its callout are brought into view. The annotation is *not*
  /// centered within the viewport. |
  ///
  /// Note that a selection initiated by a single tap gesture is always animated.
  ///
  /// @param annotation The annotation object to select.
  /// @param animated If `YES`, the annotation and callout view are animated on-screen.
  /// @param completion The block executed after the animation finishes.
  ///
  /// > Note: In versions prior to `4.0.0` selecting an offscreen annotation did not
  /// change the camera.
  void selectAnnotation_animated_completionHandler_(
      objc.ObjCObjectBase annotation,
      bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_3br9h8(
        this.ref.pointer,
        _sel_selectAnnotation_animated_completionHandler_,
        annotation.ref.pointer,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// :nodoc:
  /// Selects an annotation and displays its callout view with an optional completion
  /// handler. This method should be considered "alpha" and as such is subject to
  /// change.
  ///
  /// @param annotation The annotation object to select.
  /// @param moveIntoView If the annotation is not visible (or is partially visible) *and* is of type
  /// ``MLNPointAnnotation``, the map is panned so that the annotation and its callout are brought into
  /// view. The annotation is *not* centered within the viewport.
  /// @param animateSelection If `YES`, the annotation's selection state and callout view's presentation
  /// are animated.
  /// @param completion The block executed after the animation finishes.
  void selectAnnotation_moveIntoView_animateSelection_completionHandler_(
      objc.ObjCObjectBase annotation,
      bool moveIntoView,
      bool animateSelection,
      objc.ObjCBlock<ffi.Void Function()>? completion) {
    _objc_msgSend_11qxhhc(
        this.ref.pointer,
        _sel_selectAnnotation_moveIntoView_animateSelection_completionHandler_,
        annotation.ref.pointer,
        moveIntoView,
        animateSelection,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// Deselects an annotation and hides its callout view.
  ///
  /// @param annotation The annotation object to deselect.
  /// @param animated If `YES`, the callout view is animated offscreen.
  void deselectAnnotation_animated_(
      objc.ObjCObjectBase? annotation, bool animated) {
    _objc_msgSend_gk45w7(this.ref.pointer, _sel_deselectAnnotation_animated_,
        annotation?.ref.pointer ?? ffi.nullptr, animated);
  }

  /// The complete list of overlays associated with the receiver. (read-only)
  ///
  /// The objects in this array must adopt the ``MLNOverlay`` protocol. If no
  /// overlays are associated with the map view, the value of this property is
  /// empty array.
  objc.NSArray get overlays {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_overlays);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds a single overlay object to the map.
  ///
  /// To remove an overlay from a map, use the `-removeOverlay:` method.
  ///
  /// @param overlay The overlay object to add. This object must conform to the
  /// ``MLNOverlay`` protocol.
  void addOverlay_(objc.ObjCObjectBase overlay) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_addOverlay_, overlay.ref.pointer);
  }

  /// Adds an array of overlay objects to the map.
  ///
  /// To remove multiple overlays from a map, use the `-removeOverlays:` method.
  ///
  /// @param overlays An array of objects, each of which must conform to the
  /// ``MLNOverlay`` protocol.
  void addOverlays_(objc.NSArray overlays) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_addOverlays_, overlays.ref.pointer);
  }

  /// Removes a single overlay object from the map.
  ///
  /// If the specified overlay is not currently associated with the map view, this
  /// method does nothing.
  ///
  /// @param overlay The overlay object to remove.
  void removeOverlay_(objc.ObjCObjectBase overlay) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_removeOverlay_, overlay.ref.pointer);
  }

  /// Removes one or more overlay objects from the map.
  ///
  /// If a given overlay object is not associated with the map view, it is ignored.
  ///
  /// @param overlays An array of objects, each of which conforms to the ``MLNOverlay``
  /// protocol.
  void removeOverlays_(objc.NSArray overlays) {
    _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_removeOverlays_, overlays.ref.pointer);
  }

  /// Returns an array of rendered map features that intersect with a given point.
  ///
  /// This method may return features from any of the map’s style layers. To restrict
  /// the search to a particular layer or layers, use the
  /// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:` method. For more
  /// information about searching for map features, see that method’s documentation.
  ///
  /// @param point A point expressed in the map view’s coordinate system.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  ///
  /// #### Related examples
  /// - TODO: Select a feature within a layer: to learn how to query an
  /// ``MLNMapView`` object for visible ``MLNMapView`` objects.
  objc.NSArray visibleFeaturesAtPoint_(CGPoint point) {
    final _ret = _objc_msgSend_czt8e6(
        this.ref.pointer, _sel_visibleFeaturesAtPoint_, point);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with a given point,
  /// restricted to the given style layers.
  ///
  /// This method returns all the intersecting features from the specified layers. To
  /// filter the returned features, use the
  /// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:` method. For
  /// more information about searching for map features, see that method’s
  /// documentation.
  ///
  /// @param point A point expressed in the map view’s coordinate system.
  /// @param styleLayerIdentifiers A set of strings that correspond to the names
  /// of layers defined in the current style. Only the features contained in
  /// these layers are included in the returned array.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_(
      CGPoint point, objc.NSSet? styleLayerIdentifiers) {
    final _ret = _objc_msgSend_b4j0k2(
        this.ref.pointer,
        _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_,
        point,
        styleLayerIdentifiers?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with a given point,
  /// restricted to the given style layers and filtered by the given predicate.
  ///
  /// Each object in the returned array represents a feature rendered by the
  /// current style and provides access to attributes specified by the relevant map
  /// content sources. The returned array includes features loaded by
  /// ``MLNShapeSource`` and ``MLNShapeSource`` objects but does not include
  /// anything from ``MLNRasterTileSource`` objects, or from video or canvas sources,
  /// which are unsupported by this SDK.
  ///
  /// The returned features are drawn by a style layer in the current style. For
  /// example, suppose the current style uses the
  /// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets/">Mapbox Streets source</a>,
  /// but none of the specified style layers includes features that have the `maki`
  /// property set to `bus`. If you pass a point corresponding to the location of a
  /// bus stop into this method, the bus stop feature does not appear in the
  /// resulting array. On the other hand, if the style does include bus stops, an
  /// ``MLNFeature`` object representing that bus stop is returned and its
  /// `featureAttributes` dictionary has the `maki` key set to `bus` (along with
  /// other attributes). The dictionary contains only the attributes provided by the
  /// tile source; it does not include computed attribute values or rules about how
  /// the feature is rendered by the current style.
  ///
  /// The returned array is sorted by z-order, starting with the topmost rendered
  /// feature and ending with the bottommost rendered feature. A feature that is
  /// rendered multiple times due to wrapping across the antimeridian at low zoom
  /// levels is included only once, subject to the caveat that follows.
  ///
  /// Features come from tiled vector data or GeoJSON data that is converted to tiles
  /// internally, so feature geometries are clipped at tile boundaries and features
  /// may appear duplicated across tiles. For example, suppose the specified point
  /// lies along a road that spans the screen. The resulting array includes those
  /// parts of the road that lie within the map tile that contain the specified
  /// point, even if the road extends into other tiles.
  ///
  /// To find out the layer names in a particular style, view the style in
  /// <a href="https://maplibre.org/maputnik">Maputnik</a>.
  ///
  /// Only visible features are returned. To obtain features regardless of
  /// visibility, use the
  /// ``MLNVectorTileSource/featuresInSourceLayersWithIdentifiers:predicate:`` and
  /// ``MLNShapeSource/featuresMatchingPredicate:`` methods on the relevant sources.
  ///
  /// The returned features may also include features corresponding to annotations.
  /// These features are not object-equal to the ``MLNAnnotation`` objects that were
  /// originally added to the map. To query the map for annotations, use
  /// `visibleAnnotations` or ``MLNMapView/visibleAnnotationsInRect:``.
  ///
  ///
  /// @param point A point expressed in the map view’s coordinate system.
  /// @param styleLayerIdentifiers A set of strings that correspond to the names of
  /// layers defined in the current style. Only the features contained in these
  /// layers are included in the returned array.
  /// @param predicate A predicate to filter the returned features.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_predicate_(
      CGPoint point,
      objc.NSSet? styleLayerIdentifiers,
      NSPredicate? predicate) {
    final _ret = _objc_msgSend_1htecti(
        this.ref.pointer,
        _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_predicate_,
        point,
        styleLayerIdentifiers?.ref.pointer ?? ffi.nullptr,
        predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with the given
  /// rectangle.
  ///
  /// This method may return features from any of the map’s style layers. To restrict
  /// the search to a particular layer or layers, use the
  /// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:` method. For more
  /// information about searching for map features, see that method’s documentation.
  ///
  /// @param rect A rectangle expressed in the map view’s coordinate system.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect_(CGRect rect) {
    final _ret = _objc_msgSend_19adbty(
        this.ref.pointer, _sel_visibleFeaturesInRect_, rect);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with the given
  /// rectangle, restricted to the given style layers.
  ///
  /// This method returns all the intersecting features from the specified layers. To
  /// filter the returned features, use the
  /// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:` method. For
  /// more information about searching for map features, see that method’s
  /// documentation.
  ///
  /// @param rect A rectangle expressed in the map view’s coordinate system.
  /// @param styleLayerIdentifiers A set of strings that correspond to the names of
  /// layers defined in the current style. Only the features contained in these
  /// layers are included in the returned array.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect_inStyleLayersWithIdentifiers_(
      CGRect rect, objc.NSSet? styleLayerIdentifiers) {
    final _ret = _objc_msgSend_qsq5p6(
        this.ref.pointer,
        _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_,
        rect,
        styleLayerIdentifiers?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with the given
  /// rectangle, restricted to the given style layers and filtered by the given
  /// predicate.
  ///
  /// Each object in the returned array represents a feature rendered by the
  /// current style and provides access to attributes specified by the relevant map
  /// content sources. The returned array includes features loaded by
  /// ``MLNShapeSource`` and ``MLNShapeSource`` objects but does not include
  /// anything from ``MLNRasterTileSource`` objects, or from video or canvas sources,
  /// which are unsupported by this SDK.
  ///
  /// The returned features are drawn by a style layer in the current style. For
  /// example, suppose the current style uses a particular source,
  /// but none of the specified style layers includes features that have the `maki`
  /// property set to `bus`. If you pass a rectangle containing the location of a bus
  /// stop into this method, the bus stop feature does not appear in the resulting
  /// array. On the other hand, if the style does include bus stops, an ``MLNFeature``
  /// object representing that bus stop is returned and its `featureAttributes`
  /// dictionary has the `maki` key set to `bus` (along with other attributes). The
  /// dictionary contains only the attributes provided by the tile source; it does
  /// not include computed attribute values or rules about how the feature is
  /// rendered by the current style.
  ///
  /// The returned array is sorted by z-order, starting with the topmost rendered
  /// feature and ending with the bottommost rendered feature. A feature that is
  /// rendered multiple times due to wrapping across the antimeridian at low zoom
  /// levels is included only once, subject to the caveat that follows.
  ///
  /// Features come from tiled vector data or GeoJSON data that is converted to tiles
  /// internally, so feature geometries are clipped at tile boundaries and features
  /// may appear duplicated across tiles. For example, suppose the specified
  /// rectangle intersects with a road that spans the screen. The resulting array
  /// includes those parts of the road that lie within the map tiles covering the
  /// specified rectangle, even if the road extends into other tiles. The portion of
  /// the road within each map tile is included individually.
  ///
  /// To find out the layer names in a particular style, view the style in
  /// <a href="https://maplibre.org/maputnik">Maputnik</a>.
  ///
  /// Only visible features are returned. To obtain features regardless of
  /// visibility, use the
  /// ``MLNVectorTileSource/featuresInSourceLayersWithIdentifiers:predicate:`` and
  /// ``MLNShapeSource/featuresMatchingPredicate:`` methods on the relevant sources.
  ///
  /// @param rect A rectangle expressed in the map view’s coordinate system.
  /// @param styleLayerIdentifiers A set of strings that correspond to the names of
  /// layers defined in the current style. Only the features contained in these
  /// layers are included in the returned array.
  /// @param predicate A predicate to filter the returned features.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect_inStyleLayersWithIdentifiers_predicate_(
      CGRect rect, objc.NSSet? styleLayerIdentifiers, NSPredicate? predicate) {
    final _ret = _objc_msgSend_1hrqp72(
        this.ref.pointer,
        _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_predicate_,
        rect,
        styleLayerIdentifiers?.ref.pointer ?? ffi.nullptr,
        predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The options that determine which debugging aids are shown on the map.
  ///
  /// These options are all disabled by default and should remain disabled in
  /// released software for performance and aesthetic reasons.
  MLNMapDebugMaskOptions get debugMask {
    final _ret = _objc_msgSend_1kwkjor(this.ref.pointer, _sel_debugMask);
    return MLNMapDebugMaskOptions.fromValue(_ret);
  }

  /// The options that determine which debugging aids are shown on the map.
  ///
  /// These options are all disabled by default and should remain disabled in
  /// released software for performance and aesthetic reasons.
  set debugMask(MLNMapDebugMaskOptions value) {
    return _objc_msgSend_pisvbv(
        this.ref.pointer, _sel_setDebugMask_, value.value);
  }
}

/// WARNING: MLNPointAnnotation is a stub. To generate bindings for this class, include
/// MLNPointAnnotation in your config's objc-interfaces list.
///
/// An ``MLNPointAnnotation`` object represents a one-dimensional shape located at a
/// single geographical coordinate. Depending on how it is used, an
/// ``MLNPointAnnotation`` object is known as a point annotation or point shape. For
/// example, you could use a point shape to represent a city at low zoom levels, an
/// address at high zoom levels, or the location of a long press gesture.
///
/// You can add point shapes to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``’s or
/// ``MLNVectorTileSource``’s point shapes collectively using an ``MLNVectorTileSource`` or
/// ``MLNSymbolStyleLayer`` object.
///
/// For more interactivity, add a selectable point annotation to a map view using
/// the ``MLNMapView/addAnnotation:`` method. Alternatively, define your own model
/// class that conforms to the ``MLNAnnotation`` protocol. Configure a point
/// annotation’s appearance using
/// ``MLNMapViewDelegate/mapView:imageForAnnotation:`` or
/// ``MLNMapViewDelegate/mapView:viewForAnnotation:`` (iOS only). A point
/// annotation’s ``MLNShape/title`` and ``MLNShape/title`` properties define the
/// default content of the annotation’s callout (on iOS) or popover (on macOS).
///
/// To group multiple related points together in one shape, use an
/// ``MLNPointCollection`` or ``MLNPointCollection`` object. To access
/// a point’s attributes, use an ``MLNPointFeature`` object.
///
/// A point shape is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.2">Point</a> geometry
/// in GeoJSON.
///
/// #### Related examples
/// TODO: Mark a place on the map with an annotation
/// TODO: Mark a place on the map with an image
/// TODO: Default callout usage
/// Learn how to add ``MLNPointAnnotation`` objects to your map.
class MLNPointAnnotation extends MLNShape {
  MLNPointAnnotation._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPointAnnotation] that points to the same underlying object as [other].
  MLNPointAnnotation.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPointAnnotation] that wraps the given raw object pointer.
  MLNPointAnnotation.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: MLNPointFeature is a stub. To generate bindings for this class, include
/// MLNPointFeature in your config's objc-interfaces list.
///
/// An ``MLNPointFeature`` object associates a point shape with an optional
/// identifier and attributes.
///
/// #### Related examples
/// - <doc:WebAPIDataExample>
class MLNPointFeature extends MLNPointAnnotation {
  MLNPointFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPointFeature] that points to the same underlying object as [other].
  MLNPointFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPointFeature] that wraps the given raw object pointer.
  MLNPointFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: MLNPointFeatureCluster is a stub. To generate bindings for this class, include
/// MLNPointFeatureCluster in your config's objc-interfaces list.
///
/// An ``MLNPointFeatureCluster`` object associates a point shape (with an optional
/// identifier and attributes) and represents a point cluster.
///
/// @see ``MLNCluster``
///
/// #### Related examples
/// TODO: Clustering point data, learn how to initialize
/// clusters and add them to your map.
class MLNPointFeatureCluster extends MLNPointFeature {
  MLNPointFeatureCluster._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPointFeatureCluster] that points to the same underlying object as [other].
  MLNPointFeatureCluster.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPointFeatureCluster] that wraps the given raw object pointer.
  MLNPointFeatureCluster.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_MLNTileSource = objc.getClass("MLNTileSource");
late final _sel_configurationURL = objc.registerName("configurationURL");
late final _sel_attributionInfos = objc.registerName("attributionInfos");

/// ``MLNTileSource`` is a map content source that supplies map tiles to be shown on
/// the map. The location of and metadata about the tiles are defined either by an
/// option dictionary or by an external file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` or ``MLNRasterStyleLayer`` objects. Use a style layer to
/// control the appearance of content supplied by the tile source.
///
/// A tile source is also known as a tile set. To learn about the structure of a
/// Mapbox-hosted tile set, view it in
/// <a href="https://www.mapbox.com/studio/tilesets/">Mapbox Studio’s Tilesets editor</a>.
///
/// Create instances of ``MLNRasterTileSource`` and ``MLNRasterTileSource`` in order
/// to use ``MLNTileSource``'s properties and methods. Do not create instances of
/// ``MLNTileSource`` directly, and do not create your own subclasses of this class.
class MLNTileSource extends MLNSource {
  MLNTileSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNTileSource] that points to the same underlying object as [other].
  MLNTileSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNTileSource] that wraps the given raw object pointer.
  MLNTileSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNTileSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNTileSource);
  }

  /// The URL to the TileJSON configuration file that specifies the contents of the
  /// source.
  ///
  /// If the receiver was initialized using
  /// `-initWithIdentifier:tileURLTemplates:options`, this property is set to `nil`.
  objc.NSURL? get configurationURL {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_configurationURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// An array of ``MLNAttributionInfo`` objects that define the attribution
  /// statements to be displayed when the map is shown to the user.
  ///
  /// By default, this array is empty. If the source is initialized with a
  /// configuration URL, this array is also empty until the configuration JSON file
  /// is loaded.
  objc.NSArray get attributionInfos {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_attributionInfos);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNTileSource init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNTileSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNTileSource new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNTileSource, _sel_new);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNTileSource allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_MLNTileSource, _sel_allocWithZone_, zone);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNTileSource alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNTileSource, _sel_alloc);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNTileSource self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNTileSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNTileSource retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNTileSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNTileSource autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNTileSource.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_MLNVectorTileSource =
    objc.getClass("MapLibre.MLNVectorTileSource");
late final _sel_initWithIdentifier_configurationURL_ =
    objc.registerName("initWithIdentifier:configurationURL:");
late final _sel_initWithIdentifier_tileURLTemplates_options_ =
    objc.registerName("initWithIdentifier:tileURLTemplates:options:");
late final _sel_featuresInSourceLayersWithIdentifiers_predicate_ =
    objc.registerName("featuresInSourceLayersWithIdentifiers:predicate:");

/// ``MLNVectorTileSource`` is a map content source that supplies tiled vector data
/// in <a href="https://www.mapbox.com/vector-tiles/">Mapbox Vector Tile</a> format
/// to be shown on the map. The location of and metadata about the tiles are
/// defined either by an option dictionary or by an external file that conforms to
/// the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A vector tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNVectorStyleLayer`` objects. A vector style layer defines the appearance of
/// any content supplied by the vector tile source.
///
/// ``MLNVectorTileSource`` is optimized for data sets that are too large to fit
/// completely in memory, such as vector tile sets or data sets managed in
/// <a href="https://www.mapbox.com/studio/">Mapbox Studio</a>. For
/// <a href="http://geojson.org/">GeoJSON</a> data, use the ``MLNShapeSource``
/// class. For tiled data that changes dynamically, the ``MLNComputedShapeSource``
/// class may be a suitable alternative.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/sources/#vector"><code>vector</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNVectorTileSource`` object that you can use to initialize new style layers.
/// You can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// Within each vector tile, each geometric coordinate must lie between
/// −1&nbsp;×&nbsp;<var>extent</var> and
/// (<var>extent</var>&nbsp;×&nbsp;2)&nbsp;−&nbsp;1, inclusive. Any vector style
/// layer initialized with a vector tile source must have a non-`nil` value in its
/// `sourceLayerIdentifier` property.
///
/// Commonly used vector tile sources include
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets/">Mapbox Streets</a>,
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-terrain/">Mapbox Terrain</a>,
/// and
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-traffic-v1/">Mapbox Traffic</a>.
///
/// ### Example
///
/// ```swift
/// let source = MLNVectorTileSource(identifier: "pois", tileURLTemplates:
/// ["https://example.com/vector-tiles/{z}/{x}/{y}.mvt"], options: [ .minimumZoomLevel: 9,
/// .maximumZoomLevel: 16,
/// .attributionInfos: [
/// MLNAttributionInfo(title: NSAttributedString(string: "© Mapbox"), url: URL(string:
/// "https://mapbox.com"))
/// ]
/// ])
/// mapView.style?.addSource(source)
/// ```
///
/// #### Related examples
/// TODO: Data-driven circles, learn how to add data to your map using
/// an ``MLNVectorTileSource`` object.
class MLNVectorTileSource extends MLNTileSource {
  MLNVectorTileSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNVectorTileSource] that points to the same underlying object as [other].
  MLNVectorTileSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNVectorTileSource] that wraps the given raw object pointer.
  MLNVectorTileSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNVectorTileSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNVectorTileSource);
  }

  /// Returns a vector tile source initialized with an identifier and configuration
  /// URL.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or a canonical
  /// URL. The URL should point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @return An initialized vector tile source.
  MLNVectorTileSource initWithIdentifier_configurationURL_(
      objc.NSString identifier, objc.NSURL configurationURL) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_,
        identifier.ref.pointer,
        configurationURL.ref.pointer);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a vector tile source initialized an identifier, tile URL templates, and
  /// options.
  ///
  /// Tile URL templates are strings that specify the URLs of the vector tiles to
  /// load. See the “<a href="../tile-url-templates.html">Tile URL Templates</a>”
  /// guide for information about the format of a tile URL template.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param tileURLTemplates An array of tile URL template strings. Only the first
  /// string is used; any additional strings are ignored.
  /// @param options A dictionary containing configuration options. See
  /// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
  /// the default values.
  /// @return An initialized tile source.
  MLNVectorTileSource initWithIdentifier_tileURLTemplates_options_(
      objc.NSString identifier,
      objc.NSArray tileURLTemplates,
      objc.NSDictionary? options) {
    final _ret = _objc_msgSend_582s3n(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_tileURLTemplates_options_,
        identifier.ref.pointer,
        tileURLTemplates.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns an array of map features loaded by this source, restricted to the given
  /// source layers and filtered by the given predicate.
  ///
  /// Each object in the returned array represents a feature loaded by the source and
  /// provides access to attributes specified as part of the loaded feature. The
  /// source loads a feature if the source is added to an ``MLNMapView``’s style; that
  /// style has a layer that uses the source; and the map view has recently scrolled
  /// to the region containing the feature.
  ///
  /// Features come from tiled vector data that is converted to tiles internally, so
  /// feature geometries are clipped at tile boundaries and features may appear
  /// duplicated across tiles. For example, suppose part of a lengthy polyline
  /// representing a road has recently scrolled into view. The resulting array
  /// includes those parts of the road that lie within the map tiles that the source
  /// has loaded, even if the road extends into other tiles. The portion of the road
  /// within each map tile is included individually.
  ///
  /// Returned features may not necessarily be visible to the user at the time they
  /// are loaded: the style may contain a layer that forces the source’s tiles to
  /// load but filters out the features in question, preventing them from being
  /// drawn. To obtain only _visible_ features, use the
  /// ``MLNMapView/visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:``
  /// or
  /// ``MLNMapView/visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:``
  /// method.
  ///
  /// @param sourceLayerIdentifiers The source layers to include in the query. Only
  /// the features contained in these source layers are included in the returned
  /// array. This array may not be empty.
  /// @param predicate A predicate to filter the returned features. Use `nil` to
  /// include all loaded features.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features loaded by the source that match the predicate.
  objc.NSArray featuresInSourceLayersWithIdentifiers_predicate_(
      objc.NSSet sourceLayerIdentifiers, NSPredicate? predicate) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.pointer,
        _sel_featuresInSourceLayersWithIdentifiers_predicate_,
        sourceLayerIdentifiers.ref.pointer,
        predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNVectorTileSource init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNVectorTileSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNVectorTileSource new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNVectorTileSource, _sel_new);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNVectorTileSource allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNVectorTileSource, _sel_allocWithZone_, zone);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNVectorTileSource alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNVectorTileSource, _sel_alloc);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNVectorTileSource self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNVectorTileSource retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNVectorTileSource autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNShapeSource = objc.getClass("MLNShapeSource");
late final _sel_initWithIdentifier_URL_options_ =
    objc.registerName("initWithIdentifier:URL:options:");
late final _sel_initWithIdentifier_shape_options_ =
    objc.registerName("initWithIdentifier:shape:options:");
late final _sel_initWithIdentifier_features_options_ =
    objc.registerName("initWithIdentifier:features:options:");
late final _sel_initWithIdentifier_shapes_options_ =
    objc.registerName("initWithIdentifier:shapes:options:");
late final _sel_shape = objc.registerName("shape");
late final _sel_setShape_ = objc.registerName("setShape:");
late final _sel_URL = objc.registerName("URL");
late final _sel_setURL_ = objc.registerName("setURL:");
late final _sel_featuresMatchingPredicate_ =
    objc.registerName("featuresMatchingPredicate:");
late final _sel_leavesOfCluster_offset_limit_ =
    objc.registerName("leavesOfCluster:offset:limit:");
final _objc_msgSend_x2b4hx = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int)>();
late final _sel_childrenOfCluster_ = objc.registerName("childrenOfCluster:");
late final _sel_zoomLevelForExpandingCluster_ =
    objc.registerName("zoomLevelForExpandingCluster:");
final _objc_msgSend_hlyk7w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_hlyk7wFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// ``MLNShapeSource`` is a map content source that supplies vector shapes to be
/// shown on the map. The shapes may be instances of ``MLNShape`` or ``MLNShape``,
/// or they may be defined by local or external
/// <a href="http://geojson.org/">GeoJSON</a> code. A shape source is added to an
/// ``MLNStyle`` object along with an ``MLNStyle`` object. The vector style
/// layer defines the appearance of any content supplied by the shape source. You
/// can update a shape source by setting its `shape` or `URL` property.
///
/// ``MLNShapeSource`` is optimized for data sets that change dynamically and fit
/// completely in memory. For large data sets that do not fit completely in memory,
/// use the ``MLNComputedShapeSource`` or ``MLNComputedShapeSource`` class.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-geojson"><code>geojson</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNShapeSource`` object that you can use to refine the map’s content and
/// initialize new style layers. You can also add and remove sources dynamically
/// using methods such as ``MLNStyle/addSource:`` and
/// ``MLNStyle/sourceWithIdentifier:``.
///
/// Any vector style layer initialized with a shape source should have a `nil`
/// value in its `sourceLayerIdentifier` property.
///
/// ### Example
///
/// ```swift
/// var coordinates: [CLLocationCoordinate2D] = [
/// CLLocationCoordinate2D(latitude: 37.77, longitude: -122.42),
/// CLLocationCoordinate2D(latitude: 38.91, longitude: -77.04),
/// ]
/// let polyline = MLNPolylineFeature(coordinates: &coordinates, count: UInt(coordinates.count))
/// let source = MLNShapeSource(identifier: "lines", features: [polyline], options: nil)
/// mapView.style?.addSource(source)
/// ```
///
/// #### Related examples
/// TODO: Cluster point data
/// TODO: Use images to cluster point data
/// TODO: Add live data
/// Learn how to add data to your map using this ``MLNSource`` object.
class MLNShapeSource extends MLNSource {
  MLNShapeSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNShapeSource] that points to the same underlying object as [other].
  MLNShapeSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNShapeSource] that wraps the given raw object pointer.
  MLNShapeSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNShapeSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShapeSource);
  }

  /// Returns a shape source with an identifier, URL, and dictionary of options for
  /// the source.
  ///
  /// This class supports the following options: ``MLNShapeSourceOptionClustered``,
  /// ``MLNShapeSourceOptionClusterRadius``,
  /// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``, and
  /// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
  /// source are not clipped or wrapped automatically.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param url An HTTP(S) URL, absolute file URL, or local file URL relative to the
  /// current application’s resource bundle.
  /// @param options An `NSDictionary` of options for this source.
  /// @return An initialized shape source.
  ///
  /// #### Related examples
  /// TODO: Add live data, learn how to add live data to your map by
  /// updating the an ``MLNShapeSource`` object's `URL` property.
  MLNShapeSource initWithIdentifier_URL_options_(
      objc.NSString identifier, objc.NSURL url, objc.NSDictionary? options) {
    final _ret = _objc_msgSend_582s3n(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_URL_options_,
        identifier.ref.pointer,
        url.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a shape source with an identifier, a shape, and dictionary of options
  /// for the source.
  ///
  /// This class supports the following options: ``MLNShapeSourceOptionClustered``,
  /// ``MLNShapeSourceOptionClusterRadius``,
  /// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``, and
  /// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
  /// source are not clipped or wrapped automatically.
  ///
  /// To specify attributes about the shape, use an instance of an ``MLNShape``
  /// subclass that conforms to the ``MLNFeature`` protocol, such as ``MLNFeature``.
  /// To include multiple shapes in the source, use an ``MLNShapeCollection`` or
  /// ``MLNShapeCollectionFeature`` object, or use the
  /// `-initWithIdentifier:features:options:` or
  /// `-initWithIdentifier:shapes:options:` methods.
  ///
  /// To create a shape from GeoJSON source code, use the
  /// ``MLNShape/shapeWithData:encoding:error:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param shape A concrete subclass of ``MLNShape``
  /// @param options An `NSDictionary` of options for this source.
  /// @return An initialized shape source.
  ///
  /// #### Related examples
  /// TODO: Animate a line, learn how to animate line data by continously
  /// updating an ``MLNShapeSource``'s `shape` attribute.
  MLNShapeSource initWithIdentifier_shape_options_(
      objc.NSString identifier, MLNShape? shape, objc.NSDictionary? options) {
    final _ret = _objc_msgSend_582s3n(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_shape_options_,
        identifier.ref.pointer,
        shape?.ref.pointer ?? ffi.nullptr,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a shape source with an identifier, an array of features, and a dictionary
  /// of options for the source.
  ///
  /// This class supports the following options: ``MLNShapeSourceOptionClustered``,
  /// ``MLNShapeSourceOptionClusterRadius``,
  /// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``, and
  /// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
  /// source are not clipped or wrapped automatically.
  ///
  /// Unlike `-initWithIdentifier:shapes:options:`, this method accepts ``MLNFeature``
  /// instances, such as ``MLNPointFeature`` objects, whose attributes you can use when
  /// applying a predicate to ``MLNVectorStyleLayer`` or configuring a style layer’s
  /// appearance.
  ///
  /// To create a shape from GeoJSON source code, use the
  /// ``MLNShape/shapeWithData:encoding:error:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param features An array of objects that conform to the MLNFeature protocol.
  /// @param options An `NSDictionary` of options for this source.
  /// @return An initialized shape source.
  MLNShapeSource initWithIdentifier_features_options_(objc.NSString identifier,
      objc.NSArray features, objc.NSDictionary? options) {
    final _ret = _objc_msgSend_582s3n(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_features_options_,
        identifier.ref.pointer,
        features.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a shape source with an identifier, an array of shapes, and a dictionary of
  /// options for the source.
  ///
  /// This class supports the following options: ``MLNShapeSourceOptionClustered``,
  /// ``MLNShapeSourceOptionClusterRadius``,
  /// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``, and
  /// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
  /// source are not clipped or wrapped automatically.
  ///
  /// Any ``MLNFeature`` instance passed into this initializer is treated as an ordinary
  /// shape, causing any attributes to be inaccessible to an ``MLNVectorStyleLayer`` when
  /// evaluating a predicate or configuring certain layout or paint attributes. To
  /// preserve the attributes associated with each feature, use the
  /// `-initWithIdentifier:features:options:` method instead.
  ///
  /// To create a shape from GeoJSON source code, use the
  /// ``MLNShape/shapeWithData:encoding:error:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param shapes An array of shapes; each shape is a member of a concrete subclass of MLNShape.
  /// @param options An `NSDictionary` of options for this source.
  /// @return An initialized shape source.
  MLNShapeSource initWithIdentifier_shapes_options_(objc.NSString identifier,
      objc.NSArray shapes, objc.NSDictionary? options) {
    final _ret = _objc_msgSend_582s3n(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_shapes_options_,
        identifier.ref.pointer,
        shapes.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// The contents of the source. A shape can represent a GeoJSON geometry, a
  /// feature, or a collection of features.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:URL:options:`, this
  /// property is set to `nil`. This property is unavailable until the receiver is
  /// passed into ``MLNStyle/addSource:``.
  ///
  /// You can get/set the shapes within a collection via this property. Actions must
  /// be performed on the application's main thread.
  MLNShape? get shape {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_shape);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// The contents of the source. A shape can represent a GeoJSON geometry, a
  /// feature, or a collection of features.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:URL:options:`, this
  /// property is set to `nil`. This property is unavailable until the receiver is
  /// passed into ``MLNStyle/addSource:``.
  ///
  /// You can get/set the shapes within a collection via this property. Actions must
  /// be performed on the application's main thread.
  set shape(MLNShape? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setShape_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The URL to the GeoJSON document that specifies the contents of the source.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:shape:options:`,
  /// this property is set to `nil`.
  objc.NSURL? get URL {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_URL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// The URL to the GeoJSON document that specifies the contents of the source.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:shape:options:`,
  /// this property is set to `nil`.
  set URL(objc.NSURL? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns an array of map features for this source, filtered by the given
  /// predicate.
  ///
  /// Each object in the returned array represents a feature for the current style
  /// and provides access to attributes specified via the `shape` property.
  ///
  /// Features come from tiled GeoJSON data that is converted to tiles internally,
  /// so feature geometries are clipped at tile boundaries and features
  /// may appear duplicated across tiles. For example, suppose this source contains a
  /// long polyline representing a road. The resulting array includes those parts of
  /// the road that lie within the map tiles that the source has loaded, even if the
  /// road extends into other tiles. The portion of the road within each map tile is
  /// included individually.
  ///
  /// Returned features may not necessarily be visible to the user at the time they
  /// are loaded: the style may lack a layer that draws the features in question. To
  /// obtain only _visible_ features, use the
  /// ``MLNMapView/visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:``
  /// or
  /// ``MLNMapView/visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:``
  /// method.
  ///
  /// @param predicate A predicate to filter the returned features. Use `nil` to
  /// include all features in the source.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the source that match the predicate.
  objc.NSArray featuresMatchingPredicate_(NSPredicate? predicate) {
    final _ret = _objc_msgSend_62nh5j(this.ref.pointer,
        _sel_featuresMatchingPredicate_, predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of map features that are the leaves of the specified cluster.
  /// ("Leaves" are the original points that belong to the cluster.)
  ///
  /// This method supports pagination; you supply an offset (number of features to skip)
  /// and a maximum number of features to return.
  ///
  /// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
  /// ``MLNPointFeatureCluster`` protocol).
  /// @param offset Number of features to skip.
  /// @param limit The maximum number of features to return
  ///
  /// @return An array of objects that conform to the ``MLNFeature`` protocol.
  objc.NSArray leavesOfCluster_offset_limit_(
      MLNPointFeatureCluster cluster, int offset, int limit) {
    final _ret = _objc_msgSend_x2b4hx(this.ref.pointer,
        _sel_leavesOfCluster_offset_limit_, cluster.ref.pointer, offset, limit);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of map features that are the immediate children of the specified
  /// cluster *on the next zoom level*. The may include features that also conform to
  /// the ``MLNCluster`` protocol (currently only objects of type ``MLNCluster``).
  ///
  /// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
  /// ``MLNPointFeatureCluster`` protocol).
  ///
  /// @return An array of objects that conform to the ``MLNFeature`` protocol.
  ///
  /// > Note: The returned array may contain the `cluster` that was passed in, if the next
  /// zoom level doesn't match the zoom level for expanding that cluster. See
  /// ``MLNShapeSource/zoomLevelForExpandingCluster:``.
  objc.NSArray childrenOfCluster_(MLNPointFeatureCluster cluster) {
    final _ret = _objc_msgSend_62nh5j(
        this.ref.pointer, _sel_childrenOfCluster_, cluster.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the zoom level at which the given cluster expands.
  ///
  /// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
  /// ``MLNPointFeatureCluster`` protocol).
  ///
  /// @return Zoom level. This should be >= 0; any negative return value should be
  /// considered an error.
  double zoomLevelForExpandingCluster_(MLNPointFeatureCluster cluster) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_hlyk7wFpret(this.ref.pointer,
            _sel_zoomLevelForExpandingCluster_, cluster.ref.pointer)
        : _objc_msgSend_hlyk7w(this.ref.pointer,
            _sel_zoomLevelForExpandingCluster_, cluster.ref.pointer);
  }

  /// init
  MLNShapeSource init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNShapeSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNShapeSource new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNShapeSource, _sel_new);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNShapeSource allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_MLNShapeSource, _sel_allocWithZone_, zone);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNShapeSource alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNShapeSource, _sel_alloc);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNShapeSource self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNShapeSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNShapeSource retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNShapeSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNShapeSource autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNShapeSource.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_MLNImageSource = objc.getClass("MLNImageSource");
late final _sel_initWithIdentifier_coordinateQuad_URL_ =
    objc.registerName("initWithIdentifier:coordinateQuad:URL:");
final _objc_msgSend_1d4cwk4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                MLNCoordinateQuad,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            MLNCoordinateQuad,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithIdentifier_coordinateQuad_image_ =
    objc.registerName("initWithIdentifier:coordinateQuad:image:");
late final _sel_image = objc.registerName("image");
late final _sel_setImage_ = objc.registerName("setImage:");
late final _sel_coordinates = objc.registerName("coordinates");
final _objc_msgSend_1ua371c = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNCoordinateQuad Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        MLNCoordinateQuad Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1ua371cStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNCoordinateQuad>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<MLNCoordinateQuad>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCoordinates_ = objc.registerName("setCoordinates:");
final _objc_msgSend_1wvd2xm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNCoordinateQuad)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateQuad)>();

/// ``MLNImageSource`` is a content source that is used for a georeferenced raster
/// image to be shown on the map. The georeferenced image scales and rotates as the
/// user zooms and rotates the map. Images may also be used as icons or patterns
/// in a style layer. To register an image for use as an icon or pattern,
/// use the ``MLNStyle/setImage:forName:`` method. To configure a point
/// annotation’s image, use the ``MLNAnnotationImage`` class.
///
/// The geographic location of the raster image content, supplied with
/// ``MLNCoordinateQuad``, can be non-axis aligned.
/// ``MLNImageSource`` supports raster content from `NSURL`, `NSImage` (macOS), or
/// `UIImage` (iOS).
/// An image source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` objects. Use a raster style layer to control the
/// appearance of content supplied by the image source.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-image"><code>image</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNImageSource`` object that you can use to initialize new style layers. You
/// can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// ### Example
///
/// ```swift
/// let coordinates = MLNCoordinateQuad(
/// topLeft: CLLocationCoordinate2D(latitude: 46.437, longitude: -80.425),
/// bottomLeft: CLLocationCoordinate2D(latitude: 37.936, longitude: -80.425),
/// bottomRight: CLLocationCoordinate2D(latitude: 37.936, longitude: -71.516),
/// topRight: CLLocationCoordinate2D(latitude: 46.437, longitude: -71.516))
/// let source = MLNImageSource(identifier: "radar", coordinateQuad: coordinates, url: URL(string:
/// "https://maplibre.org/maplibre-gl-js-docs/assets/radar.gif")!) mapView.style?.addSource(source)
/// ```
///
/// #### Related examples
/// TODO: Add an image, learn how to add an image to your map using ``MLNImageSource``.
class MLNImageSource extends MLNSource {
  MLNImageSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNImageSource] that points to the same underlying object as [other].
  MLNImageSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNImageSource] that wraps the given raw object pointer.
  MLNImageSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNImageSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNImageSource);
  }

  /// Returns a georeferenced image source with an identifier, coordinates and a URL.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param coordinateQuad the top left, top right, bottom right, and bottom left coordinates for the
  /// image.
  /// @param url An HTTP(S) URL, absolute file URL, or local file URL relative to the
  /// current application’s resource bundle.
  /// @return An initialized shape source.
  MLNImageSource initWithIdentifier_coordinateQuad_URL_(
      objc.NSString identifier,
      MLNCoordinateQuad coordinateQuad,
      objc.NSURL url) {
    final _ret = _objc_msgSend_1d4cwk4(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_coordinateQuad_URL_,
        identifier.ref.pointer,
        coordinateQuad,
        url.ref.pointer);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a georeferenced image source with an identifier, coordinates and an image.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param coordinateQuad The top left, top right, bottom right, and bottom left coordinates for the
  /// image.
  /// @param image The image to display for the source.
  /// @return An initialized shape source.
  MLNImageSource initWithIdentifier_coordinateQuad_image_(
      objc.NSString identifier,
      MLNCoordinateQuad coordinateQuad,
      NSImage image) {
    final _ret = _objc_msgSend_1d4cwk4(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_coordinateQuad_image_,
        identifier.ref.pointer,
        coordinateQuad,
        image.ref.pointer);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// The URL to the source image.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:image:` or
  /// the `image` property is set, this property is set to `nil`.
  objc.NSURL? get URL {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_URL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// The URL to the source image.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:image:` or
  /// the `image` property is set, this property is set to `nil`.
  set URL(objc.NSURL? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The source image.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:URL:` or if the `URL`
  /// property is set, this property is set to `nil`.
  NSImage? get image {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_image);
    return _ret.address == 0
        ? null
        : NSImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// The source image.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:URL:` or if the `URL`
  /// property is set, this property is set to `nil`.
  set image(NSImage? value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The coordinates at which the corners of the source image will be placed.
  MLNCoordinateQuad get coordinates {
    final _ptr = pkg_ffi.calloc<MLNCoordinateQuad>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1ua371cStret(_ptr, this.ref.pointer, _sel_coordinates)
        : _ptr.ref = _objc_msgSend_1ua371c(this.ref.pointer, _sel_coordinates);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateQuad>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateQuad>(_finalizable);
  }

  /// The coordinates at which the corners of the source image will be placed.
  set coordinates(MLNCoordinateQuad value) {
    return _objc_msgSend_1wvd2xm(this.ref.pointer, _sel_setCoordinates_, value);
  }

  /// init
  MLNImageSource init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNImageSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNImageSource new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNImageSource, _sel_new);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNImageSource allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_hzlb60(_class_MLNImageSource, _sel_allocWithZone_, zone);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNImageSource alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNImageSource, _sel_alloc);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNImageSource self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNImageSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNImageSource retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNImageSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNImageSource autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNImageSource.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_MLNRasterTileSource = objc.getClass("MLNRasterTileSource");
late final _sel_initWithIdentifier_configurationURL_tileSize_ =
    objc.registerName("initWithIdentifier:configurationURL:tileSize:");

/// ``MLNRasterTileSource`` is a map content source that supplies raster image tiles
/// to be shown on the map. The location of and metadata about the tiles are
/// defined either by an option dictionary or by an external file that conforms to
/// the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A raster tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` objects. Use a raster style layer to control the
/// appearance of content supplied by the raster tile source.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-raster"><code>raster</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNRasterTileSource`` object that you can use to initialize new style layers. You
/// can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// ### Example
///
/// ```swift
/// let source = MLNRasterTileSource(identifier: "clouds", tileURLTemplates:
/// ["https://example.com/raster-tiles/{z}/{x}/{y}.png"], options: [ .minimumZoomLevel: 9,
/// .maximumZoomLevel: 16,
/// .tileSize: 512,
/// .attributionInfos: [
/// MLNAttributionInfo(title: NSAttributedString(string: "© Mapbox"), url: URL(string:
/// "https://mapbox.com"))
/// ]
/// ])
/// mapView.style?.addSource(source)
/// ```
///
/// #### Related examples
/// TODO: Add raster imagery, learn how to add a ``MLNRasterStyleLayer``
/// to your map using an ``MLNRasterTileSource``.
class MLNRasterTileSource extends MLNTileSource {
  MLNRasterTileSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNRasterTileSource] that points to the same underlying object as [other].
  MLNRasterTileSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNRasterTileSource] that wraps the given raw object pointer.
  MLNRasterTileSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNRasterTileSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterTileSource);
  }

  /// Returns a raster tile source initialized with an identifier and configuration
  /// URL.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or canonical URL. The URL should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// If a Mapbox URL is specified, this source uses a tile size of 256. For all
  /// other tilesets, the default value is 512. (See the
  /// ``MLNTileSourceOptionTileSize`` documentation for more information about tile
  /// sizes.) If you need to use a tile size other than the default, use the
  /// `-initWithIdentifier:configurationURL:tileSize:` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @return An initialized raster tile source.
  MLNRasterTileSource initWithIdentifier_configurationURL_(
      objc.NSString identifier, objc.NSURL configurationURL) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_,
        identifier.ref.pointer,
        configurationURL.ref.pointer);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a raster tile source initialized with an identifier, configuration URL,
  /// and tile size.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or, canonical URL. The URL should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @param tileSize The width and height (measured in points) of each tiled image
  /// in the raster tile source. See the ``MLNTileSourceOptionTileSize``
  /// documentation for details.
  /// @return An initialized raster tile source.
  MLNRasterTileSource initWithIdentifier_configurationURL_tileSize_(
      objc.NSString identifier, objc.NSURL configurationURL, double tileSize) {
    final _ret = _objc_msgSend_1xdeq9e(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_tileSize_,
        identifier.ref.pointer,
        configurationURL.ref.pointer,
        tileSize);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a raster tile source initialized an identifier, tile URL templates, and
  /// options.
  ///
  /// Tile URL templates are strings that specify the URLs of the raster tile images
  /// to load. See the “<a href="../tile-url-templates.html">Tile URL Templates</a>”
  /// guide for information about the format of a tile URL template.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param tileURLTemplates An array of tile URL template strings. Only the first
  /// string is used; any additional strings are ignored.
  /// @param options A dictionary containing configuration options. See
  /// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
  /// the default values.
  /// @return An initialized tile source.
  MLNRasterTileSource initWithIdentifier_tileURLTemplates_options_(
      objc.NSString identifier,
      objc.NSArray tileURLTemplates,
      objc.NSDictionary? options) {
    final _ret = _objc_msgSend_582s3n(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_tileURLTemplates_options_,
        identifier.ref.pointer,
        tileURLTemplates.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// init
  MLNRasterTileSource init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNRasterTileSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNRasterTileSource new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNRasterTileSource, _sel_new);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNRasterTileSource allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNRasterTileSource, _sel_allocWithZone_, zone);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNRasterTileSource alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNRasterTileSource, _sel_alloc);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNRasterTileSource self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNRasterTileSource retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNRasterTileSource autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNRasterDEMSource = objc.getClass("MLNRasterDEMSource");

/// ``MLNRasterDEMSource`` is a map content source that supplies rasterized
/// <a href="https://en.wikipedia.org/wiki/Digital_elevation_model">digital elevation model</a>
/// (DEM) tiles to be shown on the map. The location of and metadata about the
/// tiles are defined either by an option dictionary or by an external file that
/// conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A raster DEM source is added to an ``MLNStyle`` object along with one or more
/// ``MLNHillshadeStyleLayer`` objects. Use a hillshade style layer to control the
/// appearance of content supplied by the raster DEM source.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-raster-dem"><code>raster-dem</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNRasterDEMSource`` object that you can use to initialize new style layers.
/// You can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// Currently, raster DEM sources only support the format used by
/// <a
/// href="https://docs.mapbox.com/help/troubleshooting/access-elevation-data/#mapbox-terrain-rgb">Mapbox
/// Terrain-RGB</a>.
///
/// ### Example
///
/// ```swift
/// let terrainRGBURL = URL(string: "maptiler://sources/terrain-rgb")!
/// let source = MLNRasterDEMSource(identifier: "hills", configurationURL: terrainRGBURL)
/// mapView.style?.addSource(source)
/// ```
class MLNRasterDEMSource extends MLNRasterTileSource {
  MLNRasterDEMSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNRasterDEMSource] that points to the same underlying object as [other].
  MLNRasterDEMSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNRasterDEMSource] that wraps the given raw object pointer.
  MLNRasterDEMSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNRasterDEMSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterDEMSource);
  }

  /// Returns a raster tile source initialized with an identifier and configuration
  /// URL.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or canonical URL. The URL should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// If a Mapbox URL is specified, this source uses a tile size of 256. For all
  /// other tilesets, the default value is 512. (See the
  /// ``MLNTileSourceOptionTileSize`` documentation for more information about tile
  /// sizes.) If you need to use a tile size other than the default, use the
  /// `-initWithIdentifier:configurationURL:tileSize:` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @return An initialized raster tile source.
  MLNRasterDEMSource initWithIdentifier_configurationURL_(
      objc.NSString identifier, objc.NSURL configurationURL) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_,
        identifier.ref.pointer,
        configurationURL.ref.pointer);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a raster tile source initialized with an identifier, configuration URL,
  /// and tile size.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or, canonical URL. The URL should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @param tileSize The width and height (measured in points) of each tiled image
  /// in the raster tile source. See the ``MLNTileSourceOptionTileSize``
  /// documentation for details.
  /// @return An initialized raster tile source.
  MLNRasterDEMSource initWithIdentifier_configurationURL_tileSize_(
      objc.NSString identifier, objc.NSURL configurationURL, double tileSize) {
    final _ret = _objc_msgSend_1xdeq9e(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_tileSize_,
        identifier.ref.pointer,
        configurationURL.ref.pointer,
        tileSize);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a raster tile source initialized an identifier, tile URL templates, and
  /// options.
  ///
  /// Tile URL templates are strings that specify the URLs of the raster tile images
  /// to load. See the “<a href="../tile-url-templates.html">Tile URL Templates</a>”
  /// guide for information about the format of a tile URL template.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param tileURLTemplates An array of tile URL template strings. Only the first
  /// string is used; any additional strings are ignored.
  /// @param options A dictionary containing configuration options. See
  /// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
  /// the default values.
  /// @return An initialized tile source.
  MLNRasterDEMSource initWithIdentifier_tileURLTemplates_options_(
      objc.NSString identifier,
      objc.NSArray tileURLTemplates,
      objc.NSDictionary? options) {
    final _ret = _objc_msgSend_582s3n(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_tileURLTemplates_options_,
        identifier.ref.pointer,
        tileURLTemplates.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// init
  MLNRasterDEMSource init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNRasterDEMSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNRasterDEMSource new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNRasterDEMSource, _sel_new);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNRasterDEMSource allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNRasterDEMSource, _sel_allocWithZone_, zone);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNRasterDEMSource alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNRasterDEMSource, _sel_alloc);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNRasterDEMSource self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNRasterDEMSource retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNRasterDEMSource autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNBackgroundStyleLayer =
    objc.getClass("MLNBackgroundStyleLayer");
late final _sel_backgroundColorTransition =
    objc.registerName("backgroundColorTransition");
late final _sel_setBackgroundColorTransition_ =
    objc.registerName("setBackgroundColorTransition:");
late final _sel_backgroundOpacity = objc.registerName("backgroundOpacity");
late final _sel_setBackgroundOpacity_ =
    objc.registerName("setBackgroundOpacity:");
late final _sel_backgroundOpacityTransition =
    objc.registerName("backgroundOpacityTransition");
late final _sel_setBackgroundOpacityTransition_ =
    objc.registerName("setBackgroundOpacityTransition:");
late final _sel_backgroundPattern = objc.registerName("backgroundPattern");
late final _sel_setBackgroundPattern_ =
    objc.registerName("setBackgroundPattern:");
late final _sel_backgroundPatternTransition =
    objc.registerName("backgroundPatternTransition");
late final _sel_setBackgroundPatternTransition_ =
    objc.registerName("setBackgroundPatternTransition:");

/// An ``MLNBackgroundStyleLayer`` is a style layer that covers the entire map. Use
/// a background style layer to configure a color or pattern to show below all
/// other map content. If the style’s other layers use the Mapbox Streets source,
/// the background style layer is responsible for drawing land, whereas the oceans
/// and other bodies of water are drawn by ``MLNBackgroundStyleLayer`` objects.
///
/// A background style layer is typically the bottommost layer in a style, because
/// it covers the entire map and can occlude any layers below it. You can therefore
/// access it by getting the last item in the ``MLNStyle/layers`` array.
///
/// If the background style layer is transparent or omitted from the style, any
/// portion of the map view that does not show another style layer is transparent.
class MLNBackgroundStyleLayer extends MLNStyleLayer {
  MLNBackgroundStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNBackgroundStyleLayer] that points to the same underlying object as [other].
  MLNBackgroundStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNBackgroundStyleLayer] that wraps the given raw object pointer.
  MLNBackgroundStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNBackgroundStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNBackgroundStyleLayer);
  }

  /// Returns a background style layer initialized with an identifier.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  MLNBackgroundStyleLayer initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_62nh5j(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The color with which the background will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `backgroundPattern` is set to
  /// `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get backgroundColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_backgroundColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color with which the background will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `backgroundPattern` is set to
  /// `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set backgroundColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setBackgroundColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `backgroundColor` property.
  ///
  /// This property corresponds to the `background-color-transition` property in the style JSON file format.
  MLNTransition get backgroundColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_backgroundColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_backgroundColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `backgroundColor` property.
  ///
  /// This property corresponds to the `background-color-transition` property in the style JSON file format.
  set backgroundColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setBackgroundColorTransition_, value);
  }

  /// The opacity at which the background will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get backgroundOpacity {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_backgroundOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the background will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set backgroundOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setBackgroundOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `backgroundOpacity` property.
  ///
  /// This property corresponds to the `background-opacity-transition` property in the style JSON file format.
  MLNTransition get backgroundOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_backgroundOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_backgroundOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `backgroundOpacity` property.
  ///
  /// This property corresponds to the `background-opacity-transition` property in the style JSON file format.
  set backgroundOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setBackgroundOpacityTransition_, value);
  }

  /// Name of image in style images to use for drawing an image background. For
  /// seamless patterns, image width and height must be a factor of two (2, 4, 8,
  /// ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get backgroundPattern {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_backgroundPattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of image in style images to use for drawing an image background. For
  /// seamless patterns, image width and height must be a factor of two (2, 4, 8,
  /// ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set backgroundPattern(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setBackgroundPattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `backgroundPattern` property.
  ///
  /// This property corresponds to the `background-pattern-transition` property in the style JSON file format.
  MLNTransition get backgroundPatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_backgroundPatternTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_backgroundPatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `backgroundPattern` property.
  ///
  /// This property corresponds to the `background-pattern-transition` property in the style JSON file format.
  set backgroundPatternTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setBackgroundPatternTransition_, value);
  }

  /// init
  MLNBackgroundStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNBackgroundStyleLayer new1() {
    final _ret =
        _objc_msgSend_1x359cv(_class_MLNBackgroundStyleLayer, _sel_new);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNBackgroundStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNBackgroundStyleLayer, _sel_allocWithZone_, zone);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNBackgroundStyleLayer alloc() {
    final _ret =
        _objc_msgSend_1x359cv(_class_MLNBackgroundStyleLayer, _sel_alloc);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNBackgroundStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNBackgroundStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNBackgroundStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNForegroundStyleLayer =
    objc.getClass("MLNForegroundStyleLayer");
late final _sel_sourceIdentifier = objc.registerName("sourceIdentifier");

/// ``MLNForegroundStyleLayer`` is an abstract superclass for style layers whose
/// content is defined by an ``MLNSource`` object.
///
/// Create instances of ``MLNRasterStyleLayer``, ``MLNRasterStyleLayer``, and the
/// concrete subclasses of ``MLNVectorStyleLayer`` in order to use
/// ``MLNForegroundStyleLayer``'s methods. Do not create instances of
/// ``MLNForegroundStyleLayer`` directly, and do not create your own subclasses of
/// this class.
class MLNForegroundStyleLayer extends MLNStyleLayer {
  MLNForegroundStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNForegroundStyleLayer] that points to the same underlying object as [other].
  MLNForegroundStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNForegroundStyleLayer] that wraps the given raw object pointer.
  MLNForegroundStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNForegroundStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNForegroundStyleLayer);
  }

  /// init
  MLNForegroundStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Identifier of the source from which the receiver obtains the data to style.
  objc.NSString? get sourceIdentifier {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_sourceIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static MLNForegroundStyleLayer new1() {
    final _ret =
        _objc_msgSend_1x359cv(_class_MLNForegroundStyleLayer, _sel_new);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNForegroundStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNForegroundStyleLayer, _sel_allocWithZone_, zone);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNForegroundStyleLayer alloc() {
    final _ret =
        _objc_msgSend_1x359cv(_class_MLNForegroundStyleLayer, _sel_alloc);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNForegroundStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNForegroundStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNForegroundStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNVectorStyleLayer = objc.getClass("MLNVectorStyleLayer");
late final _sel_sourceLayerIdentifier =
    objc.registerName("sourceLayerIdentifier");
late final _sel_setSourceLayerIdentifier_ =
    objc.registerName("setSourceLayerIdentifier:");
late final _sel_setPredicate_ = objc.registerName("setPredicate:");

/// ``MLNVectorStyleLayer`` is an abstract superclass for style layers whose content
/// is defined by an ``MLNShapeSource`` or ``MLNShapeSource`` object.
///
/// Create instances of ``MLNCircleStyleLayer``, ``MLNCircleStyleLayer``,
/// ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``, and
/// ``MLNSymbolStyleLayer`` in order to use ``MLNSymbolStyleLayer``'s properties and
/// methods. Do not create instances of ``MLNVectorStyleLayer`` directly, and do not
/// create your own subclasses of this class.
class MLNVectorStyleLayer extends MLNForegroundStyleLayer {
  MLNVectorStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNVectorStyleLayer] that points to the same underlying object as [other].
  MLNVectorStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNVectorStyleLayer] that wraps the given raw object pointer.
  MLNVectorStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNVectorStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNVectorStyleLayer);
  }

  /// Identifier of the layer within the source identified by the `sourceIdentifier`
  /// property from which the receiver obtains the data to style.
  objc.NSString? get sourceLayerIdentifier {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_sourceLayerIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Identifier of the layer within the source identified by the `sourceIdentifier`
  /// property from which the receiver obtains the data to style.
  set sourceLayerIdentifier(objc.NSString? value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer,
        _sel_setSourceLayerIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The style layer’s predicate.
  ///
  /// Use the style layer’s predicate to include only the features in the source
  /// layer that satisfy a condition that you define. If the style layer initially
  /// comes from the style, its predicate corresponds to the
  /// <a href="https://maplibre.org/maplibre-style-spec/#layer-filter">`filter`</a>
  /// property in the style JSON.
  ///
  /// See the “<a href="../predicates-and-expressions.html">Predicates and Expressions</a>”
  /// guide for details about the predicate syntax supported by this class.
  ///
  /// ### Example
  ///
  /// To filter the layer to include only the features whose `index` attribute is 5
  /// or 10 and whose `ele` attribute is at least 1,500, you could create an
  /// `NSCompoundPredicate` along these lines:
  ///
  /// ```swift
  /// let layer = MLNLineStyleLayer(identifier: "contour", source: terrain)
  /// layer.sourceLayerIdentifier = "contours"
  /// layer.predicate = NSPredicate(format: "(index == 5 || index == 10) && CAST(ele, 'NSNumber') >=
  /// 1500.0") mapView.style?.addLayer(layer)
  /// ```
  NSPredicate? get predicate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_predicate);
    return _ret.address == 0
        ? null
        : NSPredicate.castFromPointer(_ret, retain: true, release: true);
  }

  /// The style layer’s predicate.
  ///
  /// Use the style layer’s predicate to include only the features in the source
  /// layer that satisfy a condition that you define. If the style layer initially
  /// comes from the style, its predicate corresponds to the
  /// <a href="https://maplibre.org/maplibre-style-spec/#layer-filter">`filter`</a>
  /// property in the style JSON.
  ///
  /// See the “<a href="../predicates-and-expressions.html">Predicates and Expressions</a>”
  /// guide for details about the predicate syntax supported by this class.
  ///
  /// ### Example
  ///
  /// To filter the layer to include only the features whose `index` attribute is 5
  /// or 10 and whose `ele` attribute is at least 1,500, you could create an
  /// `NSCompoundPredicate` along these lines:
  ///
  /// ```swift
  /// let layer = MLNLineStyleLayer(identifier: "contour", source: terrain)
  /// layer.sourceLayerIdentifier = "contours"
  /// layer.predicate = NSPredicate(format: "(index == 5 || index == 10) && CAST(ele, 'NSNumber') >=
  /// 1500.0") mapView.style?.addLayer(layer)
  /// ```
  set predicate(NSPredicate? value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer, _sel_setPredicate_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  MLNVectorStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNVectorStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNVectorStyleLayer, _sel_new);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNVectorStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNVectorStyleLayer, _sel_allocWithZone_, zone);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNVectorStyleLayer alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNVectorStyleLayer, _sel_alloc);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNVectorStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNVectorStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNVectorStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNCircleStyleLayer = objc.getClass("MLNCircleStyleLayer");
late final _sel_initWithIdentifier_source_ =
    objc.registerName("initWithIdentifier:source:");
late final _sel_circleSortKey = objc.registerName("circleSortKey");
late final _sel_setCircleSortKey_ = objc.registerName("setCircleSortKey:");
late final _sel_circleBlur = objc.registerName("circleBlur");
late final _sel_setCircleBlur_ = objc.registerName("setCircleBlur:");
late final _sel_circleBlurTransition =
    objc.registerName("circleBlurTransition");
late final _sel_setCircleBlurTransition_ =
    objc.registerName("setCircleBlurTransition:");
late final _sel_circleColor = objc.registerName("circleColor");
late final _sel_setCircleColor_ = objc.registerName("setCircleColor:");
late final _sel_circleColorTransition =
    objc.registerName("circleColorTransition");
late final _sel_setCircleColorTransition_ =
    objc.registerName("setCircleColorTransition:");
late final _sel_circleOpacity = objc.registerName("circleOpacity");
late final _sel_setCircleOpacity_ = objc.registerName("setCircleOpacity:");
late final _sel_circleOpacityTransition =
    objc.registerName("circleOpacityTransition");
late final _sel_setCircleOpacityTransition_ =
    objc.registerName("setCircleOpacityTransition:");
late final _sel_circlePitchAlignment =
    objc.registerName("circlePitchAlignment");
late final _sel_setCirclePitchAlignment_ =
    objc.registerName("setCirclePitchAlignment:");
late final _sel_circleRadius = objc.registerName("circleRadius");
late final _sel_setCircleRadius_ = objc.registerName("setCircleRadius:");
late final _sel_circleRadiusTransition =
    objc.registerName("circleRadiusTransition");
late final _sel_setCircleRadiusTransition_ =
    objc.registerName("setCircleRadiusTransition:");
late final _sel_circleScaleAlignment =
    objc.registerName("circleScaleAlignment");
late final _sel_setCircleScaleAlignment_ =
    objc.registerName("setCircleScaleAlignment:");
late final _sel_circlePitchScale = objc.registerName("circlePitchScale");
late final _sel_setCirclePitchScale_ =
    objc.registerName("setCirclePitchScale:");
late final _sel_circleStrokeColor = objc.registerName("circleStrokeColor");
late final _sel_setCircleStrokeColor_ =
    objc.registerName("setCircleStrokeColor:");
late final _sel_circleStrokeColorTransition =
    objc.registerName("circleStrokeColorTransition");
late final _sel_setCircleStrokeColorTransition_ =
    objc.registerName("setCircleStrokeColorTransition:");
late final _sel_circleStrokeOpacity = objc.registerName("circleStrokeOpacity");
late final _sel_setCircleStrokeOpacity_ =
    objc.registerName("setCircleStrokeOpacity:");
late final _sel_circleStrokeOpacityTransition =
    objc.registerName("circleStrokeOpacityTransition");
late final _sel_setCircleStrokeOpacityTransition_ =
    objc.registerName("setCircleStrokeOpacityTransition:");
late final _sel_circleStrokeWidth = objc.registerName("circleStrokeWidth");
late final _sel_setCircleStrokeWidth_ =
    objc.registerName("setCircleStrokeWidth:");
late final _sel_circleStrokeWidthTransition =
    objc.registerName("circleStrokeWidthTransition");
late final _sel_setCircleStrokeWidthTransition_ =
    objc.registerName("setCircleStrokeWidthTransition:");
late final _sel_circleTranslation = objc.registerName("circleTranslation");
late final _sel_setCircleTranslation_ =
    objc.registerName("setCircleTranslation:");
late final _sel_circleTranslationTransition =
    objc.registerName("circleTranslationTransition");
late final _sel_setCircleTranslationTransition_ =
    objc.registerName("setCircleTranslationTransition:");
late final _sel_circleTranslate = objc.registerName("circleTranslate");
late final _sel_setCircleTranslate_ = objc.registerName("setCircleTranslate:");
late final _sel_circleTranslationAnchor =
    objc.registerName("circleTranslationAnchor");
late final _sel_setCircleTranslationAnchor_ =
    objc.registerName("setCircleTranslationAnchor:");
late final _sel_circleTranslateAnchor =
    objc.registerName("circleTranslateAnchor");
late final _sel_setCircleTranslateAnchor_ =
    objc.registerName("setCircleTranslateAnchor:");

/// An ``MLNCircleStyleLayer`` is a style layer that renders one or more filled
/// circles on the map.
///
/// Use a circle style layer to configure the visual appearance of point or point
/// collection features. These features can come from vector tiles loaded by an
/// ``MLNCircleStyleLayer`` object, or they can be ``MLNCircleStyleLayer``,
/// ``MLNCircleStyleLayer``, ``MLNCircleStyleLayer``, or ``MLNCircleStyleLayer``
/// instances in an ``MLNCircleStyleLayer`` or ``MLNCircleStyleLayer`` object.
///
/// A circle style layer renders circles whose radii are measured in screen units.
/// To display circles on the map whose radii correspond to real-world distances,
/// use many-sided regular polygons and configure their appearance using an
/// ``MLNCircleStyleLayer`` object.
///
/// You can access an existing circle style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new circle style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/dds-circle-layer/">Data-driven
/// circles</a>, <a
/// href="https://docs.mapbox.com/ios/maps/examples/shape-collection/">Add multiple
/// shapes from a single shape source</a>, and <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster point
/// data</a> examples to learn how to add circles to your map using this style
/// layer.
///
/// ### Example
///
/// ```swift
/// ```
class MLNCircleStyleLayer extends MLNVectorStyleLayer {
  MLNCircleStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNCircleStyleLayer] that points to the same underlying object as [other].
  MLNCircleStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNCircleStyleLayer] that wraps the given raw object pointer.
  MLNCircleStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNCircleStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNCircleStyleLayer);
  }

  /// Returns a circle style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNCircleStyleLayer initWithIdentifier_source_(
      objc.NSString identifier, MLNSource source) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleSortKey {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleSortKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleSortKey(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleSortKey_, value.ref.pointer);
  }

  /// Amount to blur the circle. 1 blurs the circle such that only the centerpoint is
  /// full opacity.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleBlur {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleBlur);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Amount to blur the circle. 1 blurs the circle such that only the centerpoint is
  /// full opacity.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleBlur(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleBlur_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleBlur` property.
  ///
  /// This property corresponds to the `circle-blur-transition` property in the style JSON file format.
  MLNTransition get circleBlurTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleBlurTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_circleBlurTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleBlur` property.
  ///
  /// This property corresponds to the `circle-blur-transition` property in the style JSON file format.
  set circleBlurTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleBlurTransition_, value);
  }

  /// The fill color of the circle.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The fill color of the circle.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleColor` property.
  ///
  /// This property corresponds to the `circle-color-transition` property in the style JSON file format.
  MLNTransition get circleColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_circleColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleColor` property.
  ///
  /// This property corresponds to the `circle-color-transition` property in the style JSON file format.
  set circleColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleColorTransition_, value);
  }

  /// The opacity at which the circle will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleOpacity {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the circle will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleOpacity` property.
  ///
  /// This property corresponds to the `circle-opacity-transition` property in the style JSON file format.
  MLNTransition get circleOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleOpacity` property.
  ///
  /// This property corresponds to the `circle-opacity-transition` property in the style JSON file format.
  set circleOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleOpacityTransition_, value);
  }

  /// Orientation of circle when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `viewport`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCirclePitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The circle is aligned to the plane of the map.
  /// `viewport`: The circle is aligned to the plane of the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get circlePitchAlignment {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_circlePitchAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Orientation of circle when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `viewport`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCirclePitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The circle is aligned to the plane of the map.
  /// `viewport`: The circle is aligned to the plane of the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set circlePitchAlignment(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCirclePitchAlignment_, value.ref.pointer);
  }

  /// Circle radius.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `5`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleRadius {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleRadius);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Circle radius.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `5`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleRadius(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleRadius_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleRadius` property.
  ///
  /// This property corresponds to the `circle-radius-transition` property in the style JSON file format.
  MLNTransition get circleRadiusTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleRadiusTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleRadiusTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleRadius` property.
  ///
  /// This property corresponds to the `circle-radius-transition` property in the style JSON file format.
  set circleRadiusTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleRadiusTransition_, value);
  }

  /// Controls the scaling behavior of the circle when the map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-pitch-scale"><code>circle-pitch-scale</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCircleScaleAlignment` values
  /// Any of the following constant string values:
  /// `map`: Circles are scaled according to their apparent distance to the
  /// camera.
  /// `viewport`: Circles are not scaled.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get circleScaleAlignment {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleScaleAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the scaling behavior of the circle when the map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-pitch-scale"><code>circle-pitch-scale</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCircleScaleAlignment` values
  /// Any of the following constant string values:
  /// `map`: Circles are scaled according to their apparent distance to the
  /// camera.
  /// `viewport`: Circles are not scaled.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set circleScaleAlignment(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleScaleAlignment_, value.ref.pointer);
  }

  /// circlePitchScale
  NSExpression get circlePitchScale {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_circlePitchScale);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCirclePitchScale:
  set circlePitchScale(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCirclePitchScale_, value.ref.pointer);
  }

  /// The stroke color of the circle.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleStrokeColor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleStrokeColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The stroke color of the circle.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleStrokeColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleStrokeColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeColor` property.
  ///
  /// This property corresponds to the `circle-stroke-color-transition` property in the style JSON file format.
  MLNTransition get circleStrokeColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleStrokeColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleStrokeColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeColor` property.
  ///
  /// This property corresponds to the `circle-stroke-color-transition` property in the style JSON file format.
  set circleStrokeColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleStrokeColorTransition_, value);
  }

  /// The opacity of the circle's stroke.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleStrokeOpacity {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleStrokeOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity of the circle's stroke.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleStrokeOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleStrokeOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeOpacity` property.
  ///
  /// This property corresponds to the `circle-stroke-opacity-transition` property in the style JSON file format.
  MLNTransition get circleStrokeOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleStrokeOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleStrokeOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeOpacity` property.
  ///
  /// This property corresponds to the `circle-stroke-opacity-transition` property in the style JSON file format.
  set circleStrokeOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleStrokeOpacityTransition_, value);
  }

  /// The width of the circle's stroke. Strokes are placed outside of the
  /// `circleRadius`.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleStrokeWidth {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleStrokeWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The width of the circle's stroke. Strokes are placed outside of the
  /// `circleRadius`.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleStrokeWidth(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleStrokeWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeWidth` property.
  ///
  /// This property corresponds to the `circle-stroke-width-transition` property in the style JSON file format.
  MLNTransition get circleStrokeWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleStrokeWidthTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleStrokeWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeWidth` property.
  ///
  /// This property corresponds to the `circle-stroke-width-transition` property in the style JSON file format.
  set circleStrokeWidthTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleStrokeWidthTransition_, value);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate"><code>circle-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get circleTranslation {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate"><code>circle-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set circleTranslation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleTranslation` property.
  ///
  /// This property corresponds to the `circle-translate-transition` property in the style JSON file format.
  MLNTransition get circleTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleTranslation` property.
  ///
  /// This property corresponds to the `circle-translate-transition` property in the style JSON file format.
  set circleTranslationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleTranslationTransition_, value);
  }

  /// circleTranslate
  NSExpression get circleTranslate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCircleTranslate:
  set circleTranslate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `circleTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `circleTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate-anchor"><code>circle-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCircleTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The circle is translated relative to the map.
  /// `viewport`: The circle is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get circleTranslationAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `circleTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `circleTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate-anchor"><code>circle-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCircleTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The circle is translated relative to the map.
  /// `viewport`: The circle is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set circleTranslationAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleTranslationAnchor_, value.ref.pointer);
  }

  /// circleTranslateAnchor
  NSExpression get circleTranslateAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_circleTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCircleTranslateAnchor:
  set circleTranslateAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setCircleTranslateAnchor_, value.ref.pointer);
  }

  /// init
  MLNCircleStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNCircleStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNCircleStyleLayer, _sel_new);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNCircleStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNCircleStyleLayer, _sel_allocWithZone_, zone);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNCircleStyleLayer alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNCircleStyleLayer, _sel_alloc);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNCircleStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNCircleStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNCircleStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNFillExtrusionStyleLayer =
    objc.getClass("MLNFillExtrusionStyleLayer");
late final _sel_fillExtrusionBase = objc.registerName("fillExtrusionBase");
late final _sel_setFillExtrusionBase_ =
    objc.registerName("setFillExtrusionBase:");
late final _sel_fillExtrusionBaseTransition =
    objc.registerName("fillExtrusionBaseTransition");
late final _sel_setFillExtrusionBaseTransition_ =
    objc.registerName("setFillExtrusionBaseTransition:");
late final _sel_fillExtrusionColor = objc.registerName("fillExtrusionColor");
late final _sel_setFillExtrusionColor_ =
    objc.registerName("setFillExtrusionColor:");
late final _sel_fillExtrusionColorTransition =
    objc.registerName("fillExtrusionColorTransition");
late final _sel_setFillExtrusionColorTransition_ =
    objc.registerName("setFillExtrusionColorTransition:");
late final _sel_fillExtrusionHasVerticalGradient =
    objc.registerName("fillExtrusionHasVerticalGradient");
late final _sel_setFillExtrusionHasVerticalGradient_ =
    objc.registerName("setFillExtrusionHasVerticalGradient:");
late final _sel_fillExtrusionVerticalGradient =
    objc.registerName("fillExtrusionVerticalGradient");
late final _sel_setFillExtrusionVerticalGradient_ =
    objc.registerName("setFillExtrusionVerticalGradient:");
late final _sel_fillExtrusionHeight = objc.registerName("fillExtrusionHeight");
late final _sel_setFillExtrusionHeight_ =
    objc.registerName("setFillExtrusionHeight:");
late final _sel_fillExtrusionHeightTransition =
    objc.registerName("fillExtrusionHeightTransition");
late final _sel_setFillExtrusionHeightTransition_ =
    objc.registerName("setFillExtrusionHeightTransition:");
late final _sel_fillExtrusionOpacity =
    objc.registerName("fillExtrusionOpacity");
late final _sel_setFillExtrusionOpacity_ =
    objc.registerName("setFillExtrusionOpacity:");
late final _sel_fillExtrusionOpacityTransition =
    objc.registerName("fillExtrusionOpacityTransition");
late final _sel_setFillExtrusionOpacityTransition_ =
    objc.registerName("setFillExtrusionOpacityTransition:");
late final _sel_fillExtrusionPattern =
    objc.registerName("fillExtrusionPattern");
late final _sel_setFillExtrusionPattern_ =
    objc.registerName("setFillExtrusionPattern:");
late final _sel_fillExtrusionPatternTransition =
    objc.registerName("fillExtrusionPatternTransition");
late final _sel_setFillExtrusionPatternTransition_ =
    objc.registerName("setFillExtrusionPatternTransition:");
late final _sel_fillExtrusionTranslation =
    objc.registerName("fillExtrusionTranslation");
late final _sel_setFillExtrusionTranslation_ =
    objc.registerName("setFillExtrusionTranslation:");
late final _sel_fillExtrusionTranslationTransition =
    objc.registerName("fillExtrusionTranslationTransition");
late final _sel_setFillExtrusionTranslationTransition_ =
    objc.registerName("setFillExtrusionTranslationTransition:");
late final _sel_fillExtrusionTranslate =
    objc.registerName("fillExtrusionTranslate");
late final _sel_setFillExtrusionTranslate_ =
    objc.registerName("setFillExtrusionTranslate:");
late final _sel_fillExtrusionTranslationAnchor =
    objc.registerName("fillExtrusionTranslationAnchor");
late final _sel_setFillExtrusionTranslationAnchor_ =
    objc.registerName("setFillExtrusionTranslationAnchor:");
late final _sel_fillExtrusionTranslateAnchor =
    objc.registerName("fillExtrusionTranslateAnchor");
late final _sel_setFillExtrusionTranslateAnchor_ =
    objc.registerName("setFillExtrusionTranslateAnchor:");

/// An ``MLNFillExtrusionStyleLayer`` is a style layer that renders one or more 3D
/// extruded polygons on the map.
///
/// Use a fill-extrusion style layer to configure the visual appearance of polygon
/// or multipolygon features. These features can come from vector tiles loaded by
/// an ``MLNFillExtrusionStyleLayer`` object, or they can be
/// ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``,
/// ``MLNFillExtrusionStyleLayer``, or ``MLNFillExtrusionStyleLayer`` instances in
/// an ``MLNFillExtrusionStyleLayer`` or ``MLNFillExtrusionStyleLayer`` object.
///
/// You can access an existing fill-extrusion style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new fill-extrusion style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a href="https://docs.mapbox.com/ios/maps/examples/extrusions/">Display
/// 3D buildings</a> example to learn how to add and style 3D layers on a map.
///
/// ### Example
///
/// ```swift
/// ```
class MLNFillExtrusionStyleLayer extends MLNVectorStyleLayer {
  MLNFillExtrusionStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNFillExtrusionStyleLayer] that points to the same underlying object as [other].
  MLNFillExtrusionStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNFillExtrusionStyleLayer] that wraps the given raw object pointer.
  MLNFillExtrusionStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNFillExtrusionStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(obj.ref.pointer, _sel_isKindOfClass_,
        _class_MLNFillExtrusionStyleLayer);
  }

  /// Returns a fill-extrusion style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNFillExtrusionStyleLayer initWithIdentifier_source_(
      objc.NSString identifier, MLNSource source) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The height with which to extrude the base of this layer. Must be less than or
  /// equal to `fillExtrusionHeight`.
  ///
  /// This property is measured in meters.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillExtrusionHeight` is
  /// non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillExtrusionBase {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillExtrusionBase);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The height with which to extrude the base of this layer. Must be less than or
  /// equal to `fillExtrusionHeight`.
  ///
  /// This property is measured in meters.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillExtrusionHeight` is
  /// non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillExtrusionBase(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillExtrusionBase_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionBase` property.
  ///
  /// This property corresponds to the `fill-extrusion-base-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionBaseTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionBaseTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionBaseTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionBase` property.
  ///
  /// This property corresponds to the `fill-extrusion-base-transition` property in the style JSON file format.
  set fillExtrusionBaseTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionBaseTransition_, value);
  }

  /// The base color of this layer. The extrusion's surfaces will be shaded
  /// differently based on this color in combination with the `light` settings. If
  /// this color is specified with an alpha component, the alpha component will be
  /// ignored; use `fillExtrusionOpacity` to set layer opacityco.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `fillExtrusionPattern` is set to
  /// `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillExtrusionColor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillExtrusionColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The base color of this layer. The extrusion's surfaces will be shaded
  /// differently based on this color in combination with the `light` settings. If
  /// this color is specified with an alpha component, the alpha component will be
  /// ignored; use `fillExtrusionOpacity` to set layer opacityco.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `fillExtrusionPattern` is set to
  /// `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillExtrusionColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillExtrusionColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionColor` property.
  ///
  /// This property corresponds to the `fill-extrusion-color-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionColor` property.
  ///
  /// This property corresponds to the `fill-extrusion-color-transition` property in the style JSON file format.
  set fillExtrusionColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionColorTransition_, value);
  }

  /// Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If
  /// true, sides will be shaded slightly darker farther down.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-vertical-gradient"><code>fill-extrusion-vertical-gradient</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get fillExtrusionHasVerticalGradient {
    final _ret = _objc_msgSend_1x359cv(
        this.ref.pointer, _sel_fillExtrusionHasVerticalGradient);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If
  /// true, sides will be shaded slightly darker farther down.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-vertical-gradient"><code>fill-extrusion-vertical-gradient</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set fillExtrusionHasVerticalGradient(NSExpression value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer,
        _sel_setFillExtrusionHasVerticalGradient_, value.ref.pointer);
  }

  /// fillExtrusionVerticalGradient
  NSExpression get fillExtrusionVerticalGradient {
    final _ret = _objc_msgSend_1x359cv(
        this.ref.pointer, _sel_fillExtrusionVerticalGradient);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillExtrusionVerticalGradient:
  set fillExtrusionVerticalGradient(NSExpression value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer,
        _sel_setFillExtrusionVerticalGradient_, value.ref.pointer);
  }

  /// The height with which to extrude this layer.
  ///
  /// This property is measured in meters.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillExtrusionHeight {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillExtrusionHeight);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The height with which to extrude this layer.
  ///
  /// This property is measured in meters.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillExtrusionHeight(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillExtrusionHeight_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionHeight` property.
  ///
  /// This property corresponds to the `fill-extrusion-height-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionHeightTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionHeightTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionHeightTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionHeight` property.
  ///
  /// This property corresponds to the `fill-extrusion-height-transition` property in the style JSON file format.
  set fillExtrusionHeightTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionHeightTransition_, value);
  }

  /// The opacity of the entire fill extrusion layer. This is rendered on a
  /// per-layer, not per-feature, basis, and data-driven styling is not available.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get fillExtrusionOpacity {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillExtrusionOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity of the entire fill extrusion layer. This is rendered on a
  /// per-layer, not per-feature, basis, and data-driven styling is not available.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set fillExtrusionOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillExtrusionOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionOpacity` property.
  ///
  /// This property corresponds to the `fill-extrusion-opacity-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionOpacity` property.
  ///
  /// This property corresponds to the `fill-extrusion-opacity-transition` property in the style JSON file format.
  set fillExtrusionOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionOpacityTransition_, value);
  }

  /// Name of image in style images to use for drawing image fill-extrusions. For
  /// seamless patterns, image width and height must be a factor of two (2, 4, 8,
  /// ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillExtrusionPattern {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillExtrusionPattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of image in style images to use for drawing image fill-extrusions. For
  /// seamless patterns, image width and height must be a factor of two (2, 4, 8,
  /// ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillExtrusionPattern(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillExtrusionPattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionPattern` property.
  ///
  /// This property corresponds to the `fill-extrusion-pattern-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionPatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionPatternTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionPatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionPattern` property.
  ///
  /// This property corresponds to the `fill-extrusion-pattern-transition` property in the style JSON file format.
  set fillExtrusionPatternTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionPatternTransition_, value);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate"><code>fill-extrusion-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get fillExtrusionTranslation {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillExtrusionTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate"><code>fill-extrusion-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set fillExtrusionTranslation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillExtrusionTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionTranslation` property.
  ///
  /// This property corresponds to the `fill-extrusion-translate-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionTranslation` property.
  ///
  /// This property corresponds to the `fill-extrusion-translate-transition` property in the style JSON file format.
  set fillExtrusionTranslationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionTranslationTransition_, value);
  }

  /// fillExtrusionTranslate
  NSExpression get fillExtrusionTranslate {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillExtrusionTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillExtrusionTranslate:
  set fillExtrusionTranslate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillExtrusionTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `fillExtrusionTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillExtrusionTranslation` is
  /// non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate-anchor"><code>fill-extrusion-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNFillExtrusionTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The fill extrusion is translated relative to the map.
  /// `viewport`: The fill extrusion is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get fillExtrusionTranslationAnchor {
    final _ret = _objc_msgSend_1x359cv(
        this.ref.pointer, _sel_fillExtrusionTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `fillExtrusionTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillExtrusionTranslation` is
  /// non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate-anchor"><code>fill-extrusion-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNFillExtrusionTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The fill extrusion is translated relative to the map.
  /// `viewport`: The fill extrusion is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set fillExtrusionTranslationAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer,
        _sel_setFillExtrusionTranslationAnchor_, value.ref.pointer);
  }

  /// fillExtrusionTranslateAnchor
  NSExpression get fillExtrusionTranslateAnchor {
    final _ret = _objc_msgSend_1x359cv(
        this.ref.pointer, _sel_fillExtrusionTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillExtrusionTranslateAnchor:
  set fillExtrusionTranslateAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer,
        _sel_setFillExtrusionTranslateAnchor_, value.ref.pointer);
  }

  /// init
  MLNFillExtrusionStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNFillExtrusionStyleLayer new1() {
    final _ret =
        _objc_msgSend_1x359cv(_class_MLNFillExtrusionStyleLayer, _sel_new);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNFillExtrusionStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNFillExtrusionStyleLayer, _sel_allocWithZone_, zone);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNFillExtrusionStyleLayer alloc() {
    final _ret =
        _objc_msgSend_1x359cv(_class_MLNFillExtrusionStyleLayer, _sel_alloc);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNFillExtrusionStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNFillExtrusionStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNFillExtrusionStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNFillStyleLayer = objc.getClass("MLNFillStyleLayer");
late final _sel_fillSortKey = objc.registerName("fillSortKey");
late final _sel_setFillSortKey_ = objc.registerName("setFillSortKey:");
late final _sel_isFillAntialiased = objc.registerName("isFillAntialiased");
late final _sel_setFillAntialiased_ = objc.registerName("setFillAntialiased:");
late final _sel_fillAntialias = objc.registerName("fillAntialias");
late final _sel_setFillAntialias_ = objc.registerName("setFillAntialias:");
late final _sel_fillColor = objc.registerName("fillColor");
late final _sel_setFillColor_ = objc.registerName("setFillColor:");
late final _sel_fillColorTransition = objc.registerName("fillColorTransition");
late final _sel_setFillColorTransition_ =
    objc.registerName("setFillColorTransition:");
late final _sel_fillOpacity = objc.registerName("fillOpacity");
late final _sel_setFillOpacity_ = objc.registerName("setFillOpacity:");
late final _sel_fillOpacityTransition =
    objc.registerName("fillOpacityTransition");
late final _sel_setFillOpacityTransition_ =
    objc.registerName("setFillOpacityTransition:");
late final _sel_fillOutlineColor = objc.registerName("fillOutlineColor");
late final _sel_setFillOutlineColor_ =
    objc.registerName("setFillOutlineColor:");
late final _sel_fillOutlineColorTransition =
    objc.registerName("fillOutlineColorTransition");
late final _sel_setFillOutlineColorTransition_ =
    objc.registerName("setFillOutlineColorTransition:");
late final _sel_fillPattern = objc.registerName("fillPattern");
late final _sel_setFillPattern_ = objc.registerName("setFillPattern:");
late final _sel_fillPatternTransition =
    objc.registerName("fillPatternTransition");
late final _sel_setFillPatternTransition_ =
    objc.registerName("setFillPatternTransition:");
late final _sel_fillTranslation = objc.registerName("fillTranslation");
late final _sel_setFillTranslation_ = objc.registerName("setFillTranslation:");
late final _sel_fillTranslationTransition =
    objc.registerName("fillTranslationTransition");
late final _sel_setFillTranslationTransition_ =
    objc.registerName("setFillTranslationTransition:");
late final _sel_fillTranslate = objc.registerName("fillTranslate");
late final _sel_setFillTranslate_ = objc.registerName("setFillTranslate:");
late final _sel_fillTranslationAnchor =
    objc.registerName("fillTranslationAnchor");
late final _sel_setFillTranslationAnchor_ =
    objc.registerName("setFillTranslationAnchor:");
late final _sel_fillTranslateAnchor = objc.registerName("fillTranslateAnchor");
late final _sel_setFillTranslateAnchor_ =
    objc.registerName("setFillTranslateAnchor:");

/// An ``MLNFillStyleLayer`` is a style layer that renders one or more filled (and
/// optionally stroked) polygons on the map.
///
/// Use a fill style layer to configure the visual appearance of polygon or
/// multipolygon features. These features can come from vector tiles loaded by an
/// ``MLNFillStyleLayer`` object, or they can be ``MLNFillStyleLayer``,
/// ``MLNFillStyleLayer``, ``MLNFillStyleLayer``, or ``MLNFillStyleLayer``
/// instances in an ``MLNFillStyleLayer`` or ``MLNFillStyleLayer`` object.
///
/// You can access an existing fill style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new fill style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/select-layer/">Select a feature
/// within a layer</a> example to learn how to use a `TERNARY` expression to modify
/// the `fillOpacity` of an ``MLNFillStyleLayer`` object. See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/fill-pattern/">Add a pattern to
/// a polygon</a> example to learn how to use an image to add pattern to the
/// features styled by a ``MLNFillStyleLayer``.
///
/// ### Example
///
/// ```swift
/// ```
class MLNFillStyleLayer extends MLNVectorStyleLayer {
  MLNFillStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNFillStyleLayer] that points to the same underlying object as [other].
  MLNFillStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNFillStyleLayer] that wraps the given raw object pointer.
  MLNFillStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNFillStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNFillStyleLayer);
  }

  /// Returns a fill style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNFillStyleLayer initWithIdentifier_source_(
      objc.NSString identifier, MLNSource source) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillSortKey {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillSortKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillSortKey(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillSortKey_, value.ref.pointer);
  }

  /// Whether or not the fill should be antialiased.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-antialias"><code>fill-antialias</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get fillAntialiased {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_isFillAntialiased);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Whether or not the fill should be antialiased.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-antialias"><code>fill-antialias</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set fillAntialiased(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillAntialiased_, value.ref.pointer);
  }

  /// fillAntialias
  NSExpression get fillAntialias {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillAntialias);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillAntialias:
  set fillAntialias(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillAntialias_, value.ref.pointer);
  }

  /// The color of the filled part of this layer.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `fillPattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color of the filled part of this layer.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `fillPattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillColor` property.
  ///
  /// This property corresponds to the `fill-color-transition` property in the style JSON file format.
  MLNTransition get fillColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_fillColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillColor` property.
  ///
  /// This property corresponds to the `fill-color-transition` property in the style JSON file format.
  set fillColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillColorTransition_, value);
  }

  /// The opacity of the entire fill layer. In contrast to the `fillColor`, this
  /// value will also affect the 1pt stroke around the fill, if the stroke is used.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillOpacity {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity of the entire fill layer. In contrast to the `fillColor`, this
  /// value will also affect the 1pt stroke around the fill, if the stroke is used.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillOpacity` property.
  ///
  /// This property corresponds to the `fill-opacity-transition` property in the style JSON file format.
  MLNTransition get fillOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillOpacityTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_fillOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillOpacity` property.
  ///
  /// This property corresponds to the `fill-opacity-transition` property in the style JSON file format.
  set fillOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillOpacityTransition_, value);
  }

  /// The outline color of the fill. Matches the value of `fillColor` if unspecified.
  ///
  /// This property is only applied to the style if `fillPattern` is set to `nil`,
  /// and `fillAntialiased` is set to an expression that evaluates to `YES`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillOutlineColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillOutlineColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The outline color of the fill. Matches the value of `fillColor` if unspecified.
  ///
  /// This property is only applied to the style if `fillPattern` is set to `nil`,
  /// and `fillAntialiased` is set to an expression that evaluates to `YES`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillOutlineColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillOutlineColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillOutlineColor` property.
  ///
  /// This property corresponds to the `fill-outline-color-transition` property in the style JSON file format.
  MLNTransition get fillOutlineColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillOutlineColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillOutlineColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillOutlineColor` property.
  ///
  /// This property corresponds to the `fill-outline-color-transition` property in the style JSON file format.
  set fillOutlineColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillOutlineColorTransition_, value);
  }

  /// Name of image in sprite to use for drawing image fills. For seamless patterns,
  /// image width and height must be a factor of two (2, 4, 8, ..., 512). Note that
  /// zoom-dependent expressions will be evaluated only at integer zoom levels.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillPattern {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillPattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of image in sprite to use for drawing image fills. For seamless patterns,
  /// image width and height must be a factor of two (2, 4, 8, ..., 512). Note that
  /// zoom-dependent expressions will be evaluated only at integer zoom levels.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillPattern(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillPattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillPattern` property.
  ///
  /// This property corresponds to the `fill-pattern-transition` property in the style JSON file format.
  MLNTransition get fillPatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillPatternTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_fillPatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillPattern` property.
  ///
  /// This property corresponds to the `fill-pattern-transition` property in the style JSON file format.
  set fillPatternTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillPatternTransition_, value);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate"><code>fill-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get fillTranslation {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate"><code>fill-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set fillTranslation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillTranslation` property.
  ///
  /// This property corresponds to the `fill-translate-transition` property in the style JSON file format.
  MLNTransition get fillTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillTranslation` property.
  ///
  /// This property corresponds to the `fill-translate-transition` property in the style JSON file format.
  set fillTranslationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillTranslationTransition_, value);
  }

  /// fillTranslate
  NSExpression get fillTranslate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillTranslate:
  set fillTranslate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `fillTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate-anchor"><code>fill-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNFillTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The fill is translated relative to the map.
  /// `viewport`: The fill is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get fillTranslationAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `fillTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate-anchor"><code>fill-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNFillTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The fill is translated relative to the map.
  /// `viewport`: The fill is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set fillTranslationAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillTranslationAnchor_, value.ref.pointer);
  }

  /// fillTranslateAnchor
  NSExpression get fillTranslateAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_fillTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillTranslateAnchor:
  set fillTranslateAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setFillTranslateAnchor_, value.ref.pointer);
  }

  /// init
  MLNFillStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNFillStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNFillStyleLayer, _sel_new);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNFillStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNFillStyleLayer, _sel_allocWithZone_, zone);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNFillStyleLayer alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNFillStyleLayer, _sel_alloc);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNFillStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNFillStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNFillStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNFillStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNFillStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNFillStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_MLNHeatmapStyleLayer = objc.getClass("MLNHeatmapStyleLayer");
late final _sel_heatmapColor = objc.registerName("heatmapColor");
late final _sel_setHeatmapColor_ = objc.registerName("setHeatmapColor:");
late final _sel_heatmapIntensity = objc.registerName("heatmapIntensity");
late final _sel_setHeatmapIntensity_ =
    objc.registerName("setHeatmapIntensity:");
late final _sel_heatmapIntensityTransition =
    objc.registerName("heatmapIntensityTransition");
late final _sel_setHeatmapIntensityTransition_ =
    objc.registerName("setHeatmapIntensityTransition:");
late final _sel_heatmapOpacity = objc.registerName("heatmapOpacity");
late final _sel_setHeatmapOpacity_ = objc.registerName("setHeatmapOpacity:");
late final _sel_heatmapOpacityTransition =
    objc.registerName("heatmapOpacityTransition");
late final _sel_setHeatmapOpacityTransition_ =
    objc.registerName("setHeatmapOpacityTransition:");
late final _sel_heatmapRadius = objc.registerName("heatmapRadius");
late final _sel_setHeatmapRadius_ = objc.registerName("setHeatmapRadius:");
late final _sel_heatmapRadiusTransition =
    objc.registerName("heatmapRadiusTransition");
late final _sel_setHeatmapRadiusTransition_ =
    objc.registerName("setHeatmapRadiusTransition:");
late final _sel_heatmapWeight = objc.registerName("heatmapWeight");
late final _sel_setHeatmapWeight_ = objc.registerName("setHeatmapWeight:");

/// An ``MLNHeatmapStyleLayer`` is a style layer that renders a <a
/// href="https://en.wikipedia.org/wiki/Heat_map">heatmap</a>.
///
/// A heatmap visualizes the spatial distribution of a large, dense set of point
/// data, using color to avoid cluttering the map with individual points at low
/// zoom levels. The points are weighted by an attribute you specify. Use a heatmap
/// style layer in conjunction with point or point collection features. These
/// features can come from vector tiles loaded by an ``MLNHeatmapStyleLayer``
/// object, or they can be ``MLNHeatmapStyleLayer``, ``MLNHeatmapStyleLayer``,
/// ``MLNHeatmapStyleLayer``, or ``MLNHeatmapStyleLayer`` instances in an
/// ``MLNHeatmapStyleLayer`` or ``MLNHeatmapStyleLayer`` object.
///
/// Consider accompanying a heatmap style layer with an ``MLNHeatmapStyleLayer`` or
/// ``MLNHeatmapStyleLayer`` at high zoom levels. If you are unsure whether the
/// point data in an ``MLNHeatmapStyleLayer`` is dense enough to warrant a heatmap,
/// you can alternatively cluster the source using the ``MLNHeatmapStyleLayer``
/// option and render the data using an ``MLNHeatmapStyleLayer`` or
/// ``MLNHeatmapStyleLayer``.
///
/// You can access an existing heatmap style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new heatmap style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/heatmap-example/">Create a
/// heatmap layer</a> example to learn how to add this style layer to your map.
///
/// ### Example
///
/// ```swift
/// ```
class MLNHeatmapStyleLayer extends MLNVectorStyleLayer {
  MLNHeatmapStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNHeatmapStyleLayer] that points to the same underlying object as [other].
  MLNHeatmapStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNHeatmapStyleLayer] that wraps the given raw object pointer.
  MLNHeatmapStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNHeatmapStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNHeatmapStyleLayer);
  }

  /// Returns a heatmap style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNHeatmapStyleLayer initWithIdentifier_source_(
      objc.NSString identifier, MLNSource source) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The color of each screen point based on its density value in a heatmap. This
  /// property is normally set to an interpolation or step expression with the
  /// `$heatmapDensity` value as its input.
  ///
  /// The default value of this property is an expression that evaluates to a rainbow
  /// color scale from blue to red. Set this property to `nil` to reset it to the
  /// default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$heatmapDensity` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get heatmapColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_heatmapColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color of each screen point based on its density value in a heatmap. This
  /// property is normally set to an interpolation or step expression with the
  /// `$heatmapDensity` value as its input.
  ///
  /// The default value of this property is an expression that evaluates to a rainbow
  /// color scale from blue to red. Set this property to `nil` to reset it to the
  /// default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$heatmapDensity` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set heatmapColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHeatmapColor_, value.ref.pointer);
  }

  /// Similar to `heatmapWeight` but controls the intensity of the heatmap globally.
  /// Primarily used for adjusting the heatmap based on zoom level.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get heatmapIntensity {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_heatmapIntensity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Similar to `heatmapWeight` but controls the intensity of the heatmap globally.
  /// Primarily used for adjusting the heatmap based on zoom level.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set heatmapIntensity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHeatmapIntensity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `heatmapIntensity` property.
  ///
  /// This property corresponds to the `heatmap-intensity-transition` property in the style JSON file format.
  MLNTransition get heatmapIntensityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_heatmapIntensityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_heatmapIntensityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `heatmapIntensity` property.
  ///
  /// This property corresponds to the `heatmap-intensity-transition` property in the style JSON file format.
  set heatmapIntensityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHeatmapIntensityTransition_, value);
  }

  /// The global opacity at which the heatmap layer will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get heatmapOpacity {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_heatmapOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The global opacity at which the heatmap layer will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set heatmapOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHeatmapOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `heatmapOpacity` property.
  ///
  /// This property corresponds to the `heatmap-opacity-transition` property in the style JSON file format.
  MLNTransition get heatmapOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_heatmapOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_heatmapOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `heatmapOpacity` property.
  ///
  /// This property corresponds to the `heatmap-opacity-transition` property in the style JSON file format.
  set heatmapOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHeatmapOpacityTransition_, value);
  }

  /// Radius of influence of one heatmap point in points. Increasing the value makes
  /// the heatmap smoother, but less detailed.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `30`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 1
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get heatmapRadius {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_heatmapRadius);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Radius of influence of one heatmap point in points. Increasing the value makes
  /// the heatmap smoother, but less detailed.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `30`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 1
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set heatmapRadius(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHeatmapRadius_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `heatmapRadius` property.
  ///
  /// This property corresponds to the `heatmap-radius-transition` property in the style JSON file format.
  MLNTransition get heatmapRadiusTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_heatmapRadiusTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_heatmapRadiusTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `heatmapRadius` property.
  ///
  /// This property corresponds to the `heatmap-radius-transition` property in the style JSON file format.
  set heatmapRadiusTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHeatmapRadiusTransition_, value);
  }

  /// A measure of how much an individual point contributes to the heatmap. A value
  /// of 10 would be equivalent to having 10 points of weight 1 in the same spot.
  /// Especially useful when combined with clustering.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get heatmapWeight {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_heatmapWeight);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// A measure of how much an individual point contributes to the heatmap. A value
  /// of 10 would be equivalent to having 10 points of weight 1 in the same spot.
  /// Especially useful when combined with clustering.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set heatmapWeight(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHeatmapWeight_, value.ref.pointer);
  }

  /// init
  MLNHeatmapStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNHeatmapStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNHeatmapStyleLayer, _sel_new);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNHeatmapStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNHeatmapStyleLayer, _sel_allocWithZone_, zone);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNHeatmapStyleLayer alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNHeatmapStyleLayer, _sel_alloc);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNHeatmapStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNHeatmapStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNHeatmapStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNHillshadeStyleLayer =
    objc.getClass("MLNHillshadeStyleLayer");
late final _sel_hillshadeAccentColor =
    objc.registerName("hillshadeAccentColor");
late final _sel_setHillshadeAccentColor_ =
    objc.registerName("setHillshadeAccentColor:");
late final _sel_hillshadeAccentColorTransition =
    objc.registerName("hillshadeAccentColorTransition");
late final _sel_setHillshadeAccentColorTransition_ =
    objc.registerName("setHillshadeAccentColorTransition:");
late final _sel_hillshadeExaggeration =
    objc.registerName("hillshadeExaggeration");
late final _sel_setHillshadeExaggeration_ =
    objc.registerName("setHillshadeExaggeration:");
late final _sel_hillshadeExaggerationTransition =
    objc.registerName("hillshadeExaggerationTransition");
late final _sel_setHillshadeExaggerationTransition_ =
    objc.registerName("setHillshadeExaggerationTransition:");
late final _sel_hillshadeHighlightColor =
    objc.registerName("hillshadeHighlightColor");
late final _sel_setHillshadeHighlightColor_ =
    objc.registerName("setHillshadeHighlightColor:");
late final _sel_hillshadeHighlightColorTransition =
    objc.registerName("hillshadeHighlightColorTransition");
late final _sel_setHillshadeHighlightColorTransition_ =
    objc.registerName("setHillshadeHighlightColorTransition:");
late final _sel_hillshadeIlluminationAnchor =
    objc.registerName("hillshadeIlluminationAnchor");
late final _sel_setHillshadeIlluminationAnchor_ =
    objc.registerName("setHillshadeIlluminationAnchor:");
late final _sel_hillshadeIlluminationDirection =
    objc.registerName("hillshadeIlluminationDirection");
late final _sel_setHillshadeIlluminationDirection_ =
    objc.registerName("setHillshadeIlluminationDirection:");
late final _sel_hillshadeShadowColor =
    objc.registerName("hillshadeShadowColor");
late final _sel_setHillshadeShadowColor_ =
    objc.registerName("setHillshadeShadowColor:");
late final _sel_hillshadeShadowColorTransition =
    objc.registerName("hillshadeShadowColorTransition");
late final _sel_setHillshadeShadowColorTransition_ =
    objc.registerName("setHillshadeShadowColorTransition:");

/// An ``MLNHillshadeStyleLayer`` is a style layer that renders raster <a
/// href="https://en.wikipedia.org/wiki/Digital_elevation_model">digital elevation
/// model</a> (DEM) tiles on the map.
///
/// Use a hillshade style layer to configure the color parameters of raster tiles
/// loaded by an ``MLNHillshadeStyleLayer`` object. For example, you could use a
/// hillshade style layer to render <a
/// href="https://docs.mapbox.com/help/troubleshooting/access-elevation-data/#mapbox-terrain-rgb">Mapbox
/// Terrain-RGB</a> data.
///
/// To display posterized hillshading based on vector shapes, as with the <a
/// href="https://www.mapbox.com/vector-tiles/mapbox-terrain/">Mapbox Terrain</a>
/// source, use an ``MLNHillshadeStyleLayer`` object in conjunction with several
/// ``MLNHillshadeStyleLayer`` objects.
///
/// You can access an existing hillshade style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new hillshade style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// ### Example
///
/// ```swift
/// ```
class MLNHillshadeStyleLayer extends MLNForegroundStyleLayer {
  MLNHillshadeStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNHillshadeStyleLayer] that points to the same underlying object as [other].
  MLNHillshadeStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNHillshadeStyleLayer] that wraps the given raw object pointer.
  MLNHillshadeStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNHillshadeStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNHillshadeStyleLayer);
  }

  /// Returns a hillshade style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNHillshadeStyleLayer initWithIdentifier_source_(
      objc.NSString identifier, MLNSource source) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The shading color used to accentuate rugged terrain like sharp cliffs and
  /// gorges.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeAccentColor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_hillshadeAccentColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The shading color used to accentuate rugged terrain like sharp cliffs and
  /// gorges.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeAccentColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHillshadeAccentColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `hillshadeAccentColor` property.
  ///
  /// This property corresponds to the `hillshade-accent-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeAccentColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_hillshadeAccentColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_hillshadeAccentColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `hillshadeAccentColor` property.
  ///
  /// This property corresponds to the `hillshade-accent-color-transition` property in the style JSON file format.
  set hillshadeAccentColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHillshadeAccentColorTransition_, value);
  }

  /// Intensity of the hillshade
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0.5`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeExaggeration {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_hillshadeExaggeration);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Intensity of the hillshade
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0.5`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeExaggeration(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHillshadeExaggeration_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `hillshadeExaggeration` property.
  ///
  /// This property corresponds to the `hillshade-exaggeration-transition` property in the style JSON file format.
  MLNTransition get hillshadeExaggerationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_hillshadeExaggerationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_hillshadeExaggerationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `hillshadeExaggeration` property.
  ///
  /// This property corresponds to the `hillshade-exaggeration-transition` property in the style JSON file format.
  set hillshadeExaggerationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHillshadeExaggerationTransition_, value);
  }

  /// The shading color of areas that faces towards the light source.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.whiteColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeHighlightColor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_hillshadeHighlightColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The shading color of areas that faces towards the light source.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.whiteColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeHighlightColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHillshadeHighlightColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `hillshadeHighlightColor` property.
  ///
  /// This property corresponds to the `hillshade-highlight-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeHighlightColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_hillshadeHighlightColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_hillshadeHighlightColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `hillshadeHighlightColor` property.
  ///
  /// This property corresponds to the `hillshade-highlight-color-transition` property in the style JSON file format.
  set hillshadeHighlightColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHillshadeHighlightColorTransition_, value);
  }

  /// Direction of light source when map is rotated.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `viewport`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNHillshadeIlluminationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The hillshade illumination is relative to the north direction.
  /// `viewport`: The hillshade illumination is relative to the top of the
  /// viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get hillshadeIlluminationAnchor {
    final _ret = _objc_msgSend_1x359cv(
        this.ref.pointer, _sel_hillshadeIlluminationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Direction of light source when map is rotated.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `viewport`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNHillshadeIlluminationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The hillshade illumination is relative to the north direction.
  /// `viewport`: The hillshade illumination is relative to the top of the
  /// viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set hillshadeIlluminationAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer,
        _sel_setHillshadeIlluminationAnchor_, value.ref.pointer);
  }

  /// The direction of the light source used to generate the hillshading with 0 as
  /// the top of the viewport if `hillshadeIlluminationAnchor` is set to
  /// `MLNHillshadeIlluminationAnchorViewport` and due north if
  /// `hillshadeIlluminationAnchor` is set to `MLNHillshadeIlluminationAnchorMap`.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `335`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 359 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeIlluminationDirection {
    final _ret = _objc_msgSend_1x359cv(
        this.ref.pointer, _sel_hillshadeIlluminationDirection);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The direction of the light source used to generate the hillshading with 0 as
  /// the top of the viewport if `hillshadeIlluminationAnchor` is set to
  /// `MLNHillshadeIlluminationAnchorViewport` and due north if
  /// `hillshadeIlluminationAnchor` is set to `MLNHillshadeIlluminationAnchorMap`.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `335`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 359 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeIlluminationDirection(NSExpression value) {
    return _objc_msgSend_1jdvcbf(this.ref.pointer,
        _sel_setHillshadeIlluminationDirection_, value.ref.pointer);
  }

  /// The shading color of areas that face away from the light source.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeShadowColor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_hillshadeShadowColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The shading color of areas that face away from the light source.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeShadowColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setHillshadeShadowColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `hillshadeShadowColor` property.
  ///
  /// This property corresponds to the `hillshade-shadow-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeShadowColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_hillshadeShadowColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_hillshadeShadowColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `hillshadeShadowColor` property.
  ///
  /// This property corresponds to the `hillshade-shadow-color-transition` property in the style JSON file format.
  set hillshadeShadowColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHillshadeShadowColorTransition_, value);
  }

  /// init
  MLNHillshadeStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNHillshadeStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNHillshadeStyleLayer, _sel_new);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNHillshadeStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNHillshadeStyleLayer, _sel_allocWithZone_, zone);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNHillshadeStyleLayer alloc() {
    final _ret =
        _objc_msgSend_1x359cv(_class_MLNHillshadeStyleLayer, _sel_alloc);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNHillshadeStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNHillshadeStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNHillshadeStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNLineStyleLayer = objc.getClass("MLNLineStyleLayer");
late final _sel_lineCap = objc.registerName("lineCap");
late final _sel_setLineCap_ = objc.registerName("setLineCap:");
late final _sel_lineJoin = objc.registerName("lineJoin");
late final _sel_setLineJoin_ = objc.registerName("setLineJoin:");
late final _sel_lineMiterLimit = objc.registerName("lineMiterLimit");
late final _sel_setLineMiterLimit_ = objc.registerName("setLineMiterLimit:");
late final _sel_lineRoundLimit = objc.registerName("lineRoundLimit");
late final _sel_setLineRoundLimit_ = objc.registerName("setLineRoundLimit:");
late final _sel_lineSortKey = objc.registerName("lineSortKey");
late final _sel_setLineSortKey_ = objc.registerName("setLineSortKey:");
late final _sel_lineBlur = objc.registerName("lineBlur");
late final _sel_setLineBlur_ = objc.registerName("setLineBlur:");
late final _sel_lineBlurTransition = objc.registerName("lineBlurTransition");
late final _sel_setLineBlurTransition_ =
    objc.registerName("setLineBlurTransition:");
late final _sel_lineColor = objc.registerName("lineColor");
late final _sel_setLineColor_ = objc.registerName("setLineColor:");
late final _sel_lineColorTransition = objc.registerName("lineColorTransition");
late final _sel_setLineColorTransition_ =
    objc.registerName("setLineColorTransition:");
late final _sel_lineDashPattern = objc.registerName("lineDashPattern");
late final _sel_setLineDashPattern_ = objc.registerName("setLineDashPattern:");
late final _sel_lineDashPatternTransition =
    objc.registerName("lineDashPatternTransition");
late final _sel_setLineDashPatternTransition_ =
    objc.registerName("setLineDashPatternTransition:");
late final _sel_lineDasharray = objc.registerName("lineDasharray");
late final _sel_setLineDasharray_ = objc.registerName("setLineDasharray:");
late final _sel_lineGapWidth = objc.registerName("lineGapWidth");
late final _sel_setLineGapWidth_ = objc.registerName("setLineGapWidth:");
late final _sel_lineGapWidthTransition =
    objc.registerName("lineGapWidthTransition");
late final _sel_setLineGapWidthTransition_ =
    objc.registerName("setLineGapWidthTransition:");
late final _sel_lineGradient = objc.registerName("lineGradient");
late final _sel_setLineGradient_ = objc.registerName("setLineGradient:");
late final _sel_lineOffset = objc.registerName("lineOffset");
late final _sel_setLineOffset_ = objc.registerName("setLineOffset:");
late final _sel_lineOffsetTransition =
    objc.registerName("lineOffsetTransition");
late final _sel_setLineOffsetTransition_ =
    objc.registerName("setLineOffsetTransition:");
late final _sel_lineOpacity = objc.registerName("lineOpacity");
late final _sel_setLineOpacity_ = objc.registerName("setLineOpacity:");
late final _sel_lineOpacityTransition =
    objc.registerName("lineOpacityTransition");
late final _sel_setLineOpacityTransition_ =
    objc.registerName("setLineOpacityTransition:");
late final _sel_linePattern = objc.registerName("linePattern");
late final _sel_setLinePattern_ = objc.registerName("setLinePattern:");
late final _sel_linePatternTransition =
    objc.registerName("linePatternTransition");
late final _sel_setLinePatternTransition_ =
    objc.registerName("setLinePatternTransition:");
late final _sel_lineTranslation = objc.registerName("lineTranslation");
late final _sel_setLineTranslation_ = objc.registerName("setLineTranslation:");
late final _sel_lineTranslationTransition =
    objc.registerName("lineTranslationTransition");
late final _sel_setLineTranslationTransition_ =
    objc.registerName("setLineTranslationTransition:");
late final _sel_lineTranslate = objc.registerName("lineTranslate");
late final _sel_setLineTranslate_ = objc.registerName("setLineTranslate:");
late final _sel_lineTranslationAnchor =
    objc.registerName("lineTranslationAnchor");
late final _sel_setLineTranslationAnchor_ =
    objc.registerName("setLineTranslationAnchor:");
late final _sel_lineTranslateAnchor = objc.registerName("lineTranslateAnchor");
late final _sel_setLineTranslateAnchor_ =
    objc.registerName("setLineTranslateAnchor:");
late final _sel_lineWidth = objc.registerName("lineWidth");
late final _sel_setLineWidth_ = objc.registerName("setLineWidth:");
late final _sel_lineWidthTransition = objc.registerName("lineWidthTransition");
late final _sel_setLineWidthTransition_ =
    objc.registerName("setLineWidthTransition:");

/// An ``MLNLineStyleLayer`` is a style layer that renders one or more stroked
/// polylines on the map.
///
/// Use a line style layer to configure the visual appearance of polyline or
/// multipolyline features. These features can come from vector tiles loaded by an
/// ``MLNLineStyleLayer`` object, or they can be ``MLNLineStyleLayer``,
/// ``MLNLineStyleLayer``, ``MLNLineStyleLayer``, or ``MLNLineStyleLayer``
/// instances in an ``MLNLineStyleLayer`` or ``MLNLineStyleLayer`` object.
///
/// You can access an existing line style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new line style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/shape-collection/">Add multiple
/// shapes from a single shape source</a> example to learn how to add a line to
/// your map using this style layer. See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/runtime-add-line/">Add a line
/// style layer from GeoJSON</a> example to learn how to add and style line data to
/// an ``MLNMapView`` object at runtime.
///
/// ### Example
///
/// ```swift
/// ```
class MLNLineStyleLayer extends MLNVectorStyleLayer {
  MLNLineStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNLineStyleLayer] that points to the same underlying object as [other].
  MLNLineStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNLineStyleLayer] that wraps the given raw object pointer.
  MLNLineStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNLineStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNLineStyleLayer);
  }

  /// Returns a line style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNLineStyleLayer initWithIdentifier_source_(
      objc.NSString identifier, MLNSource source) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The display of line endings.
  ///
  /// The default value of this property is an expression that evaluates to `butt`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineCap` values
  /// Any of the following constant string values:
  /// `butt`: A cap with a squared-off end which is drawn to the exact endpoint
  /// of the line.
  /// `round`: A cap with a rounded end which is drawn beyond the endpoint of the
  /// line at a radius of one-half of the line's width and centered on the endpoint
  /// of the line.
  /// `square`: A cap with a squared-off end which is drawn beyond the endpoint
  /// of the line at a distance of one-half of the line's width.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get lineCap {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineCap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The display of line endings.
  ///
  /// The default value of this property is an expression that evaluates to `butt`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineCap` values
  /// Any of the following constant string values:
  /// `butt`: A cap with a squared-off end which is drawn to the exact endpoint
  /// of the line.
  /// `round`: A cap with a rounded end which is drawn beyond the endpoint of the
  /// line at a radius of one-half of the line's width and centered on the endpoint
  /// of the line.
  /// `square`: A cap with a squared-off end which is drawn beyond the endpoint
  /// of the line at a distance of one-half of the line's width.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set lineCap(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineCap_, value.ref.pointer);
  }

  /// The display of lines when joining.
  ///
  /// The default value of this property is an expression that evaluates to `miter`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineJoin` values
  /// Any of the following constant string values:
  /// `bevel`: A join with a squared-off end which is drawn beyond the endpoint
  /// of the line at a distance of one-half of the line's width.
  /// `round`: A join with a rounded end which is drawn beyond the endpoint of
  /// the line at a radius of one-half of the line's width and centered on the
  /// endpoint of the line.
  /// `miter`: A join with a sharp, angled corner which is drawn with the outer
  /// sides beyond the endpoint of the path until they meet.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineJoin {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineJoin);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The display of lines when joining.
  ///
  /// The default value of this property is an expression that evaluates to `miter`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineJoin` values
  /// Any of the following constant string values:
  /// `bevel`: A join with a squared-off end which is drawn beyond the endpoint
  /// of the line at a distance of one-half of the line's width.
  /// `round`: A join with a rounded end which is drawn beyond the endpoint of
  /// the line at a radius of one-half of the line's width and centered on the
  /// endpoint of the line.
  /// `miter`: A join with a sharp, angled corner which is drawn with the outer
  /// sides beyond the endpoint of the path until they meet.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineJoin(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineJoin_, value.ref.pointer);
  }

  /// Used to automatically convert miter joins to bevel joins for sharp angles.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineJoin` is set to an
  /// expression that evaluates to `miter`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get lineMiterLimit {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineMiterLimit);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Used to automatically convert miter joins to bevel joins for sharp angles.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineJoin` is set to an
  /// expression that evaluates to `miter`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set lineMiterLimit(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineMiterLimit_, value.ref.pointer);
  }

  /// Used to automatically convert round joins to miter joins for shallow angles.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1.05`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineJoin` is set to an
  /// expression that evaluates to `round`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get lineRoundLimit {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineRoundLimit);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Used to automatically convert round joins to miter joins for shallow angles.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1.05`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineJoin` is set to an
  /// expression that evaluates to `round`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set lineRoundLimit(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineRoundLimit_, value.ref.pointer);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineSortKey {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineSortKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineSortKey(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineSortKey_, value.ref.pointer);
  }

  /// Blur applied to the line, in points.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineBlur {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineBlur);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Blur applied to the line, in points.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineBlur(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineBlur_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineBlur` property.
  ///
  /// This property corresponds to the `line-blur-transition` property in the style JSON file format.
  MLNTransition get lineBlurTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineBlurTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineBlurTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineBlur` property.
  ///
  /// This property corresponds to the `line-blur-transition` property in the style JSON file format.
  set lineBlurTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineBlurTransition_, value);
  }

  /// The color with which the line will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `linePattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color with which the line will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `linePattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineColor` property.
  ///
  /// This property corresponds to the `line-color-transition` property in the style JSON file format.
  MLNTransition get lineColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineColor` property.
  ///
  /// This property corresponds to the `line-color-transition` property in the style JSON file format.
  set lineColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineColorTransition_, value);
  }

  /// Specifies the lengths of the alternating dashes and gaps that form the dash
  /// pattern. The lengths are later scaled by the line width. To convert a dash
  /// length to points, multiply the length by the current line width. Note that
  /// GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to
  /// the expected scale. Also note that zoom-dependent expressions will be evaluated
  /// only at integer zoom levels.
  ///
  /// This property is measured in line widths.
  ///
  /// This property is only applied to the style if `linePattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-dasharray"><code>line-dasharray</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant array values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get lineDashPattern {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineDashPattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Specifies the lengths of the alternating dashes and gaps that form the dash
  /// pattern. The lengths are later scaled by the line width. To convert a dash
  /// length to points, multiply the length by the current line width. Note that
  /// GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to
  /// the expected scale. Also note that zoom-dependent expressions will be evaluated
  /// only at integer zoom levels.
  ///
  /// This property is measured in line widths.
  ///
  /// This property is only applied to the style if `linePattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-dasharray"><code>line-dasharray</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant array values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set lineDashPattern(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineDashPattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineDashPattern` property.
  ///
  /// This property corresponds to the `line-dasharray-transition` property in the style JSON file format.
  MLNTransition get lineDashPatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineDashPatternTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_lineDashPatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineDashPattern` property.
  ///
  /// This property corresponds to the `line-dasharray-transition` property in the style JSON file format.
  set lineDashPatternTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineDashPatternTransition_, value);
  }

  /// lineDasharray
  NSExpression get lineDasharray {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineDasharray);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLineDasharray:
  set lineDasharray(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineDasharray_, value.ref.pointer);
  }

  /// Draws a line casing outside of a line's actual path. Value indicates the width
  /// of the inner gap.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineGapWidth {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineGapWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Draws a line casing outside of a line's actual path. Value indicates the width
  /// of the inner gap.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineGapWidth(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineGapWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineGapWidth` property.
  ///
  /// This property corresponds to the `line-gap-width-transition` property in the style JSON file format.
  MLNTransition get lineGapWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineGapWidthTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_lineGapWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineGapWidth` property.
  ///
  /// This property corresponds to the `line-gap-width-transition` property in the style JSON file format.
  set lineGapWidthTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineGapWidthTransition_, value);
  }

  /// The color gradient with which the line will be drawn. This property only has an
  /// effect on lines defined by an ``MLNShapeSource`` whose ``MLNShapeSource``
  /// option is set to `YES`.
  ///
  /// This property is only applied to the style if `lineDasharray` is set to `nil`,
  /// and `linePattern` is set to `nil`, and the data source requirements are met.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$lineProgress` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get lineGradient {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineGradient);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color gradient with which the line will be drawn. This property only has an
  /// effect on lines defined by an ``MLNShapeSource`` whose ``MLNShapeSource``
  /// option is set to `YES`.
  ///
  /// This property is only applied to the style if `lineDasharray` is set to `nil`,
  /// and `linePattern` is set to `nil`, and the data source requirements are met.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$lineProgress` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set lineGradient(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineGradient_, value.ref.pointer);
  }

  /// The line's offset. For linear features, a positive value offsets the line to
  /// the right, relative to the direction of the line, and a negative value to the
  /// left. For polygon features, a positive value results in an inset, and a
  /// negative value results in an outset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineOffset {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The line's offset. For linear features, a positive value offsets the line to
  /// the right, relative to the direction of the line, and a negative value to the
  /// left. For polygon features, a positive value results in an inset, and a
  /// negative value results in an outset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineOffset(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineOffset_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineOffset` property.
  ///
  /// This property corresponds to the `line-offset-transition` property in the style JSON file format.
  MLNTransition get lineOffsetTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineOffsetTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineOffsetTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineOffset` property.
  ///
  /// This property corresponds to the `line-offset-transition` property in the style JSON file format.
  set lineOffsetTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineOffsetTransition_, value);
  }

  /// The opacity at which the line will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineOpacity {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the line will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineOpacity` property.
  ///
  /// This property corresponds to the `line-opacity-transition` property in the style JSON file format.
  MLNTransition get lineOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineOpacityTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineOpacity` property.
  ///
  /// This property corresponds to the `line-opacity-transition` property in the style JSON file format.
  set lineOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineOpacityTransition_, value);
  }

  /// Name of image in style images to use for drawing image lines. For seamless
  /// patterns, image width must be a factor of two (2, 4, 8, ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get linePattern {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_linePattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of image in style images to use for drawing image lines. For seamless
  /// patterns, image width must be a factor of two (2, 4, 8, ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set linePattern(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLinePattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `linePattern` property.
  ///
  /// This property corresponds to the `line-pattern-transition` property in the style JSON file format.
  MLNTransition get linePatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_linePatternTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_linePatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `linePattern` property.
  ///
  /// This property corresponds to the `line-pattern-transition` property in the style JSON file format.
  set linePatternTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLinePatternTransition_, value);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate"><code>line-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get lineTranslation {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate"><code>line-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set lineTranslation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineTranslation` property.
  ///
  /// This property corresponds to the `line-translate-transition` property in the style JSON file format.
  MLNTransition get lineTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_lineTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineTranslation` property.
  ///
  /// This property corresponds to the `line-translate-transition` property in the style JSON file format.
  set lineTranslationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineTranslationTransition_, value);
  }

  /// lineTranslate
  NSExpression get lineTranslate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLineTranslate:
  set lineTranslate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `lineTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate-anchor"><code>line-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The line is translated relative to the map.
  /// `viewport`: The line is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get lineTranslationAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `lineTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate-anchor"><code>line-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The line is translated relative to the map.
  /// `viewport`: The line is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set lineTranslationAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineTranslationAnchor_, value.ref.pointer);
  }

  /// lineTranslateAnchor
  NSExpression get lineTranslateAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLineTranslateAnchor:
  set lineTranslateAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineTranslateAnchor_, value.ref.pointer);
  }

  /// Stroke thickness.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineWidth {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_lineWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Stroke thickness.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineWidth(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setLineWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineWidth` property.
  ///
  /// This property corresponds to the `line-width-transition` property in the style JSON file format.
  MLNTransition get lineWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineWidthTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineWidth` property.
  ///
  /// This property corresponds to the `line-width-transition` property in the style JSON file format.
  set lineWidthTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineWidthTransition_, value);
  }

  /// init
  MLNLineStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNLineStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNLineStyleLayer, _sel_new);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNLineStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNLineStyleLayer, _sel_allocWithZone_, zone);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNLineStyleLayer alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNLineStyleLayer, _sel_alloc);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNLineStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNLineStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNLineStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNLineStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNLineStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNLineStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_MLNRasterStyleLayer = objc.getClass("MLNRasterStyleLayer");
late final _sel_maximumRasterBrightness =
    objc.registerName("maximumRasterBrightness");
late final _sel_setMaximumRasterBrightness_ =
    objc.registerName("setMaximumRasterBrightness:");
late final _sel_maximumRasterBrightnessTransition =
    objc.registerName("maximumRasterBrightnessTransition");
late final _sel_setMaximumRasterBrightnessTransition_ =
    objc.registerName("setMaximumRasterBrightnessTransition:");
late final _sel_rasterBrightnessMax = objc.registerName("rasterBrightnessMax");
late final _sel_setRasterBrightnessMax_ =
    objc.registerName("setRasterBrightnessMax:");
late final _sel_minimumRasterBrightness =
    objc.registerName("minimumRasterBrightness");
late final _sel_setMinimumRasterBrightness_ =
    objc.registerName("setMinimumRasterBrightness:");
late final _sel_minimumRasterBrightnessTransition =
    objc.registerName("minimumRasterBrightnessTransition");
late final _sel_setMinimumRasterBrightnessTransition_ =
    objc.registerName("setMinimumRasterBrightnessTransition:");
late final _sel_rasterBrightnessMin = objc.registerName("rasterBrightnessMin");
late final _sel_setRasterBrightnessMin_ =
    objc.registerName("setRasterBrightnessMin:");
late final _sel_rasterContrast = objc.registerName("rasterContrast");
late final _sel_setRasterContrast_ = objc.registerName("setRasterContrast:");
late final _sel_rasterContrastTransition =
    objc.registerName("rasterContrastTransition");
late final _sel_setRasterContrastTransition_ =
    objc.registerName("setRasterContrastTransition:");
late final _sel_rasterFadeDuration = objc.registerName("rasterFadeDuration");
late final _sel_setRasterFadeDuration_ =
    objc.registerName("setRasterFadeDuration:");
late final _sel_rasterHueRotation = objc.registerName("rasterHueRotation");
late final _sel_setRasterHueRotation_ =
    objc.registerName("setRasterHueRotation:");
late final _sel_rasterHueRotationTransition =
    objc.registerName("rasterHueRotationTransition");
late final _sel_setRasterHueRotationTransition_ =
    objc.registerName("setRasterHueRotationTransition:");
late final _sel_rasterHueRotate = objc.registerName("rasterHueRotate");
late final _sel_setRasterHueRotate_ = objc.registerName("setRasterHueRotate:");
late final _sel_rasterOpacity = objc.registerName("rasterOpacity");
late final _sel_setRasterOpacity_ = objc.registerName("setRasterOpacity:");
late final _sel_rasterOpacityTransition =
    objc.registerName("rasterOpacityTransition");
late final _sel_setRasterOpacityTransition_ =
    objc.registerName("setRasterOpacityTransition:");
late final _sel_rasterResamplingMode =
    objc.registerName("rasterResamplingMode");
late final _sel_setRasterResamplingMode_ =
    objc.registerName("setRasterResamplingMode:");
late final _sel_rasterResampling = objc.registerName("rasterResampling");
late final _sel_setRasterResampling_ =
    objc.registerName("setRasterResampling:");
late final _sel_rasterSaturation = objc.registerName("rasterSaturation");
late final _sel_setRasterSaturation_ =
    objc.registerName("setRasterSaturation:");
late final _sel_rasterSaturationTransition =
    objc.registerName("rasterSaturationTransition");
late final _sel_setRasterSaturationTransition_ =
    objc.registerName("setRasterSaturationTransition:");

/// An ``MLNRasterStyleLayer`` is a style layer that renders georeferenced raster
/// imagery on the map, especially raster tiles.
///
/// Use a raster style layer to configure the color parameters of raster tiles
/// loaded by an ``MLNRasterStyleLayer`` object or raster images loaded by an
/// ``MLNRasterStyleLayer`` object. For example, you could use a raster style layer
/// to render <a href="https://www.mapbox.com/satellite/">Mapbox Satellite</a>
/// imagery, a <a
/// href="https://docs.mapbox.com/help/glossary/tileset/#raster-tilesets">raster
/// tile set</a> uploaded to Mapbox Studio, or a raster map authored in <a
/// href="https://tilemill-project.github.io/tilemill/">TileMill</a>, the classic
/// Mapbox Editor, or Mapbox Studio Classic.
///
/// Raster images may also be used as icons or patterns in a style layer. To
/// register an image for use as an icon or pattern, use the
/// ``MLNStyle/setImage:forName:`` method. To configure a point annotation’s image,
/// use the ``MLNRasterStyleLayer`` class.
///
/// You can access an existing raster style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new raster style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a href="https://docs.mapbox.com/ios/maps/examples/image-source/">Add
/// an image</a> and <a
/// href="https://docs.mapbox.com/ios/maps/examples/source-custom-raster/">Add
/// raster imagery</a> examples to learn how to add imagery with this style layer.
///
/// ### Example
///
/// ```swift
/// ```
class MLNRasterStyleLayer extends MLNForegroundStyleLayer {
  MLNRasterStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNRasterStyleLayer] that points to the same underlying object as [other].
  MLNRasterStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNRasterStyleLayer] that wraps the given raw object pointer.
  MLNRasterStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNRasterStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterStyleLayer);
  }

  /// Returns a raster style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNRasterStyleLayer initWithIdentifier_source_(
      objc.NSString identifier, MLNSource source) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Increase or reduce the brightness of the image. The value is the maximum
  /// brightness.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-max"><code>raster-brightness-max</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get maximumRasterBrightness {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_maximumRasterBrightness);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Increase or reduce the brightness of the image. The value is the maximum
  /// brightness.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-max"><code>raster-brightness-max</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set maximumRasterBrightness(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setMaximumRasterBrightness_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `maximumRasterBrightness` property.
  ///
  /// This property corresponds to the `raster-brightness-max-transition` property in the style JSON file format.
  MLNTransition get maximumRasterBrightnessTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_maximumRasterBrightnessTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_maximumRasterBrightnessTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `maximumRasterBrightness` property.
  ///
  /// This property corresponds to the `raster-brightness-max-transition` property in the style JSON file format.
  set maximumRasterBrightnessTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setMaximumRasterBrightnessTransition_, value);
  }

  /// rasterBrightnessMax
  NSExpression get rasterBrightnessMax {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterBrightnessMax);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRasterBrightnessMax:
  set rasterBrightnessMax(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterBrightnessMax_, value.ref.pointer);
  }

  /// Increase or reduce the brightness of the image. The value is the minimum
  /// brightness.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-min"><code>raster-brightness-min</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get minimumRasterBrightness {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_minimumRasterBrightness);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Increase or reduce the brightness of the image. The value is the minimum
  /// brightness.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-min"><code>raster-brightness-min</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set minimumRasterBrightness(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setMinimumRasterBrightness_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `minimumRasterBrightness` property.
  ///
  /// This property corresponds to the `raster-brightness-min-transition` property in the style JSON file format.
  MLNTransition get minimumRasterBrightnessTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_minimumRasterBrightnessTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_minimumRasterBrightnessTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `minimumRasterBrightness` property.
  ///
  /// This property corresponds to the `raster-brightness-min-transition` property in the style JSON file format.
  set minimumRasterBrightnessTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setMinimumRasterBrightnessTransition_, value);
  }

  /// rasterBrightnessMin
  NSExpression get rasterBrightnessMin {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterBrightnessMin);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRasterBrightnessMin:
  set rasterBrightnessMin(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterBrightnessMin_, value.ref.pointer);
  }

  /// Increase or reduce the contrast of the image.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between −1 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterContrast {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterContrast);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Increase or reduce the contrast of the image.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between −1 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterContrast(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterContrast_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `rasterContrast` property.
  ///
  /// This property corresponds to the `raster-contrast-transition` property in the style JSON file format.
  MLNTransition get rasterContrastTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_rasterContrastTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_rasterContrastTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `rasterContrast` property.
  ///
  /// This property corresponds to the `raster-contrast-transition` property in the style JSON file format.
  set rasterContrastTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setRasterContrastTransition_, value);
  }

  /// Fade duration when a new tile is added, or when a video is started or its
  /// coordinates are updated.
  ///
  /// This property is measured in milliseconds.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `300`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterFadeDuration {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterFadeDuration);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Fade duration when a new tile is added, or when a video is started or its
  /// coordinates are updated.
  ///
  /// This property is measured in milliseconds.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `300`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterFadeDuration(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterFadeDuration_, value.ref.pointer);
  }

  /// Rotates hues around the color wheel.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-hue-rotate"><code>raster-hue-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterHueRotation {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterHueRotation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Rotates hues around the color wheel.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-hue-rotate"><code>raster-hue-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterHueRotation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterHueRotation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `rasterHueRotation` property.
  ///
  /// This property corresponds to the `raster-hue-rotate-transition` property in the style JSON file format.
  MLNTransition get rasterHueRotationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_rasterHueRotationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_rasterHueRotationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `rasterHueRotation` property.
  ///
  /// This property corresponds to the `raster-hue-rotate-transition` property in the style JSON file format.
  set rasterHueRotationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setRasterHueRotationTransition_, value);
  }

  /// rasterHueRotate
  NSExpression get rasterHueRotate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterHueRotate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRasterHueRotate:
  set rasterHueRotate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterHueRotate_, value.ref.pointer);
  }

  /// The opacity at which the image will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterOpacity {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the image will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `rasterOpacity` property.
  ///
  /// This property corresponds to the `raster-opacity-transition` property in the style JSON file format.
  MLNTransition get rasterOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_rasterOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_rasterOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `rasterOpacity` property.
  ///
  /// This property corresponds to the `raster-opacity-transition` property in the style JSON file format.
  set rasterOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setRasterOpacityTransition_, value);
  }

  /// The resampling/interpolation method to use for overscaling, also known as
  /// texture magnification filter
  ///
  /// The default value of this property is an expression that evaluates to `linear`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-resampling"><code>raster-resampling</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNRasterResamplingMode` values
  /// Any of the following constant string values:
  /// `linear`: (Bi)linear filtering interpolates pixel values using the weighted
  /// average of the four closest original source pixels creating a smooth but blurry
  /// look when overscaled
  /// `nearest`: Nearest neighbor filtering interpolates pixel values using the
  /// nearest original source pixel creating a sharp but pixelated look when
  /// overscaled
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get rasterResamplingMode {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterResamplingMode);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The resampling/interpolation method to use for overscaling, also known as
  /// texture magnification filter
  ///
  /// The default value of this property is an expression that evaluates to `linear`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-resampling"><code>raster-resampling</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNRasterResamplingMode` values
  /// Any of the following constant string values:
  /// `linear`: (Bi)linear filtering interpolates pixel values using the weighted
  /// average of the four closest original source pixels creating a smooth but blurry
  /// look when overscaled
  /// `nearest`: Nearest neighbor filtering interpolates pixel values using the
  /// nearest original source pixel creating a sharp but pixelated look when
  /// overscaled
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set rasterResamplingMode(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterResamplingMode_, value.ref.pointer);
  }

  /// rasterResampling
  NSExpression get rasterResampling {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterResampling);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRasterResampling:
  set rasterResampling(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterResampling_, value.ref.pointer);
  }

  /// Increase or reduce the saturation of the image.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between −1 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterSaturation {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_rasterSaturation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Increase or reduce the saturation of the image.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between −1 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterSaturation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setRasterSaturation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `rasterSaturation` property.
  ///
  /// This property corresponds to the `raster-saturation-transition` property in the style JSON file format.
  MLNTransition get rasterSaturationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_rasterSaturationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_rasterSaturationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `rasterSaturation` property.
  ///
  /// This property corresponds to the `raster-saturation-transition` property in the style JSON file format.
  set rasterSaturationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setRasterSaturationTransition_, value);
  }

  /// init
  MLNRasterStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNRasterStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNRasterStyleLayer, _sel_new);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNRasterStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNRasterStyleLayer, _sel_allocWithZone_, zone);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNRasterStyleLayer alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNRasterStyleLayer, _sel_alloc);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNRasterStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNRasterStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNRasterStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _class_MLNSymbolStyleLayer = objc.getClass("MLNSymbolStyleLayer");
late final _sel_iconAllowsOverlap = objc.registerName("iconAllowsOverlap");
late final _sel_setIconAllowsOverlap_ =
    objc.registerName("setIconAllowsOverlap:");
late final _sel_iconAllowOverlap = objc.registerName("iconAllowOverlap");
late final _sel_setIconAllowOverlap_ =
    objc.registerName("setIconAllowOverlap:");
late final _sel_iconAnchor = objc.registerName("iconAnchor");
late final _sel_setIconAnchor_ = objc.registerName("setIconAnchor:");
late final _sel_iconIgnoresPlacement =
    objc.registerName("iconIgnoresPlacement");
late final _sel_setIconIgnoresPlacement_ =
    objc.registerName("setIconIgnoresPlacement:");
late final _sel_iconIgnorePlacement = objc.registerName("iconIgnorePlacement");
late final _sel_setIconIgnorePlacement_ =
    objc.registerName("setIconIgnorePlacement:");
late final _sel_iconImageName = objc.registerName("iconImageName");
late final _sel_setIconImageName_ = objc.registerName("setIconImageName:");
late final _sel_iconImage = objc.registerName("iconImage");
late final _sel_setIconImage_ = objc.registerName("setIconImage:");
late final _sel_iconOffset = objc.registerName("iconOffset");
late final _sel_setIconOffset_ = objc.registerName("setIconOffset:");
late final _sel_isIconOptional = objc.registerName("isIconOptional");
late final _sel_setIconOptional_ = objc.registerName("setIconOptional:");
late final _sel_iconPadding = objc.registerName("iconPadding");
late final _sel_setIconPadding_ = objc.registerName("setIconPadding:");
late final _sel_iconPitchAlignment = objc.registerName("iconPitchAlignment");
late final _sel_setIconPitchAlignment_ =
    objc.registerName("setIconPitchAlignment:");
late final _sel_iconRotation = objc.registerName("iconRotation");
late final _sel_setIconRotation_ = objc.registerName("setIconRotation:");
late final _sel_iconRotate = objc.registerName("iconRotate");
late final _sel_setIconRotate_ = objc.registerName("setIconRotate:");
late final _sel_iconRotationAlignment =
    objc.registerName("iconRotationAlignment");
late final _sel_setIconRotationAlignment_ =
    objc.registerName("setIconRotationAlignment:");
late final _sel_iconScale = objc.registerName("iconScale");
late final _sel_setIconScale_ = objc.registerName("setIconScale:");
late final _sel_iconSize = objc.registerName("iconSize");
late final _sel_setIconSize_ = objc.registerName("setIconSize:");
late final _sel_iconTextFit = objc.registerName("iconTextFit");
late final _sel_setIconTextFit_ = objc.registerName("setIconTextFit:");
late final _sel_iconTextFitPadding = objc.registerName("iconTextFitPadding");
late final _sel_setIconTextFitPadding_ =
    objc.registerName("setIconTextFitPadding:");
late final _sel_keepsIconUpright = objc.registerName("keepsIconUpright");
late final _sel_setKeepsIconUpright_ =
    objc.registerName("setKeepsIconUpright:");
late final _sel_iconKeepUpright = objc.registerName("iconKeepUpright");
late final _sel_setIconKeepUpright_ = objc.registerName("setIconKeepUpright:");
late final _sel_keepsTextUpright = objc.registerName("keepsTextUpright");
late final _sel_setKeepsTextUpright_ =
    objc.registerName("setKeepsTextUpright:");
late final _sel_textKeepUpright = objc.registerName("textKeepUpright");
late final _sel_setTextKeepUpright_ = objc.registerName("setTextKeepUpright:");
late final _sel_maximumTextAngle = objc.registerName("maximumTextAngle");
late final _sel_setMaximumTextAngle_ =
    objc.registerName("setMaximumTextAngle:");
late final _sel_textMaxAngle = objc.registerName("textMaxAngle");
late final _sel_setTextMaxAngle_ = objc.registerName("setTextMaxAngle:");
late final _sel_maximumTextWidth = objc.registerName("maximumTextWidth");
late final _sel_setMaximumTextWidth_ =
    objc.registerName("setMaximumTextWidth:");
late final _sel_textMaxWidth = objc.registerName("textMaxWidth");
late final _sel_setTextMaxWidth_ = objc.registerName("setTextMaxWidth:");
late final _sel_symbolAvoidsEdges = objc.registerName("symbolAvoidsEdges");
late final _sel_setSymbolAvoidsEdges_ =
    objc.registerName("setSymbolAvoidsEdges:");
late final _sel_symbolAvoidEdges = objc.registerName("symbolAvoidEdges");
late final _sel_setSymbolAvoidEdges_ =
    objc.registerName("setSymbolAvoidEdges:");
late final _sel_symbolPlacement = objc.registerName("symbolPlacement");
late final _sel_setSymbolPlacement_ = objc.registerName("setSymbolPlacement:");
late final _sel_symbolSortKey = objc.registerName("symbolSortKey");
late final _sel_setSymbolSortKey_ = objc.registerName("setSymbolSortKey:");
late final _sel_symbolSpacing = objc.registerName("symbolSpacing");
late final _sel_setSymbolSpacing_ = objc.registerName("setSymbolSpacing:");
late final _sel_symbolZOrder = objc.registerName("symbolZOrder");
late final _sel_setSymbolZOrder_ = objc.registerName("setSymbolZOrder:");
late final _sel_text = objc.registerName("text");
late final _sel_setText_ = objc.registerName("setText:");
late final _sel_textField = objc.registerName("textField");
late final _sel_setTextField_ = objc.registerName("setTextField:");
late final _sel_textAllowsOverlap = objc.registerName("textAllowsOverlap");
late final _sel_setTextAllowsOverlap_ =
    objc.registerName("setTextAllowsOverlap:");
late final _sel_textAllowOverlap = objc.registerName("textAllowOverlap");
late final _sel_setTextAllowOverlap_ =
    objc.registerName("setTextAllowOverlap:");
late final _sel_textAnchor = objc.registerName("textAnchor");
late final _sel_setTextAnchor_ = objc.registerName("setTextAnchor:");
late final _sel_textFontNames = objc.registerName("textFontNames");
late final _sel_setTextFontNames_ = objc.registerName("setTextFontNames:");
late final _sel_textFont = objc.registerName("textFont");
late final _sel_setTextFont_ = objc.registerName("setTextFont:");
late final _sel_textFontSize = objc.registerName("textFontSize");
late final _sel_setTextFontSize_ = objc.registerName("setTextFontSize:");
late final _sel_textSize = objc.registerName("textSize");
late final _sel_setTextSize_ = objc.registerName("setTextSize:");
late final _sel_textIgnoresPlacement =
    objc.registerName("textIgnoresPlacement");
late final _sel_setTextIgnoresPlacement_ =
    objc.registerName("setTextIgnoresPlacement:");
late final _sel_textIgnorePlacement = objc.registerName("textIgnorePlacement");
late final _sel_setTextIgnorePlacement_ =
    objc.registerName("setTextIgnorePlacement:");
late final _sel_textJustification = objc.registerName("textJustification");
late final _sel_setTextJustification_ =
    objc.registerName("setTextJustification:");
late final _sel_textJustify = objc.registerName("textJustify");
late final _sel_setTextJustify_ = objc.registerName("setTextJustify:");
late final _sel_textLetterSpacing = objc.registerName("textLetterSpacing");
late final _sel_setTextLetterSpacing_ =
    objc.registerName("setTextLetterSpacing:");
late final _sel_textLineHeight = objc.registerName("textLineHeight");
late final _sel_setTextLineHeight_ = objc.registerName("setTextLineHeight:");
late final _sel_textOffset = objc.registerName("textOffset");
late final _sel_setTextOffset_ = objc.registerName("setTextOffset:");
late final _sel_isTextOptional = objc.registerName("isTextOptional");
late final _sel_setTextOptional_ = objc.registerName("setTextOptional:");
late final _sel_textPadding = objc.registerName("textPadding");
late final _sel_setTextPadding_ = objc.registerName("setTextPadding:");
late final _sel_textPitchAlignment = objc.registerName("textPitchAlignment");
late final _sel_setTextPitchAlignment_ =
    objc.registerName("setTextPitchAlignment:");
late final _sel_textRadialOffset = objc.registerName("textRadialOffset");
late final _sel_setTextRadialOffset_ =
    objc.registerName("setTextRadialOffset:");
late final _sel_textRotation = objc.registerName("textRotation");
late final _sel_setTextRotation_ = objc.registerName("setTextRotation:");
late final _sel_textRotate = objc.registerName("textRotate");
late final _sel_setTextRotate_ = objc.registerName("setTextRotate:");
late final _sel_textRotationAlignment =
    objc.registerName("textRotationAlignment");
late final _sel_setTextRotationAlignment_ =
    objc.registerName("setTextRotationAlignment:");
late final _sel_textTransform = objc.registerName("textTransform");
late final _sel_setTextTransform_ = objc.registerName("setTextTransform:");
late final _sel_textVariableAnchor = objc.registerName("textVariableAnchor");
late final _sel_setTextVariableAnchor_ =
    objc.registerName("setTextVariableAnchor:");
late final _sel_textVariableAnchorOffset =
    objc.registerName("textVariableAnchorOffset");
late final _sel_setTextVariableAnchorOffset_ =
    objc.registerName("setTextVariableAnchorOffset:");
late final _sel_textWritingModes = objc.registerName("textWritingModes");
late final _sel_setTextWritingModes_ =
    objc.registerName("setTextWritingModes:");
late final _sel_textWritingMode = objc.registerName("textWritingMode");
late final _sel_setTextWritingMode_ = objc.registerName("setTextWritingMode:");
late final _sel_iconColor = objc.registerName("iconColor");
late final _sel_setIconColor_ = objc.registerName("setIconColor:");
late final _sel_iconColorTransition = objc.registerName("iconColorTransition");
late final _sel_setIconColorTransition_ =
    objc.registerName("setIconColorTransition:");
late final _sel_iconHaloBlur = objc.registerName("iconHaloBlur");
late final _sel_setIconHaloBlur_ = objc.registerName("setIconHaloBlur:");
late final _sel_iconHaloBlurTransition =
    objc.registerName("iconHaloBlurTransition");
late final _sel_setIconHaloBlurTransition_ =
    objc.registerName("setIconHaloBlurTransition:");
late final _sel_iconHaloColor = objc.registerName("iconHaloColor");
late final _sel_setIconHaloColor_ = objc.registerName("setIconHaloColor:");
late final _sel_iconHaloColorTransition =
    objc.registerName("iconHaloColorTransition");
late final _sel_setIconHaloColorTransition_ =
    objc.registerName("setIconHaloColorTransition:");
late final _sel_iconHaloWidth = objc.registerName("iconHaloWidth");
late final _sel_setIconHaloWidth_ = objc.registerName("setIconHaloWidth:");
late final _sel_iconHaloWidthTransition =
    objc.registerName("iconHaloWidthTransition");
late final _sel_setIconHaloWidthTransition_ =
    objc.registerName("setIconHaloWidthTransition:");
late final _sel_iconOpacity = objc.registerName("iconOpacity");
late final _sel_setIconOpacity_ = objc.registerName("setIconOpacity:");
late final _sel_iconOpacityTransition =
    objc.registerName("iconOpacityTransition");
late final _sel_setIconOpacityTransition_ =
    objc.registerName("setIconOpacityTransition:");
late final _sel_iconTranslation = objc.registerName("iconTranslation");
late final _sel_setIconTranslation_ = objc.registerName("setIconTranslation:");
late final _sel_iconTranslationTransition =
    objc.registerName("iconTranslationTransition");
late final _sel_setIconTranslationTransition_ =
    objc.registerName("setIconTranslationTransition:");
late final _sel_iconTranslate = objc.registerName("iconTranslate");
late final _sel_setIconTranslate_ = objc.registerName("setIconTranslate:");
late final _sel_iconTranslationAnchor =
    objc.registerName("iconTranslationAnchor");
late final _sel_setIconTranslationAnchor_ =
    objc.registerName("setIconTranslationAnchor:");
late final _sel_iconTranslateAnchor = objc.registerName("iconTranslateAnchor");
late final _sel_setIconTranslateAnchor_ =
    objc.registerName("setIconTranslateAnchor:");
late final _sel_textColor = objc.registerName("textColor");
late final _sel_setTextColor_ = objc.registerName("setTextColor:");
late final _sel_textColorTransition = objc.registerName("textColorTransition");
late final _sel_setTextColorTransition_ =
    objc.registerName("setTextColorTransition:");
late final _sel_textHaloBlur = objc.registerName("textHaloBlur");
late final _sel_setTextHaloBlur_ = objc.registerName("setTextHaloBlur:");
late final _sel_textHaloBlurTransition =
    objc.registerName("textHaloBlurTransition");
late final _sel_setTextHaloBlurTransition_ =
    objc.registerName("setTextHaloBlurTransition:");
late final _sel_textHaloColor = objc.registerName("textHaloColor");
late final _sel_setTextHaloColor_ = objc.registerName("setTextHaloColor:");
late final _sel_textHaloColorTransition =
    objc.registerName("textHaloColorTransition");
late final _sel_setTextHaloColorTransition_ =
    objc.registerName("setTextHaloColorTransition:");
late final _sel_textHaloWidth = objc.registerName("textHaloWidth");
late final _sel_setTextHaloWidth_ = objc.registerName("setTextHaloWidth:");
late final _sel_textHaloWidthTransition =
    objc.registerName("textHaloWidthTransition");
late final _sel_setTextHaloWidthTransition_ =
    objc.registerName("setTextHaloWidthTransition:");
late final _sel_textOpacity = objc.registerName("textOpacity");
late final _sel_setTextOpacity_ = objc.registerName("setTextOpacity:");
late final _sel_textOpacityTransition =
    objc.registerName("textOpacityTransition");
late final _sel_setTextOpacityTransition_ =
    objc.registerName("setTextOpacityTransition:");
late final _sel_textTranslation = objc.registerName("textTranslation");
late final _sel_setTextTranslation_ = objc.registerName("setTextTranslation:");
late final _sel_textTranslationTransition =
    objc.registerName("textTranslationTransition");
late final _sel_setTextTranslationTransition_ =
    objc.registerName("setTextTranslationTransition:");
late final _sel_textTranslate = objc.registerName("textTranslate");
late final _sel_setTextTranslate_ = objc.registerName("setTextTranslate:");
late final _sel_textTranslationAnchor =
    objc.registerName("textTranslationAnchor");
late final _sel_setTextTranslationAnchor_ =
    objc.registerName("setTextTranslationAnchor:");
late final _sel_textTranslateAnchor = objc.registerName("textTranslateAnchor");
late final _sel_setTextTranslateAnchor_ =
    objc.registerName("setTextTranslateAnchor:");

/// An ``MLNSymbolStyleLayer`` is a style layer that renders icon and text labels
/// at points or along lines on the map.
///
/// Use a symbol style layer to configure the visual appearance of feature labels.
/// These features can come from vector tiles loaded by an ``MLNSymbolStyleLayer``
/// object, or they can be ``MLNSymbolStyleLayer`` or ``MLNSymbolStyleLayer``
/// instances in an ``MLNSymbolStyleLayer`` or ``MLNSymbolStyleLayer`` object.
///
/// You can access an existing symbol style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new symbol style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/runtime-multiple-annotations/">Dynamically
/// style interactive points</a> and <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
/// images to cluster point data</a> examples learn how to style data on your map
/// using this layer.
///
/// ### Example
///
/// ```swift
/// ```
class MLNSymbolStyleLayer extends MLNVectorStyleLayer {
  MLNSymbolStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNSymbolStyleLayer] that points to the same underlying object as [other].
  MLNSymbolStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNSymbolStyleLayer] that wraps the given raw object pointer.
  MLNSymbolStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNSymbolStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_69e0x1(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNSymbolStyleLayer);
  }

  /// Returns a symbol style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNSymbolStyleLayer initWithIdentifier_source_(
      objc.NSString identifier, MLNSource source) {
    final _ret = _objc_msgSend_rsfdlh(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// If true, the icon will be visible even if it collides with other previously
  /// drawn symbols.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconOverlap` is set to `nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-allow-overlap"><code>icon-allow-overlap</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconAllowsOverlap {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconAllowsOverlap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, the icon will be visible even if it collides with other previously
  /// drawn symbols.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconOverlap` is set to `nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-allow-overlap"><code>icon-allow-overlap</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconAllowsOverlap(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconAllowsOverlap_, value.ref.pointer);
  }

  /// iconAllowOverlap
  NSExpression get iconAllowOverlap {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconAllowOverlap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconAllowOverlap:
  set iconAllowOverlap(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconAllowOverlap_, value.ref.pointer);
  }

  /// Part of the icon placed closest to the anchor.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconAnchor` values
  /// Any of the following constant string values:
  /// `center`: The center of the icon is placed closest to the anchor.
  /// `left`: The left side of the icon is placed closest to the anchor.
  /// `right`: The right side of the icon is placed closest to the anchor.
  /// `top`: The top of the icon is placed closest to the anchor.
  /// `bottom`: The bottom of the icon is placed closest to the anchor.
  /// `top-left`: The top left corner of the icon is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the icon is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the icon is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the icon is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconAnchor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Part of the icon placed closest to the anchor.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconAnchor` values
  /// Any of the following constant string values:
  /// `center`: The center of the icon is placed closest to the anchor.
  /// `left`: The left side of the icon is placed closest to the anchor.
  /// `right`: The right side of the icon is placed closest to the anchor.
  /// `top`: The top of the icon is placed closest to the anchor.
  /// `bottom`: The bottom of the icon is placed closest to the anchor.
  /// `top-left`: The top left corner of the icon is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the icon is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the icon is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the icon is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconAnchor_, value.ref.pointer);
  }

  /// If true, other symbols can be visible even if they collide with the icon.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-ignore-placement"><code>icon-ignore-placement</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconIgnoresPlacement {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconIgnoresPlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, other symbols can be visible even if they collide with the icon.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-ignore-placement"><code>icon-ignore-placement</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconIgnoresPlacement(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconIgnoresPlacement_, value.ref.pointer);
  }

  /// iconIgnorePlacement
  NSExpression get iconIgnorePlacement {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconIgnorePlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconIgnorePlacement:
  set iconIgnorePlacement(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconIgnorePlacement_, value.ref.pointer);
  }

  /// Name of a style image to use for drawing an image background.
  ///
  /// Use the ``MLNStyle/setImage:forName:`` method to associate an image with a name
  /// that you can set this property to.
  ///
  /// Within a constant string value, a feature attribute name enclosed in curly
  /// braces (e.g., `{token}`) is replaced with the value of the named attribute.
  /// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
  /// and key path expressions.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-image"><code>icon-image</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  ///
  /// #### Related examples
  /// See the <a
  /// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
  /// images to cluster point data</a> example to learn how to dynamically set your
  /// icons with an expression.
  NSExpression get iconImageName {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconImageName);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of a style image to use for drawing an image background.
  ///
  /// Use the ``MLNStyle/setImage:forName:`` method to associate an image with a name
  /// that you can set this property to.
  ///
  /// Within a constant string value, a feature attribute name enclosed in curly
  /// braces (e.g., `{token}`) is replaced with the value of the named attribute.
  /// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
  /// and key path expressions.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-image"><code>icon-image</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  ///
  /// #### Related examples
  /// See the <a
  /// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
  /// images to cluster point data</a> example to learn how to dynamically set your
  /// icons with an expression.
  set iconImageName(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconImageName_, value.ref.pointer);
  }

  /// iconImage
  NSExpression get iconImage {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconImage);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconImage:
  set iconImage(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconImage_, value.ref.pointer);
  }

  /// Offset distance of icon from its anchor.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 rightward and 0
  /// upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconOffset {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Offset distance of icon from its anchor.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 rightward and 0
  /// upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconOffset(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconOffset_, value.ref.pointer);
  }

  /// If true, text will display without their corresponding icons when the icon
  /// collides with other symbols and the text does not.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconOptional {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_isIconOptional);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, text will display without their corresponding icons when the icon
  /// collides with other symbols and the text does not.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconOptional(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconOptional_, value.ref.pointer);
  }

  /// Size of additional area round the icon bounding box used for detecting symbol
  /// collisions.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `NSEdgeInsets` struct set to 2 points on all
  /// sides. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSEdgeInsets` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconPadding {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconPadding);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Size of additional area round the icon bounding box used for detecting symbol
  /// collisions.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `NSEdgeInsets` struct set to 2 points on all
  /// sides. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSEdgeInsets` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconPadding(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconPadding_, value.ref.pointer);
  }

  /// Orientation of icon when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconPitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The icon is aligned to the plane of the map.
  /// `viewport`: The icon is aligned to the plane of the viewport.
  /// `auto`: Automatically matches the value of `icon-rotation-alignment`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconPitchAlignment {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconPitchAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Orientation of icon when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconPitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The icon is aligned to the plane of the map.
  /// `viewport`: The icon is aligned to the plane of the viewport.
  /// `auto`: Automatically matches the value of `icon-rotation-alignment`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconPitchAlignment(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconPitchAlignment_, value.ref.pointer);
  }

  /// Rotates the icon clockwise.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-rotate"><code>icon-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconRotation {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconRotation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Rotates the icon clockwise.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-rotate"><code>icon-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconRotation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconRotation_, value.ref.pointer);
  }

  /// iconRotate
  NSExpression get iconRotate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconRotate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconRotate:
  set iconRotate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconRotate_, value.ref.pointer);
  }

  /// In combination with `symbolPlacement`, determines the rotation behavior of
  /// icons.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconRotationAlignment` values
  /// Any of the following constant string values:
  /// `map`: When `symbol-placement` is set to `point`, aligns icons east-west.
  /// When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes
  /// with the line.
  /// `viewport`: Produces icons whose x-axes are aligned with the x-axis of the
  /// viewport, regardless of the value of `symbol-placement`.
  /// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
  /// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
  /// equivalent to `map`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconRotationAlignment {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconRotationAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// In combination with `symbolPlacement`, determines the rotation behavior of
  /// icons.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconRotationAlignment` values
  /// Any of the following constant string values:
  /// `map`: When `symbol-placement` is set to `point`, aligns icons east-west.
  /// When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes
  /// with the line.
  /// `viewport`: Produces icons whose x-axes are aligned with the x-axis of the
  /// viewport, regardless of the value of `symbol-placement`.
  /// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
  /// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
  /// equivalent to `map`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconRotationAlignment(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconRotationAlignment_, value.ref.pointer);
  }

  /// Scales the original size of the icon by the provided factor. The new point size
  /// of the image will be the original point size multiplied by `iconScale`. 1 is
  /// the original size; 3 triples the size of the image.
  ///
  /// This property is measured in factor of the original icon sizes.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-size"><code>icon-size</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconScale {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconScale);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Scales the original size of the icon by the provided factor. The new point size
  /// of the image will be the original point size multiplied by `iconScale`. 1 is
  /// the original size; 3 triples the size of the image.
  ///
  /// This property is measured in factor of the original icon sizes.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-size"><code>icon-size</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconScale(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconScale_, value.ref.pointer);
  }

  /// iconSize
  NSExpression get iconSize {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconSize);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconSize:
  set iconSize(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconSize_, value.ref.pointer);
  }

  /// The directions in which the icon stretches to fit around the text. If the icon
  /// image is a resizable image, the resizable areas may be stretched, while the cap
  /// insets are always drawn at the original scale.
  ///
  /// The default value of this property is an expression that evaluates to `none`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconTextFit` values
  /// Any of the following constant string values:
  /// `none`: The icon is displayed at its intrinsic aspect ratio.
  /// `width`: The icon is scaled in the x-dimension to fit the width of the
  /// text.
  /// `height`: The icon is scaled in the y-dimension to fit the height of the
  /// text.
  /// `both`: The icon is scaled in both x- and y-dimensions.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconTextFit {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconTextFit);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The directions in which the icon stretches to fit around the text. If the icon
  /// image is a resizable image, the resizable areas may be stretched, while the cap
  /// insets are always drawn at the original scale.
  ///
  /// The default value of this property is an expression that evaluates to `none`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconTextFit` values
  /// Any of the following constant string values:
  /// `none`: The icon is displayed at its intrinsic aspect ratio.
  /// `width`: The icon is scaled in the x-dimension to fit the width of the
  /// text.
  /// `height`: The icon is scaled in the y-dimension to fit the height of the
  /// text.
  /// `both`: The icon is scaled in both x- and y-dimensions.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconTextFit(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconTextFit_, value.ref.pointer);
  }

  /// Size of the additional area added to dimensions determined by `iconTextFit`.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing `NSEdgeInsetsZero`. Set this property to `nil` to
  /// reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`, and `iconTextFit` is set to an expression that evaluates
  /// to `MLNIconTextFitBoth`, `MLNIconTextFitWidth`, or `MLNIconTextFitHeight`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSEdgeInsets` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get iconTextFitPadding {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconTextFitPadding);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Size of the additional area added to dimensions determined by `iconTextFit`.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing `NSEdgeInsetsZero`. Set this property to `nil` to
  /// reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`, and `iconTextFit` is set to an expression that evaluates
  /// to `MLNIconTextFitBoth`, `MLNIconTextFitWidth`, or `MLNIconTextFitHeight`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSEdgeInsets` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set iconTextFitPadding(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconTextFitPadding_, value.ref.pointer);
  }

  /// If true, the icon may be flipped to prevent it from being rendered upside-down.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconRotationAlignment` is set to an expression that evaluates to `map`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-keep-upright"><code>icon-keep-upright</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get keepsIconUpright {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_keepsIconUpright);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, the icon may be flipped to prevent it from being rendered upside-down.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconRotationAlignment` is set to an expression that evaluates to `map`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-keep-upright"><code>icon-keep-upright</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set keepsIconUpright(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setKeepsIconUpright_, value.ref.pointer);
  }

  /// iconKeepUpright
  NSExpression get iconKeepUpright {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconKeepUpright);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconKeepUpright:
  set iconKeepUpright(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconKeepUpright_, value.ref.pointer);
  }

  /// If true, the text may be flipped vertically to prevent it from being rendered
  /// upside-down.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textRotationAlignment` is set to an expression that evaluates to `map`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-keep-upright"><code>text-keep-upright</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get keepsTextUpright {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_keepsTextUpright);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, the text may be flipped vertically to prevent it from being rendered
  /// upside-down.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textRotationAlignment` is set to an expression that evaluates to `map`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-keep-upright"><code>text-keep-upright</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set keepsTextUpright(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setKeepsTextUpright_, value.ref.pointer);
  }

  /// textKeepUpright
  NSExpression get textKeepUpright {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textKeepUpright);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextKeepUpright:
  set textKeepUpright(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextKeepUpright_, value.ref.pointer);
  }

  /// Maximum angle change between adjacent characters.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `45`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-angle"><code>text-max-angle</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get maximumTextAngle {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_maximumTextAngle);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Maximum angle change between adjacent characters.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `45`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-angle"><code>text-max-angle</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set maximumTextAngle(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setMaximumTextAngle_, value.ref.pointer);
  }

  /// textMaxAngle
  NSExpression get textMaxAngle {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textMaxAngle);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextMaxAngle:
  set textMaxAngle(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextMaxAngle_, value.ref.pointer);
  }

  /// The maximum line width for text wrapping.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `10`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-width"><code>text-max-width</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get maximumTextWidth {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_maximumTextWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The maximum line width for text wrapping.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `10`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-width"><code>text-max-width</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set maximumTextWidth(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setMaximumTextWidth_, value.ref.pointer);
  }

  /// textMaxWidth
  NSExpression get textMaxWidth {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textMaxWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextMaxWidth:
  set textMaxWidth(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextMaxWidth_, value.ref.pointer);
  }

  /// Whether symbols in this layer avoid colliding with symbols in adjacent tiles.
  ///
  /// If this property is set to `true`, symbols in this layer avoid crossing the
  /// edge of a tile. You should set this property to `true` if the backing vector
  /// tiles don’t have enough padding to prevent collisions, or if this layer’s
  /// `symbolPlacement` property is set to
  /// ``MLNSymbolPlacement/MLNSymbolPlacementPoint`` but this layer is above a symbol
  /// layer whose `symbolPlacement` property is set to
  /// ``MLNSymbolPlacement/MLNSymbolPlacementPoint``. You do not need to enable this
  /// property to prevent clipped labels at tile boundaries.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-symbol-avoid-edges"><code>symbol-avoid-edges</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get symbolAvoidsEdges {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_symbolAvoidsEdges);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Whether symbols in this layer avoid colliding with symbols in adjacent tiles.
  ///
  /// If this property is set to `true`, symbols in this layer avoid crossing the
  /// edge of a tile. You should set this property to `true` if the backing vector
  /// tiles don’t have enough padding to prevent collisions, or if this layer’s
  /// `symbolPlacement` property is set to
  /// ``MLNSymbolPlacement/MLNSymbolPlacementPoint`` but this layer is above a symbol
  /// layer whose `symbolPlacement` property is set to
  /// ``MLNSymbolPlacement/MLNSymbolPlacementPoint``. You do not need to enable this
  /// property to prevent clipped labels at tile boundaries.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-symbol-avoid-edges"><code>symbol-avoid-edges</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set symbolAvoidsEdges(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSymbolAvoidsEdges_, value.ref.pointer);
  }

  /// symbolAvoidEdges
  NSExpression get symbolAvoidEdges {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_symbolAvoidEdges);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSymbolAvoidEdges:
  set symbolAvoidEdges(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSymbolAvoidEdges_, value.ref.pointer);
  }

  /// Label placement relative to its geometry.
  ///
  /// The default value of this property is an expression that evaluates to `point`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNSymbolPlacement` values
  /// Any of the following constant string values:
  /// `point`: The label is placed at the point where the geometry is located.
  /// `line`: The label is placed along the line of the geometry. Can only be
  /// used on `LineString` and `Polygon` geometries.
  /// `line-center`: The label is placed at the center of the line of the
  /// geometry. Can only be used on `LineString` and `Polygon` geometries. Note that
  /// a single feature in a vector tile may contain multiple line geometries.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get symbolPlacement {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_symbolPlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Label placement relative to its geometry.
  ///
  /// The default value of this property is an expression that evaluates to `point`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNSymbolPlacement` values
  /// Any of the following constant string values:
  /// `point`: The label is placed at the point where the geometry is located.
  /// `line`: The label is placed along the line of the geometry. Can only be
  /// used on `LineString` and `Polygon` geometries.
  /// `line-center`: The label is placed at the center of the line of the
  /// geometry. Can only be used on `LineString` and `Polygon` geometries. Note that
  /// a single feature in a vector tile may contain multiple line geometries.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set symbolPlacement(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSymbolPlacement_, value.ref.pointer);
  }

  /// Sorts features in ascending order based on this value. Features with lower sort
  /// keys are drawn and placed first.  When `iconAllowsOverlap` or
  /// `textAllowsOverlap` is `false`, features with a lower sort key will have
  /// priority during placement. When `iconAllowsOverlap` or `textAllowsOverlap` is
  /// set to `YES`, features with a higher sort key will overlap over features with a
  /// lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get symbolSortKey {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_symbolSortKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with lower sort
  /// keys are drawn and placed first.  When `iconAllowsOverlap` or
  /// `textAllowsOverlap` is `false`, features with a lower sort key will have
  /// priority during placement. When `iconAllowsOverlap` or `textAllowsOverlap` is
  /// set to `YES`, features with a higher sort key will overlap over features with a
  /// lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set symbolSortKey(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSymbolSortKey_, value.ref.pointer);
  }

  /// Distance between two symbol anchors.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `250`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `symbolPlacement` is set to an
  /// expression that evaluates to `line`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 1
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get symbolSpacing {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_symbolSpacing);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance between two symbol anchors.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `250`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `symbolPlacement` is set to an
  /// expression that evaluates to `line`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 1
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set symbolSpacing(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSymbolSpacing_, value.ref.pointer);
  }

  /// Determines whether overlapping symbols in the same layer are rendered in the
  /// order that they appear in the data source or by their y-position relative to
  /// the viewport. To control the order and prioritization of symbols otherwise, use
  /// `symbolSortKey`.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNSymbolZOrder` values
  /// Any of the following constant string values:
  /// `auto`: Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols
  /// by their y-position relative to the viewport if `icon-allow-overlap` or
  /// `text-allow-overlap` is set to `true` or `icon-ignore-placement` or
  /// `text-ignore-placement` is `false`.
  /// `viewport-y`: Specify this z order if symbols’ appearance relies on lower
  /// features overlapping higher features. For example, symbols with a pin-like
  /// appearance would require this z order.
  /// `source`: Specify this z order if the order in which features appear in the
  /// source is significant.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get symbolZOrder {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_symbolZOrder);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Determines whether overlapping symbols in the same layer are rendered in the
  /// order that they appear in the data source or by their y-position relative to
  /// the viewport. To control the order and prioritization of symbols otherwise, use
  /// `symbolSortKey`.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNSymbolZOrder` values
  /// Any of the following constant string values:
  /// `auto`: Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols
  /// by their y-position relative to the viewport if `icon-allow-overlap` or
  /// `text-allow-overlap` is set to `true` or `icon-ignore-placement` or
  /// `text-ignore-placement` is `false`.
  /// `viewport-y`: Specify this z order if symbols’ appearance relies on lower
  /// features overlapping higher features. For example, symbols with a pin-like
  /// appearance would require this z order.
  /// `source`: Specify this z order if the order in which features appear in the
  /// source is significant.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set symbolZOrder(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setSymbolZOrder_, value.ref.pointer);
  }

  /// Value to use for a text label.
  ///
  /// Within a constant string value, a feature attribute name enclosed in curly
  /// braces (e.g., `{token}`) is replaced with the value of the named attribute.
  /// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
  /// and key path expressions.
  ///
  /// The default value of this property is an expression that evaluates to the empty
  /// string. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-field"><code>text-field</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Formatted expressions.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  ///
  /// #### Related examples
  /// See the <a href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster
  /// point data</a> and <a
  /// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
  /// images to cluster point data</a> to learn how to use an expression to set this
  /// attribute to the number of markers within a cluster.
  NSExpression get text {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_text);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Value to use for a text label.
  ///
  /// Within a constant string value, a feature attribute name enclosed in curly
  /// braces (e.g., `{token}`) is replaced with the value of the named attribute.
  /// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
  /// and key path expressions.
  ///
  /// The default value of this property is an expression that evaluates to the empty
  /// string. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-field"><code>text-field</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Formatted expressions.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  ///
  /// #### Related examples
  /// See the <a href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster
  /// point data</a> and <a
  /// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
  /// images to cluster point data</a> to learn how to use an expression to set this
  /// attribute to the number of markers within a cluster.
  set text(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setText_, value.ref.pointer);
  }

  /// textField
  NSExpression get textField {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textField);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextField:
  set textField(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextField_, value.ref.pointer);
  }

  /// If true, the text will be visible even if it collides with other previously
  /// drawn symbols.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-allow-overlap"><code>text-allow-overlap</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textAllowsOverlap {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textAllowsOverlap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, the text will be visible even if it collides with other previously
  /// drawn symbols.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-allow-overlap"><code>text-allow-overlap</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textAllowsOverlap(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextAllowsOverlap_, value.ref.pointer);
  }

  /// textAllowOverlap
  NSExpression get textAllowOverlap {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textAllowOverlap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextAllowOverlap:
  set textAllowOverlap(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextAllowOverlap_, value.ref.pointer);
  }

  /// Part of the text placed closest to the anchor.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textVariableAnchor` is set to `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextAnchor` values
  /// Any of the following constant string values:
  /// `center`: The center of the text is placed closest to the anchor.
  /// `left`: The left side of the text is placed closest to the anchor.
  /// `right`: The right side of the text is placed closest to the anchor.
  /// `top`: The top of the text is placed closest to the anchor.
  /// `bottom`: The bottom of the text is placed closest to the anchor.
  /// `top-left`: The top left corner of the text is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the text is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the text is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the text is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textAnchor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Part of the text placed closest to the anchor.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textVariableAnchor` is set to `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextAnchor` values
  /// Any of the following constant string values:
  /// `center`: The center of the text is placed closest to the anchor.
  /// `left`: The left side of the text is placed closest to the anchor.
  /// `right`: The right side of the text is placed closest to the anchor.
  /// `top`: The top of the text is placed closest to the anchor.
  /// `bottom`: The bottom of the text is placed closest to the anchor.
  /// `top-left`: The top left corner of the text is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the text is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the text is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the text is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextAnchor_, value.ref.pointer);
  }

  /// An array of font face names used to display the text.
  ///
  /// The first font named in the array is applied to the text. For each character in
  /// the text, if the first font lacks a glyph for the character, the next font is
  /// applied as a fallback, and so on.
  ///
  /// See the “[Customizing Fonts](doc:Customizing_Fonts)” guide for details on how
  /// this SDK chooses and renders fonts based on the value of this property.
  ///
  /// The default value of this property is an expression that evaluates to the array
  /// `Open Sans Regular`, `Arial Unicode MS Regular`. Set this property to `nil` to
  /// reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-font"><code>text-font</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant array values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textFontNames {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textFontNames);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// An array of font face names used to display the text.
  ///
  /// The first font named in the array is applied to the text. For each character in
  /// the text, if the first font lacks a glyph for the character, the next font is
  /// applied as a fallback, and so on.
  ///
  /// See the “[Customizing Fonts](doc:Customizing_Fonts)” guide for details on how
  /// this SDK chooses and renders fonts based on the value of this property.
  ///
  /// The default value of this property is an expression that evaluates to the array
  /// `Open Sans Regular`, `Arial Unicode MS Regular`. Set this property to `nil` to
  /// reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-font"><code>text-font</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant array values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textFontNames(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextFontNames_, value.ref.pointer);
  }

  /// textFont
  NSExpression get textFont {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textFont);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextFont:
  set textFont(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextFont_, value.ref.pointer);
  }

  /// Font size.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `16`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-size"><code>text-size</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textFontSize {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textFontSize);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Font size.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `16`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-size"><code>text-size</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textFontSize(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextFontSize_, value.ref.pointer);
  }

  /// textSize
  NSExpression get textSize {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textSize);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextSize:
  set textSize(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextSize_, value.ref.pointer);
  }

  /// If true, other symbols can be visible even if they collide with the text.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-ignore-placement"><code>text-ignore-placement</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textIgnoresPlacement {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textIgnoresPlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, other symbols can be visible even if they collide with the text.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-ignore-placement"><code>text-ignore-placement</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textIgnoresPlacement(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextIgnoresPlacement_, value.ref.pointer);
  }

  /// textIgnorePlacement
  NSExpression get textIgnorePlacement {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textIgnorePlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextIgnorePlacement:
  set textIgnorePlacement(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextIgnorePlacement_, value.ref.pointer);
  }

  /// Text justification options.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-justify"><code>text-justify</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextJustification` values
  /// Any of the following constant string values:
  /// `auto`: The text is aligned towards the anchor position.
  /// `left`: The text is aligned to the left.
  /// `center`: The text is centered.
  /// `right`: The text is aligned to the right.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textJustification {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textJustification);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Text justification options.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-justify"><code>text-justify</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextJustification` values
  /// Any of the following constant string values:
  /// `auto`: The text is aligned towards the anchor position.
  /// `left`: The text is aligned to the left.
  /// `center`: The text is centered.
  /// `right`: The text is aligned to the right.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textJustification(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextJustification_, value.ref.pointer);
  }

  /// textJustify
  NSExpression get textJustify {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textJustify);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextJustify:
  set textJustify(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextJustify_, value.ref.pointer);
  }

  /// Text tracking amount.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textLetterSpacing {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textLetterSpacing);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Text tracking amount.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textLetterSpacing(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextLetterSpacing_, value.ref.pointer);
  }

  /// Text leading value for multi-line text.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1.2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get textLineHeight {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textLineHeight);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Text leading value for multi-line text.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1.2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set textLineHeight(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextLineHeight_, value.ref.pointer);
  }

  /// Offset distance of text from its anchor.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 ems rightward and 0
  /// ems upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textRadialOffset` is set to `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textOffset {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Offset distance of text from its anchor.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 ems rightward and 0
  /// ems upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textRadialOffset` is set to `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textOffset(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextOffset_, value.ref.pointer);
  }

  /// If true, icons will display without their corresponding text when the text
  /// collides with other symbols and the icon does not.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `iconImageName` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textOptional {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_isTextOptional);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, icons will display without their corresponding text when the text
  /// collides with other symbols and the icon does not.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `iconImageName` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textOptional(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextOptional_, value.ref.pointer);
  }

  /// Size of the additional area around the text bounding box used for detecting
  /// symbol collisions.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get textPadding {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textPadding);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Size of the additional area around the text bounding box used for detecting
  /// symbol collisions.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set textPadding(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextPadding_, value.ref.pointer);
  }

  /// Orientation of text when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextPitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The text is aligned to the plane of the map.
  /// `viewport`: The text is aligned to the plane of the viewport.
  /// `auto`: Automatically matches the value of `text-rotation-alignment`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textPitchAlignment {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textPitchAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Orientation of text when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextPitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The text is aligned to the plane of the map.
  /// `viewport`: The text is aligned to the plane of the viewport.
  /// `auto`: Automatically matches the value of `text-rotation-alignment`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textPitchAlignment(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextPitchAlignment_, value.ref.pointer);
  }

  /// Radial offset of text, in the direction of the symbol's anchor. Useful in
  /// combination with `textVariableAnchor`, which defaults to using the
  /// two-dimensional `textOffset` if present.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textRadialOffset {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textRadialOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Radial offset of text, in the direction of the symbol's anchor. Useful in
  /// combination with `textVariableAnchor`, which defaults to using the
  /// two-dimensional `textOffset` if present.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textRadialOffset(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextRadialOffset_, value.ref.pointer);
  }

  /// Rotates the text clockwise.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-rotate"><code>text-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textRotation {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textRotation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Rotates the text clockwise.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-rotate"><code>text-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textRotation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextRotation_, value.ref.pointer);
  }

  /// textRotate
  NSExpression get textRotate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textRotate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextRotate:
  set textRotate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextRotate_, value.ref.pointer);
  }

  /// In combination with `symbolPlacement`, determines the rotation behavior of the
  /// individual glyphs forming the text.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextRotationAlignment` values
  /// Any of the following constant string values:
  /// `map`: When `symbol-placement` is set to `point`, aligns text east-west.
  /// When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes
  /// with the line.
  /// `viewport`: Produces glyphs whose x-axes are aligned with the x-axis of the
  /// viewport, regardless of the value of `symbol-placement`.
  /// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
  /// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
  /// equivalent to `map`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textRotationAlignment {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textRotationAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// In combination with `symbolPlacement`, determines the rotation behavior of the
  /// individual glyphs forming the text.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextRotationAlignment` values
  /// Any of the following constant string values:
  /// `map`: When `symbol-placement` is set to `point`, aligns text east-west.
  /// When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes
  /// with the line.
  /// `viewport`: Produces glyphs whose x-axes are aligned with the x-axis of the
  /// viewport, regardless of the value of `symbol-placement`.
  /// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
  /// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
  /// equivalent to `map`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textRotationAlignment(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextRotationAlignment_, value.ref.pointer);
  }

  /// Specifies how to capitalize text.
  ///
  /// The default value of this property is an expression that evaluates to `none`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextTransform` values
  /// Any of the following constant string values:
  /// `none`: The text is not altered.
  /// `uppercase`: Forces all letters to be displayed in uppercase.
  /// `lowercase`: Forces all letters to be displayed in lowercase.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textTransform {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textTransform);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Specifies how to capitalize text.
  ///
  /// The default value of this property is an expression that evaluates to `none`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextTransform` values
  /// Any of the following constant string values:
  /// `none`: The text is not altered.
  /// `uppercase`: Forces all letters to be displayed in uppercase.
  /// `lowercase`: Forces all letters to be displayed in lowercase.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textTransform(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextTransform_, value.ref.pointer);
  }

  /// To increase the chance of placing high-priority labels on the map, you can
  /// provide an array of `textAnchor` locations: the renderer will attempt to place
  /// the label at each location, in order, before moving onto the next label. Use
  /// `textJustify: auto` to choose justification based on anchor position. To apply
  /// an offset, use the `textRadialOffset` or the two-dimensional `textOffset`.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant ``MLNTextAnchor`` array values
  /// Constant array, in which each element is any of the following constant string
  /// values:
  /// `center`: The center of the text is placed closest to the anchor.
  /// `left`: The left side of the text is placed closest to the anchor.
  /// `right`: The right side of the text is placed closest to the anchor.
  /// `top`: The top of the text is placed closest to the anchor.
  /// `bottom`: The bottom of the text is placed closest to the anchor.
  /// `top-left`: The top left corner of the text is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the text is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the text is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the text is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textVariableAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textVariableAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// To increase the chance of placing high-priority labels on the map, you can
  /// provide an array of `textAnchor` locations: the renderer will attempt to place
  /// the label at each location, in order, before moving onto the next label. Use
  /// `textJustify: auto` to choose justification based on anchor position. To apply
  /// an offset, use the `textRadialOffset` or the two-dimensional `textOffset`.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant ``MLNTextAnchor`` array values
  /// Constant array, in which each element is any of the following constant string
  /// values:
  /// `center`: The center of the text is placed closest to the anchor.
  /// `left`: The left side of the text is placed closest to the anchor.
  /// `right`: The right side of the text is placed closest to the anchor.
  /// `top`: The top of the text is placed closest to the anchor.
  /// `bottom`: The bottom of the text is placed closest to the anchor.
  /// `top-left`: The top left corner of the text is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the text is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the text is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the text is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textVariableAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextVariableAnchor_, value.ref.pointer);
  }

  /// To increase the chance of placing high-priority labels on the map, you can
  /// provide an array of `textAnchor` locations, each paired with an offset value.
  /// The renderer will attempt to place the label at each location, in order, before
  /// moving on to the next location+offset. Use `textJustify: auto` to choose
  /// justification based on anchor position.
  ///
  /// The length of the array must be even, and must alternate between enum and
  /// point entries. i.e., each anchor location must be accompanied by a point, and
  /// that point defines the offset when the corresponding anchor location is used.
  /// Positive offset values indicate right and down, while negative values indicate
  /// left and up. Anchor locations may repeat, allowing the renderer to try multiple
  /// offsets to try and place a label using the same anchor.
  ///
  /// When present, this property takes precedence over `textAnchor`,
  /// `textVariableAnchor`, `textOffset`, and `textRadialOffset`.
  ///
  /// ```json
  /// { "text-variable-anchor-offset": ["top", [0, 4], "left", [3,0], "bottom", [1,
  /// 1]] }
  /// ```
  ///
  /// When the renderer chooses the `top` anchor, `[0, 4]` will be used for
  /// `textOffset`; the text will be shifted down by 4 ems.
  ///
  /// When the renderer chooses the `left` anchor, `[3, 0]` will be used for
  /// `textOffset`; the text will be shifted right by 3 ems.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant interleaved `MLNTextAnchor` and `CGVector` array values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textVariableAnchorOffset {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textVariableAnchorOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// To increase the chance of placing high-priority labels on the map, you can
  /// provide an array of `textAnchor` locations, each paired with an offset value.
  /// The renderer will attempt to place the label at each location, in order, before
  /// moving on to the next location+offset. Use `textJustify: auto` to choose
  /// justification based on anchor position.
  ///
  /// The length of the array must be even, and must alternate between enum and
  /// point entries. i.e., each anchor location must be accompanied by a point, and
  /// that point defines the offset when the corresponding anchor location is used.
  /// Positive offset values indicate right and down, while negative values indicate
  /// left and up. Anchor locations may repeat, allowing the renderer to try multiple
  /// offsets to try and place a label using the same anchor.
  ///
  /// When present, this property takes precedence over `textAnchor`,
  /// `textVariableAnchor`, `textOffset`, and `textRadialOffset`.
  ///
  /// ```json
  /// { "text-variable-anchor-offset": ["top", [0, 4], "left", [3,0], "bottom", [1,
  /// 1]] }
  /// ```
  ///
  /// When the renderer chooses the `top` anchor, `[0, 4]` will be used for
  /// `textOffset`; the text will be shifted down by 4 ems.
  ///
  /// When the renderer chooses the `left` anchor, `[3, 0]` will be used for
  /// `textOffset`; the text will be shifted right by 3 ems.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant interleaved `MLNTextAnchor` and `CGVector` array values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textVariableAnchorOffset(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextVariableAnchorOffset_, value.ref.pointer);
  }

  /// The property allows control over a symbol's orientation. Note that the property
  /// values act as a hint, so that a symbol whose language doesn’t support the
  /// provided orientation will be laid out in its natural orientation. Example:
  /// English point symbol will be rendered horizontally even if array value contains
  /// single 'vertical' enum value. The order of elements in an array define priority
  /// order for the placement of an orientation variant.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-writing-mode"><code>text-writing-mode</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant ``MLNTextWritingMode`` array values
  /// Constant array, in which each element is any of the following constant string
  /// values:
  /// `horizontal`: If a text's language supports horizontal writing mode,
  /// symbols with point placement would be laid out horizontally.
  /// `vertical`: If a text's language supports vertical writing mode, symbols
  /// with point placement would be laid out vertically.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textWritingModes {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textWritingModes);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The property allows control over a symbol's orientation. Note that the property
  /// values act as a hint, so that a symbol whose language doesn’t support the
  /// provided orientation will be laid out in its natural orientation. Example:
  /// English point symbol will be rendered horizontally even if array value contains
  /// single 'vertical' enum value. The order of elements in an array define priority
  /// order for the placement of an orientation variant.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-writing-mode"><code>text-writing-mode</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant ``MLNTextWritingMode`` array values
  /// Constant array, in which each element is any of the following constant string
  /// values:
  /// `horizontal`: If a text's language supports horizontal writing mode,
  /// symbols with point placement would be laid out horizontally.
  /// `vertical`: If a text's language supports vertical writing mode, symbols
  /// with point placement would be laid out vertically.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textWritingModes(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextWritingModes_, value.ref.pointer);
  }

  /// textWritingMode
  NSExpression get textWritingMode {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textWritingMode);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextWritingMode:
  set textWritingMode(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextWritingMode_, value.ref.pointer);
  }

  /// The tint color to apply to the icon. The `iconImageName` property must be set
  /// to a template image.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The tint color to apply to the icon. The `iconImageName` property must be set
  /// to a template image.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconColor` property.
  ///
  /// This property corresponds to the `icon-color-transition` property in the style JSON file format.
  MLNTransition get iconColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_iconColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconColor` property.
  ///
  /// This property corresponds to the `icon-color-transition` property in the style JSON file format.
  set iconColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconColorTransition_, value);
  }

  /// Fade out the halo towards the outside.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconHaloBlur {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconHaloBlur);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Fade out the halo towards the outside.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconHaloBlur(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconHaloBlur_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconHaloBlur` property.
  ///
  /// This property corresponds to the `icon-halo-blur-transition` property in the style JSON file format.
  MLNTransition get iconHaloBlurTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconHaloBlurTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_iconHaloBlurTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconHaloBlur` property.
  ///
  /// This property corresponds to the `icon-halo-blur-transition` property in the style JSON file format.
  set iconHaloBlurTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconHaloBlurTransition_, value);
  }

  /// The color of the icon’s halo. The `iconImageName` property must be set to a
  /// template image.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.clearColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconHaloColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconHaloColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color of the icon’s halo. The `iconImageName` property must be set to a
  /// template image.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.clearColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconHaloColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconHaloColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconHaloColor` property.
  ///
  /// This property corresponds to the `icon-halo-color-transition` property in the style JSON file format.
  MLNTransition get iconHaloColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconHaloColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_iconHaloColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconHaloColor` property.
  ///
  /// This property corresponds to the `icon-halo-color-transition` property in the style JSON file format.
  set iconHaloColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconHaloColorTransition_, value);
  }

  /// Distance of halo to the icon outline.
  /// The unit is in points only for SDF sprites that were created with a blur radius
  /// of 8, multiplied by the display density. I.e., the radius needs to be 16 for
  /// `@2x` sprites, etc.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconHaloWidth {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconHaloWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance of halo to the icon outline.
  /// The unit is in points only for SDF sprites that were created with a blur radius
  /// of 8, multiplied by the display density. I.e., the radius needs to be 16 for
  /// `@2x` sprites, etc.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconHaloWidth(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconHaloWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconHaloWidth` property.
  ///
  /// This property corresponds to the `icon-halo-width-transition` property in the style JSON file format.
  MLNTransition get iconHaloWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconHaloWidthTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_iconHaloWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconHaloWidth` property.
  ///
  /// This property corresponds to the `icon-halo-width-transition` property in the style JSON file format.
  set iconHaloWidthTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconHaloWidthTransition_, value);
  }

  /// The opacity at which the icon will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconOpacity {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the icon will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconOpacity` property.
  ///
  /// This property corresponds to the `icon-opacity-transition` property in the style JSON file format.
  MLNTransition get iconOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconOpacityTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_iconOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconOpacity` property.
  ///
  /// This property corresponds to the `icon-opacity-transition` property in the style JSON file format.
  set iconOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconOpacityTransition_, value);
  }

  /// Distance that the icon's anchor is moved from its original placement.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate"><code>icon-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get iconTranslation {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance that the icon's anchor is moved from its original placement.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate"><code>icon-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set iconTranslation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconTranslation` property.
  ///
  /// This property corresponds to the `icon-translate-transition` property in the style JSON file format.
  MLNTransition get iconTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_iconTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconTranslation` property.
  ///
  /// This property corresponds to the `icon-translate-transition` property in the style JSON file format.
  set iconTranslationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconTranslationTransition_, value);
  }

  /// iconTranslate
  NSExpression get iconTranslate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconTranslate:
  set iconTranslate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `iconTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconTranslation` is non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate-anchor"><code>icon-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: Icons are translated relative to the map.
  /// `viewport`: Icons are translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconTranslationAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `iconTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconTranslation` is non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate-anchor"><code>icon-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: Icons are translated relative to the map.
  /// `viewport`: Icons are translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconTranslationAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconTranslationAnchor_, value.ref.pointer);
  }

  /// iconTranslateAnchor
  NSExpression get iconTranslateAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_iconTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconTranslateAnchor:
  set iconTranslateAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setIconTranslateAnchor_, value.ref.pointer);
  }

  /// The color with which the text will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color with which the text will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textColor` property.
  ///
  /// This property corresponds to the `text-color-transition` property in the style JSON file format.
  MLNTransition get textColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_textColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textColor` property.
  ///
  /// This property corresponds to the `text-color-transition` property in the style JSON file format.
  set textColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextColorTransition_, value);
  }

  /// The halo's fadeout distance towards the outside.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textHaloBlur {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textHaloBlur);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The halo's fadeout distance towards the outside.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textHaloBlur(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextHaloBlur_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textHaloBlur` property.
  ///
  /// This property corresponds to the `text-halo-blur-transition` property in the style JSON file format.
  MLNTransition get textHaloBlurTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textHaloBlurTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_textHaloBlurTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textHaloBlur` property.
  ///
  /// This property corresponds to the `text-halo-blur-transition` property in the style JSON file format.
  set textHaloBlurTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextHaloBlurTransition_, value);
  }

  /// The color of the text's halo, which helps it stand out from backgrounds.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.clearColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textHaloColor {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textHaloColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color of the text's halo, which helps it stand out from backgrounds.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `NSColor.clearColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `NSColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textHaloColor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextHaloColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textHaloColor` property.
  ///
  /// This property corresponds to the `text-halo-color-transition` property in the style JSON file format.
  MLNTransition get textHaloColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textHaloColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_textHaloColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textHaloColor` property.
  ///
  /// This property corresponds to the `text-halo-color-transition` property in the style JSON file format.
  set textHaloColorTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextHaloColorTransition_, value);
  }

  /// Distance of halo to the font outline. Max text halo width is 1/4 of the
  /// font-size.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textHaloWidth {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textHaloWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance of halo to the font outline. Max text halo width is 1/4 of the
  /// font-size.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textHaloWidth(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextHaloWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textHaloWidth` property.
  ///
  /// This property corresponds to the `text-halo-width-transition` property in the style JSON file format.
  MLNTransition get textHaloWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textHaloWidthTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_textHaloWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textHaloWidth` property.
  ///
  /// This property corresponds to the `text-halo-width-transition` property in the style JSON file format.
  set textHaloWidthTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextHaloWidthTransition_, value);
  }

  /// The opacity at which the text will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textOpacity {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the text will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textOpacity(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textOpacity` property.
  ///
  /// This property corresponds to the `text-opacity-transition` property in the style JSON file format.
  MLNTransition get textOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textOpacityTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_textOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textOpacity` property.
  ///
  /// This property corresponds to the `text-opacity-transition` property in the style JSON file format.
  set textOpacityTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextOpacityTransition_, value);
  }

  /// Distance that the text's anchor is moved from its original placement.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate"><code>text-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get textTranslation {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance that the text's anchor is moved from its original placement.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points upward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate"><code>text-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set textTranslation(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textTranslation` property.
  ///
  /// This property corresponds to the `text-translate-transition` property in the style JSON file format.
  MLNTransition get textTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_textTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textTranslation` property.
  ///
  /// This property corresponds to the `text-translate-transition` property in the style JSON file format.
  set textTranslationTransition(MLNTransition value) {
    return _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextTranslationTransition_, value);
  }

  /// textTranslate
  NSExpression get textTranslate {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_textTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextTranslate:
  set textTranslate(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `textTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textTranslation` is non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate-anchor"><code>text-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The text is translated relative to the map.
  /// `viewport`: The text is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textTranslationAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `textTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textTranslation` is non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate-anchor"><code>text-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The text is translated relative to the map.
  /// `viewport`: The text is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textTranslationAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextTranslationAnchor_, value.ref.pointer);
  }

  /// textTranslateAnchor
  NSExpression get textTranslateAnchor {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.pointer, _sel_textTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextTranslateAnchor:
  set textTranslateAnchor(NSExpression value) {
    return _objc_msgSend_1jdvcbf(
        this.ref.pointer, _sel_setTextTranslateAnchor_, value.ref.pointer);
  }

  /// init
  MLNSymbolStyleLayer init() {
    final _ret =
        _objc_msgSend_1x359cv(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNSymbolStyleLayer new1() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNSymbolStyleLayer, _sel_new);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNSymbolStyleLayer allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_hzlb60(
        _class_MLNSymbolStyleLayer, _sel_allocWithZone_, zone);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNSymbolStyleLayer alloc() {
    final _ret = _objc_msgSend_1x359cv(_class_MLNSymbolStyleLayer, _sel_alloc);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNSymbolStyleLayer self() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_self);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNSymbolStyleLayer retain() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_retain);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNSymbolStyleLayer autorelease() {
    final _ret = _objc_msgSend_1x359cv(this.ref.pointer, _sel_autorelease);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }
}

enum NSBackingStoreType {
  NSBackingStoreRetained(0),
  NSBackingStoreNonretained(1),
  NSBackingStoreBuffered(2);

  final int value;
  const NSBackingStoreType(this.value);

  static NSBackingStoreType fromValue(int value) => switch (value) {
        0 => NSBackingStoreRetained,
        1 => NSBackingStoreNonretained,
        2 => NSBackingStoreBuffered,
        _ =>
          throw ArgumentError("Unknown value for NSBackingStoreType: $value"),
      };
}

enum NSWindowOrderingMode {
  NSWindowAbove(1),
  NSWindowBelow(-1),
  NSWindowOut(0);

  final int value;
  const NSWindowOrderingMode(this.value);

  static NSWindowOrderingMode fromValue(int value) => switch (value) {
        1 => NSWindowAbove,
        -1 => NSWindowBelow,
        0 => NSWindowOut,
        _ =>
          throw ArgumentError("Unknown value for NSWindowOrderingMode: $value"),
      };
}

enum NSFocusRingType {
  NSFocusRingTypeDefault(0),
  NSFocusRingTypeNone(1),
  NSFocusRingTypeExterior(2);

  final int value;
  const NSFocusRingType(this.value);

  static NSFocusRingType fromValue(int value) => switch (value) {
        0 => NSFocusRingTypeDefault,
        1 => NSFocusRingTypeNone,
        2 => NSFocusRingTypeExterior,
        _ => throw ArgumentError("Unknown value for NSFocusRingType: $value"),
      };
}

enum NSColorRenderingIntent {
  NSColorRenderingIntentDefault(0),
  NSColorRenderingIntentAbsoluteColorimetric(1),
  NSColorRenderingIntentRelativeColorimetric(2),
  NSColorRenderingIntentPerceptual(3),
  NSColorRenderingIntentSaturation(4);

  final int value;
  const NSColorRenderingIntent(this.value);

  static NSColorRenderingIntent fromValue(int value) => switch (value) {
        0 => NSColorRenderingIntentDefault,
        1 => NSColorRenderingIntentAbsoluteColorimetric,
        2 => NSColorRenderingIntentRelativeColorimetric,
        3 => NSColorRenderingIntentPerceptual,
        4 => NSColorRenderingIntentSaturation,
        _ => throw ArgumentError(
            "Unknown value for NSColorRenderingIntent: $value"),
      };
}

enum NSWindowDepth {
  NSWindowDepthTwentyfourBitRGB(520),
  NSWindowDepthSixtyfourBitRGB(528),
  NSWindowDepthOnehundredtwentyeightBitRGB(544);

  final int value;
  const NSWindowDepth(this.value);

  static NSWindowDepth fromValue(int value) => switch (value) {
        520 => NSWindowDepthTwentyfourBitRGB,
        528 => NSWindowDepthSixtyfourBitRGB,
        544 => NSWindowDepthOnehundredtwentyeightBitRGB,
        _ => throw ArgumentError("Unknown value for NSWindowDepth: $value"),
      };
}

enum NSDisplayGamut {
  NSDisplayGamutSRGB(1),
  NSDisplayGamutP3(2);

  final int value;
  const NSDisplayGamut(this.value);

  static NSDisplayGamut fromValue(int value) => switch (value) {
        1 => NSDisplayGamutSRGB,
        2 => NSDisplayGamutP3,
        _ => throw ArgumentError("Unknown value for NSDisplayGamut: $value"),
      };
}

enum NSImageInterpolation {
  NSImageInterpolationDefault(0),
  NSImageInterpolationNone(1),
  NSImageInterpolationLow(2),
  NSImageInterpolationMedium(4),
  NSImageInterpolationHigh(3);

  final int value;
  const NSImageInterpolation(this.value);

  static NSImageInterpolation fromValue(int value) => switch (value) {
        0 => NSImageInterpolationDefault,
        1 => NSImageInterpolationNone,
        2 => NSImageInterpolationLow,
        4 => NSImageInterpolationMedium,
        3 => NSImageInterpolationHigh,
        _ =>
          throw ArgumentError("Unknown value for NSImageInterpolation: $value"),
      };
}

enum NSAccessibilityOrientation {
  NSAccessibilityOrientationUnknown(0),
  NSAccessibilityOrientationVertical(1),
  NSAccessibilityOrientationHorizontal(2);

  final int value;
  const NSAccessibilityOrientation(this.value);

  static NSAccessibilityOrientation fromValue(int value) => switch (value) {
        0 => NSAccessibilityOrientationUnknown,
        1 => NSAccessibilityOrientationVertical,
        2 => NSAccessibilityOrientationHorizontal,
        _ => throw ArgumentError(
            "Unknown value for NSAccessibilityOrientation: $value"),
      };
}

enum NSAccessibilitySortDirection {
  NSAccessibilitySortDirectionUnknown(0),
  NSAccessibilitySortDirectionAscending(1),
  NSAccessibilitySortDirectionDescending(2);

  final int value;
  const NSAccessibilitySortDirection(this.value);

  static NSAccessibilitySortDirection fromValue(int value) => switch (value) {
        0 => NSAccessibilitySortDirectionUnknown,
        1 => NSAccessibilitySortDirectionAscending,
        2 => NSAccessibilitySortDirectionDescending,
        _ => throw ArgumentError(
            "Unknown value for NSAccessibilitySortDirection: $value"),
      };
}

enum NSAccessibilityRulerMarkerType {
  NSAccessibilityRulerMarkerTypeUnknown(0),
  NSAccessibilityRulerMarkerTypeTabStopLeft(1),
  NSAccessibilityRulerMarkerTypeTabStopRight(2),
  NSAccessibilityRulerMarkerTypeTabStopCenter(3),
  NSAccessibilityRulerMarkerTypeTabStopDecimal(4),
  NSAccessibilityRulerMarkerTypeIndentHead(5),
  NSAccessibilityRulerMarkerTypeIndentTail(6),
  NSAccessibilityRulerMarkerTypeIndentFirstLine(7);

  final int value;
  const NSAccessibilityRulerMarkerType(this.value);

  static NSAccessibilityRulerMarkerType fromValue(int value) => switch (value) {
        0 => NSAccessibilityRulerMarkerTypeUnknown,
        1 => NSAccessibilityRulerMarkerTypeTabStopLeft,
        2 => NSAccessibilityRulerMarkerTypeTabStopRight,
        3 => NSAccessibilityRulerMarkerTypeTabStopCenter,
        4 => NSAccessibilityRulerMarkerTypeTabStopDecimal,
        5 => NSAccessibilityRulerMarkerTypeIndentHead,
        6 => NSAccessibilityRulerMarkerTypeIndentTail,
        7 => NSAccessibilityRulerMarkerTypeIndentFirstLine,
        _ => throw ArgumentError(
            "Unknown value for NSAccessibilityRulerMarkerType: $value"),
      };
}

enum NSAccessibilityUnits {
  NSAccessibilityUnitsUnknown(0),
  NSAccessibilityUnitsInches(1),
  NSAccessibilityUnitsCentimeters(2),
  NSAccessibilityUnitsPoints(3),
  NSAccessibilityUnitsPicas(4);

  final int value;
  const NSAccessibilityUnits(this.value);

  static NSAccessibilityUnits fromValue(int value) => switch (value) {
        0 => NSAccessibilityUnitsUnknown,
        1 => NSAccessibilityUnitsInches,
        2 => NSAccessibilityUnitsCentimeters,
        3 => NSAccessibilityUnitsPoints,
        4 => NSAccessibilityUnitsPicas,
        _ =>
          throw ArgumentError("Unknown value for NSAccessibilityUnits: $value"),
      };
}

enum NSTouchPhase {
  NSTouchPhaseBegan(1),
  NSTouchPhaseMoved(2),
  NSTouchPhaseStationary(4),
  NSTouchPhaseEnded(8),
  NSTouchPhaseCancelled(16),
  NSTouchPhaseTouching(7),
  NSTouchPhaseAny(-1);

  final int value;
  const NSTouchPhase(this.value);

  static NSTouchPhase fromValue(int value) => switch (value) {
        1 => NSTouchPhaseBegan,
        2 => NSTouchPhaseMoved,
        4 => NSTouchPhaseStationary,
        8 => NSTouchPhaseEnded,
        16 => NSTouchPhaseCancelled,
        7 => NSTouchPhaseTouching,
        -1 => NSTouchPhaseAny,
        _ => throw ArgumentError("Unknown value for NSTouchPhase: $value"),
      };
}

enum NSTouchType {
  NSTouchTypeDirect(0),
  NSTouchTypeIndirect(1);

  final int value;
  const NSTouchType(this.value);

  static NSTouchType fromValue(int value) => switch (value) {
        0 => NSTouchTypeDirect,
        1 => NSTouchTypeIndirect,
        _ => throw ArgumentError("Unknown value for NSTouchType: $value"),
      };
}

enum NSTouchTypeMask {
  NSTouchTypeMaskDirect(1),
  NSTouchTypeMaskIndirect(2);

  final int value;
  const NSTouchTypeMask(this.value);

  static NSTouchTypeMask fromValue(int value) => switch (value) {
        1 => NSTouchTypeMaskDirect,
        2 => NSTouchTypeMaskIndirect,
        _ => throw ArgumentError("Unknown value for NSTouchTypeMask: $value"),
      };
}

final class CGImageSource extends ffi.Opaque {}

enum CGImagePropertyOrientation {
  kCGImagePropertyOrientationUp(1),
  kCGImagePropertyOrientationUpMirrored(2),
  kCGImagePropertyOrientationDown(3),
  kCGImagePropertyOrientationDownMirrored(4),
  kCGImagePropertyOrientationLeftMirrored(5),
  kCGImagePropertyOrientationRight(6),
  kCGImagePropertyOrientationRightMirrored(7),
  kCGImagePropertyOrientationLeft(8);

  final int value;
  const CGImagePropertyOrientation(this.value);

  static CGImagePropertyOrientation fromValue(int value) => switch (value) {
        1 => kCGImagePropertyOrientationUp,
        2 => kCGImagePropertyOrientationUpMirrored,
        3 => kCGImagePropertyOrientationDown,
        4 => kCGImagePropertyOrientationDownMirrored,
        5 => kCGImagePropertyOrientationLeftMirrored,
        6 => kCGImagePropertyOrientationRight,
        7 => kCGImagePropertyOrientationRightMirrored,
        8 => kCGImagePropertyOrientationLeft,
        _ => throw ArgumentError(
            "Unknown value for CGImagePropertyOrientation: $value"),
      };
}

enum NSEventType {
  NSEventTypeLeftMouseDown(1),
  NSEventTypeLeftMouseUp(2),
  NSEventTypeRightMouseDown(3),
  NSEventTypeRightMouseUp(4),
  NSEventTypeMouseMoved(5),
  NSEventTypeLeftMouseDragged(6),
  NSEventTypeRightMouseDragged(7),
  NSEventTypeMouseEntered(8),
  NSEventTypeMouseExited(9),
  NSEventTypeKeyDown(10),
  NSEventTypeKeyUp(11),
  NSEventTypeFlagsChanged(12),
  NSEventTypeAppKitDefined(13),
  NSEventTypeSystemDefined(14),
  NSEventTypeApplicationDefined(15),
  NSEventTypePeriodic(16),
  NSEventTypeCursorUpdate(17),
  NSEventTypeScrollWheel(22),
  NSEventTypeTabletPoint(23),
  NSEventTypeTabletProximity(24),
  NSEventTypeOtherMouseDown(25),
  NSEventTypeOtherMouseUp(26),
  NSEventTypeOtherMouseDragged(27),
  NSEventTypeGesture(29),
  NSEventTypeMagnify(30),
  NSEventTypeSwipe(31),
  NSEventTypeRotate(18),
  NSEventTypeBeginGesture(19),
  NSEventTypeEndGesture(20),
  NSEventTypeSmartMagnify(32),
  NSEventTypeQuickLook(33),
  NSEventTypePressure(34),
  NSEventTypeDirectTouch(37),
  NSEventTypeChangeMode(38);

  final int value;
  const NSEventType(this.value);

  static NSEventType fromValue(int value) => switch (value) {
        1 => NSEventTypeLeftMouseDown,
        2 => NSEventTypeLeftMouseUp,
        3 => NSEventTypeRightMouseDown,
        4 => NSEventTypeRightMouseUp,
        5 => NSEventTypeMouseMoved,
        6 => NSEventTypeLeftMouseDragged,
        7 => NSEventTypeRightMouseDragged,
        8 => NSEventTypeMouseEntered,
        9 => NSEventTypeMouseExited,
        10 => NSEventTypeKeyDown,
        11 => NSEventTypeKeyUp,
        12 => NSEventTypeFlagsChanged,
        13 => NSEventTypeAppKitDefined,
        14 => NSEventTypeSystemDefined,
        15 => NSEventTypeApplicationDefined,
        16 => NSEventTypePeriodic,
        17 => NSEventTypeCursorUpdate,
        22 => NSEventTypeScrollWheel,
        23 => NSEventTypeTabletPoint,
        24 => NSEventTypeTabletProximity,
        25 => NSEventTypeOtherMouseDown,
        26 => NSEventTypeOtherMouseUp,
        27 => NSEventTypeOtherMouseDragged,
        29 => NSEventTypeGesture,
        30 => NSEventTypeMagnify,
        31 => NSEventTypeSwipe,
        18 => NSEventTypeRotate,
        19 => NSEventTypeBeginGesture,
        20 => NSEventTypeEndGesture,
        32 => NSEventTypeSmartMagnify,
        33 => NSEventTypeQuickLook,
        34 => NSEventTypePressure,
        37 => NSEventTypeDirectTouch,
        38 => NSEventTypeChangeMode,
        _ => throw ArgumentError("Unknown value for NSEventType: $value"),
      };
}

enum NSEventMask {
  NSEventMaskLeftMouseDown(2),
  NSEventMaskLeftMouseUp(4),
  NSEventMaskRightMouseDown(8),
  NSEventMaskRightMouseUp(16),
  NSEventMaskMouseMoved(32),
  NSEventMaskLeftMouseDragged(64),
  NSEventMaskRightMouseDragged(128),
  NSEventMaskMouseEntered(256),
  NSEventMaskMouseExited(512),
  NSEventMaskKeyDown(1024),
  NSEventMaskKeyUp(2048),
  NSEventMaskFlagsChanged(4096),
  NSEventMaskAppKitDefined(8192),
  NSEventMaskSystemDefined(16384),
  NSEventMaskApplicationDefined(32768),
  NSEventMaskPeriodic(65536),
  NSEventMaskCursorUpdate(131072),
  NSEventMaskScrollWheel(4194304),
  NSEventMaskTabletPoint(8388608),
  NSEventMaskTabletProximity(16777216),
  NSEventMaskOtherMouseDown(33554432),
  NSEventMaskOtherMouseUp(67108864),
  NSEventMaskOtherMouseDragged(134217728),
  NSEventMaskGesture(536870912),
  NSEventMaskMagnify(1073741824),
  NSEventMaskSwipe(2147483648),
  NSEventMaskRotate(262144),
  NSEventMaskBeginGesture(524288),
  NSEventMaskEndGesture(1048576),
  NSEventMaskSmartMagnify(4294967296),
  NSEventMaskPressure(17179869184),
  NSEventMaskDirectTouch(137438953472),
  NSEventMaskChangeMode(274877906944),
  NSEventMaskAny(-1);

  final int value;
  const NSEventMask(this.value);

  static NSEventMask fromValue(int value) => switch (value) {
        2 => NSEventMaskLeftMouseDown,
        4 => NSEventMaskLeftMouseUp,
        8 => NSEventMaskRightMouseDown,
        16 => NSEventMaskRightMouseUp,
        32 => NSEventMaskMouseMoved,
        64 => NSEventMaskLeftMouseDragged,
        128 => NSEventMaskRightMouseDragged,
        256 => NSEventMaskMouseEntered,
        512 => NSEventMaskMouseExited,
        1024 => NSEventMaskKeyDown,
        2048 => NSEventMaskKeyUp,
        4096 => NSEventMaskFlagsChanged,
        8192 => NSEventMaskAppKitDefined,
        16384 => NSEventMaskSystemDefined,
        32768 => NSEventMaskApplicationDefined,
        65536 => NSEventMaskPeriodic,
        131072 => NSEventMaskCursorUpdate,
        4194304 => NSEventMaskScrollWheel,
        8388608 => NSEventMaskTabletPoint,
        16777216 => NSEventMaskTabletProximity,
        33554432 => NSEventMaskOtherMouseDown,
        67108864 => NSEventMaskOtherMouseUp,
        134217728 => NSEventMaskOtherMouseDragged,
        536870912 => NSEventMaskGesture,
        1073741824 => NSEventMaskMagnify,
        2147483648 => NSEventMaskSwipe,
        262144 => NSEventMaskRotate,
        524288 => NSEventMaskBeginGesture,
        1048576 => NSEventMaskEndGesture,
        4294967296 => NSEventMaskSmartMagnify,
        17179869184 => NSEventMaskPressure,
        137438953472 => NSEventMaskDirectTouch,
        274877906944 => NSEventMaskChangeMode,
        -1 => NSEventMaskAny,
        _ => throw ArgumentError("Unknown value for NSEventMask: $value"),
      };
}

enum NSEventModifierFlags {
  NSEventModifierFlagCapsLock(65536),
  NSEventModifierFlagShift(131072),
  NSEventModifierFlagControl(262144),
  NSEventModifierFlagOption(524288),
  NSEventModifierFlagCommand(1048576),
  NSEventModifierFlagNumericPad(2097152),
  NSEventModifierFlagHelp(4194304),
  NSEventModifierFlagFunction(8388608),
  NSEventModifierFlagDeviceIndependentFlagsMask(4294901760);

  final int value;
  const NSEventModifierFlags(this.value);

  static NSEventModifierFlags fromValue(int value) => switch (value) {
        65536 => NSEventModifierFlagCapsLock,
        131072 => NSEventModifierFlagShift,
        262144 => NSEventModifierFlagControl,
        524288 => NSEventModifierFlagOption,
        1048576 => NSEventModifierFlagCommand,
        2097152 => NSEventModifierFlagNumericPad,
        4194304 => NSEventModifierFlagHelp,
        8388608 => NSEventModifierFlagFunction,
        4294901760 => NSEventModifierFlagDeviceIndependentFlagsMask,
        _ =>
          throw ArgumentError("Unknown value for NSEventModifierFlags: $value"),
      };
}

enum NSPointingDeviceType {
  NSPointingDeviceTypeUnknown(0),
  NSPointingDeviceTypePen(1),
  NSPointingDeviceTypeCursor(2),
  NSPointingDeviceTypeEraser(3);

  final int value;
  const NSPointingDeviceType(this.value);

  static NSPointingDeviceType fromValue(int value) => switch (value) {
        0 => NSPointingDeviceTypeUnknown,
        1 => NSPointingDeviceTypePen,
        2 => NSPointingDeviceTypeCursor,
        3 => NSPointingDeviceTypeEraser,
        _ =>
          throw ArgumentError("Unknown value for NSPointingDeviceType: $value"),
      };
}

enum NSEventButtonMask {
  NSEventButtonMaskPenTip(1),
  NSEventButtonMaskPenLowerSide(2),
  NSEventButtonMaskPenUpperSide(4);

  final int value;
  const NSEventButtonMask(this.value);

  static NSEventButtonMask fromValue(int value) => switch (value) {
        1 => NSEventButtonMaskPenTip,
        2 => NSEventButtonMaskPenLowerSide,
        4 => NSEventButtonMaskPenUpperSide,
        _ => throw ArgumentError("Unknown value for NSEventButtonMask: $value"),
      };
}

enum NSEventPhase {
  NSEventPhaseNone(0),
  NSEventPhaseBegan(1),
  NSEventPhaseStationary(2),
  NSEventPhaseChanged(4),
  NSEventPhaseEnded(8),
  NSEventPhaseCancelled(16),
  NSEventPhaseMayBegin(32);

  final int value;
  const NSEventPhase(this.value);

  static NSEventPhase fromValue(int value) => switch (value) {
        0 => NSEventPhaseNone,
        1 => NSEventPhaseBegan,
        2 => NSEventPhaseStationary,
        4 => NSEventPhaseChanged,
        8 => NSEventPhaseEnded,
        16 => NSEventPhaseCancelled,
        32 => NSEventPhaseMayBegin,
        _ => throw ArgumentError("Unknown value for NSEventPhase: $value"),
      };
}

enum NSEventGestureAxis {
  NSEventGestureAxisNone(0),
  NSEventGestureAxisHorizontal(1),
  NSEventGestureAxisVertical(2);

  final int value;
  const NSEventGestureAxis(this.value);

  static NSEventGestureAxis fromValue(int value) => switch (value) {
        0 => NSEventGestureAxisNone,
        1 => NSEventGestureAxisHorizontal,
        2 => NSEventGestureAxisVertical,
        _ =>
          throw ArgumentError("Unknown value for NSEventGestureAxis: $value"),
      };
}

enum NSEventSwipeTrackingOptions {
  NSEventSwipeTrackingLockDirection(1),
  NSEventSwipeTrackingClampGestureAmount(2);

  final int value;
  const NSEventSwipeTrackingOptions(this.value);

  static NSEventSwipeTrackingOptions fromValue(int value) => switch (value) {
        1 => NSEventSwipeTrackingLockDirection,
        2 => NSEventSwipeTrackingClampGestureAmount,
        _ => throw ArgumentError(
            "Unknown value for NSEventSwipeTrackingOptions: $value"),
      };
}

enum NSEventSubtype {
  NSEventSubtypeWindowExposed(0),
  NSEventSubtypeApplicationActivated(1),
  NSEventSubtypeApplicationDeactivated(2),
  NSEventSubtypeWindowMoved(4),
  NSEventSubtypeScreenChanged(8),
  NSEventSubtypeTouch(3);

  static const NSEventSubtypePowerOff = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeMouseEvent = NSEventSubtypeWindowExposed;
  static const NSEventSubtypeTabletPoint = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeTabletProximity =
      NSEventSubtypeApplicationDeactivated;

  final int value;
  const NSEventSubtype(this.value);

  static NSEventSubtype fromValue(int value) => switch (value) {
        0 => NSEventSubtypeWindowExposed,
        1 => NSEventSubtypeApplicationActivated,
        2 => NSEventSubtypeApplicationDeactivated,
        4 => NSEventSubtypeWindowMoved,
        8 => NSEventSubtypeScreenChanged,
        3 => NSEventSubtypeTouch,
        _ => throw ArgumentError("Unknown value for NSEventSubtype: $value"),
      };

  @override
  String toString() {
    if (this == NSEventSubtypeWindowExposed)
      return "NSEventSubtype.NSEventSubtypeWindowExposed, NSEventSubtype.NSEventSubtypeMouseEvent";
    if (this == NSEventSubtypeApplicationActivated)
      return "NSEventSubtype.NSEventSubtypeApplicationActivated, NSEventSubtype.NSEventSubtypePowerOff, NSEventSubtype.NSEventSubtypeTabletPoint";
    if (this == NSEventSubtypeApplicationDeactivated)
      return "NSEventSubtype.NSEventSubtypeApplicationDeactivated, NSEventSubtype.NSEventSubtypeTabletProximity";
    return super.toString();
  }
}

enum NSPressureBehavior {
  NSPressureBehaviorUnknown(-1),
  NSPressureBehaviorPrimaryDefault(0),
  NSPressureBehaviorPrimaryClick(1),
  NSPressureBehaviorPrimaryGeneric(2),
  NSPressureBehaviorPrimaryAccelerator(3),
  NSPressureBehaviorPrimaryDeepClick(5),
  NSPressureBehaviorPrimaryDeepDrag(6);

  final int value;
  const NSPressureBehavior(this.value);

  static NSPressureBehavior fromValue(int value) => switch (value) {
        -1 => NSPressureBehaviorUnknown,
        0 => NSPressureBehaviorPrimaryDefault,
        1 => NSPressureBehaviorPrimaryClick,
        2 => NSPressureBehaviorPrimaryGeneric,
        3 => NSPressureBehaviorPrimaryAccelerator,
        5 => NSPressureBehaviorPrimaryDeepClick,
        6 => NSPressureBehaviorPrimaryDeepDrag,
        _ =>
          throw ArgumentError("Unknown value for NSPressureBehavior: $value"),
      };
}

enum NSPasteboardContentsOptions {
  NSPasteboardContentsCurrentHostOnly(1);

  final int value;
  const NSPasteboardContentsOptions(this.value);

  static NSPasteboardContentsOptions fromValue(int value) => switch (value) {
        1 => NSPasteboardContentsCurrentHostOnly,
        _ => throw ArgumentError(
            "Unknown value for NSPasteboardContentsOptions: $value"),
      };
}

enum NSAnimationCurve {
  NSAnimationEaseInOut(0),
  NSAnimationEaseIn(1),
  NSAnimationEaseOut(2),
  NSAnimationLinear(3);

  final int value;
  const NSAnimationCurve(this.value);

  static NSAnimationCurve fromValue(int value) => switch (value) {
        0 => NSAnimationEaseInOut,
        1 => NSAnimationEaseIn,
        2 => NSAnimationEaseOut,
        3 => NSAnimationLinear,
        _ => throw ArgumentError("Unknown value for NSAnimationCurve: $value"),
      };
}

enum NSAnimationBlockingMode {
  NSAnimationBlocking(0),
  NSAnimationNonblocking(1),
  NSAnimationNonblockingThreaded(2);

  final int value;
  const NSAnimationBlockingMode(this.value);

  static NSAnimationBlockingMode fromValue(int value) => switch (value) {
        0 => NSAnimationBlocking,
        1 => NSAnimationNonblocking,
        2 => NSAnimationNonblockingThreaded,
        _ => throw ArgumentError(
            "Unknown value for NSAnimationBlockingMode: $value"),
      };
}

enum NSDragOperation {
  NSDragOperationNone(0),
  NSDragOperationCopy(1),
  NSDragOperationLink(2),
  NSDragOperationGeneric(4),
  NSDragOperationPrivate(8),
  NSDragOperationMove(16),
  NSDragOperationDelete(32),
  NSDragOperationEvery(-1),
  NSDragOperationAll_Obsolete(15);

  static const NSDragOperationAll = NSDragOperationAll_Obsolete;

  final int value;
  const NSDragOperation(this.value);

  static NSDragOperation fromValue(int value) => switch (value) {
        0 => NSDragOperationNone,
        1 => NSDragOperationCopy,
        2 => NSDragOperationLink,
        4 => NSDragOperationGeneric,
        8 => NSDragOperationPrivate,
        16 => NSDragOperationMove,
        32 => NSDragOperationDelete,
        -1 => NSDragOperationEvery,
        15 => NSDragOperationAll_Obsolete,
        _ => throw ArgumentError("Unknown value for NSDragOperation: $value"),
      };

  @override
  String toString() {
    if (this == NSDragOperationAll_Obsolete)
      return "NSDragOperation.NSDragOperationAll_Obsolete, NSDragOperation.NSDragOperationAll";
    return super.toString();
  }
}

enum NSDraggingFormation {
  NSDraggingFormationDefault(0),
  NSDraggingFormationNone(1),
  NSDraggingFormationPile(2),
  NSDraggingFormationList(3),
  NSDraggingFormationStack(4);

  final int value;
  const NSDraggingFormation(this.value);

  static NSDraggingFormation fromValue(int value) => switch (value) {
        0 => NSDraggingFormationDefault,
        1 => NSDraggingFormationNone,
        2 => NSDraggingFormationPile,
        3 => NSDraggingFormationList,
        4 => NSDraggingFormationStack,
        _ =>
          throw ArgumentError("Unknown value for NSDraggingFormation: $value"),
      };
}

enum NSDraggingContext {
  NSDraggingContextOutsideApplication(0),
  NSDraggingContextWithinApplication(1);

  final int value;
  const NSDraggingContext(this.value);

  static NSDraggingContext fromValue(int value) => switch (value) {
        0 => NSDraggingContextOutsideApplication,
        1 => NSDraggingContextWithinApplication,
        _ => throw ArgumentError("Unknown value for NSDraggingContext: $value"),
      };
}

enum NSDraggingItemEnumerationOptions {
  NSDraggingItemEnumerationConcurrent(1),
  NSDraggingItemEnumerationClearNonenumeratedImages(65536);

  final int value;
  const NSDraggingItemEnumerationOptions(this.value);

  static NSDraggingItemEnumerationOptions fromValue(int value) =>
      switch (value) {
        1 => NSDraggingItemEnumerationConcurrent,
        65536 => NSDraggingItemEnumerationClearNonenumeratedImages,
        _ => throw ArgumentError(
            "Unknown value for NSDraggingItemEnumerationOptions: $value"),
      };
}

enum NSUserInterfaceLayoutDirection {
  NSUserInterfaceLayoutDirectionLeftToRight(0),
  NSUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const NSUserInterfaceLayoutDirection(this.value);

  static NSUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
        0 => NSUserInterfaceLayoutDirectionLeftToRight,
        1 => NSUserInterfaceLayoutDirectionRightToLeft,
        _ => throw ArgumentError(
            "Unknown value for NSUserInterfaceLayoutDirection: $value"),
      };
}

enum NSAutoresizingMaskOptions {
  NSViewNotSizable(0),
  NSViewMinXMargin(1),
  NSViewWidthSizable(2),
  NSViewMaxXMargin(4),
  NSViewMinYMargin(8),
  NSViewHeightSizable(16),
  NSViewMaxYMargin(32);

  final int value;
  const NSAutoresizingMaskOptions(this.value);

  static NSAutoresizingMaskOptions fromValue(int value) => switch (value) {
        0 => NSViewNotSizable,
        1 => NSViewMinXMargin,
        2 => NSViewWidthSizable,
        4 => NSViewMaxXMargin,
        8 => NSViewMinYMargin,
        16 => NSViewHeightSizable,
        32 => NSViewMaxYMargin,
        _ => throw ArgumentError(
            "Unknown value for NSAutoresizingMaskOptions: $value"),
      };
}

enum NSBorderType {
  NSNoBorder(0),
  NSLineBorder(1),
  NSBezelBorder(2),
  NSGrooveBorder(3);

  final int value;
  const NSBorderType(this.value);

  static NSBorderType fromValue(int value) => switch (value) {
        0 => NSNoBorder,
        1 => NSLineBorder,
        2 => NSBezelBorder,
        3 => NSGrooveBorder,
        _ => throw ArgumentError("Unknown value for NSBorderType: $value"),
      };
}

enum NSViewLayerContentsRedrawPolicy {
  NSViewLayerContentsRedrawNever(0),
  NSViewLayerContentsRedrawOnSetNeedsDisplay(1),
  NSViewLayerContentsRedrawDuringViewResize(2),
  NSViewLayerContentsRedrawBeforeViewResize(3),
  NSViewLayerContentsRedrawCrossfade(4);

  final int value;
  const NSViewLayerContentsRedrawPolicy(this.value);

  static NSViewLayerContentsRedrawPolicy fromValue(int value) =>
      switch (value) {
        0 => NSViewLayerContentsRedrawNever,
        1 => NSViewLayerContentsRedrawOnSetNeedsDisplay,
        2 => NSViewLayerContentsRedrawDuringViewResize,
        3 => NSViewLayerContentsRedrawBeforeViewResize,
        4 => NSViewLayerContentsRedrawCrossfade,
        _ => throw ArgumentError(
            "Unknown value for NSViewLayerContentsRedrawPolicy: $value"),
      };
}

enum NSViewLayerContentsPlacement {
  NSViewLayerContentsPlacementScaleAxesIndependently(0),
  NSViewLayerContentsPlacementScaleProportionallyToFit(1),
  NSViewLayerContentsPlacementScaleProportionallyToFill(2),
  NSViewLayerContentsPlacementCenter(3),
  NSViewLayerContentsPlacementTop(4),
  NSViewLayerContentsPlacementTopRight(5),
  NSViewLayerContentsPlacementRight(6),
  NSViewLayerContentsPlacementBottomRight(7),
  NSViewLayerContentsPlacementBottom(8),
  NSViewLayerContentsPlacementBottomLeft(9),
  NSViewLayerContentsPlacementLeft(10),
  NSViewLayerContentsPlacementTopLeft(11);

  final int value;
  const NSViewLayerContentsPlacement(this.value);

  static NSViewLayerContentsPlacement fromValue(int value) => switch (value) {
        0 => NSViewLayerContentsPlacementScaleAxesIndependently,
        1 => NSViewLayerContentsPlacementScaleProportionallyToFit,
        2 => NSViewLayerContentsPlacementScaleProportionallyToFill,
        3 => NSViewLayerContentsPlacementCenter,
        4 => NSViewLayerContentsPlacementTop,
        5 => NSViewLayerContentsPlacementTopRight,
        6 => NSViewLayerContentsPlacementRight,
        7 => NSViewLayerContentsPlacementBottomRight,
        8 => NSViewLayerContentsPlacementBottom,
        9 => NSViewLayerContentsPlacementBottomLeft,
        10 => NSViewLayerContentsPlacementLeft,
        11 => NSViewLayerContentsPlacementTopLeft,
        _ => throw ArgumentError(
            "Unknown value for NSViewLayerContentsPlacement: $value"),
      };
}

enum NSWritingDirection {
  NSWritingDirectionNatural(-1),
  NSWritingDirectionLeftToRight(0),
  NSWritingDirectionRightToLeft(1);

  final int value;
  const NSWritingDirection(this.value);

  static NSWritingDirection fromValue(int value) => switch (value) {
        -1 => NSWritingDirectionNatural,
        0 => NSWritingDirectionLeftToRight,
        1 => NSWritingDirectionRightToLeft,
        _ =>
          throw ArgumentError("Unknown value for NSWritingDirection: $value"),
      };
}

enum NSTextAlignment {
  NSTextAlignmentLeft(0),
  NSTextAlignmentCenter(1),
  NSTextAlignmentRight(2),
  NSTextAlignmentJustified(3),
  NSTextAlignmentNatural(4);

  final int value;
  const NSTextAlignment(this.value);

  static NSTextAlignment fromValue(int value) => switch (value) {
        0 => NSTextAlignmentLeft,
        1 => NSTextAlignmentCenter,
        2 => NSTextAlignmentRight,
        3 => NSTextAlignmentJustified,
        4 => NSTextAlignmentNatural,
        _ => throw ArgumentError("Unknown value for NSTextAlignment: $value"),
      };
}

enum NSLineBreakMode {
  NSLineBreakByWordWrapping(0),
  NSLineBreakByCharWrapping(1),
  NSLineBreakByClipping(2),
  NSLineBreakByTruncatingHead(3),
  NSLineBreakByTruncatingTail(4),
  NSLineBreakByTruncatingMiddle(5);

  final int value;
  const NSLineBreakMode(this.value);

  static NSLineBreakMode fromValue(int value) => switch (value) {
        0 => NSLineBreakByWordWrapping,
        1 => NSLineBreakByCharWrapping,
        2 => NSLineBreakByClipping,
        3 => NSLineBreakByTruncatingHead,
        4 => NSLineBreakByTruncatingTail,
        5 => NSLineBreakByTruncatingMiddle,
        _ => throw ArgumentError("Unknown value for NSLineBreakMode: $value"),
      };
}

enum NSLineBreakStrategy {
  NSLineBreakStrategyNone(0),
  NSLineBreakStrategyPushOut(1),
  NSLineBreakStrategyHangulWordPriority(2),
  NSLineBreakStrategyStandard(65535);

  final int value;
  const NSLineBreakStrategy(this.value);

  static NSLineBreakStrategy fromValue(int value) => switch (value) {
        0 => NSLineBreakStrategyNone,
        1 => NSLineBreakStrategyPushOut,
        2 => NSLineBreakStrategyHangulWordPriority,
        65535 => NSLineBreakStrategyStandard,
        _ =>
          throw ArgumentError("Unknown value for NSLineBreakStrategy: $value"),
      };
}

enum NSTextTabType {
  NSLeftTabStopType(0),
  NSRightTabStopType(1),
  NSCenterTabStopType(2),
  NSDecimalTabStopType(3);

  final int value;
  const NSTextTabType(this.value);

  static NSTextTabType fromValue(int value) => switch (value) {
        0 => NSLeftTabStopType,
        1 => NSRightTabStopType,
        2 => NSCenterTabStopType,
        3 => NSDecimalTabStopType,
        _ => throw ArgumentError("Unknown value for NSTextTabType: $value"),
      };
}

enum NSCellType {
  NSNullCellType(0),
  NSTextCellType(1),
  NSImageCellType(2);

  final int value;
  const NSCellType(this.value);

  static NSCellType fromValue(int value) => switch (value) {
        0 => NSNullCellType,
        1 => NSTextCellType,
        2 => NSImageCellType,
        _ => throw ArgumentError("Unknown value for NSCellType: $value"),
      };
}

enum NSCellAttribute {
  NSCellDisabled(0),
  NSCellState(1),
  NSPushInCell(2),
  NSCellEditable(3),
  NSChangeGrayCell(4),
  NSCellHighlighted(5),
  NSCellLightsByContents(6),
  NSCellLightsByGray(7),
  NSChangeBackgroundCell(8),
  NSCellLightsByBackground(9),
  NSCellIsBordered(10),
  NSCellHasOverlappingImage(11),
  NSCellHasImageHorizontal(12),
  NSCellHasImageOnLeftOrBottom(13),
  NSCellChangesContents(14),
  NSCellIsInsetButton(15),
  NSCellAllowsMixedState(16);

  final int value;
  const NSCellAttribute(this.value);

  static NSCellAttribute fromValue(int value) => switch (value) {
        0 => NSCellDisabled,
        1 => NSCellState,
        2 => NSPushInCell,
        3 => NSCellEditable,
        4 => NSChangeGrayCell,
        5 => NSCellHighlighted,
        6 => NSCellLightsByContents,
        7 => NSCellLightsByGray,
        8 => NSChangeBackgroundCell,
        9 => NSCellLightsByBackground,
        10 => NSCellIsBordered,
        11 => NSCellHasOverlappingImage,
        12 => NSCellHasImageHorizontal,
        13 => NSCellHasImageOnLeftOrBottom,
        14 => NSCellChangesContents,
        15 => NSCellIsInsetButton,
        16 => NSCellAllowsMixedState,
        _ => throw ArgumentError("Unknown value for NSCellAttribute: $value"),
      };
}

enum NSCellImagePosition {
  NSNoImage(0),
  NSImageOnly(1),
  NSImageLeft(2),
  NSImageRight(3),
  NSImageBelow(4),
  NSImageAbove(5),
  NSImageOverlaps(6),
  NSImageLeading(7),
  NSImageTrailing(8);

  final int value;
  const NSCellImagePosition(this.value);

  static NSCellImagePosition fromValue(int value) => switch (value) {
        0 => NSNoImage,
        1 => NSImageOnly,
        2 => NSImageLeft,
        3 => NSImageRight,
        4 => NSImageBelow,
        5 => NSImageAbove,
        6 => NSImageOverlaps,
        7 => NSImageLeading,
        8 => NSImageTrailing,
        _ =>
          throw ArgumentError("Unknown value for NSCellImagePosition: $value"),
      };
}

enum NSImageScaling {
  NSImageScaleProportionallyDown(0),
  NSImageScaleAxesIndependently(1),
  NSImageScaleNone(2),
  NSImageScaleProportionallyUpOrDown(3);

  static const NSScaleProportionally = NSImageScaleProportionallyDown;
  static const NSScaleToFit = NSImageScaleAxesIndependently;
  static const NSScaleNone = NSImageScaleNone;

  final int value;
  const NSImageScaling(this.value);

  static NSImageScaling fromValue(int value) => switch (value) {
        0 => NSImageScaleProportionallyDown,
        1 => NSImageScaleAxesIndependently,
        2 => NSImageScaleNone,
        3 => NSImageScaleProportionallyUpOrDown,
        _ => throw ArgumentError("Unknown value for NSImageScaling: $value"),
      };

  @override
  String toString() {
    if (this == NSImageScaleProportionallyDown)
      return "NSImageScaling.NSImageScaleProportionallyDown, NSImageScaling.NSScaleProportionally";
    if (this == NSImageScaleAxesIndependently)
      return "NSImageScaling.NSImageScaleAxesIndependently, NSImageScaling.NSScaleToFit";
    if (this == NSImageScaleNone)
      return "NSImageScaling.NSImageScaleNone, NSImageScaling.NSScaleNone";
    return super.toString();
  }
}

enum NSCellStyleMask {
  NSNoCellMask(0),
  NSContentsCellMask(1),
  NSPushInCellMask(2),
  NSChangeGrayCellMask(4),
  NSChangeBackgroundCellMask(8);

  final int value;
  const NSCellStyleMask(this.value);

  static NSCellStyleMask fromValue(int value) => switch (value) {
        0 => NSNoCellMask,
        1 => NSContentsCellMask,
        2 => NSPushInCellMask,
        4 => NSChangeGrayCellMask,
        8 => NSChangeBackgroundCellMask,
        _ => throw ArgumentError("Unknown value for NSCellStyleMask: $value"),
      };
}

enum NSControlTint {
  NSDefaultControlTint(0),
  NSBlueControlTint(1),
  NSGraphiteControlTint(6),
  NSClearControlTint(7);

  final int value;
  const NSControlTint(this.value);

  static NSControlTint fromValue(int value) => switch (value) {
        0 => NSDefaultControlTint,
        1 => NSBlueControlTint,
        6 => NSGraphiteControlTint,
        7 => NSClearControlTint,
        _ => throw ArgumentError("Unknown value for NSControlTint: $value"),
      };
}

enum NSControlSize {
  NSControlSizeRegular(0),
  NSControlSizeSmall(1),
  NSControlSizeMini(2),
  NSControlSizeLarge(3);

  final int value;
  const NSControlSize(this.value);

  static NSControlSize fromValue(int value) => switch (value) {
        0 => NSControlSizeRegular,
        1 => NSControlSizeSmall,
        2 => NSControlSizeMini,
        3 => NSControlSizeLarge,
        _ => throw ArgumentError("Unknown value for NSControlSize: $value"),
      };
}

enum NSCellHitResult {
  NSCellHitNone(0),
  NSCellHitContentArea(1),
  NSCellHitEditableTextArea(2),
  NSCellHitTrackableArea(4);

  final int value;
  const NSCellHitResult(this.value);

  static NSCellHitResult fromValue(int value) => switch (value) {
        0 => NSCellHitNone,
        1 => NSCellHitContentArea,
        2 => NSCellHitEditableTextArea,
        4 => NSCellHitTrackableArea,
        _ => throw ArgumentError("Unknown value for NSCellHitResult: $value"),
      };
}

enum NSBackgroundStyle {
  NSBackgroundStyleNormal(0),
  NSBackgroundStyleEmphasized(1),
  NSBackgroundStyleRaised(2),
  NSBackgroundStyleLowered(3);

  final int value;
  const NSBackgroundStyle(this.value);

  static NSBackgroundStyle fromValue(int value) => switch (value) {
        0 => NSBackgroundStyleNormal,
        1 => NSBackgroundStyleEmphasized,
        2 => NSBackgroundStyleRaised,
        3 => NSBackgroundStyleLowered,
        _ => throw ArgumentError("Unknown value for NSBackgroundStyle: $value"),
      };
}

enum NSMenuPresentationStyle {
  NSMenuPresentationStyleRegular(0),
  NSMenuPresentationStylePalette(1);

  final int value;
  const NSMenuPresentationStyle(this.value);

  static NSMenuPresentationStyle fromValue(int value) => switch (value) {
        0 => NSMenuPresentationStyleRegular,
        1 => NSMenuPresentationStylePalette,
        _ => throw ArgumentError(
            "Unknown value for NSMenuPresentationStyle: $value"),
      };
}

enum NSMenuSelectionMode {
  NSMenuSelectionModeAutomatic(0),
  NSMenuSelectionModeSelectOne(1),
  NSMenuSelectionModeSelectAny(2);

  final int value;
  const NSMenuSelectionMode(this.value);

  static NSMenuSelectionMode fromValue(int value) => switch (value) {
        0 => NSMenuSelectionModeAutomatic,
        1 => NSMenuSelectionModeSelectOne,
        2 => NSMenuSelectionModeSelectAny,
        _ =>
          throw ArgumentError("Unknown value for NSMenuSelectionMode: $value"),
      };
}

enum NSMenuProperties {
  NSMenuPropertyItemTitle(1),
  NSMenuPropertyItemAttributedTitle(2),
  NSMenuPropertyItemKeyEquivalent(4),
  NSMenuPropertyItemImage(8),
  NSMenuPropertyItemEnabled(16),
  NSMenuPropertyItemAccessibilityDescription(32);

  final int value;
  const NSMenuProperties(this.value);

  static NSMenuProperties fromValue(int value) => switch (value) {
        1 => NSMenuPropertyItemTitle,
        2 => NSMenuPropertyItemAttributedTitle,
        4 => NSMenuPropertyItemKeyEquivalent,
        8 => NSMenuPropertyItemImage,
        16 => NSMenuPropertyItemEnabled,
        32 => NSMenuPropertyItemAccessibilityDescription,
        _ => throw ArgumentError("Unknown value for NSMenuProperties: $value"),
      };
}

enum NSColorType {
  NSColorTypeComponentBased(0),
  NSColorTypePattern(1),
  NSColorTypeCatalog(2);

  final int value;
  const NSColorType(this.value);

  static NSColorType fromValue(int value) => switch (value) {
        0 => NSColorTypeComponentBased,
        1 => NSColorTypePattern,
        2 => NSColorTypeCatalog,
        _ => throw ArgumentError("Unknown value for NSColorType: $value"),
      };
}

enum NSColorSystemEffect {
  NSColorSystemEffectNone(0),
  NSColorSystemEffectPressed(1),
  NSColorSystemEffectDeepPressed(2),
  NSColorSystemEffectDisabled(3),
  NSColorSystemEffectRollover(4);

  final int value;
  const NSColorSystemEffect(this.value);

  static NSColorSystemEffect fromValue(int value) => switch (value) {
        0 => NSColorSystemEffectNone,
        1 => NSColorSystemEffectPressed,
        2 => NSColorSystemEffectDeepPressed,
        3 => NSColorSystemEffectDisabled,
        4 => NSColorSystemEffectRollover,
        _ =>
          throw ArgumentError("Unknown value for NSColorSystemEffect: $value"),
      };
}

enum NSButtonType {
  NSButtonTypeMomentaryLight(0),
  NSButtonTypePushOnPushOff(1),
  NSButtonTypeToggle(2),
  NSButtonTypeSwitch(3),
  NSButtonTypeRadio(4),
  NSButtonTypeMomentaryChange(5),
  NSButtonTypeOnOff(6),
  NSButtonTypeMomentaryPushIn(7),
  NSButtonTypeAccelerator(8),
  NSButtonTypeMultiLevelAccelerator(9);

  final int value;
  const NSButtonType(this.value);

  static NSButtonType fromValue(int value) => switch (value) {
        0 => NSButtonTypeMomentaryLight,
        1 => NSButtonTypePushOnPushOff,
        2 => NSButtonTypeToggle,
        3 => NSButtonTypeSwitch,
        4 => NSButtonTypeRadio,
        5 => NSButtonTypeMomentaryChange,
        6 => NSButtonTypeOnOff,
        7 => NSButtonTypeMomentaryPushIn,
        8 => NSButtonTypeAccelerator,
        9 => NSButtonTypeMultiLevelAccelerator,
        _ => throw ArgumentError("Unknown value for NSButtonType: $value"),
      };
}

enum NSBezelStyle {
  NSBezelStyleAutomatic(0),
  NSBezelStylePush(1),
  NSBezelStyleFlexiblePush(2),
  NSBezelStyleDisclosure(5),
  NSBezelStyleCircular(7),
  NSBezelStyleHelpButton(9),
  NSBezelStyleSmallSquare(10),
  NSBezelStyleToolbar(11),
  NSBezelStyleAccessoryBarAction(12),
  NSBezelStyleAccessoryBar(13),
  NSBezelStylePushDisclosure(14),
  NSBezelStyleBadge(15),
  NSBezelStyleShadowlessSquare(6),
  NSBezelStyleTexturedSquare(8);

  static const NSBezelStyleRounded = NSBezelStylePush;
  static const NSBezelStyleRegularSquare = NSBezelStyleFlexiblePush;
  static const NSBezelStyleTexturedRounded = NSBezelStyleToolbar;
  static const NSBezelStyleRoundRect = NSBezelStyleAccessoryBarAction;
  static const NSBezelStyleRecessed = NSBezelStyleAccessoryBar;
  static const NSBezelStyleRoundedDisclosure = NSBezelStylePushDisclosure;
  static const NSBezelStyleInline = NSBezelStyleBadge;

  final int value;
  const NSBezelStyle(this.value);

  static NSBezelStyle fromValue(int value) => switch (value) {
        0 => NSBezelStyleAutomatic,
        1 => NSBezelStylePush,
        2 => NSBezelStyleFlexiblePush,
        5 => NSBezelStyleDisclosure,
        7 => NSBezelStyleCircular,
        9 => NSBezelStyleHelpButton,
        10 => NSBezelStyleSmallSquare,
        11 => NSBezelStyleToolbar,
        12 => NSBezelStyleAccessoryBarAction,
        13 => NSBezelStyleAccessoryBar,
        14 => NSBezelStylePushDisclosure,
        15 => NSBezelStyleBadge,
        6 => NSBezelStyleShadowlessSquare,
        8 => NSBezelStyleTexturedSquare,
        _ => throw ArgumentError("Unknown value for NSBezelStyle: $value"),
      };

  @override
  String toString() {
    if (this == NSBezelStylePush)
      return "NSBezelStyle.NSBezelStylePush, NSBezelStyle.NSBezelStyleRounded";
    if (this == NSBezelStyleFlexiblePush)
      return "NSBezelStyle.NSBezelStyleFlexiblePush, NSBezelStyle.NSBezelStyleRegularSquare";
    if (this == NSBezelStyleToolbar)
      return "NSBezelStyle.NSBezelStyleToolbar, NSBezelStyle.NSBezelStyleTexturedRounded";
    if (this == NSBezelStyleAccessoryBarAction)
      return "NSBezelStyle.NSBezelStyleAccessoryBarAction, NSBezelStyle.NSBezelStyleRoundRect";
    if (this == NSBezelStyleAccessoryBar)
      return "NSBezelStyle.NSBezelStyleAccessoryBar, NSBezelStyle.NSBezelStyleRecessed";
    if (this == NSBezelStylePushDisclosure)
      return "NSBezelStyle.NSBezelStylePushDisclosure, NSBezelStyle.NSBezelStyleRoundedDisclosure";
    if (this == NSBezelStyleBadge)
      return "NSBezelStyle.NSBezelStyleBadge, NSBezelStyle.NSBezelStyleInline";
    return super.toString();
  }
}

enum NSGradientType {
  NSGradientNone(0),
  NSGradientConcaveWeak(1),
  NSGradientConcaveStrong(2),
  NSGradientConvexWeak(3),
  NSGradientConvexStrong(4);

  final int value;
  const NSGradientType(this.value);

  static NSGradientType fromValue(int value) => switch (value) {
        0 => NSGradientNone,
        1 => NSGradientConcaveWeak,
        2 => NSGradientConcaveStrong,
        3 => NSGradientConvexWeak,
        4 => NSGradientConvexStrong,
        _ => throw ArgumentError("Unknown value for NSGradientType: $value"),
      };
}

enum NSPopoverBehavior {
  NSPopoverBehaviorApplicationDefined(0),
  NSPopoverBehaviorTransient(1),
  NSPopoverBehaviorSemitransient(2);

  final int value;
  const NSPopoverBehavior(this.value);

  static NSPopoverBehavior fromValue(int value) => switch (value) {
        0 => NSPopoverBehaviorApplicationDefined,
        1 => NSPopoverBehaviorTransient,
        2 => NSPopoverBehaviorSemitransient,
        _ => throw ArgumentError("Unknown value for NSPopoverBehavior: $value"),
      };
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_NSCoder_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_NSCoder_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_NSCoder_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)>`.
abstract final class ObjCBlock_objcObjCObject_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCObject> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_NSCoder_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)> fromFunction(
          objc.ObjCObjectBase? Function(objc.NSCoder) fn) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_objcObjCObject_NSCoder_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) =>
                  fn(objc.NSCoder.castFromPointer(arg0, retain: true, release: true))
                      ?.ref
                      .retainAndAutorelease() ??
                  ffi.nullptr),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)>`.
extension ObjCBlock_objcObjCObject_NSCoder_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(objc.NSCoder)> {
  objc.ObjCObjectBase? call(objc.NSCoder arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true);
}

enum NSViewControllerTransitionOptions {
  NSViewControllerTransitionNone(0),
  NSViewControllerTransitionCrossfade(1),
  NSViewControllerTransitionSlideUp(16),
  NSViewControllerTransitionSlideDown(32),
  NSViewControllerTransitionSlideLeft(64),
  NSViewControllerTransitionSlideRight(128),
  NSViewControllerTransitionSlideForward(320),
  NSViewControllerTransitionSlideBackward(384),
  NSViewControllerTransitionAllowUserInteraction(4096);

  final int value;
  const NSViewControllerTransitionOptions(this.value);

  static NSViewControllerTransitionOptions fromValue(int value) =>
      switch (value) {
        0 => NSViewControllerTransitionNone,
        1 => NSViewControllerTransitionCrossfade,
        16 => NSViewControllerTransitionSlideUp,
        32 => NSViewControllerTransitionSlideDown,
        64 => NSViewControllerTransitionSlideLeft,
        128 => NSViewControllerTransitionSlideRight,
        320 => NSViewControllerTransitionSlideForward,
        384 => NSViewControllerTransitionSlideBackward,
        4096 => NSViewControllerTransitionAllowUserInteraction,
        _ => throw ArgumentError(
            "Unknown value for NSViewControllerTransitionOptions: $value"),
      };
}

enum NSHorizontalDirections {
  NSHorizontalDirectionsLeft(1),
  NSHorizontalDirectionsRight(2),
  NSHorizontalDirectionsAll(3);

  final int value;
  const NSHorizontalDirections(this.value);

  static NSHorizontalDirections fromValue(int value) => switch (value) {
        1 => NSHorizontalDirectionsLeft,
        2 => NSHorizontalDirectionsRight,
        3 => NSHorizontalDirectionsAll,
        _ => throw ArgumentError(
            "Unknown value for NSHorizontalDirections: $value"),
      };
}

enum NSVerticalDirections {
  NSVerticalDirectionsUp(1),
  NSVerticalDirectionsDown(2),
  NSVerticalDirectionsAll(3);

  final int value;
  const NSVerticalDirections(this.value);

  static NSVerticalDirections fromValue(int value) => switch (value) {
        1 => NSVerticalDirectionsUp,
        2 => NSVerticalDirectionsDown,
        3 => NSVerticalDirectionsAll,
        _ =>
          throw ArgumentError("Unknown value for NSVerticalDirections: $value"),
      };
}

enum NSFontDescriptorSymbolicTraits {
  NSFontDescriptorTraitItalic(1),
  NSFontDescriptorTraitBold(2),
  NSFontDescriptorTraitExpanded(32),
  NSFontDescriptorTraitCondensed(64),
  NSFontDescriptorTraitMonoSpace(1024),
  NSFontDescriptorTraitVertical(2048),
  NSFontDescriptorTraitUIOptimized(4096),
  NSFontDescriptorTraitTightLeading(32768),
  NSFontDescriptorTraitLooseLeading(65536),
  NSFontDescriptorClassMask(-268435456),
  NSFontDescriptorClassUnknown(0),
  NSFontDescriptorClassOldStyleSerifs(268435456),
  NSFontDescriptorClassTransitionalSerifs(536870912),
  NSFontDescriptorClassModernSerifs(805306368),
  NSFontDescriptorClassClarendonSerifs(1073741824),
  NSFontDescriptorClassSlabSerifs(1342177280),
  NSFontDescriptorClassFreeformSerifs(1879048192),
  NSFontDescriptorClassSansSerif(-2147483648),
  NSFontDescriptorClassOrnamentals(-1879048192),
  NSFontDescriptorClassScripts(-1610612736),
  NSFontDescriptorClassSymbolic(-1073741824);

  static const NSFontDescriptorTraitEmphasized = NSFontDescriptorTraitBold;

  final int value;
  const NSFontDescriptorSymbolicTraits(this.value);

  static NSFontDescriptorSymbolicTraits fromValue(int value) => switch (value) {
        1 => NSFontDescriptorTraitItalic,
        2 => NSFontDescriptorTraitBold,
        32 => NSFontDescriptorTraitExpanded,
        64 => NSFontDescriptorTraitCondensed,
        1024 => NSFontDescriptorTraitMonoSpace,
        2048 => NSFontDescriptorTraitVertical,
        4096 => NSFontDescriptorTraitUIOptimized,
        32768 => NSFontDescriptorTraitTightLeading,
        65536 => NSFontDescriptorTraitLooseLeading,
        -268435456 => NSFontDescriptorClassMask,
        0 => NSFontDescriptorClassUnknown,
        268435456 => NSFontDescriptorClassOldStyleSerifs,
        536870912 => NSFontDescriptorClassTransitionalSerifs,
        805306368 => NSFontDescriptorClassModernSerifs,
        1073741824 => NSFontDescriptorClassClarendonSerifs,
        1342177280 => NSFontDescriptorClassSlabSerifs,
        1879048192 => NSFontDescriptorClassFreeformSerifs,
        -2147483648 => NSFontDescriptorClassSansSerif,
        -1879048192 => NSFontDescriptorClassOrnamentals,
        -1610612736 => NSFontDescriptorClassScripts,
        -1073741824 => NSFontDescriptorClassSymbolic,
        _ => throw ArgumentError(
            "Unknown value for NSFontDescriptorSymbolicTraits: $value"),
      };

  @override
  String toString() {
    if (this == NSFontDescriptorTraitBold)
      return "NSFontDescriptorSymbolicTraits.NSFontDescriptorTraitBold, NSFontDescriptorSymbolicTraits.NSFontDescriptorTraitEmphasized";
    return super.toString();
  }
}

enum NSFontRenderingMode {
  NSFontDefaultRenderingMode(0),
  NSFontAntialiasedRenderingMode(1),
  NSFontIntegerAdvancementsRenderingMode(2),
  NSFontAntialiasedIntegerAdvancementsRenderingMode(3);

  final int value;
  const NSFontRenderingMode(this.value);

  static NSFontRenderingMode fromValue(int value) => switch (value) {
        0 => NSFontDefaultRenderingMode,
        1 => NSFontAntialiasedRenderingMode,
        2 => NSFontIntegerAdvancementsRenderingMode,
        3 => NSFontAntialiasedIntegerAdvancementsRenderingMode,
        _ =>
          throw ArgumentError("Unknown value for NSFontRenderingMode: $value"),
      };
}

enum NSFontTraitMask {
  NSItalicFontMask(1),
  NSBoldFontMask(2),
  NSUnboldFontMask(4),
  NSNonStandardCharacterSetFontMask(8),
  NSNarrowFontMask(16),
  NSExpandedFontMask(32),
  NSCondensedFontMask(64),
  NSSmallCapsFontMask(128),
  NSPosterFontMask(256),
  NSCompressedFontMask(512),
  NSFixedPitchFontMask(1024),
  NSUnitalicFontMask(16777216);

  final int value;
  const NSFontTraitMask(this.value);

  static NSFontTraitMask fromValue(int value) => switch (value) {
        1 => NSItalicFontMask,
        2 => NSBoldFontMask,
        4 => NSUnboldFontMask,
        8 => NSNonStandardCharacterSetFontMask,
        16 => NSNarrowFontMask,
        32 => NSExpandedFontMask,
        64 => NSCondensedFontMask,
        128 => NSSmallCapsFontMask,
        256 => NSPosterFontMask,
        512 => NSCompressedFontMask,
        1024 => NSFixedPitchFontMask,
        16777216 => NSUnitalicFontMask,
        _ => throw ArgumentError("Unknown value for NSFontTraitMask: $value"),
      };
}

enum NSWindowStyleMask {
  NSWindowStyleMaskBorderless(0),
  NSWindowStyleMaskTitled(1),
  NSWindowStyleMaskClosable(2),
  NSWindowStyleMaskMiniaturizable(4),
  NSWindowStyleMaskResizable(8),
  NSWindowStyleMaskTexturedBackground(256),
  NSWindowStyleMaskUnifiedTitleAndToolbar(4096),
  NSWindowStyleMaskFullScreen(16384),
  NSWindowStyleMaskFullSizeContentView(32768),
  NSWindowStyleMaskUtilityWindow(16),
  NSWindowStyleMaskDocModalWindow(64),
  NSWindowStyleMaskNonactivatingPanel(128),
  NSWindowStyleMaskHUDWindow(8192);

  final int value;
  const NSWindowStyleMask(this.value);

  static NSWindowStyleMask fromValue(int value) => switch (value) {
        0 => NSWindowStyleMaskBorderless,
        1 => NSWindowStyleMaskTitled,
        2 => NSWindowStyleMaskClosable,
        4 => NSWindowStyleMaskMiniaturizable,
        8 => NSWindowStyleMaskResizable,
        256 => NSWindowStyleMaskTexturedBackground,
        4096 => NSWindowStyleMaskUnifiedTitleAndToolbar,
        16384 => NSWindowStyleMaskFullScreen,
        32768 => NSWindowStyleMaskFullSizeContentView,
        16 => NSWindowStyleMaskUtilityWindow,
        64 => NSWindowStyleMaskDocModalWindow,
        128 => NSWindowStyleMaskNonactivatingPanel,
        8192 => NSWindowStyleMaskHUDWindow,
        _ => throw ArgumentError("Unknown value for NSWindowStyleMask: $value"),
      };
}

enum NSWindowSharingType {
  NSWindowSharingNone(0),
  NSWindowSharingReadOnly(1);

  final int value;
  const NSWindowSharingType(this.value);

  static NSWindowSharingType fromValue(int value) => switch (value) {
        0 => NSWindowSharingNone,
        1 => NSWindowSharingReadOnly,
        _ =>
          throw ArgumentError("Unknown value for NSWindowSharingType: $value"),
      };
}

enum NSWindowCollectionBehavior {
  NSWindowCollectionBehaviorDefault(0),
  NSWindowCollectionBehaviorCanJoinAllSpaces(1),
  NSWindowCollectionBehaviorMoveToActiveSpace(2),
  NSWindowCollectionBehaviorManaged(4),
  NSWindowCollectionBehaviorTransient(8),
  NSWindowCollectionBehaviorStationary(16),
  NSWindowCollectionBehaviorParticipatesInCycle(32),
  NSWindowCollectionBehaviorIgnoresCycle(64),
  NSWindowCollectionBehaviorFullScreenPrimary(128),
  NSWindowCollectionBehaviorFullScreenAuxiliary(256),
  NSWindowCollectionBehaviorFullScreenNone(512),
  NSWindowCollectionBehaviorFullScreenAllowsTiling(2048),
  NSWindowCollectionBehaviorFullScreenDisallowsTiling(4096),
  NSWindowCollectionBehaviorPrimary(65536),
  NSWindowCollectionBehaviorAuxiliary(131072),
  NSWindowCollectionBehaviorCanJoinAllApplications(262144);

  final int value;
  const NSWindowCollectionBehavior(this.value);

  static NSWindowCollectionBehavior fromValue(int value) => switch (value) {
        0 => NSWindowCollectionBehaviorDefault,
        1 => NSWindowCollectionBehaviorCanJoinAllSpaces,
        2 => NSWindowCollectionBehaviorMoveToActiveSpace,
        4 => NSWindowCollectionBehaviorManaged,
        8 => NSWindowCollectionBehaviorTransient,
        16 => NSWindowCollectionBehaviorStationary,
        32 => NSWindowCollectionBehaviorParticipatesInCycle,
        64 => NSWindowCollectionBehaviorIgnoresCycle,
        128 => NSWindowCollectionBehaviorFullScreenPrimary,
        256 => NSWindowCollectionBehaviorFullScreenAuxiliary,
        512 => NSWindowCollectionBehaviorFullScreenNone,
        2048 => NSWindowCollectionBehaviorFullScreenAllowsTiling,
        4096 => NSWindowCollectionBehaviorFullScreenDisallowsTiling,
        65536 => NSWindowCollectionBehaviorPrimary,
        131072 => NSWindowCollectionBehaviorAuxiliary,
        262144 => NSWindowCollectionBehaviorCanJoinAllApplications,
        _ => throw ArgumentError(
            "Unknown value for NSWindowCollectionBehavior: $value"),
      };
}

enum NSWindowAnimationBehavior {
  NSWindowAnimationBehaviorDefault(0),
  NSWindowAnimationBehaviorNone(2),
  NSWindowAnimationBehaviorDocumentWindow(3),
  NSWindowAnimationBehaviorUtilityWindow(4),
  NSWindowAnimationBehaviorAlertPanel(5);

  final int value;
  const NSWindowAnimationBehavior(this.value);

  static NSWindowAnimationBehavior fromValue(int value) => switch (value) {
        0 => NSWindowAnimationBehaviorDefault,
        2 => NSWindowAnimationBehaviorNone,
        3 => NSWindowAnimationBehaviorDocumentWindow,
        4 => NSWindowAnimationBehaviorUtilityWindow,
        5 => NSWindowAnimationBehaviorAlertPanel,
        _ => throw ArgumentError(
            "Unknown value for NSWindowAnimationBehavior: $value"),
      };
}

enum NSWindowNumberListOptions {
  NSWindowNumberListAllApplications(1),
  NSWindowNumberListAllSpaces(16);

  final int value;
  const NSWindowNumberListOptions(this.value);

  static NSWindowNumberListOptions fromValue(int value) => switch (value) {
        1 => NSWindowNumberListAllApplications,
        16 => NSWindowNumberListAllSpaces,
        _ => throw ArgumentError(
            "Unknown value for NSWindowNumberListOptions: $value"),
      };
}

enum NSWindowOcclusionState {
  NSWindowOcclusionStateVisible(2);

  final int value;
  const NSWindowOcclusionState(this.value);

  static NSWindowOcclusionState fromValue(int value) => switch (value) {
        2 => NSWindowOcclusionStateVisible,
        _ => throw ArgumentError(
            "Unknown value for NSWindowOcclusionState: $value"),
      };
}

enum NSSelectionDirection {
  NSDirectSelection(0),
  NSSelectingNext(1),
  NSSelectingPrevious(2);

  final int value;
  const NSSelectionDirection(this.value);

  static NSSelectionDirection fromValue(int value) => switch (value) {
        0 => NSDirectSelection,
        1 => NSSelectingNext,
        2 => NSSelectingPrevious,
        _ =>
          throw ArgumentError("Unknown value for NSSelectionDirection: $value"),
      };
}

enum NSWindowButton {
  NSWindowCloseButton(0),
  NSWindowMiniaturizeButton(1),
  NSWindowZoomButton(2),
  NSWindowToolbarButton(3),
  NSWindowDocumentIconButton(4),
  NSWindowDocumentVersionsButton(6);

  final int value;
  const NSWindowButton(this.value);

  static NSWindowButton fromValue(int value) => switch (value) {
        0 => NSWindowCloseButton,
        1 => NSWindowMiniaturizeButton,
        2 => NSWindowZoomButton,
        3 => NSWindowToolbarButton,
        4 => NSWindowDocumentIconButton,
        6 => NSWindowDocumentVersionsButton,
        _ => throw ArgumentError("Unknown value for NSWindowButton: $value"),
      };
}

enum NSWindowTitleVisibility {
  NSWindowTitleVisible(0),
  NSWindowTitleHidden(1);

  final int value;
  const NSWindowTitleVisibility(this.value);

  static NSWindowTitleVisibility fromValue(int value) => switch (value) {
        0 => NSWindowTitleVisible,
        1 => NSWindowTitleHidden,
        _ => throw ArgumentError(
            "Unknown value for NSWindowTitleVisibility: $value"),
      };
}

enum NSWindowToolbarStyle {
  NSWindowToolbarStyleAutomatic(0),
  NSWindowToolbarStyleExpanded(1),
  NSWindowToolbarStylePreference(2),
  NSWindowToolbarStyleUnified(3),
  NSWindowToolbarStyleUnifiedCompact(4);

  final int value;
  const NSWindowToolbarStyle(this.value);

  static NSWindowToolbarStyle fromValue(int value) => switch (value) {
        0 => NSWindowToolbarStyleAutomatic,
        1 => NSWindowToolbarStyleExpanded,
        2 => NSWindowToolbarStylePreference,
        3 => NSWindowToolbarStyleUnified,
        4 => NSWindowToolbarStyleUnifiedCompact,
        _ =>
          throw ArgumentError("Unknown value for NSWindowToolbarStyle: $value"),
      };
}

enum NSWindowUserTabbingPreference {
  NSWindowUserTabbingPreferenceManual(0),
  NSWindowUserTabbingPreferenceAlways(1),
  NSWindowUserTabbingPreferenceInFullScreen(2);

  final int value;
  const NSWindowUserTabbingPreference(this.value);

  static NSWindowUserTabbingPreference fromValue(int value) => switch (value) {
        0 => NSWindowUserTabbingPreferenceManual,
        1 => NSWindowUserTabbingPreferenceAlways,
        2 => NSWindowUserTabbingPreferenceInFullScreen,
        _ => throw ArgumentError(
            "Unknown value for NSWindowUserTabbingPreference: $value"),
      };
}

enum NSWindowTabbingMode {
  NSWindowTabbingModeAutomatic(0),
  NSWindowTabbingModePreferred(1),
  NSWindowTabbingModeDisallowed(2);

  final int value;
  const NSWindowTabbingMode(this.value);

  static NSWindowTabbingMode fromValue(int value) => switch (value) {
        0 => NSWindowTabbingModeAutomatic,
        1 => NSWindowTabbingModePreferred,
        2 => NSWindowTabbingModeDisallowed,
        _ =>
          throw ArgumentError("Unknown value for NSWindowTabbingMode: $value"),
      };
}

enum NSTitlebarSeparatorStyle {
  NSTitlebarSeparatorStyleAutomatic(0),
  NSTitlebarSeparatorStyleNone(1),
  NSTitlebarSeparatorStyleLine(2),
  NSTitlebarSeparatorStyleShadow(3);

  final int value;
  const NSTitlebarSeparatorStyle(this.value);

  static NSTitlebarSeparatorStyle fromValue(int value) => switch (value) {
        0 => NSTitlebarSeparatorStyleAutomatic,
        1 => NSTitlebarSeparatorStyleNone,
        2 => NSTitlebarSeparatorStyleLine,
        3 => NSTitlebarSeparatorStyleShadow,
        _ => throw ArgumentError(
            "Unknown value for NSTitlebarSeparatorStyle: $value"),
      };
}

enum NSWindowBackingLocation {
  NSWindowBackingLocationDefault(0),
  NSWindowBackingLocationVideoMemory(1),
  NSWindowBackingLocationMainMemory(2);

  final int value;
  const NSWindowBackingLocation(this.value);

  static NSWindowBackingLocation fromValue(int value) => switch (value) {
        0 => NSWindowBackingLocationDefault,
        1 => NSWindowBackingLocationVideoMemory,
        2 => NSWindowBackingLocationMainMemory,
        _ => throw ArgumentError(
            "Unknown value for NSWindowBackingLocation: $value"),
      };
}

enum NSMenuItemBadgeType {
  NSMenuItemBadgeTypeNone(0),
  NSMenuItemBadgeTypeUpdates(1),
  NSMenuItemBadgeTypeNewItems(2),
  NSMenuItemBadgeTypeAlerts(3);

  final int value;
  const NSMenuItemBadgeType(this.value);

  static NSMenuItemBadgeType fromValue(int value) => switch (value) {
        0 => NSMenuItemBadgeTypeNone,
        1 => NSMenuItemBadgeTypeUpdates,
        2 => NSMenuItemBadgeTypeNewItems,
        3 => NSMenuItemBadgeTypeAlerts,
        _ =>
          throw ArgumentError("Unknown value for NSMenuItemBadgeType: $value"),
      };
}

enum NSColorSpaceModel {
  NSColorSpaceModelUnknown(-1),
  NSColorSpaceModelGray(0),
  NSColorSpaceModelRGB(1),
  NSColorSpaceModelCMYK(2),
  NSColorSpaceModelLAB(3),
  NSColorSpaceModelDeviceN(4),
  NSColorSpaceModelIndexed(5),
  NSColorSpaceModelPatterned(6);

  final int value;
  const NSColorSpaceModel(this.value);

  static NSColorSpaceModel fromValue(int value) => switch (value) {
        -1 => NSColorSpaceModelUnknown,
        0 => NSColorSpaceModelGray,
        1 => NSColorSpaceModelRGB,
        2 => NSColorSpaceModelCMYK,
        3 => NSColorSpaceModelLAB,
        4 => NSColorSpaceModelDeviceN,
        5 => NSColorSpaceModelIndexed,
        6 => NSColorSpaceModelPatterned,
        _ => throw ArgumentError("Unknown value for NSColorSpaceModel: $value"),
      };
}

enum NSImageLayoutDirection {
  NSImageLayoutDirectionUnspecified(-1),
  NSImageLayoutDirectionLeftToRight(2),
  NSImageLayoutDirectionRightToLeft(3);

  final int value;
  const NSImageLayoutDirection(this.value);

  static NSImageLayoutDirection fromValue(int value) => switch (value) {
        -1 => NSImageLayoutDirectionUnspecified,
        2 => NSImageLayoutDirectionLeftToRight,
        3 => NSImageLayoutDirectionRightToLeft,
        _ => throw ArgumentError(
            "Unknown value for NSImageLayoutDirection: $value"),
      };
}

enum NSBitmapImageFileType {
  NSBitmapImageFileTypeTIFF(0),
  NSBitmapImageFileTypeBMP(1),
  NSBitmapImageFileTypeGIF(2),
  NSBitmapImageFileTypeJPEG(3),
  NSBitmapImageFileTypePNG(4),
  NSBitmapImageFileTypeJPEG2000(5);

  final int value;
  const NSBitmapImageFileType(this.value);

  static NSBitmapImageFileType fromValue(int value) => switch (value) {
        0 => NSBitmapImageFileTypeTIFF,
        1 => NSBitmapImageFileTypeBMP,
        2 => NSBitmapImageFileTypeGIF,
        3 => NSBitmapImageFileTypeJPEG,
        4 => NSBitmapImageFileTypePNG,
        5 => NSBitmapImageFileTypeJPEG2000,
        _ => throw ArgumentError(
            "Unknown value for NSBitmapImageFileType: $value"),
      };
}

enum NSBitmapFormat {
  NSBitmapFormatAlphaFirst(1),
  NSBitmapFormatAlphaNonpremultiplied(2),
  NSBitmapFormatFloatingPointSamples(4),
  NSBitmapFormatSixteenBitLittleEndian(256),
  NSBitmapFormatThirtyTwoBitLittleEndian(512),
  NSBitmapFormatSixteenBitBigEndian(1024),
  NSBitmapFormatThirtyTwoBitBigEndian(2048);

  final int value;
  const NSBitmapFormat(this.value);

  static NSBitmapFormat fromValue(int value) => switch (value) {
        1 => NSBitmapFormatAlphaFirst,
        2 => NSBitmapFormatAlphaNonpremultiplied,
        4 => NSBitmapFormatFloatingPointSamples,
        256 => NSBitmapFormatSixteenBitLittleEndian,
        512 => NSBitmapFormatThirtyTwoBitLittleEndian,
        1024 => NSBitmapFormatSixteenBitBigEndian,
        2048 => NSBitmapFormatThirtyTwoBitBigEndian,
        _ => throw ArgumentError("Unknown value for NSBitmapFormat: $value"),
      };
}

final class __CVBuffer extends ffi.Opaque {}

enum NSColorPanelMode {
  NSColorPanelModeNone(-1),
  NSColorPanelModeGray(0),
  NSColorPanelModeRGB(1),
  NSColorPanelModeCMYK(2),
  NSColorPanelModeHSB(3),
  NSColorPanelModeCustomPalette(4),
  NSColorPanelModeColorList(5),
  NSColorPanelModeWheel(6),
  NSColorPanelModeCrayon(7);

  final int value;
  const NSColorPanelMode(this.value);

  static NSColorPanelMode fromValue(int value) => switch (value) {
        -1 => NSColorPanelModeNone,
        0 => NSColorPanelModeGray,
        1 => NSColorPanelModeRGB,
        2 => NSColorPanelModeCMYK,
        3 => NSColorPanelModeHSB,
        4 => NSColorPanelModeCustomPalette,
        5 => NSColorPanelModeColorList,
        6 => NSColorPanelModeWheel,
        7 => NSColorPanelModeCrayon,
        _ => throw ArgumentError("Unknown value for NSColorPanelMode: $value"),
      };
}

enum NSColorPanelOptions {
  NSColorPanelGrayModeMask(1),
  NSColorPanelRGBModeMask(2),
  NSColorPanelCMYKModeMask(4),
  NSColorPanelHSBModeMask(8),
  NSColorPanelCustomPaletteModeMask(16),
  NSColorPanelColorListModeMask(32),
  NSColorPanelWheelModeMask(64),
  NSColorPanelCrayonModeMask(128),
  NSColorPanelAllModesMask(65535);

  final int value;
  const NSColorPanelOptions(this.value);

  static NSColorPanelOptions fromValue(int value) => switch (value) {
        1 => NSColorPanelGrayModeMask,
        2 => NSColorPanelRGBModeMask,
        4 => NSColorPanelCMYKModeMask,
        8 => NSColorPanelHSBModeMask,
        16 => NSColorPanelCustomPaletteModeMask,
        32 => NSColorPanelColorListModeMask,
        64 => NSColorPanelWheelModeMask,
        128 => NSColorPanelCrayonModeMask,
        65535 => NSColorPanelAllModesMask,
        _ =>
          throw ArgumentError("Unknown value for NSColorPanelOptions: $value"),
      };
}

enum NSCursorFrameResizePosition {
  NSCursorFrameResizePositionTop(1),
  NSCursorFrameResizePositionLeft(2),
  NSCursorFrameResizePositionBottom(4),
  NSCursorFrameResizePositionRight(8),
  NSCursorFrameResizePositionTopLeft(3),
  NSCursorFrameResizePositionTopRight(9),
  NSCursorFrameResizePositionBottomLeft(6),
  NSCursorFrameResizePositionBottomRight(12);

  final int value;
  const NSCursorFrameResizePosition(this.value);

  static NSCursorFrameResizePosition fromValue(int value) => switch (value) {
        1 => NSCursorFrameResizePositionTop,
        2 => NSCursorFrameResizePositionLeft,
        4 => NSCursorFrameResizePositionBottom,
        8 => NSCursorFrameResizePositionRight,
        3 => NSCursorFrameResizePositionTopLeft,
        9 => NSCursorFrameResizePositionTopRight,
        6 => NSCursorFrameResizePositionBottomLeft,
        12 => NSCursorFrameResizePositionBottomRight,
        _ => throw ArgumentError(
            "Unknown value for NSCursorFrameResizePosition: $value"),
      };
}

enum NSCursorFrameResizeDirections {
  NSCursorFrameResizeDirectionsInward(1),
  NSCursorFrameResizeDirectionsOutward(2),
  NSCursorFrameResizeDirectionsAll(3);

  final int value;
  const NSCursorFrameResizeDirections(this.value);

  static NSCursorFrameResizeDirections fromValue(int value) => switch (value) {
        1 => NSCursorFrameResizeDirectionsInward,
        2 => NSCursorFrameResizeDirectionsOutward,
        3 => NSCursorFrameResizeDirectionsAll,
        _ => throw ArgumentError(
            "Unknown value for NSCursorFrameResizeDirections: $value"),
      };
}

enum NSGestureRecognizerState {
  NSGestureRecognizerStatePossible(0),
  NSGestureRecognizerStateBegan(1),
  NSGestureRecognizerStateChanged(2),
  NSGestureRecognizerStateEnded(3),
  NSGestureRecognizerStateCancelled(4),
  NSGestureRecognizerStateFailed(5);

  static const NSGestureRecognizerStateRecognized =
      NSGestureRecognizerStateEnded;

  final int value;
  const NSGestureRecognizerState(this.value);

  static NSGestureRecognizerState fromValue(int value) => switch (value) {
        0 => NSGestureRecognizerStatePossible,
        1 => NSGestureRecognizerStateBegan,
        2 => NSGestureRecognizerStateChanged,
        3 => NSGestureRecognizerStateEnded,
        4 => NSGestureRecognizerStateCancelled,
        5 => NSGestureRecognizerStateFailed,
        _ => throw ArgumentError(
            "Unknown value for NSGestureRecognizerState: $value"),
      };

  @override
  String toString() {
    if (this == NSGestureRecognizerStateEnded)
      return "NSGestureRecognizerState.NSGestureRecognizerStateEnded, NSGestureRecognizerState.NSGestureRecognizerStateRecognized";
    return super.toString();
  }
}

enum NSLayoutConstraintOrientation {
  NSLayoutConstraintOrientationHorizontal(0),
  NSLayoutConstraintOrientationVertical(1);

  final int value;
  const NSLayoutConstraintOrientation(this.value);

  static NSLayoutConstraintOrientation fromValue(int value) => switch (value) {
        0 => NSLayoutConstraintOrientationHorizontal,
        1 => NSLayoutConstraintOrientationVertical,
        _ => throw ArgumentError(
            "Unknown value for NSLayoutConstraintOrientation: $value"),
      };
}

enum NSLayoutRelation {
  NSLayoutRelationLessThanOrEqual(-1),
  NSLayoutRelationEqual(0),
  NSLayoutRelationGreaterThanOrEqual(1);

  final int value;
  const NSLayoutRelation(this.value);

  static NSLayoutRelation fromValue(int value) => switch (value) {
        -1 => NSLayoutRelationLessThanOrEqual,
        0 => NSLayoutRelationEqual,
        1 => NSLayoutRelationGreaterThanOrEqual,
        _ => throw ArgumentError("Unknown value for NSLayoutRelation: $value"),
      };
}

enum NSLayoutAttribute {
  NSLayoutAttributeLeft(1),
  NSLayoutAttributeRight(2),
  NSLayoutAttributeTop(3),
  NSLayoutAttributeBottom(4),
  NSLayoutAttributeLeading(5),
  NSLayoutAttributeTrailing(6),
  NSLayoutAttributeWidth(7),
  NSLayoutAttributeHeight(8),
  NSLayoutAttributeCenterX(9),
  NSLayoutAttributeCenterY(10),
  NSLayoutAttributeLastBaseline(11),
  NSLayoutAttributeFirstBaseline(12),
  NSLayoutAttributeNotAnAttribute(0);

  static const NSLayoutAttributeBaseline = NSLayoutAttributeLastBaseline;

  final int value;
  const NSLayoutAttribute(this.value);

  static NSLayoutAttribute fromValue(int value) => switch (value) {
        1 => NSLayoutAttributeLeft,
        2 => NSLayoutAttributeRight,
        3 => NSLayoutAttributeTop,
        4 => NSLayoutAttributeBottom,
        5 => NSLayoutAttributeLeading,
        6 => NSLayoutAttributeTrailing,
        7 => NSLayoutAttributeWidth,
        8 => NSLayoutAttributeHeight,
        9 => NSLayoutAttributeCenterX,
        10 => NSLayoutAttributeCenterY,
        11 => NSLayoutAttributeLastBaseline,
        12 => NSLayoutAttributeFirstBaseline,
        0 => NSLayoutAttributeNotAnAttribute,
        _ => throw ArgumentError("Unknown value for NSLayoutAttribute: $value"),
      };

  @override
  String toString() {
    if (this == NSLayoutAttributeLastBaseline)
      return "NSLayoutAttribute.NSLayoutAttributeLastBaseline, NSLayoutAttribute.NSLayoutAttributeBaseline";
    return super.toString();
  }
}

enum NSLayoutFormatOptions {
  NSLayoutFormatAlignAllLeft(2),
  NSLayoutFormatAlignAllRight(4),
  NSLayoutFormatAlignAllTop(8),
  NSLayoutFormatAlignAllBottom(16),
  NSLayoutFormatAlignAllLeading(32),
  NSLayoutFormatAlignAllTrailing(64),
  NSLayoutFormatAlignAllCenterX(512),
  NSLayoutFormatAlignAllCenterY(1024),
  NSLayoutFormatAlignAllLastBaseline(2048),
  NSLayoutFormatAlignAllFirstBaseline(4096),
  NSLayoutFormatAlignmentMask(65535),
  NSLayoutFormatDirectionLeadingToTrailing(0),
  NSLayoutFormatDirectionLeftToRight(65536),
  NSLayoutFormatDirectionRightToLeft(131072),
  NSLayoutFormatDirectionMask(196608);

  static const NSLayoutFormatAlignAllBaseline =
      NSLayoutFormatAlignAllLastBaseline;

  final int value;
  const NSLayoutFormatOptions(this.value);

  static NSLayoutFormatOptions fromValue(int value) => switch (value) {
        2 => NSLayoutFormatAlignAllLeft,
        4 => NSLayoutFormatAlignAllRight,
        8 => NSLayoutFormatAlignAllTop,
        16 => NSLayoutFormatAlignAllBottom,
        32 => NSLayoutFormatAlignAllLeading,
        64 => NSLayoutFormatAlignAllTrailing,
        512 => NSLayoutFormatAlignAllCenterX,
        1024 => NSLayoutFormatAlignAllCenterY,
        2048 => NSLayoutFormatAlignAllLastBaseline,
        4096 => NSLayoutFormatAlignAllFirstBaseline,
        65535 => NSLayoutFormatAlignmentMask,
        0 => NSLayoutFormatDirectionLeadingToTrailing,
        65536 => NSLayoutFormatDirectionLeftToRight,
        131072 => NSLayoutFormatDirectionRightToLeft,
        196608 => NSLayoutFormatDirectionMask,
        _ => throw ArgumentError(
            "Unknown value for NSLayoutFormatOptions: $value"),
      };

  @override
  String toString() {
    if (this == NSLayoutFormatAlignAllLastBaseline)
      return "NSLayoutFormatOptions.NSLayoutFormatAlignAllLastBaseline, NSLayoutFormatOptions.NSLayoutFormatAlignAllBaseline";
    return super.toString();
  }
}

enum NSImageSymbolScale {
  NSImageSymbolScaleSmall(1),
  NSImageSymbolScaleMedium(2),
  NSImageSymbolScaleLarge(3);

  final int value;
  const NSImageSymbolScale(this.value);

  static NSImageSymbolScale fromValue(int value) => switch (value) {
        1 => NSImageSymbolScaleSmall,
        2 => NSImageSymbolScaleMedium,
        3 => NSImageSymbolScaleLarge,
        _ =>
          throw ArgumentError("Unknown value for NSImageSymbolScale: $value"),
      };
}

enum NSUsableScrollerParts {
  NSNoScrollerParts(0),
  NSOnlyScrollerArrows(1),
  NSAllScrollerParts(2);

  final int value;
  const NSUsableScrollerParts(this.value);

  static NSUsableScrollerParts fromValue(int value) => switch (value) {
        0 => NSNoScrollerParts,
        1 => NSOnlyScrollerArrows,
        2 => NSAllScrollerParts,
        _ => throw ArgumentError(
            "Unknown value for NSUsableScrollerParts: $value"),
      };
}

enum NSScrollerPart {
  NSScrollerNoPart(0),
  NSScrollerDecrementPage(1),
  NSScrollerKnob(2),
  NSScrollerIncrementPage(3),
  NSScrollerDecrementLine(4),
  NSScrollerIncrementLine(5),
  NSScrollerKnobSlot(6);

  final int value;
  const NSScrollerPart(this.value);

  static NSScrollerPart fromValue(int value) => switch (value) {
        0 => NSScrollerNoPart,
        1 => NSScrollerDecrementPage,
        2 => NSScrollerKnob,
        3 => NSScrollerIncrementPage,
        4 => NSScrollerDecrementLine,
        5 => NSScrollerIncrementLine,
        6 => NSScrollerKnobSlot,
        _ => throw ArgumentError("Unknown value for NSScrollerPart: $value"),
      };
}

enum NSScrollerStyle {
  NSScrollerStyleLegacy(0),
  NSScrollerStyleOverlay(1);

  final int value;
  const NSScrollerStyle(this.value);

  static NSScrollerStyle fromValue(int value) => switch (value) {
        0 => NSScrollerStyleLegacy,
        1 => NSScrollerStyleOverlay,
        _ => throw ArgumentError("Unknown value for NSScrollerStyle: $value"),
      };
}

enum NSScrollerKnobStyle {
  NSScrollerKnobStyleDefault(0),
  NSScrollerKnobStyleDark(1),
  NSScrollerKnobStyleLight(2);

  final int value;
  const NSScrollerKnobStyle(this.value);

  static NSScrollerKnobStyle fromValue(int value) => switch (value) {
        0 => NSScrollerKnobStyleDefault,
        1 => NSScrollerKnobStyleDark,
        2 => NSScrollerKnobStyleLight,
        _ =>
          throw ArgumentError("Unknown value for NSScrollerKnobStyle: $value"),
      };
}

enum NSScrollArrowPosition {
  NSScrollerArrowsMaxEnd(0),
  NSScrollerArrowsMinEnd(1),
  NSScrollerArrowsNone(2);

  static const NSScrollerArrowsDefaultSetting = NSScrollerArrowsMaxEnd;

  final int value;
  const NSScrollArrowPosition(this.value);

  static NSScrollArrowPosition fromValue(int value) => switch (value) {
        0 => NSScrollerArrowsMaxEnd,
        1 => NSScrollerArrowsMinEnd,
        2 => NSScrollerArrowsNone,
        _ => throw ArgumentError(
            "Unknown value for NSScrollArrowPosition: $value"),
      };

  @override
  String toString() {
    if (this == NSScrollerArrowsMaxEnd)
      return "NSScrollArrowPosition.NSScrollerArrowsMaxEnd, NSScrollArrowPosition.NSScrollerArrowsDefaultSetting";
    return super.toString();
  }
}

enum NSScrollerArrow {
  NSScrollerIncrementArrow(0),
  NSScrollerDecrementArrow(1);

  final int value;
  const NSScrollerArrow(this.value);

  static NSScrollerArrow fromValue(int value) => switch (value) {
        0 => NSScrollerIncrementArrow,
        1 => NSScrollerDecrementArrow,
        _ => throw ArgumentError("Unknown value for NSScrollerArrow: $value"),
      };
}

enum NSScrollElasticity {
  NSScrollElasticityAutomatic(0),
  NSScrollElasticityNone(1),
  NSScrollElasticityAllowed(2);

  final int value;
  const NSScrollElasticity(this.value);

  static NSScrollElasticity fromValue(int value) => switch (value) {
        0 => NSScrollElasticityAutomatic,
        1 => NSScrollElasticityNone,
        2 => NSScrollElasticityAllowed,
        _ =>
          throw ArgumentError("Unknown value for NSScrollElasticity: $value"),
      };
}

enum NSScrollViewFindBarPosition {
  NSScrollViewFindBarPositionAboveHorizontalRuler(0),
  NSScrollViewFindBarPositionAboveContent(1),
  NSScrollViewFindBarPositionBelowContent(2);

  final int value;
  const NSScrollViewFindBarPosition(this.value);

  static NSScrollViewFindBarPosition fromValue(int value) => switch (value) {
        0 => NSScrollViewFindBarPositionAboveHorizontalRuler,
        1 => NSScrollViewFindBarPositionAboveContent,
        2 => NSScrollViewFindBarPositionBelowContent,
        _ => throw ArgumentError(
            "Unknown value for NSScrollViewFindBarPosition: $value"),
      };
}

enum NSTextCursorAccessoryPlacement {
  NSTextCursorAccessoryPlacementUnspecified(0),
  NSTextCursorAccessoryPlacementBackward(1),
  NSTextCursorAccessoryPlacementForward(2),
  NSTextCursorAccessoryPlacementInvisible(3),
  NSTextCursorAccessoryPlacementCenter(4),
  NSTextCursorAccessoryPlacementOffscreenLeft(5),
  NSTextCursorAccessoryPlacementOffscreenTop(6),
  NSTextCursorAccessoryPlacementOffscreenRight(7),
  NSTextCursorAccessoryPlacementOffscreenBottom(8);

  final int value;
  const NSTextCursorAccessoryPlacement(this.value);

  static NSTextCursorAccessoryPlacement fromValue(int value) => switch (value) {
        0 => NSTextCursorAccessoryPlacementUnspecified,
        1 => NSTextCursorAccessoryPlacementBackward,
        2 => NSTextCursorAccessoryPlacementForward,
        3 => NSTextCursorAccessoryPlacementInvisible,
        4 => NSTextCursorAccessoryPlacementCenter,
        5 => NSTextCursorAccessoryPlacementOffscreenLeft,
        6 => NSTextCursorAccessoryPlacementOffscreenTop,
        7 => NSTextCursorAccessoryPlacementOffscreenRight,
        8 => NSTextCursorAccessoryPlacementOffscreenBottom,
        _ => throw ArgumentError(
            "Unknown value for NSTextCursorAccessoryPlacement: $value"),
      };
}

enum NSTextInputTraitType {
  NSTextInputTraitTypeDefault(0),
  NSTextInputTraitTypeNo(1),
  NSTextInputTraitTypeYes(2);

  final int value;
  const NSTextInputTraitType(this.value);

  static NSTextInputTraitType fromValue(int value) => switch (value) {
        0 => NSTextInputTraitTypeDefault,
        1 => NSTextInputTraitTypeNo,
        2 => NSTextInputTraitTypeYes,
        _ =>
          throw ArgumentError("Unknown value for NSTextInputTraitType: $value"),
      };
}

enum NSWritingToolsBehavior {
  NSWritingToolsBehaviorNone(-1),
  NSWritingToolsBehaviorDefault(0),
  NSWritingToolsBehaviorComplete(1),
  NSWritingToolsBehaviorLimited(2);

  final int value;
  const NSWritingToolsBehavior(this.value);

  static NSWritingToolsBehavior fromValue(int value) => switch (value) {
        -1 => NSWritingToolsBehaviorNone,
        0 => NSWritingToolsBehaviorDefault,
        1 => NSWritingToolsBehaviorComplete,
        2 => NSWritingToolsBehaviorLimited,
        _ => throw ArgumentError(
            "Unknown value for NSWritingToolsBehavior: $value"),
      };
}

enum NSWritingToolsResultOptions {
  NSWritingToolsResultDefault(0),
  NSWritingToolsResultPlainText(1),
  NSWritingToolsResultRichText(2),
  NSWritingToolsResultList(4),
  NSWritingToolsResultTable(8);

  final int value;
  const NSWritingToolsResultOptions(this.value);

  static NSWritingToolsResultOptions fromValue(int value) => switch (value) {
        0 => NSWritingToolsResultDefault,
        1 => NSWritingToolsResultPlainText,
        2 => NSWritingToolsResultRichText,
        4 => NSWritingToolsResultList,
        8 => NSWritingToolsResultTable,
        _ => throw ArgumentError(
            "Unknown value for NSWritingToolsResultOptions: $value"),
      };
}

enum NSUnderlineStyle {
  NSUnderlineStyleNone(0),
  NSUnderlineStyleSingle(1),
  NSUnderlineStyleThick(2),
  NSUnderlineStyleDouble(9),
  NSUnderlineStylePatternDot(256),
  NSUnderlineStylePatternDash(512),
  NSUnderlineStylePatternDashDot(768),
  NSUnderlineStylePatternDashDotDot(1024),
  NSUnderlineStyleByWord(32768);

  static const NSUnderlineStylePatternSolid = NSUnderlineStyleNone;

  final int value;
  const NSUnderlineStyle(this.value);

  static NSUnderlineStyle fromValue(int value) => switch (value) {
        0 => NSUnderlineStyleNone,
        1 => NSUnderlineStyleSingle,
        2 => NSUnderlineStyleThick,
        9 => NSUnderlineStyleDouble,
        256 => NSUnderlineStylePatternDot,
        512 => NSUnderlineStylePatternDash,
        768 => NSUnderlineStylePatternDashDot,
        1024 => NSUnderlineStylePatternDashDotDot,
        32768 => NSUnderlineStyleByWord,
        _ => throw ArgumentError("Unknown value for NSUnderlineStyle: $value"),
      };

  @override
  String toString() {
    if (this == NSUnderlineStyleNone)
      return "NSUnderlineStyle.NSUnderlineStyleNone, NSUnderlineStyle.NSUnderlineStylePatternSolid";
    return super.toString();
  }
}

enum NSTextStorageEditActions {
  NSTextStorageEditedAttributes(1),
  NSTextStorageEditedCharacters(2);

  final int value;
  const NSTextStorageEditActions(this.value);

  static NSTextStorageEditActions fromValue(int value) => switch (value) {
        1 => NSTextStorageEditedAttributes,
        2 => NSTextStorageEditedCharacters,
        _ => throw ArgumentError(
            "Unknown value for NSTextStorageEditActions: $value"),
      };
}

enum NSTextLayoutOrientation {
  NSTextLayoutOrientationHorizontal(0),
  NSTextLayoutOrientationVertical(1);

  final int value;
  const NSTextLayoutOrientation(this.value);

  static NSTextLayoutOrientation fromValue(int value) => switch (value) {
        0 => NSTextLayoutOrientationHorizontal,
        1 => NSTextLayoutOrientationVertical,
        _ => throw ArgumentError(
            "Unknown value for NSTextLayoutOrientation: $value"),
      };
}

enum NSGlyphProperty {
  NSGlyphPropertyNull(1),
  NSGlyphPropertyControlCharacter(2),
  NSGlyphPropertyElastic(4),
  NSGlyphPropertyNonBaseCharacter(8);

  final int value;
  const NSGlyphProperty(this.value);

  static NSGlyphProperty fromValue(int value) => switch (value) {
        1 => NSGlyphPropertyNull,
        2 => NSGlyphPropertyControlCharacter,
        4 => NSGlyphPropertyElastic,
        8 => NSGlyphPropertyNonBaseCharacter,
        _ => throw ArgumentError("Unknown value for NSGlyphProperty: $value"),
      };
}

enum NSTypesetterBehavior {
  NSTypesetterLatestBehavior(-1),
  NSTypesetterOriginalBehavior(0),
  NSTypesetterBehavior_10_2_WithCompatibility(1),
  NSTypesetterBehavior_10_2(2),
  NSTypesetterBehavior_10_3(3),
  NSTypesetterBehavior_10_4(4);

  final int value;
  const NSTypesetterBehavior(this.value);

  static NSTypesetterBehavior fromValue(int value) => switch (value) {
        -1 => NSTypesetterLatestBehavior,
        0 => NSTypesetterOriginalBehavior,
        1 => NSTypesetterBehavior_10_2_WithCompatibility,
        2 => NSTypesetterBehavior_10_2,
        3 => NSTypesetterBehavior_10_3,
        4 => NSTypesetterBehavior_10_4,
        _ =>
          throw ArgumentError("Unknown value for NSTypesetterBehavior: $value"),
      };
}

enum NSGlyphInscription {
  NSGlyphInscribeBase(0),
  NSGlyphInscribeBelow(1),
  NSGlyphInscribeAbove(2),
  NSGlyphInscribeOverstrike(3),
  NSGlyphInscribeOverBelow(4);

  final int value;
  const NSGlyphInscription(this.value);

  static NSGlyphInscription fromValue(int value) => switch (value) {
        0 => NSGlyphInscribeBase,
        1 => NSGlyphInscribeBelow,
        2 => NSGlyphInscribeAbove,
        3 => NSGlyphInscribeOverstrike,
        4 => NSGlyphInscribeOverBelow,
        _ =>
          throw ArgumentError("Unknown value for NSGlyphInscription: $value"),
      };
}

enum NSLineSweepDirection {
  NSLineSweepLeft(0),
  NSLineSweepRight(1),
  NSLineSweepDown(2),
  NSLineSweepUp(3);

  final int value;
  const NSLineSweepDirection(this.value);

  static NSLineSweepDirection fromValue(int value) => switch (value) {
        0 => NSLineSweepLeft,
        1 => NSLineSweepRight,
        2 => NSLineSweepDown,
        3 => NSLineSweepUp,
        _ =>
          throw ArgumentError("Unknown value for NSLineSweepDirection: $value"),
      };
}

enum NSLineMovementDirection {
  NSLineDoesntMove(0),
  NSLineMovesLeft(1),
  NSLineMovesRight(2),
  NSLineMovesDown(3),
  NSLineMovesUp(4);

  final int value;
  const NSLineMovementDirection(this.value);

  static NSLineMovementDirection fromValue(int value) => switch (value) {
        0 => NSLineDoesntMove,
        1 => NSLineMovesLeft,
        2 => NSLineMovesRight,
        3 => NSLineMovesDown,
        4 => NSLineMovesUp,
        _ => throw ArgumentError(
            "Unknown value for NSLineMovementDirection: $value"),
      };
}

enum NSTrackingAreaOptions {
  NSTrackingMouseEnteredAndExited(1),
  NSTrackingMouseMoved(2),
  NSTrackingCursorUpdate(4),
  NSTrackingActiveWhenFirstResponder(16),
  NSTrackingActiveInKeyWindow(32),
  NSTrackingActiveInActiveApp(64),
  NSTrackingActiveAlways(128),
  NSTrackingAssumeInside(256),
  NSTrackingInVisibleRect(512),
  NSTrackingEnabledDuringMouseDrag(1024);

  final int value;
  const NSTrackingAreaOptions(this.value);

  static NSTrackingAreaOptions fromValue(int value) => switch (value) {
        1 => NSTrackingMouseEnteredAndExited,
        2 => NSTrackingMouseMoved,
        4 => NSTrackingCursorUpdate,
        16 => NSTrackingActiveWhenFirstResponder,
        32 => NSTrackingActiveInKeyWindow,
        64 => NSTrackingActiveInActiveApp,
        128 => NSTrackingActiveAlways,
        256 => NSTrackingAssumeInside,
        512 => NSTrackingInVisibleRect,
        1024 => NSTrackingEnabledDuringMouseDrag,
        _ => throw ArgumentError(
            "Unknown value for NSTrackingAreaOptions: $value"),
      };
}

enum NSToolbarDisplayMode {
  NSToolbarDisplayModeDefault(0),
  NSToolbarDisplayModeIconAndLabel(1),
  NSToolbarDisplayModeIconOnly(2),
  NSToolbarDisplayModeLabelOnly(3);

  final int value;
  const NSToolbarDisplayMode(this.value);

  static NSToolbarDisplayMode fromValue(int value) => switch (value) {
        0 => NSToolbarDisplayModeDefault,
        1 => NSToolbarDisplayModeIconAndLabel,
        2 => NSToolbarDisplayModeIconOnly,
        3 => NSToolbarDisplayModeLabelOnly,
        _ =>
          throw ArgumentError("Unknown value for NSToolbarDisplayMode: $value"),
      };
}

enum NSToolbarSizeMode {
  NSToolbarSizeModeDefault(0),
  NSToolbarSizeModeRegular(1),
  NSToolbarSizeModeSmall(2);

  final int value;
  const NSToolbarSizeMode(this.value);

  static NSToolbarSizeMode fromValue(int value) => switch (value) {
        0 => NSToolbarSizeModeDefault,
        1 => NSToolbarSizeModeRegular,
        2 => NSToolbarSizeModeSmall,
        _ => throw ArgumentError("Unknown value for NSToolbarSizeMode: $value"),
      };
}

enum NSSelectionGranularity {
  NSSelectByCharacter(0),
  NSSelectByWord(1),
  NSSelectByParagraph(2);

  final int value;
  const NSSelectionGranularity(this.value);

  static NSSelectionGranularity fromValue(int value) => switch (value) {
        0 => NSSelectByCharacter,
        1 => NSSelectByWord,
        2 => NSSelectByParagraph,
        _ => throw ArgumentError(
            "Unknown value for NSSelectionGranularity: $value"),
      };
}

enum NSSelectionAffinity {
  NSSelectionAffinityUpstream(0),
  NSSelectionAffinityDownstream(1);

  final int value;
  const NSSelectionAffinity(this.value);

  static NSSelectionAffinity fromValue(int value) => switch (value) {
        0 => NSSelectionAffinityUpstream,
        1 => NSSelectionAffinityDownstream,
        _ =>
          throw ArgumentError("Unknown value for NSSelectionAffinity: $value"),
      };
}

enum NSStringDrawingOptions {
  NSStringDrawingUsesLineFragmentOrigin(1),
  NSStringDrawingUsesFontLeading(2),
  NSStringDrawingUsesDeviceMetrics(8),
  NSStringDrawingTruncatesLastVisibleLine(32),
  NSStringDrawingDisableScreenFontSubstitution(4),
  NSStringDrawingOneShot(16);

  final int value;
  const NSStringDrawingOptions(this.value);

  static NSStringDrawingOptions fromValue(int value) => switch (value) {
        1 => NSStringDrawingUsesLineFragmentOrigin,
        2 => NSStringDrawingUsesFontLeading,
        8 => NSStringDrawingUsesDeviceMetrics,
        32 => NSStringDrawingTruncatesLastVisibleLine,
        4 => NSStringDrawingDisableScreenFontSubstitution,
        16 => NSStringDrawingOneShot,
        _ => throw ArgumentError(
            "Unknown value for NSStringDrawingOptions: $value"),
      };
}

enum NSRulerOrientation {
  NSHorizontalRuler(0),
  NSVerticalRuler(1);

  final int value;
  const NSRulerOrientation(this.value);

  static NSRulerOrientation fromValue(int value) => switch (value) {
        0 => NSHorizontalRuler,
        1 => NSVerticalRuler,
        _ =>
          throw ArgumentError("Unknown value for NSRulerOrientation: $value"),
      };
}

enum NSLineCapStyle {
  NSLineCapStyleButt(0),
  NSLineCapStyleRound(1),
  NSLineCapStyleSquare(2);

  final int value;
  const NSLineCapStyle(this.value);

  static NSLineCapStyle fromValue(int value) => switch (value) {
        0 => NSLineCapStyleButt,
        1 => NSLineCapStyleRound,
        2 => NSLineCapStyleSquare,
        _ => throw ArgumentError("Unknown value for NSLineCapStyle: $value"),
      };
}

enum NSLineJoinStyle {
  NSLineJoinStyleMiter(0),
  NSLineJoinStyleRound(1),
  NSLineJoinStyleBevel(2);

  final int value;
  const NSLineJoinStyle(this.value);

  static NSLineJoinStyle fromValue(int value) => switch (value) {
        0 => NSLineJoinStyleMiter,
        1 => NSLineJoinStyleRound,
        2 => NSLineJoinStyleBevel,
        _ => throw ArgumentError("Unknown value for NSLineJoinStyle: $value"),
      };
}

enum NSWindingRule {
  NSWindingRuleNonZero(0),
  NSWindingRuleEvenOdd(1);

  final int value;
  const NSWindingRule(this.value);

  static NSWindingRule fromValue(int value) => switch (value) {
        0 => NSWindingRuleNonZero,
        1 => NSWindingRuleEvenOdd,
        _ => throw ArgumentError("Unknown value for NSWindingRule: $value"),
      };
}

enum NSBezierPathElement {
  NSBezierPathElementMoveTo(0),
  NSBezierPathElementLineTo(1),
  NSBezierPathElementCubicCurveTo(2),
  NSBezierPathElementClosePath(3),
  NSBezierPathElementQuadraticCurveTo(4);

  static const NSBezierPathElementCurveTo = NSBezierPathElementCubicCurveTo;

  final int value;
  const NSBezierPathElement(this.value);

  static NSBezierPathElement fromValue(int value) => switch (value) {
        0 => NSBezierPathElementMoveTo,
        1 => NSBezierPathElementLineTo,
        2 => NSBezierPathElementCubicCurveTo,
        3 => NSBezierPathElementClosePath,
        4 => NSBezierPathElementQuadraticCurveTo,
        _ =>
          throw ArgumentError("Unknown value for NSBezierPathElement: $value"),
      };

  @override
  String toString() {
    if (this == NSBezierPathElementCubicCurveTo)
      return "NSBezierPathElement.NSBezierPathElementCubicCurveTo, NSBezierPathElement.NSBezierPathElementCurveTo";
    return super.toString();
  }
}

final class CATransform3D extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m13;

  @ffi.Double()
  external double m14;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double m23;

  @ffi.Double()
  external double m24;

  @ffi.Double()
  external double m31;

  @ffi.Double()
  external double m32;

  @ffi.Double()
  external double m33;

  @ffi.Double()
  external double m34;

  @ffi.Double()
  external double m41;

  @ffi.Double()
  external double m42;

  @ffi.Double()
  external double m43;

  @ffi.Double()
  external double m44;
}

enum CAAutoresizingMask {
  kCALayerNotSizable(0),
  kCALayerMinXMargin(1),
  kCALayerWidthSizable(2),
  kCALayerMaxXMargin(4),
  kCALayerMinYMargin(8),
  kCALayerHeightSizable(16),
  kCALayerMaxYMargin(32);

  final int value;
  const CAAutoresizingMask(this.value);

  static CAAutoresizingMask fromValue(int value) => switch (value) {
        0 => kCALayerNotSizable,
        1 => kCALayerMinXMargin,
        2 => kCALayerWidthSizable,
        4 => kCALayerMaxXMargin,
        8 => kCALayerMinYMargin,
        16 => kCALayerHeightSizable,
        32 => kCALayerMaxYMargin,
        _ =>
          throw ArgumentError("Unknown value for CAAutoresizingMask: $value"),
      };
}

enum CAEdgeAntialiasingMask {
  kCALayerLeftEdge(1),
  kCALayerRightEdge(2),
  kCALayerBottomEdge(4),
  kCALayerTopEdge(8);

  final int value;
  const CAEdgeAntialiasingMask(this.value);

  static CAEdgeAntialiasingMask fromValue(int value) => switch (value) {
        1 => kCALayerLeftEdge,
        2 => kCALayerRightEdge,
        4 => kCALayerBottomEdge,
        8 => kCALayerTopEdge,
        _ => throw ArgumentError(
            "Unknown value for CAEdgeAntialiasingMask: $value"),
      };
}

enum CACornerMask {
  kCALayerMinXMinYCorner(1),
  kCALayerMaxXMinYCorner(2),
  kCALayerMinXMaxYCorner(4),
  kCALayerMaxXMaxYCorner(8);

  final int value;
  const CACornerMask(this.value);

  static CACornerMask fromValue(int value) => switch (value) {
        1 => kCALayerMinXMinYCorner,
        2 => kCALayerMaxXMinYCorner,
        4 => kCALayerMinXMaxYCorner,
        8 => kCALayerMaxXMaxYCorner,
        _ => throw ArgumentError("Unknown value for CACornerMask: $value"),
      };
}

enum NSTypesetterControlCharacterAction {
  NSTypesetterZeroAdvancementAction(1),
  NSTypesetterWhitespaceAction(2),
  NSTypesetterHorizontalTabAction(4),
  NSTypesetterLineBreakAction(8),
  NSTypesetterParagraphBreakAction(16),
  NSTypesetterContainerBreakAction(32);

  final int value;
  const NSTypesetterControlCharacterAction(this.value);

  static NSTypesetterControlCharacterAction fromValue(int value) =>
      switch (value) {
        1 => NSTypesetterZeroAdvancementAction,
        2 => NSTypesetterWhitespaceAction,
        4 => NSTypesetterHorizontalTabAction,
        8 => NSTypesetterLineBreakAction,
        16 => NSTypesetterParagraphBreakAction,
        32 => NSTypesetterContainerBreakAction,
        _ => throw ArgumentError(
            "Unknown value for NSTypesetterControlCharacterAction: $value"),
      };
}

enum NSTextListOptions {
  NSTextListPrependEnclosingMarker(1);

  final int value;
  const NSTextListOptions(this.value);

  static NSTextListOptions fromValue(int value) => switch (value) {
        1 => NSTextListPrependEnclosingMarker,
        _ => throw ArgumentError("Unknown value for NSTextListOptions: $value"),
      };
}

enum NSTextBlockValueType {
  NSTextBlockAbsoluteValueType(0),
  NSTextBlockPercentageValueType(1);

  final int value;
  const NSTextBlockValueType(this.value);

  static NSTextBlockValueType fromValue(int value) => switch (value) {
        0 => NSTextBlockAbsoluteValueType,
        1 => NSTextBlockPercentageValueType,
        _ =>
          throw ArgumentError("Unknown value for NSTextBlockValueType: $value"),
      };
}

enum NSTextBlockDimension {
  NSTextBlockWidth(0),
  NSTextBlockMinimumWidth(1),
  NSTextBlockMaximumWidth(2),
  NSTextBlockHeight(4),
  NSTextBlockMinimumHeight(5),
  NSTextBlockMaximumHeight(6);

  final int value;
  const NSTextBlockDimension(this.value);

  static NSTextBlockDimension fromValue(int value) => switch (value) {
        0 => NSTextBlockWidth,
        1 => NSTextBlockMinimumWidth,
        2 => NSTextBlockMaximumWidth,
        4 => NSTextBlockHeight,
        5 => NSTextBlockMinimumHeight,
        6 => NSTextBlockMaximumHeight,
        _ =>
          throw ArgumentError("Unknown value for NSTextBlockDimension: $value"),
      };
}

enum NSTextBlockLayer {
  NSTextBlockPadding(-1),
  NSTextBlockBorder(0),
  NSTextBlockMargin(1);

  final int value;
  const NSTextBlockLayer(this.value);

  static NSTextBlockLayer fromValue(int value) => switch (value) {
        -1 => NSTextBlockPadding,
        0 => NSTextBlockBorder,
        1 => NSTextBlockMargin,
        _ => throw ArgumentError("Unknown value for NSTextBlockLayer: $value"),
      };
}

enum NSTextBlockVerticalAlignment {
  NSTextBlockTopAlignment(0),
  NSTextBlockMiddleAlignment(1),
  NSTextBlockBottomAlignment(2),
  NSTextBlockBaselineAlignment(3);

  final int value;
  const NSTextBlockVerticalAlignment(this.value);

  static NSTextBlockVerticalAlignment fromValue(int value) => switch (value) {
        0 => NSTextBlockTopAlignment,
        1 => NSTextBlockMiddleAlignment,
        2 => NSTextBlockBottomAlignment,
        3 => NSTextBlockBaselineAlignment,
        _ => throw ArgumentError(
            "Unknown value for NSTextBlockVerticalAlignment: $value"),
      };
}

enum NSTextTableLayoutAlgorithm {
  NSTextTableAutomaticLayoutAlgorithm(0),
  NSTextTableFixedLayoutAlgorithm(1);

  final int value;
  const NSTextTableLayoutAlgorithm(this.value);

  static NSTextTableLayoutAlgorithm fromValue(int value) => switch (value) {
        0 => NSTextTableAutomaticLayoutAlgorithm,
        1 => NSTextTableFixedLayoutAlgorithm,
        _ => throw ArgumentError(
            "Unknown value for NSTextTableLayoutAlgorithm: $value"),
      };
}

enum NSTextSelectionGranularity {
  NSTextSelectionGranularityCharacter(0),
  NSTextSelectionGranularityWord(1),
  NSTextSelectionGranularityParagraph(2),
  NSTextSelectionGranularityLine(3),
  NSTextSelectionGranularitySentence(4);

  final int value;
  const NSTextSelectionGranularity(this.value);

  static NSTextSelectionGranularity fromValue(int value) => switch (value) {
        0 => NSTextSelectionGranularityCharacter,
        1 => NSTextSelectionGranularityWord,
        2 => NSTextSelectionGranularityParagraph,
        3 => NSTextSelectionGranularityLine,
        4 => NSTextSelectionGranularitySentence,
        _ => throw ArgumentError(
            "Unknown value for NSTextSelectionGranularity: $value"),
      };
}

enum NSTextSelectionAffinity {
  NSTextSelectionAffinityUpstream(0),
  NSTextSelectionAffinityDownstream(1);

  final int value;
  const NSTextSelectionAffinity(this.value);

  static NSTextSelectionAffinity fromValue(int value) => switch (value) {
        0 => NSTextSelectionAffinityUpstream,
        1 => NSTextSelectionAffinityDownstream,
        _ => throw ArgumentError(
            "Unknown value for NSTextSelectionAffinity: $value"),
      };
}

enum NSTextSelectionNavigationDirection {
  NSTextSelectionNavigationDirectionForward(0),
  NSTextSelectionNavigationDirectionBackward(1),
  NSTextSelectionNavigationDirectionRight(2),
  NSTextSelectionNavigationDirectionLeft(3),
  NSTextSelectionNavigationDirectionUp(4),
  NSTextSelectionNavigationDirectionDown(5);

  final int value;
  const NSTextSelectionNavigationDirection(this.value);

  static NSTextSelectionNavigationDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationDirectionForward,
        1 => NSTextSelectionNavigationDirectionBackward,
        2 => NSTextSelectionNavigationDirectionRight,
        3 => NSTextSelectionNavigationDirectionLeft,
        4 => NSTextSelectionNavigationDirectionUp,
        5 => NSTextSelectionNavigationDirectionDown,
        _ => throw ArgumentError(
            "Unknown value for NSTextSelectionNavigationDirection: $value"),
      };
}

enum NSTextSelectionNavigationDestination {
  NSTextSelectionNavigationDestinationCharacter(0),
  NSTextSelectionNavigationDestinationWord(1),
  NSTextSelectionNavigationDestinationLine(2),
  NSTextSelectionNavigationDestinationSentence(3),
  NSTextSelectionNavigationDestinationParagraph(4),
  NSTextSelectionNavigationDestinationContainer(5),
  NSTextSelectionNavigationDestinationDocument(6);

  final int value;
  const NSTextSelectionNavigationDestination(this.value);

  static NSTextSelectionNavigationDestination fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationDestinationCharacter,
        1 => NSTextSelectionNavigationDestinationWord,
        2 => NSTextSelectionNavigationDestinationLine,
        3 => NSTextSelectionNavigationDestinationSentence,
        4 => NSTextSelectionNavigationDestinationParagraph,
        5 => NSTextSelectionNavigationDestinationContainer,
        6 => NSTextSelectionNavigationDestinationDocument,
        _ => throw ArgumentError(
            "Unknown value for NSTextSelectionNavigationDestination: $value"),
      };
}

enum NSTextSelectionNavigationModifier {
  NSTextSelectionNavigationModifierExtend(1),
  NSTextSelectionNavigationModifierVisual(2),
  NSTextSelectionNavigationModifierMultiple(4);

  final int value;
  const NSTextSelectionNavigationModifier(this.value);

  static NSTextSelectionNavigationModifier fromValue(int value) =>
      switch (value) {
        1 => NSTextSelectionNavigationModifierExtend,
        2 => NSTextSelectionNavigationModifierVisual,
        4 => NSTextSelectionNavigationModifierMultiple,
        _ => throw ArgumentError(
            "Unknown value for NSTextSelectionNavigationModifier: $value"),
      };
}

enum NSTextSelectionNavigationWritingDirection {
  NSTextSelectionNavigationWritingDirectionLeftToRight(0),
  NSTextSelectionNavigationWritingDirectionRightToLeft(1);

  final int value;
  const NSTextSelectionNavigationWritingDirection(this.value);

  static NSTextSelectionNavigationWritingDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationWritingDirectionLeftToRight,
        1 => NSTextSelectionNavigationWritingDirectionRightToLeft,
        _ => throw ArgumentError(
            "Unknown value for NSTextSelectionNavigationWritingDirection: $value"),
      };
}

enum NSTextSelectionNavigationLayoutOrientation {
  NSTextSelectionNavigationLayoutOrientationHorizontal(0),
  NSTextSelectionNavigationLayoutOrientationVertical(1);

  final int value;
  const NSTextSelectionNavigationLayoutOrientation(this.value);

  static NSTextSelectionNavigationLayoutOrientation fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationLayoutOrientationHorizontal,
        1 => NSTextSelectionNavigationLayoutOrientationVertical,
        _ => throw ArgumentError(
            "Unknown value for NSTextSelectionNavigationLayoutOrientation: $value"),
      };
}

enum NSTextContentManagerEnumerationOptions {
  NSTextContentManagerEnumerationOptionsNone(0),
  NSTextContentManagerEnumerationOptionsReverse(1);

  final int value;
  const NSTextContentManagerEnumerationOptions(this.value);

  static NSTextContentManagerEnumerationOptions fromValue(int value) =>
      switch (value) {
        0 => NSTextContentManagerEnumerationOptionsNone,
        1 => NSTextContentManagerEnumerationOptionsReverse,
        _ => throw ArgumentError(
            "Unknown value for NSTextContentManagerEnumerationOptions: $value"),
      };
}

enum NSTextLayoutFragmentEnumerationOptions {
  NSTextLayoutFragmentEnumerationOptionsNone(0),
  NSTextLayoutFragmentEnumerationOptionsReverse(1),
  NSTextLayoutFragmentEnumerationOptionsEstimatesSize(2),
  NSTextLayoutFragmentEnumerationOptionsEnsuresLayout(4),
  NSTextLayoutFragmentEnumerationOptionsEnsuresExtraLineFragment(8);

  final int value;
  const NSTextLayoutFragmentEnumerationOptions(this.value);

  static NSTextLayoutFragmentEnumerationOptions fromValue(int value) =>
      switch (value) {
        0 => NSTextLayoutFragmentEnumerationOptionsNone,
        1 => NSTextLayoutFragmentEnumerationOptionsReverse,
        2 => NSTextLayoutFragmentEnumerationOptionsEstimatesSize,
        4 => NSTextLayoutFragmentEnumerationOptionsEnsuresLayout,
        8 => NSTextLayoutFragmentEnumerationOptionsEnsuresExtraLineFragment,
        _ => throw ArgumentError(
            "Unknown value for NSTextLayoutFragmentEnumerationOptions: $value"),
      };
}

enum NSTextLayoutFragmentState {
  NSTextLayoutFragmentStateNone(0),
  NSTextLayoutFragmentStateEstimatedUsageBounds(1),
  NSTextLayoutFragmentStateCalculatedUsageBounds(2),
  NSTextLayoutFragmentStateLayoutAvailable(3);

  final int value;
  const NSTextLayoutFragmentState(this.value);

  static NSTextLayoutFragmentState fromValue(int value) => switch (value) {
        0 => NSTextLayoutFragmentStateNone,
        1 => NSTextLayoutFragmentStateEstimatedUsageBounds,
        2 => NSTextLayoutFragmentStateCalculatedUsageBounds,
        3 => NSTextLayoutFragmentStateLayoutAvailable,
        _ => throw ArgumentError(
            "Unknown value for NSTextLayoutFragmentState: $value"),
      };
}

enum NSTextLayoutManagerSegmentType {
  NSTextLayoutManagerSegmentTypeStandard(0),
  NSTextLayoutManagerSegmentTypeSelection(1),
  NSTextLayoutManagerSegmentTypeHighlight(2);

  final int value;
  const NSTextLayoutManagerSegmentType(this.value);

  static NSTextLayoutManagerSegmentType fromValue(int value) => switch (value) {
        0 => NSTextLayoutManagerSegmentTypeStandard,
        1 => NSTextLayoutManagerSegmentTypeSelection,
        2 => NSTextLayoutManagerSegmentTypeHighlight,
        _ => throw ArgumentError(
            "Unknown value for NSTextLayoutManagerSegmentType: $value"),
      };
}

enum NSTextLayoutManagerSegmentOptions {
  NSTextLayoutManagerSegmentOptionsNone(0),
  NSTextLayoutManagerSegmentOptionsRangeNotRequired(1),
  NSTextLayoutManagerSegmentOptionsMiddleFragmentsExcluded(2),
  NSTextLayoutManagerSegmentOptionsHeadSegmentExtended(4),
  NSTextLayoutManagerSegmentOptionsTailSegmentExtended(8),
  NSTextLayoutManagerSegmentOptionsUpstreamAffinity(16);

  final int value;
  const NSTextLayoutManagerSegmentOptions(this.value);

  static NSTextLayoutManagerSegmentOptions fromValue(int value) =>
      switch (value) {
        0 => NSTextLayoutManagerSegmentOptionsNone,
        1 => NSTextLayoutManagerSegmentOptionsRangeNotRequired,
        2 => NSTextLayoutManagerSegmentOptionsMiddleFragmentsExcluded,
        4 => NSTextLayoutManagerSegmentOptionsHeadSegmentExtended,
        8 => NSTextLayoutManagerSegmentOptionsTailSegmentExtended,
        16 => NSTextLayoutManagerSegmentOptionsUpstreamAffinity,
        _ => throw ArgumentError(
            "Unknown value for NSTextLayoutManagerSegmentOptions: $value"),
      };
}
