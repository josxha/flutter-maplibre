// ignore_for_file: type=lint, unused_element, unused_field |
// dart format off

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    instancetype Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()
external instancetype _MapLibreFFi_protocolTrampoline_10z9f5k(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
);

@ffi.Native<
    ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external int _MapLibreFFi_protocolTrampoline_1ldqghh(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_1q0i84(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCBlockImpl> arg2,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1a22wz(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_1a22wz(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external bool _MapLibreFFi_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external void _MapLibreFFi_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    instancetype Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external instancetype _MapLibreFFi_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_lmc3p5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_lmc3p5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    UIEdgeInsets Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external UIEdgeInsets _MapLibreFFi_protocolTrampoline_1rtilx3(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external objc.CGRect _MapLibreFFi_protocolTrampoline_szn7s6(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_zi5eed(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external objc.CGPoint _MapLibreFFi_protocolTrampoline_7ohnx8(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1bktu2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_1bktu2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGPoint)>()
external void _MapLibreFFi_protocolTrampoline_1bktu2(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
);

@ffi.Native<
    objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external objc.CGRect _MapLibreFFi_protocolTrampoline_1c3uc0w(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    CGAffineTransform Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external CGAffineTransform _MapLibreFFi_protocolTrampoline_8o6he9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1lznlw3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_1lznlw3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        CGAffineTransform)>()
external void _MapLibreFFi_protocolTrampoline_1lznlw3(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  CGAffineTransform arg1,
);

@ffi.Native<
    ffi.UnsignedLong Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _MapLibreFFi_protocolTrampoline_ku69ws(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>()
external objc.CGPoint _MapLibreFFi_protocolTrampoline_17ipln5(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        objc.CGRect, ffi.Pointer<objc.ObjCObject>)>()
external objc.CGRect _MapLibreFFi_protocolTrampoline_1sh7l9z(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _MapLibreFFi_protocolTrampoline_1qeotwu(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external void _MapLibreFFi_protocolTrampoline_ovsamd(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external bool _MapLibreFFi_protocolTrampoline_3su7tt(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()
external void _MapLibreFFi_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGRect)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_12thpau(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_qvcerx(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_qvcerx(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>)>()
external void _MapLibreFFi_protocolTrampoline_qvcerx(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<CGContext> arg2,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_g285me(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCSelector> arg3,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_wyrm70(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCSelector> arg2,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1l4hxwm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_1l4hxwm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCBlockImpl>)>()
external void _MapLibreFFi_protocolTrampoline_1l4hxwm(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
);

@ffi.Native<
    ffi.UnsignedLong Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _MapLibreFFi_protocolTrampoline_1tmn9mr(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1lmpkp(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_1lmpkp(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.UnsignedLong)>()
external void _MapLibreFFi_protocolTrampoline_1lmpkp(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
    ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _MapLibreFFi_protocolTrampoline_gvl1rz(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_1mm4s9d(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_1mm4s9d(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Long)>()
external void _MapLibreFFi_protocolTrampoline_1mm4s9d(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_10lndml(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_10lndml(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Bool)>()
external void _MapLibreFFi_protocolTrampoline_10lndml(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  bool arg1,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()
external bool _MapLibreFFi_protocolTrampoline_2n06mv(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_6p7ndb(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_6p7ndb(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_13x5jor(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_13x5jor(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    CLLocationCoordinate2D Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external CLLocationCoordinate2D _MapLibreFFi_protocolTrampoline_neuenc(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    MLNCoordinateBounds Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external MLNCoordinateBounds _MapLibreFFi_protocolTrampoline_1fkc0ji(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        MLNCoordinateBounds)>()
external bool _MapLibreFFi_protocolTrampoline_krbldm(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  MLNCoordinateBounds arg1,
);

@ffi.Native<
    ffi.UnsignedLong Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _MapLibreFFi_protocolTrampoline_1ckyi24(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.UnsignedLong,
        ffi.UnsignedLong,
        ffi.UnsignedLong)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_fclj7c(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
  int arg2,
  int arg3,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>, MLNCoordinateBounds, ffi.UnsignedLong)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_129i16p(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  MLNCoordinateBounds arg1,
  int arg2,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapListenerBlock_r8gdi7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _MapLibreFFi_wrapBlockingBlock_r8gdi7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<objc.ObjCObject>)>()
external ffi.Pointer<objc.ObjCObject> _MapLibreFFi_protocolTrampoline_1fy0zqa(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  int arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
);

final class CGVector extends ffi.Struct {
  @ffi.Double()
  external double dx;

  @ffi.Double()
  external double dy;
}

final class CGAffineTransform extends ffi.Struct {
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;
}

late final _class_NSString = objc.getClass("NSString");
late final _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_ =
    objc.registerName(
        "stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:");
final _objc_msgSend_1q2ox4r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Bool>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Bool>)>();

/// NSStringEncodingDetection
extension NSStringEncodingDetection on objc.NSString {
  /// stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:
  static int stringEncodingForData(objc.NSData data,
      {objc.NSDictionary? encodingOptions,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> convertedString,
      required ffi.Pointer<ffi.Bool> usedLossyConversion}) {
    objc.checkOsVersionInternal(
        'NSString.stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:',
        iOS: (false, (8, 0, 0)),
        macOS: (false, (10, 10, 0)));
    return _objc_msgSend_1q2ox4r(
        _class_NSString,
        _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_,
        data.ref.pointer,
        encodingOptions?.ref.pointer ?? ffi.nullptr,
        convertedString,
        usedLossyConversion);
  }
}

late final _sel_readableTypeIdentifiersForItemProvider =
    objc.registerName("readableTypeIdentifiersForItemProvider");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSArray_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSArray Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSArray_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_objectWithItemProviderData_typeIdentifier_error_ =
    objc.registerName("objectWithItemProviderData:typeIdentifier:error:");
final _objc_msgSend_1pnyuds = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
instancetype
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        instancetype Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>()
                .asFunction<
                    instancetype Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()(
            arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
            _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
            _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>,
              objc.NSData,
              objc.NSString,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject>? Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSData,
                  objc.NSString,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>,
                      objc.NSData,
                      objc.NSString,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
              objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
                      fn(arg0, objc.NSData.castFromPointer(arg1, retain: true, release: true), objc.NSString.castFromPointer(arg2, retain: true, release: true), arg3)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSData,
            objc.NSString,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSData arg1, objc.NSString arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>()
              .asFunction<
                  instancetype Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()
              (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>().asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3),
          retain: true,
          release: true);
}

late final _sel_writableTypeIdentifiersForItemProvider =
    objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ =
    objc.registerName(
        "itemProviderVisibilityForRepresentationWithTypeIdentifier:");
final _objc_msgSend_16fy0up = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Long Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Long Function(ffi.Pointer<ffi.Void>,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newPointerBlock(
              _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(
          objc.NSItemProviderRepresentationVisibility Function(
                  ffi.Pointer<ffi.Void>, objc.NSString)
              fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newClosureBlock(
              _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true)).value,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.NSItemProviderRepresentationVisibility call(
          ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      objc.NSItemProviderRepresentationVisibility.fromValue(ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Long Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer));
}

/// WARNING: NSProgress is a stub. To generate bindings for this class, include
/// NSProgress in your config's objc-interfaces list.
///
/// NSProgress
class NSProgress extends objc.NSObject {
  NSProgress._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSProgress',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
  }

  /// Constructs a [NSProgress] that points to the same underlying object as [other].
  NSProgress.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSProgress] that wraps the given raw object pointer.
  NSProgress.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(
          void Function(objc.NSData?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSData_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSData.castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      listener(void Function(objc.NSData?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      blocking(void Function(objc.NSData?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
      arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ =
    objc.registerName(
        "loadDataWithTypeIdentifier:forItemProviderCompletionHandler:");
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
              objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
                      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
              objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>> ptr) =>
          objc.ObjCBlock<
                  NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
                      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(
              objc.newPointerBlock(_ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      fromFunction(NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
                      fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true), ObjCBlock_ffiVoid_NSData_NSError.castFromPointer(arg2, retain: true, release: true))?.ref.retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_CallExtension
    on objc.ObjCBlock<
        NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
            objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> {
  NSProgress? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCBlockImpl>)>()
                  (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
                  .address ==
              0
          ? null
          : NSProgress.castFromPointer(
              ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>().asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCBlockImpl>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
              retain: true,
              release: true);
}

/// NSItemProvider
extension NSItemProvider on objc.NSString {
  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal(
        'NSString.readableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSString, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static objc.NSString? objectWithItemProviderData(objc.NSData data,
      {required objc.NSString typeIdentifier,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSString.objectWithItemProviderData:typeIdentifier:error:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1pnyuds(
        _class_NSString,
        _sel_objectWithItemProviderData_typeIdentifier_error_,
        data.ref.pointer,
        typeIdentifier.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal(
        'NSString.writableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSString, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider$1 {
    objc.checkOsVersionInternal(
        'NSString.writableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSString', 'writableTypeIdentifiersForItemProvider');
    }
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier(
          objc.NSString typeIdentifier) {
    objc.checkOsVersionInternal(
        'NSString.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(_class_NSString,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSString',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        _class_NSString,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier$1(
          objc.NSString typeIdentifier) {
    objc.checkOsVersionInternal(
        'NSString.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSString',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  NSProgress? loadDataWithTypeIdentifier(objc.NSString typeIdentifier,
      {required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
          forItemProviderCompletionHandler}) {
    objc.checkOsVersionInternal(
        'NSString.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        typeIdentifier.ref.pointer,
        forItemProviderCompletionHandler.ref.pointer);
    return _ret.address == 0
        ? null
        : NSProgress.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_propertyList = objc.registerName("propertyList");
late final _sel_propertyListFromStringsFileFormat =
    objc.registerName("propertyListFromStringsFileFormat");

/// NSExtendedStringPropertyListParsing
extension NSExtendedStringPropertyListParsing on objc.NSString {
  /// propertyList
  objc.ObjCObjectBase propertyList() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_propertyList);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// propertyListFromStringsFileFormat
  objc.NSDictionary? propertyListFromStringsFileFormat() {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_propertyListFromStringsFileFormat);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_cString = objc.registerName("cString");
final _objc_msgSend_1fuqfwb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_lossyCString = objc.registerName("lossyCString");
late final _sel_cStringLength = objc.registerName("cStringLength");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_getCString_ = objc.registerName("getCString:");
final _objc_msgSend_1r7ue5f = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)>();
late final _sel_getCString_maxLength_ =
    objc.registerName("getCString:maxLength:");
final _objc_msgSend_1h3mito = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>, int)>();
late final _sel_getCString_maxLength_range_remainingRange_ =
    objc.registerName("getCString:maxLength:range:remainingRange:");
final _objc_msgSend_3gpdva = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong,
                objc.NSRange,
                ffi.Pointer<objc.NSRange>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Char>,
            int,
            objc.NSRange,
            ffi.Pointer<objc.NSRange>)>();
late final _sel_writeToFile_atomically_ =
    objc.registerName("writeToFile:atomically:");
final _objc_msgSend_1iyq28l = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_writeToURL_atomically_ =
    objc.registerName("writeToURL:atomically:");
late final _sel_initWithContentsOfFile_ =
    objc.registerName("initWithContentsOfFile:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithContentsOfURL_ =
    objc.registerName("initWithContentsOfURL:");
late final _sel_stringWithContentsOfFile_ =
    objc.registerName("stringWithContentsOfFile:");
late final _sel_stringWithContentsOfURL_ =
    objc.registerName("stringWithContentsOfURL:");
late final _sel_initWithCStringNoCopy_length_freeWhenDone_ =
    objc.registerName("initWithCStringNoCopy:length:freeWhenDone:");
final _objc_msgSend_1ojrli4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Char>,
            int,
            bool)>();
late final _sel_initWithCString_length_ =
    objc.registerName("initWithCString:length:");
final _objc_msgSend_erqryg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>, int)>();
late final _sel_initWithCString_ = objc.registerName("initWithCString:");
final _objc_msgSend_56zxyn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)>();
late final _sel_stringWithCString_length_ =
    objc.registerName("stringWithCString:length:");
late final _sel_stringWithCString_ = objc.registerName("stringWithCString:");
late final _sel_getCharacters_ = objc.registerName("getCharacters:");
final _objc_msgSend_g3kdhc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedShort>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.UnsignedShort>)>();

/// NSStringDeprecated
extension NSStringDeprecated on objc.NSString {
  /// cString
  ffi.Pointer<ffi.Char> cString() {
    objc.checkOsVersionInternal('NSString.cString',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1fuqfwb(this.ref.pointer, _sel_cString);
  }

  /// lossyCString
  ffi.Pointer<ffi.Char> lossyCString() {
    objc.checkOsVersionInternal('NSString.lossyCString',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1fuqfwb(this.ref.pointer, _sel_lossyCString);
  }

  /// cStringLength
  int cStringLength() {
    objc.checkOsVersionInternal('NSString.cStringLength',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_cStringLength);
  }

  /// getCString:
  void getCString(ffi.Pointer<ffi.Char> bytes) {
    objc.checkOsVersionInternal('NSString.getCString:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_1r7ue5f(this.ref.pointer, _sel_getCString_, bytes);
  }

  /// getCString:maxLength:
  void getCString$1(ffi.Pointer<ffi.Char> bytes, {required int maxLength}) {
    objc.checkOsVersionInternal('NSString.getCString:maxLength:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_1h3mito(
        this.ref.pointer, _sel_getCString_maxLength_, bytes, maxLength);
  }

  /// getCString:maxLength:range:remainingRange:
  void getCString$2(ffi.Pointer<ffi.Char> bytes,
      {required int maxLength,
      required objc.NSRange range,
      required ffi.Pointer<objc.NSRange> remainingRange}) {
    objc.checkOsVersionInternal(
        'NSString.getCString:maxLength:range:remainingRange:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    _objc_msgSend_3gpdva(
        this.ref.pointer,
        _sel_getCString_maxLength_range_remainingRange_,
        bytes,
        maxLength,
        range,
        remainingRange);
  }

  /// writeToFile:atomically:
  bool writeToFile(objc.NSString path, {required bool atomically}) {
    objc.checkOsVersionInternal('NSString.writeToFile:atomically:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(this.ref.pointer, _sel_writeToFile_atomically_,
        path.ref.pointer, atomically);
  }

  /// writeToURL:atomically:
  bool writeToURL(objc.NSURL url, {required bool atomically}) {
    objc.checkOsVersionInternal('NSString.writeToURL:atomically:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(this.ref.pointer, _sel_writeToURL_atomically_,
        url.ref.pointer, atomically);
  }

  /// initWithContentsOfFile:
  objc.ObjCObjectBase? initWithContentsOfFile(objc.NSString path) {
    objc.checkOsVersionInternal('NSString.initWithContentsOfFile:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.ObjCObjectBase? initWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal('NSString.initWithContentsOfURL:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// stringWithContentsOfFile:
  static objc.ObjCObjectBase? stringWithContentsOfFile(objc.NSString path) {
    objc.checkOsVersionInternal('NSString.stringWithContentsOfFile:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSString, _sel_stringWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// stringWithContentsOfURL:
  static objc.ObjCObjectBase? stringWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal('NSString.stringWithContentsOfURL:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSString, _sel_stringWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithCStringNoCopy:length:freeWhenDone:
  objc.ObjCObjectBase? initWithCStringNoCopy(ffi.Pointer<ffi.Char> bytes,
      {required int length, required bool freeWhenDone}) {
    objc.checkOsVersionInternal(
        'NSString.initWithCStringNoCopy:length:freeWhenDone:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1ojrli4(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCStringNoCopy_length_freeWhenDone_,
        bytes,
        length,
        freeWhenDone);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// initWithCString:length:
  objc.ObjCObjectBase? initWithCString(ffi.Pointer<ffi.Char> bytes,
      {required int length}) {
    objc.checkOsVersionInternal('NSString.initWithCString:length:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_erqryg(this.ref.retainAndReturnPointer(),
        _sel_initWithCString_length_, bytes, length);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// initWithCString:
  objc.ObjCObjectBase? initWithCString$1(ffi.Pointer<ffi.Char> bytes) {
    objc.checkOsVersionInternal('NSString.initWithCString:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_56zxyn(
        this.ref.retainAndReturnPointer(), _sel_initWithCString_, bytes);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// stringWithCString:length:
  static objc.ObjCObjectBase? stringWithCString(ffi.Pointer<ffi.Char> bytes,
      {required int length}) {
    objc.checkOsVersionInternal('NSString.stringWithCString:length:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_erqryg(
        _class_NSString, _sel_stringWithCString_length_, bytes, length);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// stringWithCString:
  static objc.ObjCObjectBase? stringWithCString$1(ffi.Pointer<ffi.Char> bytes) {
    objc.checkOsVersionInternal('NSString.stringWithCString:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_56zxyn(_class_NSString, _sel_stringWithCString_, bytes);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// getCharacters:
  void getCharacters(ffi.Pointer<ffi.UnsignedShort> buffer) {
    _objc_msgSend_g3kdhc(this.ref.pointer, _sel_getCharacters_, buffer);
  }
}

void _ObjCBlock_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function()>>()
        .asFunction<void Function()>()();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_fnPtrCallable = ffi.Pointer
        .fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_fnPtrTrampoline)
    .cast();
void _ObjCBlock_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    (objc.getBlockClosure(block) as void Function())();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_closureCallable = ffi.Pointer
        .fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_closureTrampoline)
    .cast();
void _ObjCBlock_ffiVoid_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) {
  (objc.getBlockClosure(block) as void Function())();
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter) {
  try {
    (objc.getBlockClosure(block) as void Function())();
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.isolateLocal(
        _ObjCBlock_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function()>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr) =>
      objc.ObjCBlock<ffi.Void Function()>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(void Function() fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function()>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_closureCallable, () => fn(), keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(void Function() fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_listenerCallable.nativeFunction.cast(),
        () => fn(),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(void Function() fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_blockingCallable.nativeFunction.cast(),
        () => fn(),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_blockingListenerCallable.nativeFunction.cast(),
        () => fn(),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1pl9qdv(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

ffi.Pointer<objc.ObjCBlockImpl>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCBlockImpl> Function(
                        ffi.Pointer<objc.ObjCObject> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCBlockImpl> Function(
                    ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCBlockImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCBlockImpl>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCBlockImpl>
            Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCBlockImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>`.
abstract final class ObjCBlock_NSProgressUnpublishingHandler_NSProgress {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.ObjCBlock<ffi.Void Function()>? Function(
                  NSProgress)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCBlockImpl> Function(
                          ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
          objc.newPointerBlock(
              _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>
      fromFunction(objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0) =>
                      fn(NSProgress.castFromPointer(arg0, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>`.
extension ObjCBlock_NSProgressUnpublishingHandler_NSProgress_CallExtension
    on objc
    .ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)> {
  objc.ObjCBlock<ffi.Void Function()>? call(NSProgress arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCBlockImpl> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : ObjCBlock_ffiVoid.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true);
}

/// WARNING: NSProgressReporting is a stub. To generate bindings for this class, include
/// NSProgressReporting in your config's objc-protocols list.
///
/// NSProgressReporting
interface class NSProgressReporting extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSProgressReporting._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSProgressReporting] that points to the same underlying object as [other].
  NSProgressReporting.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSProgressReporting] that wraps the given raw object pointer.
  NSProgressReporting.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_variantFittingPresentationWidth_ =
    objc.registerName("variantFittingPresentationWidth:");
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// NSBundleExtensionMethods
extension NSBundleExtensionMethods on objc.NSString {
  /// variantFittingPresentationWidth:
  objc.NSString variantFittingPresentationWidth(int width) {
    objc.checkOsVersionInternal('NSString.variantFittingPresentationWidth:',
        iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_qugqlf(
        this.ref.pointer, _sel_variantFittingPresentationWidth_, width);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_NSAttributedString = objc.getClass("NSAttributedString");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_length = objc.registerName("length");
late final _sel_attribute_atIndex_effectiveRange_ =
    objc.registerName("attribute:atIndex:effectiveRange:");
final _objc_msgSend_7km9vu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.NSRange>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.NSRange>)>();
late final _sel_attributedSubstringFromRange_ =
    objc.registerName("attributedSubstringFromRange:");
final _objc_msgSend_1k1o1s7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>();
late final _sel_attributesAtIndex_longestEffectiveRange_inRange_ =
    objc.registerName("attributesAtIndex:longestEffectiveRange:inRange:");
final _objc_msgSend_1pp2gs8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.NSRange>,
                objc.NSRange)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.NSRange>,
            objc.NSRange)>();
late final _sel_attribute_atIndex_longestEffectiveRange_inRange_ =
    objc.registerName("attribute:atIndex:longestEffectiveRange:inRange:");
final _objc_msgSend_1k1akuq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.NSRange>,
                objc.NSRange)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.NSRange>,
            objc.NSRange)>();
late final _sel_isEqualToAttributedString_ =
    objc.registerName("isEqualToAttributedString:");

enum NSAttributedStringEnumerationOptions {
  NSAttributedStringEnumerationReverse(2),
  NSAttributedStringEnumerationLongestEffectiveRangeNotRequired(1048576);

  final int value;
  const NSAttributedStringEnumerationOptions(this.value);

  static NSAttributedStringEnumerationOptions fromValue(int value) =>
      switch (value) {
        2 => NSAttributedStringEnumerationReverse,
        1048576 =>
          NSAttributedStringEnumerationLongestEffectiveRangeNotRequired,
        _ => throw ArgumentError(
            'Unknown value for NSAttributedStringEnumerationOptions: $value'),
      };
}

void _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        objc.NSRange arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>, objc.NSRange,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    objc.NSRange,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        objc.NSRange arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        objc.NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    objc.NSRange,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    objc.NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
      objc.NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, objc.NSRange, ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    objc.NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        objc.NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSDictionary_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      fromFunction(void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                          ffi.Pointer<ffi.Bool> arg2) =>
                      fn(objc.NSDictionary.castFromPointer(arg0, retain: true, release: true), arg1, arg2),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> listener(
      void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(
                objc.NSDictionary.castFromPointer(arg0,
                    retain: false, release: true),
                arg1,
                arg2),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1a22wz(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSDictionary, objc.NSRange,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> blocking(
      void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(
                objc.NSDictionary.castFromPointer(arg0,
                    retain: false, release: true),
                arg1,
                arg2),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(
                objc.NSDictionary.castFromPointer(arg0,
                    retain: false, release: true),
                arg1,
                arg2),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1a22wz(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSDictionary, objc.NSRange,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSDictionary_NSRange_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> {
  void call(objc.NSDictionary arg0, objc.NSRange arg1,
          ffi.Pointer<ffi.Bool> arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          objc.NSRange arg1,
                          ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>()(
          ref.pointer, arg0.ref.pointer, arg1, arg2);
}

late final _sel_enumerateAttributesInRange_options_usingBlock_ =
    objc.registerName("enumerateAttributesInRange:options:usingBlock:");
final _objc_msgSend_1kok4b = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
void _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        objc.NSRange arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>, objc.NSRange,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    objc.NSRange,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        objc.NSRange arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        objc.NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    objc.NSRange,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    objc.NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
      objc.NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, objc.NSRange, ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    objc.NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        objc.NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.isolateLocal(
        _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
              ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      fromFunction(void Function(objc.ObjCObjectBase?, objc.NSRange, ffi.Pointer<ffi.Bool>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                          ffi.Pointer<ffi.Bool> arg2) =>
                      fn(arg0.address == 0 ? null : objc.ObjCObjectBase(arg0, retain: true, release: true), arg1, arg2),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
          ffi.Pointer<ffi.Bool>)> listener(
      void Function(objc.ObjCObjectBase?, objc.NSRange, ffi.Pointer<ffi.Bool>)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg0, retain: false, release: true),
                arg1,
                arg2),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1a22wz(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
          ffi.Pointer<ffi.Bool>)> blocking(
      void Function(objc.ObjCObjectBase?, objc.NSRange, ffi.Pointer<ffi.Bool>)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg0, retain: false, release: true),
                arg1,
                arg2),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg0, retain: false, release: true),
                arg1,
                arg2),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1a22wz(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_objcObjCObject_NSRange_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
            ffi.Pointer<ffi.Bool>)> {
  void call(objc.ObjCObjectBase? arg0, objc.NSRange arg1,
          ffi.Pointer<ffi.Bool> arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          objc.NSRange arg1,
                          ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>()(
          ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2);
}

late final _sel_enumerateAttribute_inRange_options_usingBlock_ =
    objc.registerName("enumerateAttribute:inRange:options:usingBlock:");
final _objc_msgSend_ipgwfh = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// NSExtendedAttributedString
extension NSExtendedAttributedString on NSAttributedString {
  /// length
  int get length {
    objc.checkOsVersionInternal('NSAttributedString.length',
        iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_length);
  }

  /// attribute:atIndex:effectiveRange:
  objc.ObjCObjectBase? attribute(objc.NSString attrName,
      {required int atIndex,
      required ffi.Pointer<objc.NSRange> effectiveRange}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.attribute:atIndex:effectiveRange:',
        iOS: (false, (3, 2, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_7km9vu(
        this.ref.pointer,
        _sel_attribute_atIndex_effectiveRange_,
        attrName.ref.pointer,
        atIndex,
        effectiveRange);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// attributedSubstringFromRange:
  NSAttributedString attributedSubstringFromRange(objc.NSRange range) {
    objc.checkOsVersionInternal(
        'NSAttributedString.attributedSubstringFromRange:',
        iOS: (false, (3, 2, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1k1o1s7(
        this.ref.pointer, _sel_attributedSubstringFromRange_, range);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// attributesAtIndex:longestEffectiveRange:inRange:
  objc.NSDictionary attributesAtIndex(int location,
      {required ffi.Pointer<objc.NSRange> longestEffectiveRange,
      required objc.NSRange inRange}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.attributesAtIndex:longestEffectiveRange:inRange:',
        iOS: (false, (3, 2, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1pp2gs8(
        this.ref.pointer,
        _sel_attributesAtIndex_longestEffectiveRange_inRange_,
        location,
        longestEffectiveRange,
        inRange);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// attribute:atIndex:longestEffectiveRange:inRange:
  objc.ObjCObjectBase? attribute$1(objc.NSString attrName,
      {required int atIndex,
      required ffi.Pointer<objc.NSRange> longestEffectiveRange,
      required objc.NSRange inRange}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.attribute:atIndex:longestEffectiveRange:inRange:',
        iOS: (false, (3, 2, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1k1akuq(
        this.ref.pointer,
        _sel_attribute_atIndex_longestEffectiveRange_inRange_,
        attrName.ref.pointer,
        atIndex,
        longestEffectiveRange,
        inRange);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// isEqualToAttributedString:
  bool isEqualToAttributedString(NSAttributedString other) {
    objc.checkOsVersionInternal('NSAttributedString.isEqualToAttributedString:',
        iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqualToAttributedString_, other.ref.pointer);
  }

  /// enumerateAttributesInRange:options:usingBlock:
  void enumerateAttributesInRange(objc.NSRange enumerationRange,
      {required NSAttributedStringEnumerationOptions options,
      required objc.ObjCBlock<
              ffi.Void Function(
                  objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>
          usingBlock}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.enumerateAttributesInRange:options:usingBlock:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    _objc_msgSend_1kok4b(
        this.ref.pointer,
        _sel_enumerateAttributesInRange_options_usingBlock_,
        enumerationRange,
        options.value,
        usingBlock.ref.pointer);
  }

  /// enumerateAttribute:inRange:options:usingBlock:
  void enumerateAttribute(objc.NSString attrName,
      {required objc.NSRange inRange,
      required NSAttributedStringEnumerationOptions options,
      required objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSRange,
                  ffi.Pointer<ffi.Bool>)>
          usingBlock}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.enumerateAttribute:inRange:options:usingBlock:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    _objc_msgSend_ipgwfh(
        this.ref.pointer,
        _sel_enumerateAttribute_inRange_options_usingBlock_,
        attrName.ref.pointer,
        inRange,
        options.value,
        usingBlock.ref.pointer);
  }
}

/// NSAttributedStringCreateFromMarkdown
extension NSAttributedStringCreateFromMarkdown on NSAttributedString {}

/// NSAttributedStringFormatting
extension NSAttributedStringFormatting on NSAttributedString {}

late final _sel_attributedStringByInflectingString =
    objc.registerName("attributedStringByInflectingString");

/// NSMorphology
extension NSMorphology on NSAttributedString {
  /// attributedStringByInflectingString
  NSAttributedString attributedStringByInflectingString() {
    objc.checkOsVersionInternal(
        'NSAttributedString.attributedStringByInflectingString',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_attributedStringByInflectingString);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }
}

/// WARNING: NSTextAttachment is a stub. To generate bindings for this class, include
/// NSTextAttachment in your config's objc-interfaces list.
///
/// NSTextAttachment
class NSTextAttachment extends objc.NSObject
    implements NSTextAttachmentLayout, objc.NSSecureCoding {
  NSTextAttachment._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSTextAttachment',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSTextAttachment] that points to the same underlying object as [other].
  NSTextAttachment.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSTextAttachment] that wraps the given raw object pointer.
  NSTextAttachment.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_attributedStringWithAttachment_ =
    objc.registerName("attributedStringWithAttachment:");

/// NSAttributedStringAttachmentConveniences
extension NSAttributedStringAttachmentConveniences on NSAttributedString {
  /// attributedStringWithAttachment:
  static NSAttributedString attributedStringWithAttachment(
      NSTextAttachment attachment) {
    objc.checkOsVersionInternal(
        'NSAttributedString.attributedStringWithAttachment:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_NSAttributedString,
        _sel_attributedStringWithAttachment_, attachment.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_dataFromRange_documentAttributes_error_ =
    objc.registerName("dataFromRange:documentAttributes:error:");
final _objc_msgSend_193219c = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();

/// WARNING: NSFileWrapper is a stub. To generate bindings for this class, include
/// NSFileWrapper in your config's objc-interfaces list.
///
/// NSFileWrapper
class NSFileWrapper extends objc.NSObject implements objc.NSSecureCoding {
  NSFileWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSFileWrapper',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSFileWrapper] that points to the same underlying object as [other].
  NSFileWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSFileWrapper] that wraps the given raw object pointer.
  NSFileWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_fileWrapperFromRange_documentAttributes_error_ =
    objc.registerName("fileWrapperFromRange:documentAttributes:error:");

/// NSAttributedStringDocumentFormats
extension NSAttributedStringDocumentFormats on NSAttributedString {
  /// dataFromRange:documentAttributes:error:
  objc.NSData? dataFromRange(objc.NSRange range,
      {required objc.NSDictionary documentAttributes,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.dataFromRange:documentAttributes:error:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_193219c(
        this.ref.pointer,
        _sel_dataFromRange_documentAttributes_error_,
        range,
        documentAttributes.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// fileWrapperFromRange:documentAttributes:error:
  NSFileWrapper? fileWrapperFromRange(objc.NSRange range,
      {required objc.NSDictionary documentAttributes,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.fileWrapperFromRange:documentAttributes:error:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_193219c(
        this.ref.pointer,
        _sel_fileWrapperFromRange_documentAttributes_error_,
        range,
        documentAttributes.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : NSFileWrapper.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_containsAttachmentsInRange_ =
    objc.registerName("containsAttachmentsInRange:");
final _objc_msgSend_p4nurx = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>();
late final _sel_prefersRTFDInRange_ = objc.registerName("prefersRTFDInRange:");

/// NSAttributedStringKitAdditions
extension NSAttributedStringKitAdditions on NSAttributedString {
  /// containsAttachmentsInRange:
  bool containsAttachmentsInRange(objc.NSRange range) {
    objc.checkOsVersionInternal(
        'NSAttributedString.containsAttachmentsInRange:',
        iOS: (false, (9, 0, 0)),
        macOS: (false, (10, 11, 0)));
    return _objc_msgSend_p4nurx(
        this.ref.pointer, _sel_containsAttachmentsInRange_, range);
  }

  /// prefersRTFDInRange:
  bool prefersRTFDInRange(objc.NSRange range) {
    objc.checkOsVersionInternal('NSAttributedString.prefersRTFDInRange:',
        iOS: (false, (18, 0, 0)), macOS: (false, (15, 0, 0)));
    return _objc_msgSend_p4nurx(
        this.ref.pointer, _sel_prefersRTFDInRange_, range);
  }
}

/// NSAttributedString_ItemProvider
extension NSAttributedString_ItemProvider on NSAttributedString {
  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal(
        'NSAttributedString.readableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSAttributedString, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal(
        'NSAttributedString.writableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSAttributedString, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider$1 {
    objc.checkOsVersionInternal(
        'NSAttributedString.writableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSAttributedString', 'writableTypeIdentifiersForItemProvider');
    }
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier(
          objc.NSString typeIdentifier) {
    objc.checkOsVersionInternal(
        'NSAttributedString.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(_class_NSAttributedString,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSAttributedString',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        _class_NSAttributedString,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier$1(
          objc.NSString typeIdentifier) {
    objc.checkOsVersionInternal(
        'NSAttributedString.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSAttributedString',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  NSProgress? loadDataWithTypeIdentifier(objc.NSString typeIdentifier,
      {required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
          forItemProviderCompletionHandler}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        typeIdentifier.ref.pointer,
        forItemProviderCompletionHandler.ref.pointer);
    return _ret.address == 0
        ? null
        : NSProgress.castFromPointer(_ret, retain: true, release: true);
  }
}

/// NSDeprecatedKitAdditions
extension NSDeprecatedKitAdditions on NSAttributedString {}

late final _sel_size = objc.registerName("size");
final _objc_msgSend_1vdfken = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_drawAtPoint_ = objc.registerName("drawAtPoint:");
final _objc_msgSend_iy8iz6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>();
late final _sel_drawInRect_ = objc.registerName("drawInRect:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>();

/// NSStringDrawing
extension NSStringDrawing on NSAttributedString {
  /// size
  objc.CGSize size() {
    objc.checkOsVersionInternal('NSAttributedString.size',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(_ptr, this.ref.pointer, _sel_size)
        : _ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_size);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawAtPoint:
  void drawAtPoint(objc.CGPoint point) {
    objc.checkOsVersionInternal('NSAttributedString.drawAtPoint:',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_drawAtPoint_, point);
  }

  /// drawInRect:
  void drawInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('NSAttributedString.drawInRect:',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_drawInRect_, rect);
  }
}

enum NSStringDrawingOptions {
  NSStringDrawingUsesLineFragmentOrigin(1),
  NSStringDrawingUsesFontLeading(2),
  NSStringDrawingUsesDeviceMetrics(8),
  NSStringDrawingTruncatesLastVisibleLine(32);

  final int value;
  const NSStringDrawingOptions(this.value);

  static NSStringDrawingOptions fromValue(int value) => switch (value) {
        1 => NSStringDrawingUsesLineFragmentOrigin,
        2 => NSStringDrawingUsesFontLeading,
        8 => NSStringDrawingUsesDeviceMetrics,
        32 => NSStringDrawingTruncatesLastVisibleLine,
        _ => throw ArgumentError(
            'Unknown value for NSStringDrawingOptions: $value'),
      };
}

/// WARNING: NSStringDrawingContext is a stub. To generate bindings for this class, include
/// NSStringDrawingContext in your config's objc-interfaces list.
///
/// NSStringDrawingContext
class NSStringDrawingContext extends objc.NSObject {
  NSStringDrawingContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSStringDrawingContext',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSStringDrawingContext] that points to the same underlying object as [other].
  NSStringDrawingContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSStringDrawingContext] that wraps the given raw object pointer.
  NSStringDrawingContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_drawWithRect_options_context_ =
    objc.registerName("drawWithRect:options:context:");
final _objc_msgSend_g5bnri = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_boundingRectWithSize_options_context_ =
    objc.registerName("boundingRectWithSize:options:context:");
final _objc_msgSend_1y1y0ic = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGSize,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGRect Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGSize,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_1y1y0icStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGSize,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGSize,
            int,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSExtendedStringDrawing
extension NSExtendedStringDrawing on NSAttributedString {
  /// drawWithRect:options:context:
  void drawWithRect(objc.CGRect rect,
      {required NSStringDrawingOptions options,
      NSStringDrawingContext? context}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.drawWithRect:options:context:',
        iOS: (false, (6, 0, 0)),
        macOS: (false, (10, 11, 0)));
    _objc_msgSend_g5bnri(this.ref.pointer, _sel_drawWithRect_options_context_,
        rect, options.value, context?.ref.pointer ?? ffi.nullptr);
  }

  /// boundingRectWithSize:options:context:
  objc.CGRect boundingRectWithSize(objc.CGSize size,
      {required NSStringDrawingOptions options,
      NSStringDrawingContext? context}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.boundingRectWithSize:options:context:',
        iOS: (false, (6, 0, 0)),
        macOS: (false, (10, 11, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1y1y0icStret(
            _ptr,
            this.ref.pointer,
            _sel_boundingRectWithSize_options_context_,
            size,
            options.value,
            context?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_1y1y0ic(
            this.ref.pointer,
            _sel_boundingRectWithSize_options_context_,
            size,
            options.value,
            context?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }
}

/// NSAttributedStringAdaptiveImageGlyphConveniences
extension NSAttributedStringAdaptiveImageGlyphConveniences
    on NSAttributedString {}

late final _sel_string = objc.registerName("string");
late final _sel_attributesAtIndex_effectiveRange_ =
    objc.registerName("attributesAtIndex:effectiveRange:");
final _objc_msgSend_1776v9k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.NSRange>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<objc.NSRange>)>();
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_supportsSecureCoding =
    objc.registerName("supportsSecureCoding");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
bool _ObjCBlock_bool_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_bool_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            instancetype Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>, objc.NSCoder)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                      ffi.Pointer<ffi.Void>, objc.NSCoder)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(
          Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true))
                      ?.ref
                      .retainAndReturnPointer() ??
                  ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
            ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true);
}

late final _sel_initWithString_ = objc.registerName("initWithString:");
late final _sel_initWithString_attributes_ =
    objc.registerName("initWithString:attributes:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithAttributedString_ =
    objc.registerName("initWithAttributedString:");

/// WARNING: NSAttributedStringMarkdownParsingOptions is a stub. To generate bindings for this class, include
/// NSAttributedStringMarkdownParsingOptions in your config's objc-interfaces list.
///
/// NSAttributedStringMarkdownParsingOptions
class NSAttributedStringMarkdownParsingOptions extends objc.NSObject
    implements objc.NSCopying {
  NSAttributedStringMarkdownParsingOptions._(
      ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false,
      bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSAttributedStringMarkdownParsingOptions',
        iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
  }

  /// Constructs a [NSAttributedStringMarkdownParsingOptions] that points to the same underlying object as [other].
  NSAttributedStringMarkdownParsingOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAttributedStringMarkdownParsingOptions] that wraps the given raw object pointer.
  NSAttributedStringMarkdownParsingOptions.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_initWithContentsOfMarkdownFileAtURL_options_baseURL_error_ =
    objc.registerName(
        "initWithContentsOfMarkdownFileAtURL:options:baseURL:error:");
final _objc_msgSend_1k0ezzm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_initWithMarkdown_options_baseURL_error_ =
    objc.registerName("initWithMarkdown:options:baseURL:error:");
late final _sel_initWithMarkdownString_options_baseURL_error_ =
    objc.registerName("initWithMarkdownString:options:baseURL:error:");

enum NSAttributedStringFormattingOptions {
  NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging(1),
  NSAttributedStringFormattingApplyReplacementIndexAttribute(2);

  final int value;
  const NSAttributedStringFormattingOptions(this.value);

  static NSAttributedStringFormattingOptions fromValue(int value) =>
      switch (value) {
        1 => NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging,
        2 => NSAttributedStringFormattingApplyReplacementIndexAttribute,
        _ => throw ArgumentError(
            'Unknown value for NSAttributedStringFormattingOptions: $value'),
      };
}

late final _sel_initWithFormat_options_locale_ =
    objc.registerName("initWithFormat:options:locale:");
final _objc_msgSend_187k8ck = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_localizedAttributedStringWithFormat_ =
    objc.registerName("localizedAttributedStringWithFormat:");
late final _sel_localizedAttributedStringWithFormat_options_ =
    objc.registerName("localizedAttributedStringWithFormat:options:");
final _objc_msgSend_s058d2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_initWithFormat_options_locale_context_ =
    objc.registerName("initWithFormat:options:locale:context:");
final _objc_msgSend_3fn4ca = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_localizedAttributedStringWithFormat_context_ =
    objc.registerName("localizedAttributedStringWithFormat:context:");
late final _sel_localizedAttributedStringWithFormat_options_context_ =
    objc.registerName("localizedAttributedStringWithFormat:options:context:");
late final _sel_attributedStringWithAttachment_attributes_ =
    objc.registerName("attributedStringWithAttachment:attributes:");
late final _sel_initWithURL_options_documentAttributes_error_ =
    objc.registerName("initWithURL:options:documentAttributes:error:");
final _objc_msgSend_of3pfd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_initWithData_options_documentAttributes_error_ =
    objc.registerName("initWithData:options:documentAttributes:error:");
late final _sel_initWithFileURL_options_documentAttributes_error_ =
    objc.registerName("initWithFileURL:options:documentAttributes:error:");

/// WARNING: NSAdaptiveImageGlyph is a stub. To generate bindings for this class, include
/// NSAdaptiveImageGlyph in your config's objc-interfaces list.
///
/// NSAdaptiveImageGlyph
class NSAdaptiveImageGlyph extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding, CTAdaptiveImageProviding {
  NSAdaptiveImageGlyph._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSAdaptiveImageGlyph',
        iOS: (false, (18, 0, 0)), macOS: (false, (15, 0, 0)));
  }

  /// Constructs a [NSAdaptiveImageGlyph] that points to the same underlying object as [other].
  NSAdaptiveImageGlyph.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAdaptiveImageGlyph] that wraps the given raw object pointer.
  NSAdaptiveImageGlyph.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_attributedStringWithAdaptiveImageGlyph_attributes_ =
    objc.registerName("attributedStringWithAdaptiveImageGlyph:attributes:");

/// NSAttributedString
class NSAttributedString extends objc.NSObject
    implements objc.NSCopying, objc.NSMutableCopying, objc.NSSecureCoding {
  NSAttributedString._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSAttributedString',
        iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSAttributedString] that points to the same underlying object as [other].
  NSAttributedString.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAttributedString] that wraps the given raw object pointer.
  NSAttributedString.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSAttributedString].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSAttributedString);
  }

  /// string
  objc.NSString get string {
    objc.checkOsVersionInternal('NSAttributedString.string',
        iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_string);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// attributesAtIndex:effectiveRange:
  objc.NSDictionary attributesAtIndex(int location,
      {required ffi.Pointer<objc.NSRange> effectiveRange}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.attributesAtIndex:effectiveRange:',
        iOS: (false, (3, 2, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1776v9k(this.ref.pointer,
        _sel_attributesAtIndex_effectiveRange_, location, effectiveRange);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSAttributedString init() {
    objc.checkOsVersionInternal('NSAttributedString.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static NSAttributedString new$() {
    final _ret = _objc_msgSend_151sglz(_class_NSAttributedString, _sel_new);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSAttributedString allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSAttributedString, _sel_allocWithZone_, zone);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSAttributedString alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSAttributedString, _sel_alloc);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_NSAttributedString, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  NSAttributedString? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// initWithString:
  NSAttributedString initWithString(objc.NSString str) {
    objc.checkOsVersionInternal('NSAttributedString.initWithString:',
        iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithString_, str.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithString:attributes:
  NSAttributedString initWithString$1(objc.NSString str,
      {objc.NSDictionary? attributes}) {
    objc.checkOsVersionInternal('NSAttributedString.initWithString:attributes:',
        iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithString_attributes_,
        str.ref.pointer,
        attributes?.ref.pointer ?? ffi.nullptr);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithAttributedString:
  NSAttributedString initWithAttributedString(NSAttributedString attrStr) {
    objc.checkOsVersionInternal('NSAttributedString.initWithAttributedString:',
        iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithAttributedString_, attrStr.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithContentsOfMarkdownFileAtURL:options:baseURL:error:
  NSAttributedString? initWithContentsOfMarkdownFileAtURL(
      objc.NSURL markdownFile,
      {NSAttributedStringMarkdownParsingOptions? options,
      objc.NSURL? baseURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.initWithContentsOfMarkdownFileAtURL:options:baseURL:error:',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_1k0ezzm(
        this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfMarkdownFileAtURL_options_baseURL_error_,
        markdownFile.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr,
        baseURL?.ref.pointer ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// initWithMarkdown:options:baseURL:error:
  NSAttributedString? initWithMarkdown(objc.NSData markdown,
      {NSAttributedStringMarkdownParsingOptions? options,
      objc.NSURL? baseURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.initWithMarkdown:options:baseURL:error:',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_1k0ezzm(
        this.ref.retainAndReturnPointer(),
        _sel_initWithMarkdown_options_baseURL_error_,
        markdown.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr,
        baseURL?.ref.pointer ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// initWithMarkdownString:options:baseURL:error:
  NSAttributedString? initWithMarkdownString(objc.NSString markdownString,
      {NSAttributedStringMarkdownParsingOptions? options,
      objc.NSURL? baseURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.initWithMarkdownString:options:baseURL:error:',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_1k0ezzm(
        this.ref.retainAndReturnPointer(),
        _sel_initWithMarkdownString_options_baseURL_error_,
        markdownString.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr,
        baseURL?.ref.pointer ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// initWithFormat:options:locale:
  NSAttributedString initWithFormat(NSAttributedString format,
      {required NSAttributedStringFormattingOptions options,
      objc.NSLocale? locale}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.initWithFormat:options:locale:',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_187k8ck(
        this.ref.retainAndReturnPointer(),
        _sel_initWithFormat_options_locale_,
        format.ref.pointer,
        options.value,
        locale?.ref.pointer ?? ffi.nullptr);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// localizedAttributedStringWithFormat:
  static NSAttributedString localizedAttributedStringWithFormat(
      NSAttributedString format) {
    objc.checkOsVersionInternal(
        'NSAttributedString.localizedAttributedStringWithFormat:',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_NSAttributedString,
        _sel_localizedAttributedStringWithFormat_, format.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// localizedAttributedStringWithFormat:options:
  static NSAttributedString localizedAttributedStringWithFormat$1(
      NSAttributedString format,
      {required NSAttributedStringFormattingOptions options}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.localizedAttributedStringWithFormat:options:',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_s058d2(
        _class_NSAttributedString,
        _sel_localizedAttributedStringWithFormat_options_,
        format.ref.pointer,
        options.value);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// initWithFormat:options:locale:context:
  NSAttributedString initWithFormat$1(NSAttributedString format,
      {required NSAttributedStringFormattingOptions options,
      objc.NSLocale? locale,
      required objc.NSDictionary context}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.initWithFormat:options:locale:context:',
        iOS: (false, (17, 0, 0)),
        macOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_3fn4ca(
        this.ref.retainAndReturnPointer(),
        _sel_initWithFormat_options_locale_context_,
        format.ref.pointer,
        options.value,
        locale?.ref.pointer ?? ffi.nullptr,
        context.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// localizedAttributedStringWithFormat:context:
  static NSAttributedString localizedAttributedStringWithFormat$2(
      NSAttributedString format,
      {required objc.NSDictionary context}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.localizedAttributedStringWithFormat:context:',
        iOS: (false, (17, 0, 0)),
        macOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_NSAttributedString,
        _sel_localizedAttributedStringWithFormat_context_,
        format.ref.pointer,
        context.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// localizedAttributedStringWithFormat:options:context:
  static NSAttributedString localizedAttributedStringWithFormat$3(
      NSAttributedString format,
      {required NSAttributedStringFormattingOptions options,
      required objc.NSDictionary context}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.localizedAttributedStringWithFormat:options:context:',
        iOS: (false, (17, 0, 0)),
        macOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_187k8ck(
        _class_NSAttributedString,
        _sel_localizedAttributedStringWithFormat_options_context_,
        format.ref.pointer,
        options.value,
        context.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// attributedStringWithAttachment:attributes:
  static NSAttributedString attributedStringWithAttachment(
      NSTextAttachment attachment,
      {required objc.NSDictionary attributes}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.attributedStringWithAttachment:attributes:',
        iOS: (false, (18, 0, 0)),
        macOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_NSAttributedString,
        _sel_attributedStringWithAttachment_attributes_,
        attachment.ref.pointer,
        attributes.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// initWithURL:options:documentAttributes:error:
  NSAttributedString? initWithURL(objc.NSURL url,
      {required objc.NSDictionary options,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> documentAttributes,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.initWithURL:options:documentAttributes:error:',
        iOS: (false, (9, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_of3pfd(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_options_documentAttributes_error_,
        url.ref.pointer,
        options.ref.pointer,
        documentAttributes,
        error);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// initWithData:options:documentAttributes:error:
  NSAttributedString? initWithData(objc.NSData data,
      {required objc.NSDictionary options,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> documentAttributes,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.initWithData:options:documentAttributes:error:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_of3pfd(
        this.ref.retainAndReturnPointer(),
        _sel_initWithData_options_documentAttributes_error_,
        data.ref.pointer,
        options.ref.pointer,
        documentAttributes,
        error);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static NSAttributedString? objectWithItemProviderData(objc.NSData data,
      {required objc.NSString typeIdentifier,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.objectWithItemProviderData:typeIdentifier:error:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1pnyuds(
        _class_NSAttributedString,
        _sel_objectWithItemProviderData_typeIdentifier_error_,
        data.ref.pointer,
        typeIdentifier.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithFileURL:options:documentAttributes:error:
  NSAttributedString? initWithFileURL(objc.NSURL url,
      {required objc.NSDictionary options,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> documentAttributes,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.initWithFileURL:options:documentAttributes:error:',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_of3pfd(
        this.ref.retainAndReturnPointer(),
        _sel_initWithFileURL_options_documentAttributes_error_,
        url.ref.pointer,
        options.ref.pointer,
        documentAttributes,
        error);
    return _ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// attributedStringWithAdaptiveImageGlyph:attributes:
  static NSAttributedString attributedStringWithAdaptiveImageGlyph(
      NSAdaptiveImageGlyph adaptiveImageGlyph,
      {required objc.NSDictionary attributes}) {
    objc.checkOsVersionInternal(
        'NSAttributedString.attributedStringWithAdaptiveImageGlyph:attributes:',
        iOS: (false, (18, 0, 0)),
        macOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_NSAttributedString,
        _sel_attributedStringWithAdaptiveImageGlyph_attributes_,
        adaptiveImageGlyph.ref.pointer,
        attributes.ref.pointer);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of NSAttributedString constructed with the default `new` method.
  factory NSAttributedString() => new$();
}

enum NSAttributedStringMarkdownParsingFailurePolicy {
  NSAttributedStringMarkdownParsingFailureReturnError(0),
  NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible(1);

  final int value;
  const NSAttributedStringMarkdownParsingFailurePolicy(this.value);

  static NSAttributedStringMarkdownParsingFailurePolicy fromValue(int value) =>
      switch (value) {
        0 => NSAttributedStringMarkdownParsingFailureReturnError,
        1 =>
          NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible,
        _ => throw ArgumentError(
            'Unknown value for NSAttributedStringMarkdownParsingFailurePolicy: $value'),
      };
}

enum NSAttributedStringMarkdownInterpretedSyntax {
  NSAttributedStringMarkdownInterpretedSyntaxFull(0),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnly(1),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace(2);

  final int value;
  const NSAttributedStringMarkdownInterpretedSyntax(this.value);

  static NSAttributedStringMarkdownInterpretedSyntax fromValue(int value) =>
      switch (value) {
        0 => NSAttributedStringMarkdownInterpretedSyntaxFull,
        1 => NSAttributedStringMarkdownInterpretedSyntaxInlineOnly,
        2 =>
          NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace,
        _ => throw ArgumentError(
            'Unknown value for NSAttributedStringMarkdownInterpretedSyntax: $value'),
      };
}

late final _sel_pathWithComponents_ = objc.registerName("pathWithComponents:");
late final _sel_pathComponents = objc.registerName("pathComponents");
late final _sel_isAbsolutePath = objc.registerName("isAbsolutePath");
late final _sel_lastPathComponent = objc.registerName("lastPathComponent");
late final _sel_stringByDeletingLastPathComponent =
    objc.registerName("stringByDeletingLastPathComponent");
late final _sel_stringByAppendingPathComponent_ =
    objc.registerName("stringByAppendingPathComponent:");
late final _sel_pathExtension = objc.registerName("pathExtension");
late final _sel_stringByDeletingPathExtension =
    objc.registerName("stringByDeletingPathExtension");
late final _sel_stringByAppendingPathExtension_ =
    objc.registerName("stringByAppendingPathExtension:");
late final _sel_stringByAbbreviatingWithTildeInPath =
    objc.registerName("stringByAbbreviatingWithTildeInPath");
late final _sel_stringByExpandingTildeInPath =
    objc.registerName("stringByExpandingTildeInPath");
late final _sel_stringByStandardizingPath =
    objc.registerName("stringByStandardizingPath");
late final _sel_stringByResolvingSymlinksInPath =
    objc.registerName("stringByResolvingSymlinksInPath");
late final _sel_stringsByAppendingPaths_ =
    objc.registerName("stringsByAppendingPaths:");
late final _sel_completePathIntoString_caseSensitive_matchesIntoArray_filterTypes_ =
    objc.registerName(
        "completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:");
final _objc_msgSend_8mvqcu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Bool,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            bool,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_fileSystemRepresentation =
    objc.registerName("fileSystemRepresentation");
late final _sel_getFileSystemRepresentation_maxLength_ =
    objc.registerName("getFileSystemRepresentation:maxLength:");
final _objc_msgSend_8cymbm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>, int)>();

/// NSStringPathExtensions
extension NSStringPathExtensions on objc.NSString {
  /// pathWithComponents:
  static objc.NSString pathWithComponents(objc.NSArray components) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSString, _sel_pathWithComponents_, components.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathComponents
  objc.NSArray get pathComponents {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pathComponents);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// isAbsolutePath
  bool get absolutePath {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isAbsolutePath);
  }

  /// lastPathComponent
  objc.NSString get lastPathComponent {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_lastPathComponent);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByDeletingLastPathComponent
  objc.NSString get stringByDeletingLastPathComponent {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_stringByDeletingLastPathComponent);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByAppendingPathComponent:
  objc.NSString stringByAppendingPathComponent(objc.NSString str) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_stringByAppendingPathComponent_, str.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathExtension
  objc.NSString get pathExtension {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pathExtension);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByDeletingPathExtension
  objc.NSString get stringByDeletingPathExtension {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_stringByDeletingPathExtension);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByAppendingPathExtension:
  objc.NSString? stringByAppendingPathExtension(objc.NSString str) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_stringByAppendingPathExtension_, str.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByAbbreviatingWithTildeInPath
  objc.NSString get stringByAbbreviatingWithTildeInPath {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_stringByAbbreviatingWithTildeInPath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByExpandingTildeInPath
  objc.NSString get stringByExpandingTildeInPath {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_stringByExpandingTildeInPath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByStandardizingPath
  objc.NSString get stringByStandardizingPath {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_stringByStandardizingPath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByResolvingSymlinksInPath
  objc.NSString get stringByResolvingSymlinksInPath {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_stringByResolvingSymlinksInPath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringsByAppendingPaths:
  objc.NSArray stringsByAppendingPaths(objc.NSArray paths) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_stringsByAppendingPaths_, paths.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:
  int completePathIntoString(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> outputName,
      {required bool caseSensitive,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> matchesIntoArray,
      objc.NSArray? filterTypes}) {
    return _objc_msgSend_8mvqcu(
        this.ref.pointer,
        _sel_completePathIntoString_caseSensitive_matchesIntoArray_filterTypes_,
        outputName,
        caseSensitive,
        matchesIntoArray,
        filterTypes?.ref.pointer ?? ffi.nullptr);
  }

  /// fileSystemRepresentation
  ffi.Pointer<ffi.Char> get fileSystemRepresentation {
    return _objc_msgSend_1fuqfwb(
        this.ref.pointer, _sel_fileSystemRepresentation);
  }

  /// getFileSystemRepresentation:maxLength:
  bool getFileSystemRepresentation(ffi.Pointer<ffi.Char> cname,
      {required int maxLength}) {
    return _objc_msgSend_8cymbm(this.ref.pointer,
        _sel_getFileSystemRepresentation_maxLength_, cname, maxLength);
  }
}

enum NSSearchPathDirectory {
  NSApplicationDirectory(1),
  NSDemoApplicationDirectory(2),
  NSDeveloperApplicationDirectory(3),
  NSAdminApplicationDirectory(4),
  NSLibraryDirectory(5),
  NSDeveloperDirectory(6),
  NSUserDirectory(7),
  NSDocumentationDirectory(8),
  NSDocumentDirectory(9),
  NSCoreServiceDirectory(10),
  NSAutosavedInformationDirectory(11),
  NSDesktopDirectory(12),
  NSCachesDirectory(13),
  NSApplicationSupportDirectory(14),
  NSDownloadsDirectory(15),
  NSInputMethodsDirectory(16),
  NSMoviesDirectory(17),
  NSMusicDirectory(18),
  NSPicturesDirectory(19),
  NSPrinterDescriptionDirectory(20),
  NSSharedPublicDirectory(21),
  NSPreferencePanesDirectory(22),
  NSApplicationScriptsDirectory(23),
  NSItemReplacementDirectory(99),
  NSAllApplicationsDirectory(100),
  NSAllLibrariesDirectory(101),
  NSTrashDirectory(102);

  final int value;
  const NSSearchPathDirectory(this.value);

  static NSSearchPathDirectory fromValue(int value) => switch (value) {
        1 => NSApplicationDirectory,
        2 => NSDemoApplicationDirectory,
        3 => NSDeveloperApplicationDirectory,
        4 => NSAdminApplicationDirectory,
        5 => NSLibraryDirectory,
        6 => NSDeveloperDirectory,
        7 => NSUserDirectory,
        8 => NSDocumentationDirectory,
        9 => NSDocumentDirectory,
        10 => NSCoreServiceDirectory,
        11 => NSAutosavedInformationDirectory,
        12 => NSDesktopDirectory,
        13 => NSCachesDirectory,
        14 => NSApplicationSupportDirectory,
        15 => NSDownloadsDirectory,
        16 => NSInputMethodsDirectory,
        17 => NSMoviesDirectory,
        18 => NSMusicDirectory,
        19 => NSPicturesDirectory,
        20 => NSPrinterDescriptionDirectory,
        21 => NSSharedPublicDirectory,
        22 => NSPreferencePanesDirectory,
        23 => NSApplicationScriptsDirectory,
        99 => NSItemReplacementDirectory,
        100 => NSAllApplicationsDirectory,
        101 => NSAllLibrariesDirectory,
        102 => NSTrashDirectory,
        _ => throw ArgumentError(
            'Unknown value for NSSearchPathDirectory: $value'),
      };
}

enum NSSearchPathDomainMask {
  NSUserDomainMask(1),
  NSLocalDomainMask(2),
  NSNetworkDomainMask(4),
  NSSystemDomainMask(8),
  NSAllDomainsMask(65535);

  final int value;
  const NSSearchPathDomainMask(this.value);

  static NSSearchPathDomainMask fromValue(int value) => switch (value) {
        1 => NSUserDomainMask,
        2 => NSLocalDomainMask,
        4 => NSNetworkDomainMask,
        8 => NSSystemDomainMask,
        65535 => NSAllDomainsMask,
        _ => throw ArgumentError(
            'Unknown value for NSSearchPathDomainMask: $value'),
      };
}

late final _sel_stringByAddingPercentEncodingWithAllowedCharacters_ =
    objc.registerName("stringByAddingPercentEncodingWithAllowedCharacters:");
late final _sel_stringByRemovingPercentEncoding =
    objc.registerName("stringByRemovingPercentEncoding");
late final _sel_stringByAddingPercentEscapesUsingEncoding_ =
    objc.registerName("stringByAddingPercentEscapesUsingEncoding:");
final _objc_msgSend_14hpxwa = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_stringByReplacingPercentEscapesUsingEncoding_ =
    objc.registerName("stringByReplacingPercentEscapesUsingEncoding:");

/// NSURLUtilities
extension NSURLUtilities on objc.NSString {
  /// stringByAddingPercentEncodingWithAllowedCharacters:
  objc.NSString? stringByAddingPercentEncodingWithAllowedCharacters(
      objc.NSCharacterSet allowedCharacters) {
    objc.checkOsVersionInternal(
        'NSString.stringByAddingPercentEncodingWithAllowedCharacters:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_stringByAddingPercentEncodingWithAllowedCharacters_,
        allowedCharacters.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByRemovingPercentEncoding
  objc.NSString? get stringByRemovingPercentEncoding {
    objc.checkOsVersionInternal('NSString.stringByRemovingPercentEncoding',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_stringByRemovingPercentEncoding);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByAddingPercentEscapesUsingEncoding:
  objc.NSString? stringByAddingPercentEscapesUsingEncoding(int enc) {
    objc.checkOsVersionInternal(
        'NSString.stringByAddingPercentEscapesUsingEncoding:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_14hpxwa(
        this.ref.pointer, _sel_stringByAddingPercentEscapesUsingEncoding_, enc);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByReplacingPercentEscapesUsingEncoding:
  objc.NSString? stringByReplacingPercentEscapesUsingEncoding(int enc) {
    objc.checkOsVersionInternal(
        'NSString.stringByReplacingPercentEscapesUsingEncoding:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_14hpxwa(this.ref.pointer,
        _sel_stringByReplacingPercentEscapesUsingEncoding_, enc);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

enum NSVolumeEnumerationOptions {
  NSVolumeEnumerationSkipHiddenVolumes(2),
  NSVolumeEnumerationProduceFileReferenceURLs(4);

  final int value;
  const NSVolumeEnumerationOptions(this.value);

  static NSVolumeEnumerationOptions fromValue(int value) => switch (value) {
        2 => NSVolumeEnumerationSkipHiddenVolumes,
        4 => NSVolumeEnumerationProduceFileReferenceURLs,
        _ => throw ArgumentError(
            'Unknown value for NSVolumeEnumerationOptions: $value'),
      };
}

enum NSDirectoryEnumerationOptions {
  NSDirectoryEnumerationSkipsSubdirectoryDescendants(1),
  NSDirectoryEnumerationSkipsPackageDescendants(2),
  NSDirectoryEnumerationSkipsHiddenFiles(4),
  NSDirectoryEnumerationIncludesDirectoriesPostOrder(8),
  NSDirectoryEnumerationProducesRelativePathURLs(16);

  final int value;
  const NSDirectoryEnumerationOptions(this.value);

  static NSDirectoryEnumerationOptions fromValue(int value) => switch (value) {
        1 => NSDirectoryEnumerationSkipsSubdirectoryDescendants,
        2 => NSDirectoryEnumerationSkipsPackageDescendants,
        4 => NSDirectoryEnumerationSkipsHiddenFiles,
        8 => NSDirectoryEnumerationIncludesDirectoriesPostOrder,
        16 => NSDirectoryEnumerationProducesRelativePathURLs,
        _ => throw ArgumentError(
            'Unknown value for NSDirectoryEnumerationOptions: $value'),
      };
}

enum NSFileManagerItemReplacementOptions {
  NSFileManagerItemReplacementUsingNewMetadataOnly(1),
  NSFileManagerItemReplacementWithoutDeletingBackupItem(2);

  final int value;
  const NSFileManagerItemReplacementOptions(this.value);

  static NSFileManagerItemReplacementOptions fromValue(int value) =>
      switch (value) {
        1 => NSFileManagerItemReplacementUsingNewMetadataOnly,
        2 => NSFileManagerItemReplacementWithoutDeletingBackupItem,
        _ => throw ArgumentError(
            'Unknown value for NSFileManagerItemReplacementOptions: $value'),
      };
}

enum NSURLRelationship {
  NSURLRelationshipContains(0),
  NSURLRelationshipSame(1),
  NSURLRelationshipOther(2);

  final int value;
  const NSURLRelationship(this.value);

  static NSURLRelationship fromValue(int value) => switch (value) {
        0 => NSURLRelationshipContains,
        1 => NSURLRelationshipSame,
        2 => NSURLRelationshipOther,
        _ => throw ArgumentError('Unknown value for NSURLRelationship: $value'),
      };
}

enum NSFileManagerUnmountOptions {
  NSFileManagerUnmountAllPartitionsAndEjectDisk(1),
  NSFileManagerUnmountWithoutUI(2);

  final int value;
  const NSFileManagerUnmountOptions(this.value);

  static NSFileManagerUnmountOptions fromValue(int value) => switch (value) {
        1 => NSFileManagerUnmountAllPartitionsAndEjectDisk,
        2 => NSFileManagerUnmountWithoutUI,
        _ => throw ArgumentError(
            'Unknown value for NSFileManagerUnmountOptions: $value'),
      };
}

enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow(-8),
  NSOperationQueuePriorityLow(-4),
  NSOperationQueuePriorityNormal(0),
  NSOperationQueuePriorityHigh(4),
  NSOperationQueuePriorityVeryHigh(8);

  final int value;
  const NSOperationQueuePriority(this.value);

  static NSOperationQueuePriority fromValue(int value) => switch (value) {
        -8 => NSOperationQueuePriorityVeryLow,
        -4 => NSOperationQueuePriorityLow,
        0 => NSOperationQueuePriorityNormal,
        4 => NSOperationQueuePriorityHigh,
        8 => NSOperationQueuePriorityVeryHigh,
        _ => throw ArgumentError(
            'Unknown value for NSOperationQueuePriority: $value'),
      };
}

/// WARNING: NSOperationQueue is a stub. To generate bindings for this class, include
/// NSOperationQueue in your config's objc-interfaces list.
///
/// NSOperationQueue
class NSOperationQueue extends objc.NSObject implements NSProgressReporting {
  NSOperationQueue._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSOperationQueue',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }

  /// Constructs a [NSOperationQueue] that points to the same underlying object as [other].
  NSOperationQueue.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSOperationQueue] that wraps the given raw object pointer.
  NSOperationQueue.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSOrthography is a stub. To generate bindings for this class, include
/// NSOrthography in your config's objc-interfaces list.
///
/// NSOrthography
class NSOrthography extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSOrthography._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSOrthography',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
  }

  /// Constructs a [NSOrthography] that points to the same underlying object as [other].
  NSOrthography.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSOrthography] that wraps the given raw object pointer.
  NSOrthography.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSPredicate is a stub. To generate bindings for this class, include
/// NSPredicate in your config's objc-interfaces list.
///
/// NSPredicate
class NSPredicate extends objc.NSObject
    implements objc.NSSecureCoding, objc.NSCopying {
  NSPredicate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSPredicate',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [NSPredicate] that points to the same underlying object as [other].
  NSPredicate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSPredicate] that wraps the given raw object pointer.
  NSPredicate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum NSExpressionType {
  NSConstantValueExpressionType(0),
  NSEvaluatedObjectExpressionType(1),
  NSVariableExpressionType(2),
  NSKeyPathExpressionType(3),
  NSFunctionExpressionType(4),
  NSUnionSetExpressionType(5),
  NSIntersectSetExpressionType(6),
  NSMinusSetExpressionType(7),
  NSSubqueryExpressionType(13),
  NSAggregateExpressionType(14),
  NSAnyKeyExpressionType(15),
  NSBlockExpressionType(19),
  NSConditionalExpressionType(20);

  final int value;
  const NSExpressionType(this.value);

  static NSExpressionType fromValue(int value) => switch (value) {
        0 => NSConstantValueExpressionType,
        1 => NSEvaluatedObjectExpressionType,
        2 => NSVariableExpressionType,
        3 => NSKeyPathExpressionType,
        4 => NSFunctionExpressionType,
        5 => NSUnionSetExpressionType,
        6 => NSIntersectSetExpressionType,
        7 => NSMinusSetExpressionType,
        13 => NSSubqueryExpressionType,
        14 => NSAggregateExpressionType,
        15 => NSAnyKeyExpressionType,
        19 => NSBlockExpressionType,
        20 => NSConditionalExpressionType,
        _ => throw ArgumentError('Unknown value for NSExpressionType: $value'),
      };
}

late final _class_NSExpression = objc.getClass("NSExpression");
late final _sel_zoomLevelVariableExpression =
    objc.registerName("zoomLevelVariableExpression");
late final _sel_heatmapDensityVariableExpression =
    objc.registerName("heatmapDensityVariableExpression");
late final _sel_lineProgressVariableExpression =
    objc.registerName("lineProgressVariableExpression");
late final _sel_geometryTypeVariableExpression =
    objc.registerName("geometryTypeVariableExpression");
late final _sel_featureIdentifierVariableExpression =
    objc.registerName("featureIdentifierVariableExpression");
late final _sel_featureAccumulatedVariableExpression =
    objc.registerName("featureAccumulatedVariableExpression");
late final _sel_featureAttributesVariableExpression =
    objc.registerName("featureAttributesVariableExpression");
late final _sel_featurePropertiesVariableExpression =
    objc.registerName("featurePropertiesVariableExpression");
late final _sel_mgl_jsonExpressionObject =
    objc.registerName("mgl_jsonExpressionObject");
late final _sel_mgl_expressionLocalizedIntoLocale_ =
    objc.registerName("mgl_expressionLocalizedIntoLocale:");

/// Methods for creating expressions that use Mapbox-specific functionality and for
/// converting to and from the JSON format defined in the
/// <a href="https://maplibre.org/maplibre-style-spec/expressions/">MapLibre Style Spec</a>.
extension MLNAdditions on NSExpression {
  /// `NSExpression` variable that corresponds to the
  /// <a href="https://maplibre.org/maplibre-style-spec/expressions/#zoom"><code>zoom</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getZoomLevelVariableExpression() {
    objc.checkOsVersionInternal('NSExpression.zoomLevelVariableExpression',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_zoomLevelVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a
  /// href="https://maplibre.org/maplibre-style-spec/expressions/#heatmap-density"><code>heatmap-density</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getHeatmapDensityVariableExpression() {
    objc.checkOsVersionInternal('NSExpression.heatmapDensityVariableExpression',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_heatmapDensityVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a
  /// href="https://maplibre.org/maplibre-style-spec/expressions/#line-progress"><code>line-progress</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getLineProgressVariableExpression() {
    objc.checkOsVersionInternal('NSExpression.lineProgressVariableExpression',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_lineProgressVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a
  /// href="https://maplibre.org/maplibre-style-spec/expressions/#geometry-type"><code>geometry-type</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getGeometryTypeVariableExpression() {
    objc.checkOsVersionInternal('NSExpression.geometryTypeVariableExpression',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_geometryTypeVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a href="https://maplibre.org/maplibre-style-spec/expressions/#id"><code>id</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureIdentifierVariableExpression() {
    objc.checkOsVersionInternal(
        'NSExpression.featureIdentifierVariableExpression',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_featureIdentifierVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a href="https://docs.mapbox.com/mapbox-gl-js/style-spec/#accumulated"><code>id</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureAccumulatedVariableExpression() {
    objc.checkOsVersionInternal(
        'NSExpression.featureAccumulatedVariableExpression',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_featureAccumulatedVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// `NSExpression` variable that corresponds to the
  /// <a
  /// href="https://maplibre.org/maplibre-style-spec/expressions/#properties"><code>properties</code></a>
  /// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureAttributesVariableExpression() {
    objc.checkOsVersionInternal(
        'NSExpression.featureAttributesVariableExpression',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_featureAttributesVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// featurePropertiesVariableExpression
  static NSExpression getFeaturePropertiesVariableExpression() {
    objc.checkOsVersionInternal(
        'NSExpression.featurePropertiesVariableExpression',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_featurePropertiesVariableExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// An equivalent Foundation object that can be serialized as JSON.
  ///
  /// The Foundation object conforms to the
  /// [MapLibre Style Spec](https://maplibre.org/maplibre-style-spec/expressions/).
  /// See the
  /// “[Information for Style Authors](../for-style-authors.html#setting-attribute-values)”
  /// guide for a correspondence of operators and types between the style
  /// specification and the `NSExpression` representation used by this SDK.
  ///
  /// You can use `NSJSONSerialization` to serialize the Foundation object as data to
  /// write to a file.
  objc.ObjCObjectBase get mgl_jsonExpressionObject {
    objc.checkOsVersionInternal('NSExpression.mgl_jsonExpressionObject',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_mgl_jsonExpressionObject);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a copy of the receiver localized into the given locale.
  ///
  /// This method assumes the receiver refers to the feature attributes that are
  /// available in vector tiles supplied by the
  /// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets-v8/#overview">Mapbox Streets
  /// source</a>. On iOS, the user can set the system’s preferred language in Settings, General Settings,
  /// Language & Region. On macOS, the user can set the system’s preferred language in the Language &
  /// Region pane of System Preferences.
  ///
  /// @param locale The locale into which labels should be localized. To use the
  /// system’s preferred language, if supported, specify `nil`. To use the local
  /// language, specify a locale with the identifier `mul`.
  NSExpression mgl_expressionLocalizedIntoLocale(objc.NSLocale? locale) {
    objc.checkOsVersionInternal(
        'NSExpression.mgl_expressionLocalizedIntoLocale:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_mgl_expressionLocalizedIntoLocale_,
        locale?.ref.pointer ?? ffi.nullptr);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_expressionWithFormat_argumentArray_ =
    objc.registerName("expressionWithFormat:argumentArray:");
late final _sel_expressionWithFormat_ =
    objc.registerName("expressionWithFormat:");
late final _sel_expressionForConstantValue_ =
    objc.registerName("expressionForConstantValue:");
late final _sel_expressionForEvaluatedObject =
    objc.registerName("expressionForEvaluatedObject");
late final _sel_expressionForVariable_ =
    objc.registerName("expressionForVariable:");
late final _sel_expressionForKeyPath_ =
    objc.registerName("expressionForKeyPath:");
late final _sel_expressionForFunction_arguments_ =
    objc.registerName("expressionForFunction:arguments:");
late final _sel_expressionForAggregate_ =
    objc.registerName("expressionForAggregate:");
late final _sel_expressionForUnionSet_with_ =
    objc.registerName("expressionForUnionSet:with:");
late final _sel_expressionForIntersectSet_with_ =
    objc.registerName("expressionForIntersectSet:with:");
late final _sel_expressionForMinusSet_with_ =
    objc.registerName("expressionForMinusSet:with:");
late final _sel_expressionForSubquery_usingIteratorVariable_predicate_ =
    objc.registerName("expressionForSubquery:usingIteratorVariable:predicate:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_expressionForFunction_selectorName_arguments_ =
    objc.registerName("expressionForFunction:selectorName:arguments:");
late final _sel_expressionForAnyKey = objc.registerName("expressionForAnyKey");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?, objc.NSArray, objc.NSMutableDictionary?)>`.
abstract final class ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?,
              objc.NSArray, objc.NSMutableDictionary?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCObject>?,
                      objc.NSArray,
                      objc.NSMutableDictionary?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?,
              objc.NSArray, objc.NSMutableDictionary?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCObject>?,
                      objc.NSArray,
                      objc.NSMutableDictionary?)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?, objc.NSArray, objc.NSMutableDictionary?)> fromFunction(objc.ObjCObjectBase Function(objc.ObjCObjectBase?, objc.NSArray, objc.NSMutableDictionary?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?, objc.NSArray, objc.NSMutableDictionary?)>(
          objc.newClosureBlock(
              _ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0.address == 0 ? null : objc.ObjCObjectBase(arg0, retain: true, release: true),
                      objc.NSArray.castFromPointer(arg1, retain: true, release: true),
                      arg2.address == 0 ? null : objc.NSMutableDictionary.castFromPointer(arg2, retain: true, release: true))
                  .ref
                  .retainAndAutorelease(),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?, objc.NSArray, objc.NSMutableDictionary?)>`.
extension ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?,
            objc.NSArray, objc.NSMutableDictionary?)> {
  objc.ObjCObjectBase call(objc.ObjCObjectBase? arg0, objc.NSArray arg1, objc.NSMutableDictionary? arg2) =>
      objc.ObjCObjectBase(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<objc.ObjCObject> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer,
              arg0?.ref.pointer ?? ffi.nullptr,
              arg1.ref.pointer,
              arg2?.ref.pointer ?? ffi.nullptr),
          retain: true,
          release: true);
}

late final _sel_expressionForBlock_arguments_ =
    objc.registerName("expressionForBlock:arguments:");
final _objc_msgSend_27lb7c = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_expressionForConditional_trueExpression_falseExpression_ = objc
    .registerName("expressionForConditional:trueExpression:falseExpression:");
late final _sel_initWithExpressionType_ =
    objc.registerName("initWithExpressionType:");
final _objc_msgSend_1rz5npq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_expressionType = objc.registerName("expressionType");
final _objc_msgSend_1ts4niw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_constantValue = objc.registerName("constantValue");
late final _sel_keyPath = objc.registerName("keyPath");
late final _sel_function = objc.registerName("function");
late final _sel_variable = objc.registerName("variable");
late final _sel_operand = objc.registerName("operand");
late final _sel_arguments = objc.registerName("arguments");
late final _sel_collection = objc.registerName("collection");
late final _sel_predicate = objc.registerName("predicate");
late final _sel_leftExpression = objc.registerName("leftExpression");
late final _sel_rightExpression = objc.registerName("rightExpression");
late final _sel_trueExpression = objc.registerName("trueExpression");
late final _sel_falseExpression = objc.registerName("falseExpression");
late final _sel_expressionBlock = objc.registerName("expressionBlock");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_expressionValueWithObject_context_ =
    objc.registerName("expressionValueWithObject:context:");
late final _sel_allowEvaluation = objc.registerName("allowEvaluation");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_self = objc.registerName("self");
instancetype _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<instancetype Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_instancetype_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_instancetype_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");
late final _sel_mgl_expressionForConditional_trueExpression_falseExpresssion_ =
    objc.registerName(
        "mgl_expressionForConditional:trueExpression:falseExpresssion:");
late final _sel_mgl_expressionForSteppingExpression_fromExpression_stops_ = objc
    .registerName("mgl_expressionForSteppingExpression:fromExpression:stops:");
late final _sel_mgl_expressionForInterpolatingExpression_withCurveType_parameters_stops_ =
    objc.registerName(
        "mgl_expressionForInterpolatingExpression:withCurveType:parameters:stops:");
final _objc_msgSend_s92gih = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_mgl_expressionForMatchingExpression_inDictionary_defaultExpression_ =
    objc.registerName(
        "mgl_expressionForMatchingExpression:inDictionary:defaultExpression:");
late final _sel_mgl_expressionForAttributedExpressions_ =
    objc.registerName("mgl_expressionForAttributedExpressions:");
late final _sel_mgl_expressionByAppendingExpression_ =
    objc.registerName("mgl_expressionByAppendingExpression:");
late final _sel_expressionWithMLNJSONObject_ =
    objc.registerName("expressionWithMLNJSONObject:");

/// NSExpression
class NSExpression extends objc.NSObject
    implements objc.NSSecureCoding, objc.NSCopying {
  NSExpression._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSExpression',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [NSExpression] that points to the same underlying object as [other].
  NSExpression.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSExpression] that wraps the given raw object pointer.
  NSExpression.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSExpression].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSExpression);
  }

  /// expressionWithFormat:argumentArray:
  static NSExpression expressionWithFormat(objc.NSString expressionFormat,
      {required objc.NSArray argumentArray}) {
    objc.checkOsVersionInternal(
        'NSExpression.expressionWithFormat:argumentArray:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_NSExpression,
        _sel_expressionWithFormat_argumentArray_,
        expressionFormat.ref.pointer,
        argumentArray.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionWithFormat:
  static NSExpression expressionWithFormat$1(objc.NSString expressionFormat) {
    objc.checkOsVersionInternal('NSExpression.expressionWithFormat:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_NSExpression,
        _sel_expressionWithFormat_, expressionFormat.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForConstantValue:
  static NSExpression expressionForConstantValue(objc.ObjCObjectBase? obj) {
    objc.checkOsVersionInternal('NSExpression.expressionForConstantValue:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_NSExpression,
        _sel_expressionForConstantValue_, obj?.ref.pointer ?? ffi.nullptr);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForEvaluatedObject
  static NSExpression expressionForEvaluatedObject() {
    objc.checkOsVersionInternal('NSExpression.expressionForEvaluatedObject',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSExpression, _sel_expressionForEvaluatedObject);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForVariable:
  static NSExpression expressionForVariable(objc.NSString string) {
    objc.checkOsVersionInternal('NSExpression.expressionForVariable:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSExpression, _sel_expressionForVariable_, string.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForKeyPath:
  static NSExpression expressionForKeyPath(objc.NSString keyPath) {
    objc.checkOsVersionInternal('NSExpression.expressionForKeyPath:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSExpression, _sel_expressionForKeyPath_, keyPath.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForFunction:arguments:
  static NSExpression expressionForFunction(objc.NSString name,
      {required objc.NSArray arguments}) {
    objc.checkOsVersionInternal('NSExpression.expressionForFunction:arguments:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_NSExpression,
        _sel_expressionForFunction_arguments_,
        name.ref.pointer,
        arguments.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForAggregate:
  static NSExpression expressionForAggregate(objc.NSArray subexpressions) {
    objc.checkOsVersionInternal('NSExpression.expressionForAggregate:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_NSExpression,
        _sel_expressionForAggregate_, subexpressions.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForUnionSet:with:
  static NSExpression expressionForUnionSet(NSExpression left,
      {required NSExpression with$}) {
    objc.checkOsVersionInternal('NSExpression.expressionForUnionSet:with:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_15qeuct(_class_NSExpression,
        _sel_expressionForUnionSet_with_, left.ref.pointer, with$.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForIntersectSet:with:
  static NSExpression expressionForIntersectSet(NSExpression left,
      {required NSExpression with$}) {
    objc.checkOsVersionInternal('NSExpression.expressionForIntersectSet:with:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_NSExpression,
        _sel_expressionForIntersectSet_with_,
        left.ref.pointer,
        with$.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForMinusSet:with:
  static NSExpression expressionForMinusSet(NSExpression left,
      {required NSExpression with$}) {
    objc.checkOsVersionInternal('NSExpression.expressionForMinusSet:with:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_15qeuct(_class_NSExpression,
        _sel_expressionForMinusSet_with_, left.ref.pointer, with$.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForSubquery:usingIteratorVariable:predicate:
  static NSExpression expressionForSubquery(NSExpression expression,
      {required objc.NSString usingIteratorVariable,
      required NSPredicate predicate}) {
    objc.checkOsVersionInternal(
        'NSExpression.expressionForSubquery:usingIteratorVariable:predicate:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_11spmsz(
        _class_NSExpression,
        _sel_expressionForSubquery_usingIteratorVariable_predicate_,
        expression.ref.pointer,
        usingIteratorVariable.ref.pointer,
        predicate.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForFunction:selectorName:arguments:
  static NSExpression expressionForFunction$1(NSExpression target,
      {required objc.NSString selectorName, objc.NSArray? arguments}) {
    objc.checkOsVersionInternal(
        'NSExpression.expressionForFunction:selectorName:arguments:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_11spmsz(
        _class_NSExpression,
        _sel_expressionForFunction_selectorName_arguments_,
        target.ref.pointer,
        selectorName.ref.pointer,
        arguments?.ref.pointer ?? ffi.nullptr);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForAnyKey
  static NSExpression expressionForAnyKey() {
    objc.checkOsVersionInternal('NSExpression.expressionForAnyKey',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_NSExpression, _sel_expressionForAnyKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForBlock:arguments:
  static NSExpression expressionForBlock(
      objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>?,
                  objc.NSArray,
                  objc.NSMutableDictionary?)>
          block,
      {objc.NSArray? arguments}) {
    objc.checkOsVersionInternal('NSExpression.expressionForBlock:arguments:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_27lb7c(
        _class_NSExpression,
        _sel_expressionForBlock_arguments_,
        block.ref.pointer,
        arguments?.ref.pointer ?? ffi.nullptr);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionForConditional:trueExpression:falseExpression:
  static NSExpression expressionForConditional(NSPredicate predicate,
      {required NSExpression trueExpression,
      required NSExpression falseExpression}) {
    objc.checkOsVersionInternal(
        'NSExpression.expressionForConditional:trueExpression:falseExpression:',
        iOS: (false, (9, 0, 0)),
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_11spmsz(
        _class_NSExpression,
        _sel_expressionForConditional_trueExpression_falseExpression_,
        predicate.ref.pointer,
        trueExpression.ref.pointer,
        falseExpression.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithExpressionType:
  NSExpression initWithExpressionType(NSExpressionType type) {
    objc.checkOsVersionInternal('NSExpression.initWithExpressionType:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1rz5npq(this.ref.retainAndReturnPointer(),
        _sel_initWithExpressionType_, type.value);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSExpression? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// expressionType
  NSExpressionType get expressionType {
    objc.checkOsVersionInternal('NSExpression.expressionType',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1ts4niw(this.ref.pointer, _sel_expressionType);
    return NSExpressionType.fromValue(_ret);
  }

  /// constantValue
  objc.ObjCObjectBase? get constantValue {
    objc.checkOsVersionInternal('NSExpression.constantValue',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_constantValue);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// keyPath
  objc.NSString get keyPath {
    objc.checkOsVersionInternal('NSExpression.keyPath',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keyPath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// function
  objc.NSString get function {
    objc.checkOsVersionInternal('NSExpression.function',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_function);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// variable
  objc.NSString get variable {
    objc.checkOsVersionInternal('NSExpression.variable',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_variable);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// operand
  NSExpression get operand {
    objc.checkOsVersionInternal('NSExpression.operand',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_operand);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// arguments
  objc.NSArray? get arguments {
    objc.checkOsVersionInternal('NSExpression.arguments',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_arguments);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// collection
  objc.ObjCObjectBase get collection {
    objc.checkOsVersionInternal('NSExpression.collection',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_collection);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// predicate
  NSPredicate get predicate {
    objc.checkOsVersionInternal('NSExpression.predicate',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_predicate);
    return NSPredicate.castFromPointer(_ret, retain: true, release: true);
  }

  /// leftExpression
  NSExpression get leftExpression {
    objc.checkOsVersionInternal('NSExpression.leftExpression',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leftExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// rightExpression
  NSExpression get rightExpression {
    objc.checkOsVersionInternal('NSExpression.rightExpression',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rightExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// trueExpression
  NSExpression get trueExpression {
    objc.checkOsVersionInternal('NSExpression.trueExpression',
        iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_trueExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// falseExpression
  NSExpression get falseExpression {
    objc.checkOsVersionInternal('NSExpression.falseExpression',
        iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_falseExpression);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionBlock
  objc.ObjCBlock<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>?,
          objc.NSArray, objc.NSMutableDictionary?)> get expressionBlock {
    objc.checkOsVersionInternal('NSExpression.expressionBlock',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_uwvaik(this.ref.pointer, _sel_expressionBlock);
    return ObjCBlock_objcObjCObject_objcObjCObject_NSArray_NSMutableDictionary
        .castFromPointer(_ret, retain: true, release: true);
  }

  /// expressionValueWithObject:context:
  objc.ObjCObjectBase? expressionValueWithObject(objc.ObjCObjectBase? object,
      {objc.NSMutableDictionary? context}) {
    objc.checkOsVersionInternal(
        'NSExpression.expressionValueWithObject:context:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_expressionValueWithObject_context_,
        object?.ref.pointer ?? ffi.nullptr,
        context?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// allowEvaluation
  void allowEvaluation() {
    objc.checkOsVersionInternal('NSExpression.allowEvaluation',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_allowEvaluation);
  }

  /// init
  NSExpression init() {
    objc.checkOsVersionInternal('NSExpression.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSExpression new$() {
    final _ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_new);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSExpression allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_NSExpression, _sel_allocWithZone_, zone);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSExpression alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_alloc);
    return NSExpression.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSExpression self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSExpression retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSExpression autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSExpression, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// Returns a conditional function expression specifying the string predicate, and
  /// expressions for each condition.
  ///
  /// @param conditionPredicate The predicate to get evaluated.
  /// @param trueExpression The expression for conditions equal to true.
  /// @param falseExpression The expression for conditions equal to false.
  static NSExpression mgl_expressionForConditional(
      NSPredicate conditionPredicate,
      {required NSExpression trueExpression$1,
      required NSExpression falseExpresssion}) {
    objc.checkOsVersionInternal(
        'NSExpression.mgl_expressionForConditional:trueExpression:falseExpresssion:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_11spmsz(
        _class_NSExpression,
        _sel_mgl_expressionForConditional_trueExpression_falseExpresssion_,
        conditionPredicate.ref.pointer,
        trueExpression$1.ref.pointer,
        falseExpresssion.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a step function expression specifying the stepping, from expression
  /// and stops.
  ///
  /// @param steppingExpression The stepping expression.
  /// @param minimumExpression The expression which could be a constant or function expression.
  /// @param stops The stops must be an `NSDictionary` constant `NSExpression`.
  ///
  /// #### Related examples
  /// TODO: Data-driven circles
  /// TODO: Cluster point data
  /// TODO: Use images to cluster point data
  /// Learn how to use this expression to style a map layer based on an attribute value.
  static NSExpression mgl_expressionForSteppingExpression(
      NSExpression steppingExpression,
      {required NSExpression fromExpression,
      required NSExpression stops}) {
    objc.checkOsVersionInternal(
        'NSExpression.mgl_expressionForSteppingExpression:fromExpression:stops:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_11spmsz(
        _class_NSExpression,
        _sel_mgl_expressionForSteppingExpression_fromExpression_stops_,
        steppingExpression.ref.pointer,
        fromExpression.ref.pointer,
        stops.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an interpolated function expression specifying the function operator, curve type,
  /// parameters and steps.
  ///
  /// @param inputExpression The interpolating expression input.
  /// @param curveType The curve type could be ``MLNExpressionInterpolationModeLinear``,
  /// ``MLNExpressionInterpolationModeExponential`` and
  /// ``MLNExpressionInterpolationModeCubicBezier``.
  /// @param parameters The parameters expression.
  /// @param stops The stops expression.
  ///
  /// #### Related examples
  /// TODO: Create a heatmap layer, learn how to style an ``MLNHeatmapStyleLayer``
  /// based on zoom level and point density with this expression.
  static NSExpression mgl_expressionForInterpolatingExpression(
      NSExpression inputExpression,
      {required objc.NSString withCurveType,
      NSExpression? parameters,
      required NSExpression stops}) {
    objc.checkOsVersionInternal(
        'NSExpression.mgl_expressionForInterpolatingExpression:withCurveType:parameters:stops:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_s92gih(
        _class_NSExpression,
        _sel_mgl_expressionForInterpolatingExpression_withCurveType_parameters_stops_,
        inputExpression.ref.pointer,
        withCurveType.ref.pointer,
        parameters?.ref.pointer ?? ffi.nullptr,
        stops.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a match function expression specifying the input, matching values,
  /// and default value.
  ///
  /// @param inputExpression The matching expression.
  /// @param matchedExpressions The matched values expression dictionary must be condition : value.
  /// @param defaultExpression The defaultValue expression to be used in case there is no match.
  static NSExpression mgl_expressionForMatchingExpression(
      NSExpression inputExpression,
      {required objc.NSDictionary inDictionary,
      required NSExpression defaultExpression}) {
    objc.checkOsVersionInternal(
        'NSExpression.mgl_expressionForMatchingExpression:inDictionary:defaultExpression:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_11spmsz(
        _class_NSExpression,
        _sel_mgl_expressionForMatchingExpression_inDictionary_defaultExpression_,
        inputExpression.ref.pointer,
        inDictionary.ref.pointer,
        defaultExpression.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an attributed function expression specifying an ``MLNAttributedExpression`` constant
  /// expression array.
  ///
  /// @param attributedExpressions The ``MLNAttributedExpression`` constant expression array.
  static NSExpression mgl_expressionForAttributedExpressions(
      objc.NSArray attributedExpressions) {
    objc.checkOsVersionInternal(
        'NSExpression.mgl_expressionForAttributedExpressions:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSExpression,
        _sel_mgl_expressionForAttributedExpressions_,
        attributedExpressions.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a constant expression appending the passed expression.
  ///
  /// > Note: Both the receiver and the given expression must be an `NSString` constant
  /// expression type; otherwise, an exception is rised.
  ///
  /// @param expression The expression to append to the receiver.
  NSExpression mgl_expressionByAppendingExpression(NSExpression expression) {
    objc.checkOsVersionInternal(
        'NSExpression.mgl_expressionByAppendingExpression:',
        iOS: (false, (3, 0, 0)),
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_mgl_expressionByAppendingExpression_, expression.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an expression equivalent to the given Foundation object deserialized
  /// from JSON data.
  ///
  /// The Foundation object is interpreted according to the
  /// [MapLibre Style Spec](https://maplibre.org/maplibre-style-spec/expressions/).
  /// See the
  /// “[Information for Style Authors](../for-style-authors.html#setting-attribute-values)”
  /// guide for a correspondence of operators and types between the style
  /// specification and the `NSExpression` representation used by this SDK.
  ///
  /// @param object A Foundation object deserialized from JSON data, for example
  /// using `NSJSONSerialization`.
  /// @return An initialized expression equivalent to `object`, suitable for use as
  /// the value of a style layer attribute.
  static NSExpression expressionWithMLNJSONObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal('NSExpression.expressionWithMLNJSONObject:',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_NSExpression,
        _sel_expressionWithMLNJSONObject_, object.ref.pointer);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of NSExpression constructed with the default `new` method.
  factory NSExpression() => new$();
}

enum NSFileWrapperReadingOptions {
  NSFileWrapperReadingImmediate(1),
  NSFileWrapperReadingWithoutMapping(2);

  final int value;
  const NSFileWrapperReadingOptions(this.value);

  static NSFileWrapperReadingOptions fromValue(int value) => switch (value) {
        1 => NSFileWrapperReadingImmediate,
        2 => NSFileWrapperReadingWithoutMapping,
        _ => throw ArgumentError(
            'Unknown value for NSFileWrapperReadingOptions: $value'),
      };
}

enum NSFileWrapperWritingOptions {
  NSFileWrapperWritingAtomic(1),
  NSFileWrapperWritingWithNameUpdating(2);

  final int value;
  const NSFileWrapperWritingOptions(this.value);

  static NSFileWrapperWritingOptions fromValue(int value) => switch (value) {
        1 => NSFileWrapperWritingAtomic,
        2 => NSFileWrapperWritingWithNameUpdating,
        _ => throw ArgumentError(
            'Unknown value for NSFileWrapperWritingOptions: $value'),
      };
}

late final _sel_linguisticTagsInRange_scheme_options_orthography_tokenRanges_ =
    objc.registerName(
        "linguisticTagsInRange:scheme:options:orthography:tokenRanges:");
final _objc_msgSend_1l09uru = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        objc.NSRange arg1,
        objc.NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject> arg0,
                    objc.NSRange arg1,
                    objc.NSRange arg2,
                    ffi.Pointer<ffi.Bool> arg3)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>, objc.NSRange,
                objc.NSRange, ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    objc.NSRange,
                    objc.NSRange,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        objc.NSRange arg1,
        objc.NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        objc.NSRange,
        objc.NSRange,
        ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    objc.NSRange,
                    objc.NSRange,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    objc.NSRange arg1,
    objc.NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>,
      objc.NSRange,
      objc.NSRange,
      ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            objc.NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    objc.NSRange arg1,
    objc.NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        objc.NSRange,
        objc.NSRange,
        ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            objc.NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            objc.NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                objc.NSRange,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      fromFunction(void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                          objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>
                      fn(arg0.address == 0 ? null : objc.NSString.castFromPointer(arg0, retain: true, release: true), arg1, arg2, arg3),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
          ffi.Pointer<ffi.Bool>)> listener(
      void Function(
              objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2,
                arg3),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_lmc3p5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
          ffi.Pointer<ffi.Bool>)> blocking(
      void Function(
              objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2,
                arg3),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, objc.NSRange arg1,
                objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2,
                arg3),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_lmc3p5(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
            ffi.Pointer<ffi.Bool>)> {
  void call(objc.NSString? arg0, objc.NSRange arg1, objc.NSRange arg2,
          ffi.Pointer<ffi.Bool> arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          objc.NSRange arg1,
                          objc.NSRange arg2,
                          ffi.Pointer<ffi.Bool> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      objc.NSRange,
                      objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>()(
          ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2, arg3);
}

late final _sel_enumerateLinguisticTagsInRange_scheme_options_orthography_usingBlock_ =
    objc.registerName(
        "enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:");
final _objc_msgSend_vij4rw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// NSLinguisticAnalysis
extension NSLinguisticAnalysis on objc.NSString {
  /// linguisticTagsInRange:scheme:options:orthography:tokenRanges:
  objc.NSArray linguisticTagsInRange(objc.NSRange range,
      {required objc.NSString scheme,
      required objc.NSLinguisticTaggerOptions options,
      NSOrthography? orthography,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> tokenRanges}) {
    objc.checkOsVersionInternal(
        'NSString.linguisticTagsInRange:scheme:options:orthography:tokenRanges:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_1l09uru(
        this.ref.pointer,
        _sel_linguisticTagsInRange_scheme_options_orthography_tokenRanges_,
        range,
        scheme.ref.pointer,
        options.value,
        orthography?.ref.pointer ?? ffi.nullptr,
        tokenRanges);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:
  void enumerateLinguisticTagsInRange(objc.NSRange range,
      {required objc.NSString scheme,
      required objc.NSLinguisticTaggerOptions options,
      NSOrthography? orthography,
      required objc.ObjCBlock<
              ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
                  ffi.Pointer<ffi.Bool>)>
          usingBlock}) {
    objc.checkOsVersionInternal(
        'NSString.enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    _objc_msgSend_vij4rw(
        this.ref.pointer,
        _sel_enumerateLinguisticTagsInRange_scheme_options_orthography_usingBlock_,
        range,
        scheme.ref.pointer,
        options.value,
        orthography?.ref.pointer ?? ffi.nullptr,
        usingBlock.ref.pointer);
  }
}

/// WARNING: NSUndoManager is a stub. To generate bindings for this class, include
/// NSUndoManager in your config's objc-interfaces list.
///
/// NSUndoManager
class NSUndoManager extends objc.NSObject {
  NSUndoManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUndoManager',
        iOS: (false, (3, 0, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSUndoManager] that points to the same underlying object as [other].
  NSUndoManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUndoManager] that wraps the given raw object pointer.
  NSUndoManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSUserActivity is a stub. To generate bindings for this class, include
/// NSUserActivity in your config's objc-interfaces list.
///
/// NSUserActivity
class NSUserActivity extends objc.NSObject {
  NSUserActivity._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUserActivity',
        iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
  }

  /// Constructs a [NSUserActivity] that points to the same underlying object as [other].
  NSUserActivity.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUserActivity] that wraps the given raw object pointer.
  NSUserActivity.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_Helpers = objc.getClass("maplibre_ios.Helpers");
late final _sel_addImageToStyleWithTarget_field_expression_ =
    objc.registerName("addImageToStyleWithTarget:field:expression:");
final _objc_msgSend_r8gdi7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setExpressionWithTarget_field_expression_ =
    objc.registerName("setExpressionWithTarget:field:expression:");
late final _sel_parseExpressionWithPropertyName_expression_ =
    objc.registerName("parseExpressionWithPropertyName:expression:");

/// Helpers
class Helpers extends objc.NSObject {
  Helpers._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [Helpers] that points to the same underlying object as [other].
  Helpers.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [Helpers] that wraps the given raw object pointer.
  Helpers.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [Helpers].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_Helpers);
  }

  /// addImageToStyleWithTarget:field:expression:
  static void addImageToStyleWithTarget(objc.NSObject target,
      {required objc.NSString field, required NSExpression expression}) {
    _objc_msgSend_r8gdi7(
        _class_Helpers,
        _sel_addImageToStyleWithTarget_field_expression_,
        target.ref.pointer,
        field.ref.pointer,
        expression.ref.pointer);
  }

  /// setExpressionWithTarget:field:expression:
  static void setExpressionWithTarget(objc.NSObject target,
      {required objc.NSString field, required NSExpression expression}) {
    _objc_msgSend_r8gdi7(
        _class_Helpers,
        _sel_setExpressionWithTarget_field_expression_,
        target.ref.pointer,
        field.ref.pointer,
        expression.ref.pointer);
  }

  /// parseExpressionWithPropertyName:expression:
  static NSExpression? parseExpressionWithPropertyName(
      objc.NSString propertyName,
      {required objc.NSString expression}) {
    final _ret = _objc_msgSend_15qeuct(
        _class_Helpers,
        _sel_parseExpressionWithPropertyName_expression_,
        propertyName.ref.pointer,
        expression.ref.pointer);
    return _ret.address == 0
        ? null
        : NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  Helpers init() {
    objc.checkOsVersionInternal('Helpers.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return Helpers.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static Helpers new$() {
    final _ret = _objc_msgSend_151sglz(_class_Helpers, _sel_new);
    return Helpers.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static Helpers allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_Helpers, _sel_allocWithZone_, zone);
    return Helpers.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static Helpers alloc() {
    final _ret = _objc_msgSend_151sglz(_class_Helpers, _sel_alloc);
    return Helpers.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  Helpers self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return Helpers.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  Helpers retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return Helpers.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  Helpers autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return Helpers.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of Helpers constructed with the default `new` method.
  factory Helpers() => new$();
}

late final _class_MapLibreRegistry =
    objc.getClass("maplibre_ios.MapLibreRegistry");
late final _sel_getMapWithViewId_ = objc.registerName("getMapWithViewId:");
final _objc_msgSend_1ya1kjn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int64)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_activity = objc.registerName("activity");
late final _sel_setActivity_ = objc.registerName("setActivity:");
late final _sel_context = objc.registerName("context");
late final _sel_setContext_ = objc.registerName("setContext:");

/// MapLibreRegistry
class MapLibreRegistry extends objc.NSObject {
  MapLibreRegistry._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MapLibreRegistry] that points to the same underlying object as [other].
  MapLibreRegistry.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MapLibreRegistry] that wraps the given raw object pointer.
  MapLibreRegistry.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MapLibreRegistry].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MapLibreRegistry);
  }

  /// getMapWithViewId:
  static objc.ObjCObjectBase? getMapWithViewId(int viewId) {
    final _ret = _objc_msgSend_1ya1kjn(
        _class_MapLibreRegistry, _sel_getMapWithViewId_, viewId);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// activity
  static objc.ObjCObjectBase? getActivity() {
    final _ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_activity);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setActivity:
  static void setActivity(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(_class_MapLibreRegistry, _sel_setActivity_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// context
  static objc.ObjCObjectBase? getContext() {
    final _ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_context);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setContext:
  static void setContext(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(_class_MapLibreRegistry, _sel_setContext_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  MapLibreRegistry init() {
    objc.checkOsVersionInternal('MapLibreRegistry.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MapLibreRegistry.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MapLibreRegistry new$() {
    final _ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_new);
    return MapLibreRegistry.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MapLibreRegistry allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MapLibreRegistry, _sel_allocWithZone_, zone);
    return MapLibreRegistry.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MapLibreRegistry alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_alloc);
    return MapLibreRegistry.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MapLibreRegistry self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MapLibreRegistry.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MapLibreRegistry retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MapLibreRegistry.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MapLibreRegistry autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MapLibreRegistry.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MapLibreRegistry constructed with the default `new` method.
  factory MapLibreRegistry() => new$();
}

final class __IOSurface extends ffi.Opaque {}

final class CGContext extends ffi.Opaque {}

final class CGColor extends ffi.Opaque {}

final class CGColorSpace extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGPath extends ffi.Opaque {}

enum CGLineJoin {
  kCGLineJoinMiter(0),
  kCGLineJoinRound(1),
  kCGLineJoinBevel(2);

  final int value;
  const CGLineJoin(this.value);

  static CGLineJoin fromValue(int value) => switch (value) {
        0 => kCGLineJoinMiter,
        1 => kCGLineJoinRound,
        2 => kCGLineJoinBevel,
        _ => throw ArgumentError('Unknown value for CGLineJoin: $value'),
      };
}

enum CGLineCap {
  kCGLineCapButt(0),
  kCGLineCapRound(1),
  kCGLineCapSquare(2);

  final int value;
  const CGLineCap(this.value);

  static CGLineCap fromValue(int value) => switch (value) {
        0 => kCGLineCapButt,
        1 => kCGLineCapRound,
        2 => kCGLineCapSquare,
        _ => throw ArgumentError('Unknown value for CGLineCap: $value'),
      };
}

enum CGBlendMode {
  kCGBlendModeNormal(0),
  kCGBlendModeMultiply(1),
  kCGBlendModeScreen(2),
  kCGBlendModeOverlay(3),
  kCGBlendModeDarken(4),
  kCGBlendModeLighten(5),
  kCGBlendModeColorDodge(6),
  kCGBlendModeColorBurn(7),
  kCGBlendModeSoftLight(8),
  kCGBlendModeHardLight(9),
  kCGBlendModeDifference(10),
  kCGBlendModeExclusion(11),
  kCGBlendModeHue(12),
  kCGBlendModeSaturation(13),
  kCGBlendModeColor(14),
  kCGBlendModeLuminosity(15),
  kCGBlendModeClear(16),
  kCGBlendModeCopy(17),
  kCGBlendModeSourceIn(18),
  kCGBlendModeSourceOut(19),
  kCGBlendModeSourceAtop(20),
  kCGBlendModeDestinationOver(21),
  kCGBlendModeDestinationIn(22),
  kCGBlendModeDestinationOut(23),
  kCGBlendModeDestinationAtop(24),
  kCGBlendModeXOR(25),
  kCGBlendModePlusDarker(26),
  kCGBlendModePlusLighter(27);

  final int value;
  const CGBlendMode(this.value);

  static CGBlendMode fromValue(int value) => switch (value) {
        0 => kCGBlendModeNormal,
        1 => kCGBlendModeMultiply,
        2 => kCGBlendModeScreen,
        3 => kCGBlendModeOverlay,
        4 => kCGBlendModeDarken,
        5 => kCGBlendModeLighten,
        6 => kCGBlendModeColorDodge,
        7 => kCGBlendModeColorBurn,
        8 => kCGBlendModeSoftLight,
        9 => kCGBlendModeHardLight,
        10 => kCGBlendModeDifference,
        11 => kCGBlendModeExclusion,
        12 => kCGBlendModeHue,
        13 => kCGBlendModeSaturation,
        14 => kCGBlendModeColor,
        15 => kCGBlendModeLuminosity,
        16 => kCGBlendModeClear,
        17 => kCGBlendModeCopy,
        18 => kCGBlendModeSourceIn,
        19 => kCGBlendModeSourceOut,
        20 => kCGBlendModeSourceAtop,
        21 => kCGBlendModeDestinationOver,
        22 => kCGBlendModeDestinationIn,
        23 => kCGBlendModeDestinationOut,
        24 => kCGBlendModeDestinationAtop,
        25 => kCGBlendModeXOR,
        26 => kCGBlendModePlusDarker,
        27 => kCGBlendModePlusLighter,
        _ => throw ArgumentError('Unknown value for CGBlendMode: $value'),
      };
}

final class CGLayer extends ffi.Opaque {}

final class UIEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double left;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double right;
}

final class NSDirectionalEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double leading;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double trailing;
}

final class UIOffset extends ffi.Struct {
  @ffi.Double()
  external double horizontal;

  @ffi.Double()
  external double vertical;
}

enum UIRectEdge {
  UIRectEdgeNone(0),
  UIRectEdgeTop(1),
  UIRectEdgeLeft(2),
  UIRectEdgeBottom(4),
  UIRectEdgeRight(8),
  UIRectEdgeAll(15);

  final int value;
  const UIRectEdge(this.value);

  static UIRectEdge fromValue(int value) => switch (value) {
        0 => UIRectEdgeNone,
        1 => UIRectEdgeTop,
        2 => UIRectEdgeLeft,
        4 => UIRectEdgeBottom,
        8 => UIRectEdgeRight,
        15 => UIRectEdgeAll,
        _ => throw ArgumentError('Unknown value for UIRectEdge: $value'),
      };
}

enum UIRectCorner {
  UIRectCornerTopLeft(1),
  UIRectCornerTopRight(2),
  UIRectCornerBottomLeft(4),
  UIRectCornerBottomRight(8),
  UIRectCornerAllCorners(-1);

  final int value;
  const UIRectCorner(this.value);

  static UIRectCorner fromValue(int value) => switch (value) {
        1 => UIRectCornerTopLeft,
        2 => UIRectCornerTopRight,
        4 => UIRectCornerBottomLeft,
        8 => UIRectCornerBottomRight,
        -1 => UIRectCornerAllCorners,
        _ => throw ArgumentError('Unknown value for UIRectCorner: $value'),
      };
}

enum UIAxis {
  UIAxisNeither(0),
  UIAxisHorizontal(1),
  UIAxisVertical(2),
  UIAxisBoth(3);

  final int value;
  const UIAxis(this.value);

  static UIAxis fromValue(int value) => switch (value) {
        0 => UIAxisNeither,
        1 => UIAxisHorizontal,
        2 => UIAxisVertical,
        3 => UIAxisBoth,
        _ => throw ArgumentError('Unknown value for UIAxis: $value'),
      };
}

enum NSDirectionalRectEdge {
  NSDirectionalRectEdgeNone(0),
  NSDirectionalRectEdgeTop(1),
  NSDirectionalRectEdgeLeading(2),
  NSDirectionalRectEdgeBottom(4),
  NSDirectionalRectEdgeTrailing(8),
  NSDirectionalRectEdgeAll(15);

  final int value;
  const NSDirectionalRectEdge(this.value);

  static NSDirectionalRectEdge fromValue(int value) => switch (value) {
        0 => NSDirectionalRectEdgeNone,
        1 => NSDirectionalRectEdgeTop,
        2 => NSDirectionalRectEdgeLeading,
        4 => NSDirectionalRectEdgeBottom,
        8 => NSDirectionalRectEdgeTrailing,
        15 => NSDirectionalRectEdgeAll,
        _ => throw ArgumentError(
            'Unknown value for NSDirectionalRectEdge: $value'),
      };
}

/// WARNING: UIBezierPath is a stub. To generate bindings for this class, include
/// UIBezierPath in your config's objc-interfaces list.
///
/// UIBezierPath
class UIBezierPath extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  UIBezierPath._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBezierPath', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIBezierPath] that points to the same underlying object as [other].
  UIBezierPath.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBezierPath] that wraps the given raw object pointer.
  UIBezierPath.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

final class __CVBuffer extends ffi.Opaque {}

final class CGImageSource extends ffi.Opaque {}

enum CGImagePropertyOrientation {
  kCGImagePropertyOrientationUp(1),
  kCGImagePropertyOrientationUpMirrored(2),
  kCGImagePropertyOrientationDown(3),
  kCGImagePropertyOrientationDownMirrored(4),
  kCGImagePropertyOrientationLeftMirrored(5),
  kCGImagePropertyOrientationRight(6),
  kCGImagePropertyOrientationRightMirrored(7),
  kCGImagePropertyOrientationLeft(8);

  final int value;
  const CGImagePropertyOrientation(this.value);

  static CGImagePropertyOrientation fromValue(int value) => switch (value) {
        1 => kCGImagePropertyOrientationUp,
        2 => kCGImagePropertyOrientationUpMirrored,
        3 => kCGImagePropertyOrientationDown,
        4 => kCGImagePropertyOrientationDownMirrored,
        5 => kCGImagePropertyOrientationLeftMirrored,
        6 => kCGImagePropertyOrientationRight,
        7 => kCGImagePropertyOrientationRightMirrored,
        8 => kCGImagePropertyOrientationLeft,
        _ => throw ArgumentError(
            'Unknown value for CGImagePropertyOrientation: $value'),
      };
}

enum UIColorProminence {
  UIColorProminencePrimary(0),
  UIColorProminenceSecondary(1),
  UIColorProminenceTertiary(2),
  UIColorProminenceQuaternary(3);

  final int value;
  const UIColorProminence(this.value);

  static UIColorProminence fromValue(int value) => switch (value) {
        0 => UIColorProminencePrimary,
        1 => UIColorProminenceSecondary,
        2 => UIColorProminenceTertiary,
        3 => UIColorProminenceQuaternary,
        _ => throw ArgumentError('Unknown value for UIColorProminence: $value'),
      };
}

/// WARNING: UIColor is a stub. To generate bindings for this class, include
/// UIColor in your config's objc-interfaces list.
///
/// UIColor
class UIColor extends objc.NSObject
    implements objc.NSSecureCoding, objc.NSCopying {
  UIColor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIColor] that points to the same underlying object as [other].
  UIColor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIColor] that wraps the given raw object pointer.
  UIColor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIFontDescriptorSymbolicTraits {
  UIFontDescriptorTraitItalic(1),
  UIFontDescriptorTraitBold(2),
  UIFontDescriptorTraitExpanded(32),
  UIFontDescriptorTraitCondensed(64),
  UIFontDescriptorTraitMonoSpace(1024),
  UIFontDescriptorTraitVertical(2048),
  UIFontDescriptorTraitUIOptimized(4096),
  UIFontDescriptorTraitTightLeading(32768),
  UIFontDescriptorTraitLooseLeading(65536),
  UIFontDescriptorClassMask(-268435456),
  UIFontDescriptorClassUnknown(0),
  UIFontDescriptorClassOldStyleSerifs(268435456),
  UIFontDescriptorClassTransitionalSerifs(536870912),
  UIFontDescriptorClassModernSerifs(805306368),
  UIFontDescriptorClassClarendonSerifs(1073741824),
  UIFontDescriptorClassSlabSerifs(1342177280),
  UIFontDescriptorClassFreeformSerifs(1879048192),
  UIFontDescriptorClassSansSerif(-2147483648),
  UIFontDescriptorClassOrnamentals(-1879048192),
  UIFontDescriptorClassScripts(-1610612736),
  UIFontDescriptorClassSymbolic(-1073741824);

  final int value;
  const UIFontDescriptorSymbolicTraits(this.value);

  static UIFontDescriptorSymbolicTraits fromValue(int value) => switch (value) {
        1 => UIFontDescriptorTraitItalic,
        2 => UIFontDescriptorTraitBold,
        32 => UIFontDescriptorTraitExpanded,
        64 => UIFontDescriptorTraitCondensed,
        1024 => UIFontDescriptorTraitMonoSpace,
        2048 => UIFontDescriptorTraitVertical,
        4096 => UIFontDescriptorTraitUIOptimized,
        32768 => UIFontDescriptorTraitTightLeading,
        65536 => UIFontDescriptorTraitLooseLeading,
        -268435456 => UIFontDescriptorClassMask,
        0 => UIFontDescriptorClassUnknown,
        268435456 => UIFontDescriptorClassOldStyleSerifs,
        536870912 => UIFontDescriptorClassTransitionalSerifs,
        805306368 => UIFontDescriptorClassModernSerifs,
        1073741824 => UIFontDescriptorClassClarendonSerifs,
        1342177280 => UIFontDescriptorClassSlabSerifs,
        1879048192 => UIFontDescriptorClassFreeformSerifs,
        -2147483648 => UIFontDescriptorClassSansSerif,
        -1879048192 => UIFontDescriptorClassOrnamentals,
        -1610612736 => UIFontDescriptorClassScripts,
        -1073741824 => UIFontDescriptorClassSymbolic,
        _ => throw ArgumentError(
            'Unknown value for UIFontDescriptorSymbolicTraits: $value'),
      };
}

/// WARNING: UIFont is a stub. To generate bindings for this class, include
/// UIFont in your config's objc-interfaces list.
///
/// UIFont
class UIFont extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  UIFont._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFont', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIFont] that points to the same underlying object as [other].
  UIFont.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFont] that wraps the given raw object pointer.
  UIFont.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSTextAttachmentLayout is a stub. To generate bindings for this class, include
/// NSTextAttachmentLayout in your config's objc-protocols list.
///
/// NSTextAttachmentLayout
interface class NSTextAttachmentLayout extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSTextAttachmentLayout._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSTextAttachmentLayout] that points to the same underlying object as [other].
  NSTextAttachmentLayout.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSTextAttachmentLayout] that wraps the given raw object pointer.
  NSTextAttachmentLayout.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIImageOrientation {
  UIImageOrientationUp(0),
  UIImageOrientationDown(1),
  UIImageOrientationLeft(2),
  UIImageOrientationRight(3),
  UIImageOrientationUpMirrored(4),
  UIImageOrientationDownMirrored(5),
  UIImageOrientationLeftMirrored(6),
  UIImageOrientationRightMirrored(7);

  final int value;
  const UIImageOrientation(this.value);

  static UIImageOrientation fromValue(int value) => switch (value) {
        0 => UIImageOrientationUp,
        1 => UIImageOrientationDown,
        2 => UIImageOrientationLeft,
        3 => UIImageOrientationRight,
        4 => UIImageOrientationUpMirrored,
        5 => UIImageOrientationDownMirrored,
        6 => UIImageOrientationLeftMirrored,
        7 => UIImageOrientationRightMirrored,
        _ =>
          throw ArgumentError('Unknown value for UIImageOrientation: $value'),
      };
}

enum UIImageResizingMode {
  UIImageResizingModeTile(0),
  UIImageResizingModeStretch(1);

  final int value;
  const UIImageResizingMode(this.value);

  static UIImageResizingMode fromValue(int value) => switch (value) {
        0 => UIImageResizingModeTile,
        1 => UIImageResizingModeStretch,
        _ =>
          throw ArgumentError('Unknown value for UIImageResizingMode: $value'),
      };
}

enum UIImageRenderingMode {
  UIImageRenderingModeAutomatic(0),
  UIImageRenderingModeAlwaysOriginal(1),
  UIImageRenderingModeAlwaysTemplate(2);

  final int value;
  const UIImageRenderingMode(this.value);

  static UIImageRenderingMode fromValue(int value) => switch (value) {
        0 => UIImageRenderingModeAutomatic,
        1 => UIImageRenderingModeAlwaysOriginal,
        2 => UIImageRenderingModeAlwaysTemplate,
        _ =>
          throw ArgumentError('Unknown value for UIImageRenderingMode: $value'),
      };
}

/// WARNING: UIImage is a stub. To generate bindings for this class, include
/// UIImage in your config's objc-interfaces list.
///
/// UIImage
class UIImage extends objc.NSObject implements objc.NSSecureCoding {
  UIImage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImage', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIImage] that points to the same underlying object as [other].
  UIImage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIImage] that wraps the given raw object pointer.
  UIImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIImageConfiguration is a stub. To generate bindings for this class, include
/// UIImageConfiguration in your config's objc-interfaces list.
///
/// UIImageConfiguration
class UIImageConfiguration extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  UIImageConfiguration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImageConfiguration',
        iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIImageConfiguration] that points to the same underlying object as [other].
  UIImageConfiguration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIImageConfiguration] that wraps the given raw object pointer.
  UIImageConfiguration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIImageSymbolScale {
  UIImageSymbolScaleDefault(-1),
  UIImageSymbolScaleUnspecified(0),
  UIImageSymbolScaleSmall(1),
  UIImageSymbolScaleMedium(2),
  UIImageSymbolScaleLarge(3);

  final int value;
  const UIImageSymbolScale(this.value);

  static UIImageSymbolScale fromValue(int value) => switch (value) {
        -1 => UIImageSymbolScaleDefault,
        0 => UIImageSymbolScaleUnspecified,
        1 => UIImageSymbolScaleSmall,
        2 => UIImageSymbolScaleMedium,
        3 => UIImageSymbolScaleLarge,
        _ =>
          throw ArgumentError('Unknown value for UIImageSymbolScale: $value'),
      };
}

enum UIImageSymbolWeight {
  UIImageSymbolWeightUnspecified(0),
  UIImageSymbolWeightUltraLight(1),
  UIImageSymbolWeightThin(2),
  UIImageSymbolWeightLight(3),
  UIImageSymbolWeightRegular(4),
  UIImageSymbolWeightMedium(5),
  UIImageSymbolWeightSemibold(6),
  UIImageSymbolWeightBold(7),
  UIImageSymbolWeightHeavy(8),
  UIImageSymbolWeightBlack(9);

  final int value;
  const UIImageSymbolWeight(this.value);

  static UIImageSymbolWeight fromValue(int value) => switch (value) {
        0 => UIImageSymbolWeightUnspecified,
        1 => UIImageSymbolWeightUltraLight,
        2 => UIImageSymbolWeightThin,
        3 => UIImageSymbolWeightLight,
        4 => UIImageSymbolWeightRegular,
        5 => UIImageSymbolWeightMedium,
        6 => UIImageSymbolWeightSemibold,
        7 => UIImageSymbolWeightBold,
        8 => UIImageSymbolWeightHeavy,
        9 => UIImageSymbolWeightBlack,
        _ =>
          throw ArgumentError('Unknown value for UIImageSymbolWeight: $value'),
      };
}

/// WARNING: UIImageSymbolConfiguration is a stub. To generate bindings for this class, include
/// UIImageSymbolConfiguration in your config's objc-interfaces list.
///
/// UIImageSymbolConfiguration
class UIImageSymbolConfiguration extends UIImageConfiguration {
  UIImageSymbolConfiguration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImageSymbolConfiguration',
        iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIImageSymbolConfiguration] that points to the same underlying object as [other].
  UIImageSymbolConfiguration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIImageSymbolConfiguration] that wraps the given raw object pointer.
  UIImageSymbolConfiguration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum NSUnderlineStyle {
  NSUnderlineStyleNone(0),
  NSUnderlineStyleSingle(1),
  NSUnderlineStyleThick(2),
  NSUnderlineStyleDouble(9),
  NSUnderlineStylePatternDot(256),
  NSUnderlineStylePatternDash(512),
  NSUnderlineStylePatternDashDot(768),
  NSUnderlineStylePatternDashDotDot(1024),
  NSUnderlineStyleByWord(32768);

  static const NSUnderlineStylePatternSolid = NSUnderlineStyleNone;

  final int value;
  const NSUnderlineStyle(this.value);

  static NSUnderlineStyle fromValue(int value) => switch (value) {
        0 => NSUnderlineStyleNone,
        1 => NSUnderlineStyleSingle,
        2 => NSUnderlineStyleThick,
        9 => NSUnderlineStyleDouble,
        256 => NSUnderlineStylePatternDot,
        512 => NSUnderlineStylePatternDash,
        768 => NSUnderlineStylePatternDashDot,
        1024 => NSUnderlineStylePatternDashDotDot,
        32768 => NSUnderlineStyleByWord,
        _ => throw ArgumentError('Unknown value for NSUnderlineStyle: $value'),
      };

  @override
  String toString() {
    if (this == NSUnderlineStyleNone)
      return "NSUnderlineStyle.NSUnderlineStyleNone, NSUnderlineStyle.NSUnderlineStylePatternSolid";
    return super.toString();
  }
}

enum NSWritingDirection {
  NSWritingDirectionNatural(-1),
  NSWritingDirectionLeftToRight(0),
  NSWritingDirectionRightToLeft(1);

  final int value;
  const NSWritingDirection(this.value);

  static NSWritingDirection fromValue(int value) => switch (value) {
        -1 => NSWritingDirectionNatural,
        0 => NSWritingDirectionLeftToRight,
        1 => NSWritingDirectionRightToLeft,
        _ =>
          throw ArgumentError('Unknown value for NSWritingDirection: $value'),
      };
}

enum NSTextAlignment {
  NSTextAlignmentLeft(0),
  NSTextAlignmentCenter(1),
  NSTextAlignmentRight(2),
  NSTextAlignmentJustified(3),
  NSTextAlignmentNatural(4);

  final int value;
  const NSTextAlignment(this.value);

  static NSTextAlignment fromValue(int value) => switch (value) {
        0 => NSTextAlignmentLeft,
        1 => NSTextAlignmentCenter,
        2 => NSTextAlignmentRight,
        3 => NSTextAlignmentJustified,
        4 => NSTextAlignmentNatural,
        _ => throw ArgumentError('Unknown value for NSTextAlignment: $value'),
      };
}

enum NSLineBreakMode {
  NSLineBreakByWordWrapping(0),
  NSLineBreakByCharWrapping(1),
  NSLineBreakByClipping(2),
  NSLineBreakByTruncatingHead(3),
  NSLineBreakByTruncatingTail(4),
  NSLineBreakByTruncatingMiddle(5);

  final int value;
  const NSLineBreakMode(this.value);

  static NSLineBreakMode fromValue(int value) => switch (value) {
        0 => NSLineBreakByWordWrapping,
        1 => NSLineBreakByCharWrapping,
        2 => NSLineBreakByClipping,
        3 => NSLineBreakByTruncatingHead,
        4 => NSLineBreakByTruncatingTail,
        5 => NSLineBreakByTruncatingMiddle,
        _ => throw ArgumentError('Unknown value for NSLineBreakMode: $value'),
      };
}

enum NSLineBreakStrategy {
  NSLineBreakStrategyNone(0),
  NSLineBreakStrategyPushOut(1),
  NSLineBreakStrategyHangulWordPriority(2),
  NSLineBreakStrategyStandard(65535);

  final int value;
  const NSLineBreakStrategy(this.value);

  static NSLineBreakStrategy fromValue(int value) => switch (value) {
        0 => NSLineBreakStrategyNone,
        1 => NSLineBreakStrategyPushOut,
        2 => NSLineBreakStrategyHangulWordPriority,
        65535 => NSLineBreakStrategyStandard,
        _ =>
          throw ArgumentError('Unknown value for NSLineBreakStrategy: $value'),
      };
}

late final _sel_sizeWithAttributes_ = objc.registerName("sizeWithAttributes:");
final _objc_msgSend_18r320v = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGSize Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_18r320vStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_drawAtPoint_withAttributes_ =
    objc.registerName("drawAtPoint:withAttributes:");
final _objc_msgSend_bkebbk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_drawInRect_withAttributes_ =
    objc.registerName("drawInRect:withAttributes:");
final _objc_msgSend_f227js = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSStringDrawing
extension NSStringDrawing$1 on objc.NSString {
  /// sizeWithAttributes:
  objc.CGSize sizeWithAttributes(objc.NSDictionary? attrs) {
    objc.checkOsVersionInternal('NSString.sizeWithAttributes:',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18r320vStret(_ptr, this.ref.pointer,
            _sel_sizeWithAttributes_, attrs?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_18r320v(this.ref.pointer,
            _sel_sizeWithAttributes_, attrs?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawAtPoint:withAttributes:
  void drawAtPoint(objc.CGPoint point, {objc.NSDictionary? withAttributes}) {
    objc.checkOsVersionInternal('NSString.drawAtPoint:withAttributes:',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_bkebbk(this.ref.pointer, _sel_drawAtPoint_withAttributes_,
        point, withAttributes?.ref.pointer ?? ffi.nullptr);
  }

  /// drawInRect:withAttributes:
  void drawInRect(objc.CGRect rect, {objc.NSDictionary? withAttributes}) {
    objc.checkOsVersionInternal('NSString.drawInRect:withAttributes:',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_f227js(this.ref.pointer, _sel_drawInRect_withAttributes_,
        rect, withAttributes?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_drawWithRect_options_attributes_context_ =
    objc.registerName("drawWithRect:options:attributes:context:");
final _objc_msgSend_1dr66uk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_boundingRectWithSize_options_attributes_context_ =
    objc.registerName("boundingRectWithSize:options:attributes:context:");
final _objc_msgSend_k8g3u = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGSize,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGRect Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGSize,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_k8g3uStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGSize,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGSize,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSExtendedStringDrawing
extension NSExtendedStringDrawing$1 on objc.NSString {
  /// drawWithRect:options:attributes:context:
  void drawWithRect(objc.CGRect rect,
      {required NSStringDrawingOptions options,
      objc.NSDictionary? attributes,
      NSStringDrawingContext? context}) {
    objc.checkOsVersionInternal(
        'NSString.drawWithRect:options:attributes:context:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 11, 0)));
    _objc_msgSend_1dr66uk(
        this.ref.pointer,
        _sel_drawWithRect_options_attributes_context_,
        rect,
        options.value,
        attributes?.ref.pointer ?? ffi.nullptr,
        context?.ref.pointer ?? ffi.nullptr);
  }

  /// boundingRectWithSize:options:attributes:context:
  objc.CGRect boundingRectWithSize(objc.CGSize size,
      {required NSStringDrawingOptions options,
      objc.NSDictionary? attributes,
      NSStringDrawingContext? context}) {
    objc.checkOsVersionInternal(
        'NSString.boundingRectWithSize:options:attributes:context:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 11, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_k8g3uStret(
            _ptr,
            this.ref.pointer,
            _sel_boundingRectWithSize_options_attributes_context_,
            size,
            options.value,
            attributes?.ref.pointer ?? ffi.nullptr,
            context?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_k8g3u(
            this.ref.pointer,
            _sel_boundingRectWithSize_options_attributes_context_,
            size,
            options.value,
            attributes?.ref.pointer ?? ffi.nullptr,
            context?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }
}

final class CATransform3D extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m13;

  @ffi.Double()
  external double m14;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double m23;

  @ffi.Double()
  external double m24;

  @ffi.Double()
  external double m31;

  @ffi.Double()
  external double m32;

  @ffi.Double()
  external double m33;

  @ffi.Double()
  external double m34;

  @ffi.Double()
  external double m41;

  @ffi.Double()
  external double m42;

  @ffi.Double()
  external double m43;

  @ffi.Double()
  external double m44;
}

/// WARNING: CAMediaTiming is a stub. To generate bindings for this class, include
/// CAMediaTiming in your config's objc-protocols list.
///
/// CAMediaTiming
interface class CAMediaTiming extends objc.ObjCProtocolBase {
  CAMediaTiming._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CAMediaTiming] that points to the same underlying object as [other].
  CAMediaTiming.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CAMediaTiming] that wraps the given raw object pointer.
  CAMediaTiming.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum CAEdgeAntialiasingMask {
  kCALayerLeftEdge(1),
  kCALayerRightEdge(2),
  kCALayerBottomEdge(4),
  kCALayerTopEdge(8);

  final int value;
  const CAEdgeAntialiasingMask(this.value);

  static CAEdgeAntialiasingMask fromValue(int value) => switch (value) {
        1 => kCALayerLeftEdge,
        2 => kCALayerRightEdge,
        4 => kCALayerBottomEdge,
        8 => kCALayerTopEdge,
        _ => throw ArgumentError(
            'Unknown value for CAEdgeAntialiasingMask: $value'),
      };
}

enum CACornerMask {
  kCALayerMinXMinYCorner(1),
  kCALayerMaxXMinYCorner(2),
  kCALayerMinXMaxYCorner(4),
  kCALayerMaxXMaxYCorner(8);

  final int value;
  const CACornerMask(this.value);

  static CACornerMask fromValue(int value) => switch (value) {
        1 => kCALayerMinXMinYCorner,
        2 => kCALayerMaxXMinYCorner,
        4 => kCALayerMinXMaxYCorner,
        8 => kCALayerMaxXMaxYCorner,
        _ => throw ArgumentError('Unknown value for CACornerMask: $value'),
      };
}

/// WARNING: CALayer is a stub. To generate bindings for this class, include
/// CALayer in your config's objc-interfaces list.
///
/// CALayer
class CALayer extends objc.NSObject
    implements objc.NSSecureCoding, CAMediaTiming {
  CALayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CALayer',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }

  /// Constructs a [CALayer] that points to the same underlying object as [other].
  CALayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CALayer] that wraps the given raw object pointer.
  CALayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: CAAction is a stub. To generate bindings for this class, include
/// CAAction in your config's objc-protocols list.
///
/// CAAction
interface class CAAction extends objc.ObjCProtocolBase {
  CAAction._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CAAction] that points to the same underlying object as [other].
  CAAction.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CAAction] that wraps the given raw object pointer.
  CAAction.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: CALayerDelegate is a stub. To generate bindings for this class, include
/// CALayerDelegate in your config's objc-protocols list.
///
/// CALayerDelegate
interface class CALayerDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  CALayerDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CALayerDelegate] that points to the same underlying object as [other].
  CALayerDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CALayerDelegate] that wraps the given raw object pointer.
  CALayerDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

final class CAFrameRateRange extends ffi.Struct {
  @ffi.Float()
  external double minimum;

  @ffi.Float()
  external double maximum;

  @ffi.Float()
  external double preferred;
}

/// WARNING: CAMediaTimingFunction is a stub. To generate bindings for this class, include
/// CAMediaTimingFunction in your config's objc-interfaces list.
///
/// CAMediaTimingFunction
class CAMediaTimingFunction extends objc.NSObject
    implements objc.NSSecureCoding {
  CAMediaTimingFunction._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CAMediaTimingFunction',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }

  /// Constructs a [CAMediaTimingFunction] that points to the same underlying object as [other].
  CAMediaTimingFunction.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CAMediaTimingFunction] that wraps the given raw object pointer.
  CAMediaTimingFunction.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIMenuElementState {
  UIMenuElementStateOff(0),
  UIMenuElementStateOn(1),
  UIMenuElementStateMixed(2);

  final int value;
  const UIMenuElementState(this.value);

  static UIMenuElementState fromValue(int value) => switch (value) {
        0 => UIMenuElementStateOff,
        1 => UIMenuElementStateOn,
        2 => UIMenuElementStateMixed,
        _ =>
          throw ArgumentError('Unknown value for UIMenuElementState: $value'),
      };
}

enum UIMenuElementAttributes {
  UIMenuElementAttributesDisabled(1),
  UIMenuElementAttributesDestructive(2),
  UIMenuElementAttributesHidden(4),
  UIMenuElementAttributesKeepsMenuPresented(8);

  final int value;
  const UIMenuElementAttributes(this.value);

  static UIMenuElementAttributes fromValue(int value) => switch (value) {
        1 => UIMenuElementAttributesDisabled,
        2 => UIMenuElementAttributesDestructive,
        4 => UIMenuElementAttributesHidden,
        8 => UIMenuElementAttributesKeepsMenuPresented,
        _ => throw ArgumentError(
            'Unknown value for UIMenuElementAttributes: $value'),
      };
}

late final _class_UIMenuElement = objc.getClass("UIMenuElement");

/// WARNING: UIAccessibilityIdentification is a stub. To generate bindings for this class, include
/// UIAccessibilityIdentification in your config's objc-protocols list.
///
/// UIAccessibilityIdentification
interface class UIAccessibilityIdentification extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIAccessibilityIdentification._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAccessibilityIdentification] that points to the same underlying object as [other].
  UIAccessibilityIdentification.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAccessibilityIdentification] that wraps the given raw object pointer.
  UIAccessibilityIdentification.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_accessibilityIdentifier =
    objc.registerName("accessibilityIdentifier");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSString_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSString_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSString_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSString_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSString_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSString_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSString_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSString? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSString_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.NSString.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_setAccessibilityIdentifier_ =
    objc.registerName("setAccessibilityIdentifier:");
void _ObjCBlock_ffiVoid_ffiVoid_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSString_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSString_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSString_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSString_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSString_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSString_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSString_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSString_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSString_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSString_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
          pointer,
          retain: retain,
          release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSString_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSString_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0,
                  arg1.address == 0
                      ? null
                      : objc.NSString.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSString_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSString.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSString_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSString.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSString_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSString.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSString_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSString? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

/// UIAccessibility
extension UIAccessibility on UIMenuElement {
  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
    objc.checkOsVersionInternal('UIMenuElement.accessibilityIdentifier',
        iOS: (false, (5, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_accessibilityIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIMenuElement.setAccessibilityIdentifier:',
        iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAccessibilityIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_title = objc.registerName("title");
late final _sel_subtitle = objc.registerName("subtitle");
late final _sel_setSubtitle_ = objc.registerName("setSubtitle:");
late final _sel_image = objc.registerName("image");

/// UIMenuElement
class UIMenuElement extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  UIMenuElement._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenuElement', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIMenuElement] that points to the same underlying object as [other].
  UIMenuElement.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenuElement] that wraps the given raw object pointer.
  UIMenuElement.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIMenuElement].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIMenuElement);
  }

  /// title
  objc.NSString get title {
    objc.checkOsVersionInternal('UIMenuElement.title',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// subtitle
  objc.NSString? get subtitle {
    objc.checkOsVersionInternal('UIMenuElement.subtitle',
        iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSubtitle:
  set subtitle(objc.NSString? value) {
    objc.checkOsVersionInternal('UIMenuElement.setSubtitle:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSubtitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal('UIMenuElement.image',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  UIMenuElement? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// init
  UIMenuElement init() {
    objc.checkOsVersionInternal('UIMenuElement.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIMenuElement new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_new);
    return UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIMenuElement allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_UIMenuElement, _sel_allocWithZone_, zone);
    return UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIMenuElement alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_alloc);
    return UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_UIMenuElement, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// Returns a new instance of UIMenuElement constructed with the default `new` method.
  factory UIMenuElement() => new$();
}

/// WARNING: UIMenuDisplayPreferences is a stub. To generate bindings for this class, include
/// UIMenuDisplayPreferences in your config's objc-interfaces list.
///
/// UIMenuDisplayPreferences
class UIMenuDisplayPreferences extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  UIMenuDisplayPreferences._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenuDisplayPreferences',
        iOS: (false, (17, 4, 0)));
  }

  /// Constructs a [UIMenuDisplayPreferences] that points to the same underlying object as [other].
  UIMenuDisplayPreferences.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenuDisplayPreferences] that wraps the given raw object pointer.
  UIMenuDisplayPreferences.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIMenuOptions {
  UIMenuOptionsDisplayInline(1),
  UIMenuOptionsDestructive(2),
  UIMenuOptionsSingleSelection(32),
  UIMenuOptionsDisplayAsPalette(128);

  final int value;
  const UIMenuOptions(this.value);

  static UIMenuOptions fromValue(int value) => switch (value) {
        1 => UIMenuOptionsDisplayInline,
        2 => UIMenuOptionsDestructive,
        32 => UIMenuOptionsSingleSelection,
        128 => UIMenuOptionsDisplayAsPalette,
        _ => throw ArgumentError('Unknown value for UIMenuOptions: $value'),
      };
}

enum UIMenuElementSize {
  UIMenuElementSizeSmall(0),
  UIMenuElementSizeMedium(1),
  UIMenuElementSizeLarge(2),
  UIMenuElementSizeAutomatic(-1);

  final int value;
  const UIMenuElementSize(this.value);

  static UIMenuElementSize fromValue(int value) => switch (value) {
        0 => UIMenuElementSizeSmall,
        1 => UIMenuElementSizeMedium,
        2 => UIMenuElementSizeLarge,
        -1 => UIMenuElementSizeAutomatic,
        _ => throw ArgumentError('Unknown value for UIMenuElementSize: $value'),
      };
}

late final _class_UIMenu = objc.getClass("UIMenu");
late final _sel_identifier = objc.registerName("identifier");
late final _sel_options = objc.registerName("options");
final _objc_msgSend_1cz0z8u = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_preferredElementSize =
    objc.registerName("preferredElementSize");
final _objc_msgSend_xjcq8x = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPreferredElementSize_ =
    objc.registerName("setPreferredElementSize:");
final _objc_msgSend_b88ef1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_children = objc.registerName("children");
late final _sel_selectedElements = objc.registerName("selectedElements");
late final _sel_displayPreferences = objc.registerName("displayPreferences");
late final _sel_setDisplayPreferences_ =
    objc.registerName("setDisplayPreferences:");
late final _sel_menuWithChildren_ = objc.registerName("menuWithChildren:");
late final _sel_menuWithTitle_children_ =
    objc.registerName("menuWithTitle:children:");
late final _sel_menuWithTitle_image_identifier_options_children_ =
    objc.registerName("menuWithTitle:image:identifier:options:children:");
final _objc_msgSend_zjuvxo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_menuByReplacingChildren_ =
    objc.registerName("menuByReplacingChildren:");

/// UIMenu
class UIMenu extends UIMenuElement {
  UIMenu._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenu', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIMenu] that points to the same underlying object as [other].
  UIMenu.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenu] that wraps the given raw object pointer.
  UIMenu.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIMenu].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIMenu);
  }

  /// identifier
  objc.NSString get identifier {
    objc.checkOsVersionInternal('UIMenu.identifier', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// options
  UIMenuOptions get options {
    objc.checkOsVersionInternal('UIMenu.options', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1cz0z8u(this.ref.pointer, _sel_options);
    return UIMenuOptions.fromValue(_ret);
  }

  /// preferredElementSize
  UIMenuElementSize get preferredElementSize {
    objc.checkOsVersionInternal('UIMenu.preferredElementSize',
        iOS: (false, (16, 0, 0)));
    final _ret =
        _objc_msgSend_xjcq8x(this.ref.pointer, _sel_preferredElementSize);
    return UIMenuElementSize.fromValue(_ret);
  }

  /// setPreferredElementSize:
  set preferredElementSize(UIMenuElementSize value) {
    objc.checkOsVersionInternal('UIMenu.setPreferredElementSize:',
        iOS: (false, (16, 0, 0)));
    _objc_msgSend_b88ef1(
        this.ref.pointer, _sel_setPreferredElementSize_, value.value);
  }

  /// children
  objc.NSArray get children {
    objc.checkOsVersionInternal('UIMenu.children', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_children);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// selectedElements
  objc.NSArray get selectedElements {
    objc.checkOsVersionInternal('UIMenu.selectedElements',
        iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedElements);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// displayPreferences
  UIMenuDisplayPreferences? get displayPreferences {
    objc.checkOsVersionInternal('UIMenu.displayPreferences',
        iOS: (false, (17, 4, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_displayPreferences);
    return _ret.address == 0
        ? null
        : UIMenuDisplayPreferences.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setDisplayPreferences:
  set displayPreferences(UIMenuDisplayPreferences? value) {
    objc.checkOsVersionInternal('UIMenu.setDisplayPreferences:',
        iOS: (false, (17, 4, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDisplayPreferences_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// menuWithChildren:
  static UIMenu menuWithChildren(objc.NSArray children$1) {
    objc.checkOsVersionInternal('UIMenu.menuWithChildren:',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_UIMenu, _sel_menuWithChildren_, children$1.ref.pointer);
    return UIMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// menuWithTitle:children:
  static UIMenu menuWithTitle(objc.NSString title,
      {required objc.NSArray children$1}) {
    final _ret = _objc_msgSend_15qeuct(
        _class_UIMenu,
        _sel_menuWithTitle_children_,
        title.ref.pointer,
        children$1.ref.pointer);
    return UIMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// menuWithTitle:image:identifier:options:children:
  static UIMenu menuWithTitle$1(objc.NSString title,
      {UIImage? image,
      objc.NSString? identifier$1,
      required UIMenuOptions options$1,
      required objc.NSArray children$1}) {
    final _ret = _objc_msgSend_zjuvxo(
        _class_UIMenu,
        _sel_menuWithTitle_image_identifier_options_children_,
        title.ref.pointer,
        image?.ref.pointer ?? ffi.nullptr,
        identifier$1?.ref.pointer ?? ffi.nullptr,
        options$1.value,
        children$1.ref.pointer);
    return UIMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  UIMenu? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// init
  UIMenu init() {
    objc.checkOsVersionInternal('UIMenu.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIMenu new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_new);
    return UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// menuByReplacingChildren:
  UIMenu menuByReplacingChildren(objc.NSArray newChildren) {
    objc.checkOsVersionInternal('UIMenu.menuByReplacingChildren:',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_menuByReplacingChildren_, newChildren.ref.pointer);
    return UIMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// allocWithZone:
  static UIMenu allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_UIMenu, _sel_allocWithZone_, zone);
    return UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIMenu alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_alloc);
    return UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIMenu, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIMenu constructed with the default `new` method.
  factory UIMenu() => new$();
}

/// WARNING: UIMenuLeaf is a stub. To generate bindings for this class, include
/// UIMenuLeaf in your config's objc-protocols list.
///
/// UIMenuLeaf
interface class UIMenuLeaf extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIMenuLeaf._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIMenuLeaf] that points to the same underlying object as [other].
  UIMenuLeaf.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenuLeaf] that wraps the given raw object pointer.
  UIMenuLeaf.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIKeyModifierFlags {
  UIKeyModifierAlphaShift(65536),
  UIKeyModifierShift(131072),
  UIKeyModifierControl(262144),
  UIKeyModifierAlternate(524288),
  UIKeyModifierCommand(1048576),
  UIKeyModifierNumericPad(2097152);

  final int value;
  const UIKeyModifierFlags(this.value);

  static UIKeyModifierFlags fromValue(int value) => switch (value) {
        65536 => UIKeyModifierAlphaShift,
        131072 => UIKeyModifierShift,
        262144 => UIKeyModifierControl,
        524288 => UIKeyModifierAlternate,
        1048576 => UIKeyModifierCommand,
        2097152 => UIKeyModifierNumericPad,
        _ =>
          throw ArgumentError('Unknown value for UIKeyModifierFlags: $value'),
      };
}

/// WARNING: UICommand is a stub. To generate bindings for this class, include
/// UICommand in your config's objc-interfaces list.
///
/// UICommand
class UICommand extends UIMenuElement implements UIMenuLeaf {
  UICommand._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UICommand', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UICommand] that points to the same underlying object as [other].
  UICommand.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UICommand] that wraps the given raw object pointer.
  UICommand.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIEventType {
  UIEventTypeTouches(0),
  UIEventTypeMotion(1),
  UIEventTypeRemoteControl(2),
  UIEventTypePresses(3),
  UIEventTypeScroll(10),
  UIEventTypeHover(11),
  UIEventTypeTransform(14);

  final int value;
  const UIEventType(this.value);

  static UIEventType fromValue(int value) => switch (value) {
        0 => UIEventTypeTouches,
        1 => UIEventTypeMotion,
        2 => UIEventTypeRemoteControl,
        3 => UIEventTypePresses,
        10 => UIEventTypeScroll,
        11 => UIEventTypeHover,
        14 => UIEventTypeTransform,
        _ => throw ArgumentError('Unknown value for UIEventType: $value'),
      };
}

enum UIEventSubtype {
  UIEventSubtypeNone(0),
  UIEventSubtypeMotionShake(1),
  UIEventSubtypeRemoteControlPlay(100),
  UIEventSubtypeRemoteControlPause(101),
  UIEventSubtypeRemoteControlStop(102),
  UIEventSubtypeRemoteControlTogglePlayPause(103),
  UIEventSubtypeRemoteControlNextTrack(104),
  UIEventSubtypeRemoteControlPreviousTrack(105),
  UIEventSubtypeRemoteControlBeginSeekingBackward(106),
  UIEventSubtypeRemoteControlEndSeekingBackward(107),
  UIEventSubtypeRemoteControlBeginSeekingForward(108),
  UIEventSubtypeRemoteControlEndSeekingForward(109);

  final int value;
  const UIEventSubtype(this.value);

  static UIEventSubtype fromValue(int value) => switch (value) {
        0 => UIEventSubtypeNone,
        1 => UIEventSubtypeMotionShake,
        100 => UIEventSubtypeRemoteControlPlay,
        101 => UIEventSubtypeRemoteControlPause,
        102 => UIEventSubtypeRemoteControlStop,
        103 => UIEventSubtypeRemoteControlTogglePlayPause,
        104 => UIEventSubtypeRemoteControlNextTrack,
        105 => UIEventSubtypeRemoteControlPreviousTrack,
        106 => UIEventSubtypeRemoteControlBeginSeekingBackward,
        107 => UIEventSubtypeRemoteControlEndSeekingBackward,
        108 => UIEventSubtypeRemoteControlBeginSeekingForward,
        109 => UIEventSubtypeRemoteControlEndSeekingForward,
        _ => throw ArgumentError('Unknown value for UIEventSubtype: $value'),
      };
}

enum UIEventButtonMask {
  UIEventButtonMaskPrimary(1),
  UIEventButtonMaskSecondary(2);

  final int value;
  const UIEventButtonMask(this.value);

  static UIEventButtonMask fromValue(int value) => switch (value) {
        1 => UIEventButtonMaskPrimary,
        2 => UIEventButtonMaskSecondary,
        _ => throw ArgumentError('Unknown value for UIEventButtonMask: $value'),
      };
}

/// WARNING: UIEvent is a stub. To generate bindings for this class, include
/// UIEvent in your config's objc-interfaces list.
///
/// UIEvent
class UIEvent extends objc.NSObject {
  UIEvent._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIEvent] that points to the same underlying object as [other].
  UIEvent.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIEvent] that wraps the given raw object pointer.
  UIEvent.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIPasteConfigurationSupporting is a stub. To generate bindings for this class, include
/// UIPasteConfigurationSupporting in your config's objc-protocols list.
///
/// UIPasteConfigurationSupporting
interface class UIPasteConfigurationSupporting extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIPasteConfigurationSupporting._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPasteConfigurationSupporting] that points to the same underlying object as [other].
  UIPasteConfigurationSupporting.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPasteConfigurationSupporting] that wraps the given raw object pointer.
  UIPasteConfigurationSupporting.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIUserActivityRestoring is a stub. To generate bindings for this class, include
/// UIUserActivityRestoring in your config's objc-protocols list.
///
/// UIUserActivityRestoring
interface class UIUserActivityRestoring extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIUserActivityRestoring._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIUserActivityRestoring] that points to the same underlying object as [other].
  UIUserActivityRestoring.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIUserActivityRestoring] that wraps the given raw object pointer.
  UIUserActivityRestoring.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSDictionary_NSDictionary_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_NSDictionary_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSDictionary_NSDictionary_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSDictionary_NSDictionary_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_NSDictionary_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSDictionary_NSDictionary_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
abstract final class ObjCBlock_NSDictionary_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
          objc.newPointerBlock(
              _ObjCBlock_NSDictionary_NSDictionary_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      objc.NSDictionary Function(objc.NSDictionary)> fromFunction(
          objc.NSDictionary Function(objc.NSDictionary) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
          objc.newClosureBlock(
              _ObjCBlock_NSDictionary_NSDictionary_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) =>
                  fn(objc.NSDictionary.castFromPointer(arg0, retain: true, release: true))
                      .ref
                      .retainAndAutorelease(),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
extension ObjCBlock_NSDictionary_NSDictionary_CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> {
  objc.NSDictionary call(objc.NSDictionary arg0) =>
      objc.NSDictionary.castFromPointer(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<objc.ObjCObject> arg0)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true);
}

enum UIEditingInteractionConfiguration {
  UIEditingInteractionConfigurationNone(0),
  UIEditingInteractionConfigurationDefault(1);

  final int value;
  const UIEditingInteractionConfiguration(this.value);

  static UIEditingInteractionConfiguration fromValue(int value) =>
      switch (value) {
        0 => UIEditingInteractionConfigurationNone,
        1 => UIEditingInteractionConfigurationDefault,
        _ => throw ArgumentError(
            'Unknown value for UIEditingInteractionConfiguration: $value'),
      };
}

/// WARNING: UIResponderStandardEditActions is a stub. To generate bindings for this class, include
/// UIResponderStandardEditActions in your config's objc-protocols list.
///
/// UIResponderStandardEditActions
interface class UIResponderStandardEditActions extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIResponderStandardEditActions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIResponderStandardEditActions] that points to the same underlying object as [other].
  UIResponderStandardEditActions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIResponderStandardEditActions] that wraps the given raw object pointer.
  UIResponderStandardEditActions.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_UIResponder = objc.getClass("UIResponder");
late final _sel_keyCommands = objc.registerName("keyCommands");

/// UIResponderKeyCommands
extension UIResponderKeyCommands on UIResponder {
  /// keyCommands
  objc.NSArray? get keyCommands {
    objc.checkOsVersionInternal('UIResponder.keyCommands',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keyCommands);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_UIView = objc.getClass("UIView");

/// WARNING: UIAppearance is a stub. To generate bindings for this class, include
/// UIAppearance in your config's objc-protocols list.
///
/// UIAppearance
interface class UIAppearance extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIAppearance._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAppearance] that points to the same underlying object as [other].
  UIAppearance.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAppearance] that wraps the given raw object pointer.
  UIAppearance.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIAppearanceContainer is a stub. To generate bindings for this class, include
/// UIAppearanceContainer in your config's objc-protocols list.
///
/// UIAppearanceContainer
interface class UIAppearanceContainer extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIAppearanceContainer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAppearanceContainer] that points to the same underlying object as [other].
  UIAppearanceContainer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAppearanceContainer] that wraps the given raw object pointer.
  UIAppearanceContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIDynamicItem is a stub. To generate bindings for this class, include
/// UIDynamicItem in your config's objc-protocols list.
///
/// UIDynamicItem
interface class UIDynamicItem extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIDynamicItem._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIDynamicItem] that points to the same underlying object as [other].
  UIDynamicItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIDynamicItem] that wraps the given raw object pointer.
  UIDynamicItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UITraitEnvironment is a stub. To generate bindings for this class, include
/// UITraitEnvironment in your config's objc-protocols list.
///
/// UITraitEnvironment
interface class UITraitEnvironment extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UITraitEnvironment._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UITraitEnvironment] that points to the same underlying object as [other].
  UITraitEnvironment.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitEnvironment] that wraps the given raw object pointer.
  UITraitEnvironment.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UICoordinateSpace is a stub. To generate bindings for this class, include
/// UICoordinateSpace in your config's objc-protocols list.
///
/// UICoordinateSpace
interface class UICoordinateSpace extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UICoordinateSpace._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UICoordinateSpace] that points to the same underlying object as [other].
  UICoordinateSpace.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UICoordinateSpace] that wraps the given raw object pointer.
  UICoordinateSpace.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIFocusItem is a stub. To generate bindings for this class, include
/// UIFocusItem in your config's objc-protocols list.
///
/// UIFocusItem
interface class UIFocusItem extends objc.ObjCProtocolBase
    implements UIFocusEnvironment {
  UIFocusItem._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItem] that points to the same underlying object as [other].
  UIFocusItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItem] that wraps the given raw object pointer.
  UIFocusItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIFocusItemContainer is a stub. To generate bindings for this class, include
/// UIFocusItemContainer in your config's objc-protocols list.
///
/// UIFocusItemContainer
interface class UIFocusItemContainer extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIFocusItemContainer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItemContainer] that points to the same underlying object as [other].
  UIFocusItemContainer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItemContainer] that wraps the given raw object pointer.
  UIFocusItemContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_frame = objc.registerName("frame");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        objc.CGRect Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setFrame_ = objc.registerName("setFrame:");
late final _sel_bounds = objc.registerName("bounds");
late final _sel_setBounds_ = objc.registerName("setBounds:");
late final _sel_center = objc.registerName("center");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        objc.CGPoint Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCenter_ = objc.registerName("setCenter:");
late final _sel_transform = objc.registerName("transform");
final _objc_msgSend_5qswvj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGAffineTransform Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_5qswvjStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGAffineTransform>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGAffineTransform>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTransform_ = objc.registerName("setTransform:");
final _objc_msgSend_qgt66z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGAffineTransform)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGAffineTransform)>();
late final _sel_transform3D = objc.registerName("transform3D");
final _objc_msgSend_5qlg3j = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CATransform3D Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CATransform3D Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_5qlg3jStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CATransform3D>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CATransform3D>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTransform3D_ = objc.registerName("setTransform3D:");
final _objc_msgSend_1s50tpz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CATransform3D)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CATransform3D)>();
late final _sel_contentScaleFactor = objc.registerName("contentScaleFactor");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentScaleFactor_ =
    objc.registerName("setContentScaleFactor:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_anchorPoint = objc.registerName("anchorPoint");
late final _sel_setAnchorPoint_ = objc.registerName("setAnchorPoint:");
late final _sel_isMultipleTouchEnabled =
    objc.registerName("isMultipleTouchEnabled");
late final _sel_setMultipleTouchEnabled_ =
    objc.registerName("setMultipleTouchEnabled:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_isExclusiveTouch = objc.registerName("isExclusiveTouch");
late final _sel_setExclusiveTouch_ = objc.registerName("setExclusiveTouch:");
late final _sel_hitTest_withEvent_ = objc.registerName("hitTest:withEvent:");
final _objc_msgSend_u7nfz8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_pointInside_withEvent_ =
    objc.registerName("pointInside:withEvent:");
final _objc_msgSend_yvwe5y = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertPoint_toView_ =
    objc.registerName("convertPoint:toView:");
final _objc_msgSend_3l1tu1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGPoint Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGPoint Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_3l1tu1Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGPoint>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertPoint_fromView_ =
    objc.registerName("convertPoint:fromView:");
late final _sel_convertRect_toView_ = objc.registerName("convertRect:toView:");
final _objc_msgSend_2olghr = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGRect Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_2olghrStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertRect_fromView_ =
    objc.registerName("convertRect:fromView:");
late final _sel_autoresizesSubviews = objc.registerName("autoresizesSubviews");
late final _sel_setAutoresizesSubviews_ =
    objc.registerName("setAutoresizesSubviews:");

enum UIViewAutoresizing {
  UIViewAutoresizingNone(0),
  UIViewAutoresizingFlexibleLeftMargin(1),
  UIViewAutoresizingFlexibleWidth(2),
  UIViewAutoresizingFlexibleRightMargin(4),
  UIViewAutoresizingFlexibleTopMargin(8),
  UIViewAutoresizingFlexibleHeight(16),
  UIViewAutoresizingFlexibleBottomMargin(32);

  final int value;
  const UIViewAutoresizing(this.value);

  static UIViewAutoresizing fromValue(int value) => switch (value) {
        0 => UIViewAutoresizingNone,
        1 => UIViewAutoresizingFlexibleLeftMargin,
        2 => UIViewAutoresizingFlexibleWidth,
        4 => UIViewAutoresizingFlexibleRightMargin,
        8 => UIViewAutoresizingFlexibleTopMargin,
        16 => UIViewAutoresizingFlexibleHeight,
        32 => UIViewAutoresizingFlexibleBottomMargin,
        _ =>
          throw ArgumentError('Unknown value for UIViewAutoresizing: $value'),
      };
}

late final _sel_autoresizingMask = objc.registerName("autoresizingMask");
final _objc_msgSend_sq30wq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAutoresizingMask_ =
    objc.registerName("setAutoresizingMask:");
final _objc_msgSend_qjq6uk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_sizeThatFits_ = objc.registerName("sizeThatFits:");
final _objc_msgSend_1owrp3b = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>>()
    .asFunction<
        objc.CGSize Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>();
final _objc_msgSend_1owrp3bStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGSize)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>();
late final _sel_sizeToFit = objc.registerName("sizeToFit");

/// UIViewGeometry
extension UIViewGeometry on UIView {
  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_frame)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_frame);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// setFrame:
  set frame(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setFrame:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setFrame_, value);
  }

  /// bounds
  objc.CGRect get bounds {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_bounds)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_bounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// setBounds:
  set bounds(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setBounds:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setBounds_, value);
  }

  /// center
  objc.CGPoint get center {
    objc.checkOsVersionInternal('UIView.center', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(_ptr, this.ref.pointer, _sel_center)
        : _ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_center);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// setCenter:
  set center(objc.CGPoint value) {
    objc.checkOsVersionInternal('UIView.setCenter:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setCenter_, value);
  }

  /// transform
  CGAffineTransform get transform {
    objc.checkOsVersionInternal('UIView.transform', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret(_ptr, this.ref.pointer, _sel_transform)
        : _ptr.ref = _objc_msgSend_5qswvj(this.ref.pointer, _sel_transform);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGAffineTransform>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGAffineTransform>(_finalizable);
  }

  /// setTransform:
  set transform(CGAffineTransform value) {
    objc.checkOsVersionInternal('UIView.setTransform:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_qgt66z(this.ref.pointer, _sel_setTransform_, value);
  }

  /// transform3D
  CATransform3D get transform3D {
    objc.checkOsVersionInternal('UIView.transform3D', iOS: (false, (13, 0, 0)));
    final _ptr = pkg_ffi.calloc<CATransform3D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qlg3jStret(_ptr, this.ref.pointer, _sel_transform3D)
        : _ptr.ref = _objc_msgSend_5qlg3j(this.ref.pointer, _sel_transform3D);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CATransform3D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CATransform3D>(_finalizable);
  }

  /// setTransform3D:
  set transform3D(CATransform3D value) {
    objc.checkOsVersionInternal('UIView.setTransform3D:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s50tpz(this.ref.pointer, _sel_setTransform3D_, value);
  }

  /// contentScaleFactor
  double get contentScaleFactor {
    objc.checkOsVersionInternal('UIView.contentScaleFactor',
        iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_contentScaleFactor)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_contentScaleFactor);
  }

  /// setContentScaleFactor:
  set contentScaleFactor(double value) {
    objc.checkOsVersionInternal('UIView.setContentScaleFactor:',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setContentScaleFactor_, value);
  }

  /// anchorPoint
  objc.CGPoint get anchorPoint {
    objc.checkOsVersionInternal('UIView.anchorPoint', iOS: (false, (16, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(_ptr, this.ref.pointer, _sel_anchorPoint)
        : _ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_anchorPoint);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// setAnchorPoint:
  set anchorPoint(objc.CGPoint value) {
    objc.checkOsVersionInternal('UIView.setAnchorPoint:',
        iOS: (false, (16, 0, 0)));
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setAnchorPoint_, value);
  }

  /// isMultipleTouchEnabled
  bool get multipleTouchEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isMultipleTouchEnabled);
  }

  /// setMultipleTouchEnabled:
  set multipleTouchEnabled(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setMultipleTouchEnabled_, value);
  }

  /// isExclusiveTouch
  bool get exclusiveTouch {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isExclusiveTouch);
  }

  /// setExclusiveTouch:
  set exclusiveTouch(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setExclusiveTouch_, value);
  }

  /// hitTest:withEvent:
  UIView? hitTest(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIView.hitTest:withEvent:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_u7nfz8(this.ref.pointer, _sel_hitTest_withEvent_,
        point, withEvent?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// pointInside:withEvent:
  bool pointInside(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIView.pointInside:withEvent:',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_yvwe5y(this.ref.pointer, _sel_pointInside_withEvent_,
        point, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// convertPoint:toView:
  objc.CGPoint convertPoint(objc.CGPoint point, {UIView? toView}) {
    objc.checkOsVersionInternal('UIView.convertPoint:toView:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertPoint:fromView:
  objc.CGPoint convertPoint$1(objc.CGPoint point, {UIView? fromView}) {
    objc.checkOsVersionInternal('UIView.convertPoint:fromView:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertRect:toView:
  objc.CGRect convertRect(objc.CGRect rect, {UIView? toView}) {
    objc.checkOsVersionInternal('UIView.convertRect:toView:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(_ptr, this.ref.pointer,
            _sel_convertRect_toView_, rect, toView?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_2olghr(this.ref.pointer,
            _sel_convertRect_toView_, rect, toView?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// convertRect:fromView:
  objc.CGRect convertRect$1(objc.CGRect rect, {UIView? fromView}) {
    objc.checkOsVersionInternal('UIView.convertRect:fromView:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// autoresizesSubviews
  bool get autoresizesSubviews {
    objc.checkOsVersionInternal('UIView.autoresizesSubviews',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_autoresizesSubviews);
  }

  /// setAutoresizesSubviews:
  set autoresizesSubviews(bool value) {
    objc.checkOsVersionInternal('UIView.setAutoresizesSubviews:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAutoresizesSubviews_, value);
  }

  /// autoresizingMask
  UIViewAutoresizing get autoresizingMask {
    objc.checkOsVersionInternal('UIView.autoresizingMask',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_sq30wq(this.ref.pointer, _sel_autoresizingMask);
    return UIViewAutoresizing.fromValue(_ret);
  }

  /// setAutoresizingMask:
  set autoresizingMask(UIViewAutoresizing value) {
    objc.checkOsVersionInternal('UIView.setAutoresizingMask:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_qjq6uk(
        this.ref.pointer, _sel_setAutoresizingMask_, value.value);
  }

  /// sizeThatFits:
  objc.CGSize sizeThatFits(objc.CGSize size) {
    objc.checkOsVersionInternal('UIView.sizeThatFits:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            _ptr, this.ref.pointer, _sel_sizeThatFits_, size)
        : _ptr.ref =
            _objc_msgSend_1owrp3b(this.ref.pointer, _sel_sizeThatFits_, size);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// sizeToFit
  void sizeToFit() {
    objc.checkOsVersionInternal('UIView.sizeToFit', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_sizeToFit);
  }
}

late final _sel_superview = objc.registerName("superview");
late final _sel_subviews = objc.registerName("subviews");

/// WARNING: UIWindow is a stub. To generate bindings for this class, include
/// UIWindow in your config's objc-interfaces list.
///
/// UIWindow
class UIWindow extends UIView {
  UIWindow._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIWindow', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIWindow] that points to the same underlying object as [other].
  UIWindow.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIWindow] that wraps the given raw object pointer.
  UIWindow.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_window = objc.registerName("window");
late final _sel_removeFromSuperview = objc.registerName("removeFromSuperview");
late final _sel_insertSubview_atIndex_ =
    objc.registerName("insertSubview:atIndex:");
final _objc_msgSend_1nvl641 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_exchangeSubviewAtIndex_withSubviewAtIndex_ =
    objc.registerName("exchangeSubviewAtIndex:withSubviewAtIndex:");
final _objc_msgSend_1w5k0al = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_addSubview_ = objc.registerName("addSubview:");
late final _sel_insertSubview_belowSubview_ =
    objc.registerName("insertSubview:belowSubview:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_insertSubview_aboveSubview_ =
    objc.registerName("insertSubview:aboveSubview:");
late final _sel_bringSubviewToFront_ =
    objc.registerName("bringSubviewToFront:");
late final _sel_sendSubviewToBack_ = objc.registerName("sendSubviewToBack:");
late final _sel_didAddSubview_ = objc.registerName("didAddSubview:");
late final _sel_willRemoveSubview_ = objc.registerName("willRemoveSubview:");
late final _sel_willMoveToSuperview_ =
    objc.registerName("willMoveToSuperview:");
late final _sel_didMoveToSuperview = objc.registerName("didMoveToSuperview");
late final _sel_willMoveToWindow_ = objc.registerName("willMoveToWindow:");
late final _sel_didMoveToWindow = objc.registerName("didMoveToWindow");
late final _sel_isDescendantOfView_ = objc.registerName("isDescendantOfView:");
late final _sel_viewWithTag_ = objc.registerName("viewWithTag:");
late final _sel_setNeedsLayout = objc.registerName("setNeedsLayout");
late final _sel_layoutIfNeeded = objc.registerName("layoutIfNeeded");
late final _sel_layoutSubviews = objc.registerName("layoutSubviews");
late final _sel_layoutMargins = objc.registerName("layoutMargins");
final _objc_msgSend_ct4cu5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            UIEdgeInsets Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        UIEdgeInsets Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_ct4cu5Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<UIEdgeInsets>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<UIEdgeInsets>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLayoutMargins_ = objc.registerName("setLayoutMargins:");
final _objc_msgSend_1g8fos5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, UIEdgeInsets)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, UIEdgeInsets)>();
late final _sel_directionalLayoutMargins =
    objc.registerName("directionalLayoutMargins");
final _objc_msgSend_12yjd2m = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        NSDirectionalEdgeInsets Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_12yjd2mStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<NSDirectionalEdgeInsets>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<NSDirectionalEdgeInsets>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setDirectionalLayoutMargins_ =
    objc.registerName("setDirectionalLayoutMargins:");
final _objc_msgSend_s0isf8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSDirectionalEdgeInsets)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, NSDirectionalEdgeInsets)>();
late final _sel_preservesSuperviewLayoutMargins =
    objc.registerName("preservesSuperviewLayoutMargins");
late final _sel_setPreservesSuperviewLayoutMargins_ =
    objc.registerName("setPreservesSuperviewLayoutMargins:");
late final _sel_insetsLayoutMarginsFromSafeArea =
    objc.registerName("insetsLayoutMarginsFromSafeArea");
late final _sel_setInsetsLayoutMarginsFromSafeArea_ =
    objc.registerName("setInsetsLayoutMarginsFromSafeArea:");
late final _sel_layoutMarginsDidChange =
    objc.registerName("layoutMarginsDidChange");
late final _sel_safeAreaInsets = objc.registerName("safeAreaInsets");
late final _sel_safeAreaInsetsDidChange =
    objc.registerName("safeAreaInsetsDidChange");

/// WARNING: UILayoutGuide is a stub. To generate bindings for this class, include
/// UILayoutGuide in your config's objc-interfaces list.
///
/// UILayoutGuide
class UILayoutGuide extends objc.NSObject implements objc.NSCoding {
  UILayoutGuide._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UILayoutGuide] that points to the same underlying object as [other].
  UILayoutGuide.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILayoutGuide] that wraps the given raw object pointer.
  UILayoutGuide.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_layoutMarginsGuide = objc.registerName("layoutMarginsGuide");
late final _sel_readableContentGuide =
    objc.registerName("readableContentGuide");
late final _sel_safeAreaLayoutGuide = objc.registerName("safeAreaLayoutGuide");

/// WARNING: UIKeyboardLayoutGuide is a stub. To generate bindings for this class, include
/// UIKeyboardLayoutGuide in your config's objc-interfaces list.
///
/// UIKeyboardLayoutGuide
class UIKeyboardLayoutGuide extends UITrackingLayoutGuide {
  UIKeyboardLayoutGuide._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIKeyboardLayoutGuide',
        iOS: (false, (15, 0, 0)));
  }

  /// Constructs a [UIKeyboardLayoutGuide] that points to the same underlying object as [other].
  UIKeyboardLayoutGuide.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIKeyboardLayoutGuide] that wraps the given raw object pointer.
  UIKeyboardLayoutGuide.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_keyboardLayoutGuide = objc.registerName("keyboardLayoutGuide");

/// UIViewHierarchy
extension UIViewHierarchy on UIView {
  /// superview
  UIView? get superview {
    objc.checkOsVersionInternal('UIView.superview', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_superview);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// subviews
  objc.NSArray get subviews {
    objc.checkOsVersionInternal('UIView.subviews', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subviews);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// window
  UIWindow? get window {
    objc.checkOsVersionInternal('UIView.window', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_window);
    return _ret.address == 0
        ? null
        : UIWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// removeFromSuperview
  void removeFromSuperview() {
    objc.checkOsVersionInternal('UIView.removeFromSuperview',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeFromSuperview);
  }

  /// insertSubview:atIndex:
  void insertSubview(UIView view, {required int atIndex}) {
    objc.checkOsVersionInternal('UIView.insertSubview:atIndex:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1nvl641(this.ref.pointer, _sel_insertSubview_atIndex_,
        view.ref.pointer, atIndex);
  }

  /// exchangeSubviewAtIndex:withSubviewAtIndex:
  void exchangeSubviewAtIndex(int index1, {required int withSubviewAtIndex}) {
    objc.checkOsVersionInternal(
        'UIView.exchangeSubviewAtIndex:withSubviewAtIndex:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1w5k0al(
        this.ref.pointer,
        _sel_exchangeSubviewAtIndex_withSubviewAtIndex_,
        index1,
        withSubviewAtIndex);
  }

  /// addSubview:
  void addSubview(UIView view) {
    objc.checkOsVersionInternal('UIView.addSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addSubview_, view.ref.pointer);
  }

  /// insertSubview:belowSubview:
  void insertSubview$1(UIView view, {required UIView belowSubview}) {
    objc.checkOsVersionInternal('UIView.insertSubview:belowSubview:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_insertSubview_belowSubview_,
        view.ref.pointer, belowSubview.ref.pointer);
  }

  /// insertSubview:aboveSubview:
  void insertSubview$2(UIView view, {required UIView aboveSubview}) {
    objc.checkOsVersionInternal('UIView.insertSubview:aboveSubview:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_insertSubview_aboveSubview_,
        view.ref.pointer, aboveSubview.ref.pointer);
  }

  /// bringSubviewToFront:
  void bringSubviewToFront(UIView view) {
    objc.checkOsVersionInternal('UIView.bringSubviewToFront:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_bringSubviewToFront_, view.ref.pointer);
  }

  /// sendSubviewToBack:
  void sendSubviewToBack(UIView view) {
    objc.checkOsVersionInternal('UIView.sendSubviewToBack:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_sendSubviewToBack_, view.ref.pointer);
  }

  /// didAddSubview:
  void didAddSubview(UIView subview) {
    objc.checkOsVersionInternal('UIView.didAddSubview:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_didAddSubview_, subview.ref.pointer);
  }

  /// willRemoveSubview:
  void willRemoveSubview(UIView subview) {
    objc.checkOsVersionInternal('UIView.willRemoveSubview:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_willRemoveSubview_, subview.ref.pointer);
  }

  /// willMoveToSuperview:
  void willMoveToSuperview(UIView? newSuperview) {
    objc.checkOsVersionInternal('UIView.willMoveToSuperview:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willMoveToSuperview_,
        newSuperview?.ref.pointer ?? ffi.nullptr);
  }

  /// didMoveToSuperview
  void didMoveToSuperview() {
    objc.checkOsVersionInternal('UIView.didMoveToSuperview',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_didMoveToSuperview);
  }

  /// willMoveToWindow:
  void willMoveToWindow(UIWindow? newWindow) {
    objc.checkOsVersionInternal('UIView.willMoveToWindow:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willMoveToWindow_,
        newWindow?.ref.pointer ?? ffi.nullptr);
  }

  /// didMoveToWindow
  void didMoveToWindow() {
    objc.checkOsVersionInternal('UIView.didMoveToWindow',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_didMoveToWindow);
  }

  /// isDescendantOfView:
  bool isDescendantOfView(UIView view) {
    objc.checkOsVersionInternal('UIView.isDescendantOfView:',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isDescendantOfView_, view.ref.pointer);
  }

  /// viewWithTag:
  UIView? viewWithTag(int tag) {
    objc.checkOsVersionInternal('UIView.viewWithTag:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_qugqlf(this.ref.pointer, _sel_viewWithTag_, tag);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setNeedsLayout
  void setNeedsLayout() {
    objc.checkOsVersionInternal('UIView.setNeedsLayout',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsLayout);
  }

  /// layoutIfNeeded
  void layoutIfNeeded() {
    objc.checkOsVersionInternal('UIView.layoutIfNeeded',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutIfNeeded);
  }

  /// layoutSubviews
  void layoutSubviews() {
    objc.checkOsVersionInternal('UIView.layoutSubviews',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutSubviews);
  }

  /// layoutMargins
  UIEdgeInsets get layoutMargins {
    objc.checkOsVersionInternal('UIView.layoutMargins',
        iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_layoutMargins)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_layoutMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setLayoutMargins:
  set layoutMargins(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIView.setLayoutMargins:',
        iOS: (false, (8, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setLayoutMargins_, value);
  }

  /// directionalLayoutMargins
  NSDirectionalEdgeInsets get directionalLayoutMargins {
    objc.checkOsVersionInternal('UIView.directionalLayoutMargins',
        iOS: (false, (11, 0, 0)));
    final _ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_12yjd2mStret(
            _ptr, this.ref.pointer, _sel_directionalLayoutMargins)
        : _ptr.ref = _objc_msgSend_12yjd2m(
            this.ref.pointer, _sel_directionalLayoutMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSDirectionalEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSDirectionalEdgeInsets>(_finalizable);
  }

  /// setDirectionalLayoutMargins:
  set directionalLayoutMargins(NSDirectionalEdgeInsets value) {
    objc.checkOsVersionInternal('UIView.setDirectionalLayoutMargins:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_s0isf8(
        this.ref.pointer, _sel_setDirectionalLayoutMargins_, value);
  }

  /// preservesSuperviewLayoutMargins
  bool get preservesSuperviewLayoutMargins {
    objc.checkOsVersionInternal('UIView.preservesSuperviewLayoutMargins',
        iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_preservesSuperviewLayoutMargins);
  }

  /// setPreservesSuperviewLayoutMargins:
  set preservesSuperviewLayoutMargins(bool value) {
    objc.checkOsVersionInternal('UIView.setPreservesSuperviewLayoutMargins:',
        iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPreservesSuperviewLayoutMargins_, value);
  }

  /// insetsLayoutMarginsFromSafeArea
  bool get insetsLayoutMarginsFromSafeArea {
    objc.checkOsVersionInternal('UIView.insetsLayoutMarginsFromSafeArea',
        iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_insetsLayoutMarginsFromSafeArea);
  }

  /// setInsetsLayoutMarginsFromSafeArea:
  set insetsLayoutMarginsFromSafeArea(bool value) {
    objc.checkOsVersionInternal('UIView.setInsetsLayoutMarginsFromSafeArea:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setInsetsLayoutMarginsFromSafeArea_, value);
  }

  /// layoutMarginsDidChange
  void layoutMarginsDidChange() {
    objc.checkOsVersionInternal('UIView.layoutMarginsDidChange',
        iOS: (false, (8, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutMarginsDidChange);
  }

  /// safeAreaInsets
  UIEdgeInsets get safeAreaInsets {
    objc.checkOsVersionInternal('UIView.safeAreaInsets',
        iOS: (false, (11, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_safeAreaInsets)
        : _ptr.ref =
            _objc_msgSend_ct4cu5(this.ref.pointer, _sel_safeAreaInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// safeAreaInsetsDidChange
  void safeAreaInsetsDidChange() {
    objc.checkOsVersionInternal('UIView.safeAreaInsetsDidChange',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_safeAreaInsetsDidChange);
  }

  /// layoutMarginsGuide
  UILayoutGuide get layoutMarginsGuide {
    objc.checkOsVersionInternal('UIView.layoutMarginsGuide',
        iOS: (false, (9, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_layoutMarginsGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// readableContentGuide
  UILayoutGuide get readableContentGuide {
    objc.checkOsVersionInternal('UIView.readableContentGuide',
        iOS: (false, (9, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_readableContentGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// safeAreaLayoutGuide
  UILayoutGuide get safeAreaLayoutGuide {
    objc.checkOsVersionInternal('UIView.safeAreaLayoutGuide',
        iOS: (false, (11, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_safeAreaLayoutGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// keyboardLayoutGuide
  UIKeyboardLayoutGuide get keyboardLayoutGuide {
    objc.checkOsVersionInternal('UIView.keyboardLayoutGuide',
        iOS: (false, (15, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_keyboardLayoutGuide);
    return UIKeyboardLayoutGuide.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_drawRect_ = objc.registerName("drawRect:");
late final _sel_setNeedsDisplay = objc.registerName("setNeedsDisplay");
late final _sel_setNeedsDisplayInRect_ =
    objc.registerName("setNeedsDisplayInRect:");
late final _sel_clipsToBounds = objc.registerName("clipsToBounds");
late final _sel_setClipsToBounds_ = objc.registerName("setClipsToBounds:");
late final _sel_backgroundColor = objc.registerName("backgroundColor");
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
late final _sel_alpha = objc.registerName("alpha");
late final _sel_setAlpha_ = objc.registerName("setAlpha:");
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_setOpaque_ = objc.registerName("setOpaque:");
late final _sel_clearsContextBeforeDrawing =
    objc.registerName("clearsContextBeforeDrawing");
late final _sel_setClearsContextBeforeDrawing_ =
    objc.registerName("setClearsContextBeforeDrawing:");
late final _sel_isHidden = objc.registerName("isHidden");
late final _sel_setHidden_ = objc.registerName("setHidden:");

enum UIViewContentMode {
  UIViewContentModeScaleToFill(0),
  UIViewContentModeScaleAspectFit(1),
  UIViewContentModeScaleAspectFill(2),
  UIViewContentModeRedraw(3),
  UIViewContentModeCenter(4),
  UIViewContentModeTop(5),
  UIViewContentModeBottom(6),
  UIViewContentModeLeft(7),
  UIViewContentModeRight(8),
  UIViewContentModeTopLeft(9),
  UIViewContentModeTopRight(10),
  UIViewContentModeBottomLeft(11),
  UIViewContentModeBottomRight(12);

  final int value;
  const UIViewContentMode(this.value);

  static UIViewContentMode fromValue(int value) => switch (value) {
        0 => UIViewContentModeScaleToFill,
        1 => UIViewContentModeScaleAspectFit,
        2 => UIViewContentModeScaleAspectFill,
        3 => UIViewContentModeRedraw,
        4 => UIViewContentModeCenter,
        5 => UIViewContentModeTop,
        6 => UIViewContentModeBottom,
        7 => UIViewContentModeLeft,
        8 => UIViewContentModeRight,
        9 => UIViewContentModeTopLeft,
        10 => UIViewContentModeTopRight,
        11 => UIViewContentModeBottomLeft,
        12 => UIViewContentModeBottomRight,
        _ => throw ArgumentError('Unknown value for UIViewContentMode: $value'),
      };
}

late final _sel_contentMode = objc.registerName("contentMode");
final _objc_msgSend_12r2l30 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentMode_ = objc.registerName("setContentMode:");
final _objc_msgSend_26z7iq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_contentStretch = objc.registerName("contentStretch");
late final _sel_setContentStretch_ = objc.registerName("setContentStretch:");
late final _sel_maskView = objc.registerName("maskView");
late final _sel_setMaskView_ = objc.registerName("setMaskView:");
late final _sel_tintColor = objc.registerName("tintColor");
late final _sel_setTintColor_ = objc.registerName("setTintColor:");

enum UIViewTintAdjustmentMode {
  UIViewTintAdjustmentModeAutomatic(0),
  UIViewTintAdjustmentModeNormal(1),
  UIViewTintAdjustmentModeDimmed(2);

  final int value;
  const UIViewTintAdjustmentMode(this.value);

  static UIViewTintAdjustmentMode fromValue(int value) => switch (value) {
        0 => UIViewTintAdjustmentModeAutomatic,
        1 => UIViewTintAdjustmentModeNormal,
        2 => UIViewTintAdjustmentModeDimmed,
        _ => throw ArgumentError(
            'Unknown value for UIViewTintAdjustmentMode: $value'),
      };
}

late final _sel_tintAdjustmentMode = objc.registerName("tintAdjustmentMode");
final _objc_msgSend_1tlsbkb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTintAdjustmentMode_ =
    objc.registerName("setTintAdjustmentMode:");
final _objc_msgSend_15t6owj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_tintColorDidChange = objc.registerName("tintColorDidChange");

/// UIViewRendering
extension UIViewRendering on UIView {
  /// drawRect:
  void drawRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.drawRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_drawRect_, rect);
  }

  /// setNeedsDisplay
  void setNeedsDisplay() {
    objc.checkOsVersionInternal('UIView.setNeedsDisplay',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsDisplay);
  }

  /// setNeedsDisplayInRect:
  void setNeedsDisplayInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.setNeedsDisplayInRect:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setNeedsDisplayInRect_, rect);
  }

  /// clipsToBounds
  bool get clipsToBounds {
    objc.checkOsVersionInternal('UIView.clipsToBounds',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_clipsToBounds);
  }

  /// setClipsToBounds:
  set clipsToBounds(bool value) {
    objc.checkOsVersionInternal('UIView.setClipsToBounds:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setClipsToBounds_, value);
  }

  /// backgroundColor
  UIColor? get backgroundColor {
    objc.checkOsVersionInternal('UIView.backgroundColor',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundColor);
    return _ret.address == 0
        ? null
        : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackgroundColor:
  set backgroundColor(UIColor? value) {
    objc.checkOsVersionInternal('UIView.setBackgroundColor:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundColor_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// alpha
  double get alpha {
    objc.checkOsVersionInternal('UIView.alpha', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_alpha)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_alpha);
  }

  /// setAlpha:
  set alpha(double value) {
    objc.checkOsVersionInternal('UIView.setAlpha:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setAlpha_, value);
  }

  /// isOpaque
  bool get opaque {
    objc.checkOsVersionInternal('UIView.isOpaque', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isOpaque);
  }

  /// setOpaque:
  set opaque(bool value) {
    objc.checkOsVersionInternal('UIView.setOpaque:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setOpaque_, value);
  }

  /// clearsContextBeforeDrawing
  bool get clearsContextBeforeDrawing {
    objc.checkOsVersionInternal('UIView.clearsContextBeforeDrawing',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_clearsContextBeforeDrawing);
  }

  /// setClearsContextBeforeDrawing:
  set clearsContextBeforeDrawing(bool value) {
    objc.checkOsVersionInternal('UIView.setClearsContextBeforeDrawing:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setClearsContextBeforeDrawing_, value);
  }

  /// isHidden
  bool get hidden {
    objc.checkOsVersionInternal('UIView.isHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHidden);
  }

  /// setHidden:
  set hidden(bool value) {
    objc.checkOsVersionInternal('UIView.setHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidden_, value);
  }

  /// contentMode
  UIViewContentMode get contentMode {
    objc.checkOsVersionInternal('UIView.contentMode', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_12r2l30(this.ref.pointer, _sel_contentMode);
    return UIViewContentMode.fromValue(_ret);
  }

  /// setContentMode:
  set contentMode(UIViewContentMode value) {
    objc.checkOsVersionInternal('UIView.setContentMode:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_26z7iq(this.ref.pointer, _sel_setContentMode_, value.value);
  }

  /// contentStretch
  objc.CGRect get contentStretch {
    objc.checkOsVersionInternal('UIView.contentStretch',
        iOS: (false, (3, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_contentStretch)
        : _ptr.ref =
            _objc_msgSend_bu1hbw(this.ref.pointer, _sel_contentStretch);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// setContentStretch:
  set contentStretch(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setContentStretch:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setContentStretch_, value);
  }

  /// maskView
  UIView? get maskView {
    objc.checkOsVersionInternal('UIView.maskView', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_maskView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMaskView:
  set maskView(UIView? value) {
    objc.checkOsVersionInternal('UIView.setMaskView:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setMaskView_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// tintColor
  UIColor get tintColor {
    objc.checkOsVersionInternal('UIView.tintColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tintColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTintColor:
  set tintColor(UIColor value) {
    objc.checkOsVersionInternal('UIView.setTintColor:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTintColor_, value.ref.pointer);
  }

  /// tintAdjustmentMode
  UIViewTintAdjustmentMode get tintAdjustmentMode {
    objc.checkOsVersionInternal('UIView.tintAdjustmentMode',
        iOS: (false, (7, 0, 0)));
    final _ret =
        _objc_msgSend_1tlsbkb(this.ref.pointer, _sel_tintAdjustmentMode);
    return UIViewTintAdjustmentMode.fromValue(_ret);
  }

  /// setTintAdjustmentMode:
  set tintAdjustmentMode(UIViewTintAdjustmentMode value) {
    objc.checkOsVersionInternal('UIView.setTintAdjustmentMode:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_15t6owj(
        this.ref.pointer, _sel_setTintAdjustmentMode_, value.value);
  }

  /// tintColorDidChange
  void tintColorDidChange() {
    objc.checkOsVersionInternal('UIView.tintColorDidChange',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_tintColorDidChange);
  }
}

late final _sel_setAnimationsEnabled_ =
    objc.registerName("setAnimationsEnabled:");
late final _sel_areAnimationsEnabled =
    objc.registerName("areAnimationsEnabled");
late final _sel_performWithoutAnimation_ =
    objc.registerName("performWithoutAnimation:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_inheritedAnimationDuration =
    objc.registerName("inheritedAnimationDuration");

/// UIViewAnimation
extension UIViewAnimation on UIView {
  /// setAnimationsEnabled:
  static void setAnimationsEnabled(bool enabled) {
    objc.checkOsVersionInternal('UIView.setAnimationsEnabled:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationsEnabled_, enabled);
  }

  /// areAnimationsEnabled
  static bool getAreAnimationsEnabled() {
    objc.checkOsVersionInternal('UIView.areAnimationsEnabled',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(_class_UIView, _sel_areAnimationsEnabled);
  }

  /// performWithoutAnimation:
  static void performWithoutAnimation(
      objc.ObjCBlock<ffi.Void Function()> actionsWithoutAnimation) {
    objc.checkOsVersionInternal('UIView.performWithoutAnimation:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_f167m6(_class_UIView, _sel_performWithoutAnimation_,
        actionsWithoutAnimation.ref.pointer);
  }

  /// inheritedAnimationDuration
  static double getInheritedAnimationDuration() {
    objc.checkOsVersionInternal('UIView.inheritedAnimationDuration',
        iOS: (false, (9, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            _class_UIView, _sel_inheritedAnimationDuration)
        : _objc_msgSend_1ukqyt8(_class_UIView, _sel_inheritedAnimationDuration);
  }
}

enum UIViewAnimationOptions {
  UIViewAnimationOptionLayoutSubviews(1),
  UIViewAnimationOptionAllowUserInteraction(2),
  UIViewAnimationOptionBeginFromCurrentState(4),
  UIViewAnimationOptionRepeat(8),
  UIViewAnimationOptionAutoreverse(16),
  UIViewAnimationOptionOverrideInheritedDuration(32),
  UIViewAnimationOptionOverrideInheritedCurve(64),
  UIViewAnimationOptionAllowAnimatedContent(128),
  UIViewAnimationOptionShowHideTransitionViews(256),
  UIViewAnimationOptionOverrideInheritedOptions(512),
  UIViewAnimationOptionCurveEaseInOut(0),
  UIViewAnimationOptionCurveEaseIn(65536),
  UIViewAnimationOptionCurveEaseOut(131072),
  UIViewAnimationOptionCurveLinear(196608),
  UIViewAnimationOptionTransitionFlipFromLeft(1048576),
  UIViewAnimationOptionTransitionFlipFromRight(2097152),
  UIViewAnimationOptionTransitionCurlUp(3145728),
  UIViewAnimationOptionTransitionCurlDown(4194304),
  UIViewAnimationOptionTransitionCrossDissolve(5242880),
  UIViewAnimationOptionTransitionFlipFromTop(6291456),
  UIViewAnimationOptionTransitionFlipFromBottom(7340032),
  UIViewAnimationOptionPreferredFramesPerSecond60(50331648),
  UIViewAnimationOptionPreferredFramesPerSecond30(117440512);

  static const UIViewAnimationOptionTransitionNone =
      UIViewAnimationOptionCurveEaseInOut;
  static const UIViewAnimationOptionPreferredFramesPerSecondDefault =
      UIViewAnimationOptionCurveEaseInOut;

  final int value;
  const UIViewAnimationOptions(this.value);

  static UIViewAnimationOptions fromValue(int value) => switch (value) {
        1 => UIViewAnimationOptionLayoutSubviews,
        2 => UIViewAnimationOptionAllowUserInteraction,
        4 => UIViewAnimationOptionBeginFromCurrentState,
        8 => UIViewAnimationOptionRepeat,
        16 => UIViewAnimationOptionAutoreverse,
        32 => UIViewAnimationOptionOverrideInheritedDuration,
        64 => UIViewAnimationOptionOverrideInheritedCurve,
        128 => UIViewAnimationOptionAllowAnimatedContent,
        256 => UIViewAnimationOptionShowHideTransitionViews,
        512 => UIViewAnimationOptionOverrideInheritedOptions,
        0 => UIViewAnimationOptionCurveEaseInOut,
        65536 => UIViewAnimationOptionCurveEaseIn,
        131072 => UIViewAnimationOptionCurveEaseOut,
        196608 => UIViewAnimationOptionCurveLinear,
        1048576 => UIViewAnimationOptionTransitionFlipFromLeft,
        2097152 => UIViewAnimationOptionTransitionFlipFromRight,
        3145728 => UIViewAnimationOptionTransitionCurlUp,
        4194304 => UIViewAnimationOptionTransitionCurlDown,
        5242880 => UIViewAnimationOptionTransitionCrossDissolve,
        6291456 => UIViewAnimationOptionTransitionFlipFromTop,
        7340032 => UIViewAnimationOptionTransitionFlipFromBottom,
        50331648 => UIViewAnimationOptionPreferredFramesPerSecond60,
        117440512 => UIViewAnimationOptionPreferredFramesPerSecond30,
        _ => throw ArgumentError(
            'Unknown value for UIViewAnimationOptions: $value'),
      };

  @override
  String toString() {
    if (this == UIViewAnimationOptionCurveEaseInOut)
      return "UIViewAnimationOptions.UIViewAnimationOptionCurveEaseInOut, UIViewAnimationOptions.UIViewAnimationOptionTransitionNone, UIViewAnimationOptions.UIViewAnimationOptionPreferredFramesPerSecondDefault";
    return super.toString();
  }
}

void _ObjCBlock_ffiVoid_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
        .asFunction<void Function(bool)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Bool)>(_ObjCBlock_ffiVoid_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_bool_closureCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Bool)>(_ObjCBlock_ffiVoid_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) {
  (objc.getBlockClosure(block) as void Function(bool))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_listenerCallable = ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Bool)>.listener(_ObjCBlock_ffiVoid_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    bool arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_blockingCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool)>.isolateLocal(_ObjCBlock_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_blockingListenerCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool)>.listener(_ObjCBlock_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_bool_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(
          void Function(bool) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_bool_closureCallable,
              (bool arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(
      void Function(bool) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_listenerCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(
      void Function(bool) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_blockingCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_blockingListenerCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1s56lr9(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Bool arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool)>()(
      ref.pointer, arg0);
}

late final _sel_animateWithDuration_delay_options_animations_completion_ = objc
    .registerName("animateWithDuration:delay:options:animations:completion:");
final _objc_msgSend_1pforg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Double,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            double,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_animateWithDuration_animations_completion_ =
    objc.registerName("animateWithDuration:animations:completion:");
final _objc_msgSend_1isavsq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_animateWithDuration_animations_ =
    objc.registerName("animateWithDuration:animations:");
final _objc_msgSend_16dy26p = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion_ =
    objc.registerName(
        "animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:");
final _objc_msgSend_r4l13g = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Double,
                ffi.Double,
                ffi.Double,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            double,
            double,
            double,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_ =
    objc.registerName(
        "animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:");
late final _sel_transitionWithView_duration_options_animations_completion_ =
    objc.registerName(
        "transitionWithView:duration:options:animations:completion:");
final _objc_msgSend_q6v4dl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_transitionFromView_toView_duration_options_completion_ =
    objc.registerName("transitionFromView:toView:duration:options:completion:");
final _objc_msgSend_1eh0loo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

enum UISystemAnimation {
  UISystemAnimationDelete(0);

  final int value;
  const UISystemAnimation(this.value);

  static UISystemAnimation fromValue(int value) => switch (value) {
        0 => UISystemAnimationDelete,
        _ => throw ArgumentError('Unknown value for UISystemAnimation: $value'),
      };
}

late final _sel_performSystemAnimation_onViews_options_animations_completion_ =
    objc.registerName(
        "performSystemAnimation:onViews:options:animations:completion:");
final _objc_msgSend_fqrtz5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_ = objc
    .registerName("modifyAnimationsWithRepeatCount:autoreverses:animations:");
final _objc_msgSend_nxk2e9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// UIViewAnimationWithBlocks
extension UIViewAnimationWithBlocks on UIView {
  /// animateWithDuration:delay:options:animations:completion:
  static void animateWithDuration(double duration,
      {required double delay,
      required UIViewAnimationOptions options,
      required objc.ObjCBlock<ffi.Void Function()> animations,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
    objc.checkOsVersionInternal(
        'UIView.animateWithDuration:delay:options:animations:completion:',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pforg(
        _class_UIView,
        _sel_animateWithDuration_delay_options_animations_completion_,
        duration,
        delay,
        options.value,
        animations.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// animateWithDuration:animations:completion:
  static void animateWithDuration$1(double duration,
      {required objc.ObjCBlock<ffi.Void Function()> animations,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
    objc.checkOsVersionInternal(
        'UIView.animateWithDuration:animations:completion:',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_1isavsq(
        _class_UIView,
        _sel_animateWithDuration_animations_completion_,
        duration,
        animations.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// animateWithDuration:animations:
  static void animateWithDuration$2(double duration,
      {required objc.ObjCBlock<ffi.Void Function()> animations}) {
    objc.checkOsVersionInternal('UIView.animateWithDuration:animations:',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_16dy26p(_class_UIView, _sel_animateWithDuration_animations_,
        duration, animations.ref.pointer);
  }

  /// animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:
  static void animateWithSpringDuration(double duration,
      {required double bounce,
      required double initialSpringVelocity,
      required double delay,
      required UIViewAnimationOptions options,
      required objc.ObjCBlock<ffi.Void Function()> animations,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
    objc.checkOsVersionInternal(
        'UIView.animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_r4l13g(
        _class_UIView,
        _sel_animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion_,
        duration,
        bounce,
        initialSpringVelocity,
        delay,
        options.value,
        animations.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:
  static void animateWithDuration$3(double duration,
      {required double delay,
      required double usingSpringWithDamping,
      required double initialSpringVelocity,
      required UIViewAnimationOptions options,
      required objc.ObjCBlock<ffi.Void Function()> animations,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
    objc.checkOsVersionInternal(
        'UIView.animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_r4l13g(
        _class_UIView,
        _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_,
        duration,
        delay,
        usingSpringWithDamping,
        initialSpringVelocity,
        options.value,
        animations.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// transitionWithView:duration:options:animations:completion:
  static void transitionWithView(UIView view,
      {required double duration,
      required UIViewAnimationOptions options,
      objc.ObjCBlock<ffi.Void Function()>? animations,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
    objc.checkOsVersionInternal(
        'UIView.transitionWithView:duration:options:animations:completion:',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_q6v4dl(
        _class_UIView,
        _sel_transitionWithView_duration_options_animations_completion_,
        view.ref.pointer,
        duration,
        options.value,
        animations?.ref.pointer ?? ffi.nullptr,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// transitionFromView:toView:duration:options:completion:
  static void transitionFromView(UIView fromView,
      {required UIView toView,
      required double duration,
      required UIViewAnimationOptions options,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
    objc.checkOsVersionInternal(
        'UIView.transitionFromView:toView:duration:options:completion:',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_1eh0loo(
        _class_UIView,
        _sel_transitionFromView_toView_duration_options_completion_,
        fromView.ref.pointer,
        toView.ref.pointer,
        duration,
        options.value,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// performSystemAnimation:onViews:options:animations:completion:
  static void performSystemAnimation(UISystemAnimation animation,
      {required objc.NSArray onViews,
      required UIViewAnimationOptions options,
      objc.ObjCBlock<ffi.Void Function()>? animations,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
    objc.checkOsVersionInternal(
        'UIView.performSystemAnimation:onViews:options:animations:completion:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_fqrtz5(
        _class_UIView,
        _sel_performSystemAnimation_onViews_options_animations_completion_,
        animation.value,
        onViews.ref.pointer,
        options.value,
        animations?.ref.pointer ?? ffi.nullptr,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// modifyAnimationsWithRepeatCount:autoreverses:animations:
  static void modifyAnimationsWithRepeatCount(double count,
      {required bool autoreverses,
      required objc.ObjCBlock<ffi.Void Function()> animations}) {
    objc.checkOsVersionInternal(
        'UIView.modifyAnimationsWithRepeatCount:autoreverses:animations:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_nxk2e9(
        _class_UIView,
        _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_,
        count,
        autoreverses,
        animations.ref.pointer);
  }
}

enum UIViewKeyframeAnimationOptions {
  UIViewKeyframeAnimationOptionLayoutSubviews(1),
  UIViewKeyframeAnimationOptionAllowUserInteraction(2),
  UIViewKeyframeAnimationOptionBeginFromCurrentState(4),
  UIViewKeyframeAnimationOptionRepeat(8),
  UIViewKeyframeAnimationOptionAutoreverse(16),
  UIViewKeyframeAnimationOptionOverrideInheritedDuration(32),
  UIViewKeyframeAnimationOptionOverrideInheritedOptions(512),
  UIViewKeyframeAnimationOptionCalculationModeLinear(0),
  UIViewKeyframeAnimationOptionCalculationModeDiscrete(1024),
  UIViewKeyframeAnimationOptionCalculationModePaced(2048),
  UIViewKeyframeAnimationOptionCalculationModeCubic(3072),
  UIViewKeyframeAnimationOptionCalculationModeCubicPaced(4096);

  final int value;
  const UIViewKeyframeAnimationOptions(this.value);

  static UIViewKeyframeAnimationOptions fromValue(int value) => switch (value) {
        1 => UIViewKeyframeAnimationOptionLayoutSubviews,
        2 => UIViewKeyframeAnimationOptionAllowUserInteraction,
        4 => UIViewKeyframeAnimationOptionBeginFromCurrentState,
        8 => UIViewKeyframeAnimationOptionRepeat,
        16 => UIViewKeyframeAnimationOptionAutoreverse,
        32 => UIViewKeyframeAnimationOptionOverrideInheritedDuration,
        512 => UIViewKeyframeAnimationOptionOverrideInheritedOptions,
        0 => UIViewKeyframeAnimationOptionCalculationModeLinear,
        1024 => UIViewKeyframeAnimationOptionCalculationModeDiscrete,
        2048 => UIViewKeyframeAnimationOptionCalculationModePaced,
        3072 => UIViewKeyframeAnimationOptionCalculationModeCubic,
        4096 => UIViewKeyframeAnimationOptionCalculationModeCubicPaced,
        _ => throw ArgumentError(
            'Unknown value for UIViewKeyframeAnimationOptions: $value'),
      };
}

late final _sel_animateKeyframesWithDuration_delay_options_animations_completion_ =
    objc.registerName(
        "animateKeyframesWithDuration:delay:options:animations:completion:");
final _objc_msgSend_ciuhtc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Double,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            double,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_ =
    objc.registerName(
        "addKeyframeWithRelativeStartTime:relativeDuration:animations:");
final _objc_msgSend_6jt11a = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// UIViewKeyframeAnimations
extension UIViewKeyframeAnimations on UIView {
  /// animateKeyframesWithDuration:delay:options:animations:completion:
  static void animateKeyframesWithDuration(double duration,
      {required double delay,
      required UIViewKeyframeAnimationOptions options,
      required objc.ObjCBlock<ffi.Void Function()> animations,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
    objc.checkOsVersionInternal(
        'UIView.animateKeyframesWithDuration:delay:options:animations:completion:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_ciuhtc(
        _class_UIView,
        _sel_animateKeyframesWithDuration_delay_options_animations_completion_,
        duration,
        delay,
        options.value,
        animations.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// addKeyframeWithRelativeStartTime:relativeDuration:animations:
  static void addKeyframeWithRelativeStartTime(double frameStartTime,
      {required double relativeDuration,
      required objc.ObjCBlock<ffi.Void Function()> animations}) {
    objc.checkOsVersionInternal(
        'UIView.addKeyframeWithRelativeStartTime:relativeDuration:animations:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_6jt11a(
        _class_UIView,
        _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_,
        frameStartTime,
        relativeDuration,
        animations.ref.pointer);
  }
}

late final _sel_gestureRecognizers = objc.registerName("gestureRecognizers");
late final _sel_setGestureRecognizers_ =
    objc.registerName("setGestureRecognizers:");

/// WARNING: UIGestureRecognizer is a stub. To generate bindings for this class, include
/// UIGestureRecognizer in your config's objc-interfaces list.
///
/// UIGestureRecognizer
class UIGestureRecognizer extends objc.NSObject {
  UIGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIGestureRecognizer', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIGestureRecognizer] that points to the same underlying object as [other].
  UIGestureRecognizer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIGestureRecognizer] that wraps the given raw object pointer.
  UIGestureRecognizer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_addGestureRecognizer_ =
    objc.registerName("addGestureRecognizer:");
late final _sel_removeGestureRecognizer_ =
    objc.registerName("removeGestureRecognizer:");
late final _sel_gestureRecognizerShouldBegin_ =
    objc.registerName("gestureRecognizerShouldBegin:");

/// UIViewGestureRecognizers
extension UIViewGestureRecognizers on UIView {
  /// gestureRecognizers
  objc.NSArray? get gestureRecognizers {
    objc.checkOsVersionInternal('UIView.gestureRecognizers',
        iOS: (false, (3, 2, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_gestureRecognizers);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setGestureRecognizers:
  set gestureRecognizers(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIView.setGestureRecognizers:',
        iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setGestureRecognizers_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// addGestureRecognizer:
  void addGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.addGestureRecognizer:',
        iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addGestureRecognizer_,
        gestureRecognizer.ref.pointer);
  }

  /// removeGestureRecognizer:
  void removeGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.removeGestureRecognizer:',
        iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeGestureRecognizer_,
        gestureRecognizer.ref.pointer);
  }

  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.gestureRecognizerShouldBegin:',
        iOS: (false, (6, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer,
        _sel_gestureRecognizerShouldBegin_, gestureRecognizer.ref.pointer);
  }
}

/// WARNING: UIMotionEffect is a stub. To generate bindings for this class, include
/// UIMotionEffect in your config's objc-interfaces list.
///
/// UIMotionEffect
class UIMotionEffect extends objc.NSObject
    implements objc.NSCopying, objc.NSCoding {
  UIMotionEffect._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMotionEffect', iOS: (false, (7, 0, 0)));
  }

  /// Constructs a [UIMotionEffect] that points to the same underlying object as [other].
  UIMotionEffect.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMotionEffect] that wraps the given raw object pointer.
  UIMotionEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_addMotionEffect_ = objc.registerName("addMotionEffect:");
late final _sel_removeMotionEffect_ = objc.registerName("removeMotionEffect:");
late final _sel_motionEffects = objc.registerName("motionEffects");
late final _sel_setMotionEffects_ = objc.registerName("setMotionEffects:");

/// UIViewMotionEffects
extension UIViewMotionEffects on UIView {
  /// addMotionEffect:
  void addMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal('UIView.addMotionEffect:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addMotionEffect_, effect.ref.pointer);
  }

  /// removeMotionEffect:
  void removeMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal('UIView.removeMotionEffect:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeMotionEffect_, effect.ref.pointer);
  }

  /// motionEffects
  objc.NSArray get motionEffects {
    objc.checkOsVersionInternal('UIView.motionEffects',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_motionEffects);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMotionEffects:
  set motionEffects(objc.NSArray value) {
    objc.checkOsVersionInternal('UIView.setMotionEffects:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setMotionEffects_, value.ref.pointer);
  }
}

late final _sel_constraints = objc.registerName("constraints");

/// WARNING: NSLayoutConstraint is a stub. To generate bindings for this class, include
/// NSLayoutConstraint in your config's objc-interfaces list.
///
/// NSLayoutConstraint
class NSLayoutConstraint extends objc.NSObject {
  NSLayoutConstraint._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutConstraint',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [NSLayoutConstraint] that points to the same underlying object as [other].
  NSLayoutConstraint.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutConstraint] that wraps the given raw object pointer.
  NSLayoutConstraint.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_addConstraint_ = objc.registerName("addConstraint:");
late final _sel_addConstraints_ = objc.registerName("addConstraints:");
late final _sel_removeConstraint_ = objc.registerName("removeConstraint:");
late final _sel_removeConstraints_ = objc.registerName("removeConstraints:");

/// UIConstraintBasedLayoutInstallingConstraints
extension UIConstraintBasedLayoutInstallingConstraints on UIView {
  /// constraints
  objc.NSArray get constraints {
    objc.checkOsVersionInternal('UIView.constraints', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_constraints);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// addConstraint:
  void addConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal('UIView.addConstraint:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addConstraint_, constraint.ref.pointer);
  }

  /// addConstraints:
  void addConstraints(objc.NSArray constraints$1) {
    objc.checkOsVersionInternal('UIView.addConstraints:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addConstraints_, constraints$1.ref.pointer);
  }

  /// removeConstraint:
  void removeConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal('UIView.removeConstraint:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeConstraint_, constraint.ref.pointer);
  }

  /// removeConstraints:
  void removeConstraints(objc.NSArray constraints$1) {
    objc.checkOsVersionInternal('UIView.removeConstraints:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeConstraints_, constraints$1.ref.pointer);
  }
}

late final _sel_updateConstraintsIfNeeded =
    objc.registerName("updateConstraintsIfNeeded");
late final _sel_updateConstraints = objc.registerName("updateConstraints");
late final _sel_needsUpdateConstraints =
    objc.registerName("needsUpdateConstraints");
late final _sel_setNeedsUpdateConstraints =
    objc.registerName("setNeedsUpdateConstraints");

/// UIConstraintBasedLayoutCoreMethods
extension UIConstraintBasedLayoutCoreMethods on UIView {
  /// updateConstraintsIfNeeded
  void updateConstraintsIfNeeded() {
    objc.checkOsVersionInternal('UIView.updateConstraintsIfNeeded',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateConstraintsIfNeeded);
  }

  /// updateConstraints
  void updateConstraints() {
    objc.checkOsVersionInternal('UIView.updateConstraints',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateConstraints);
  }

  /// needsUpdateConstraints
  bool needsUpdateConstraints() {
    objc.checkOsVersionInternal('UIView.needsUpdateConstraints',
        iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_needsUpdateConstraints);
  }

  /// setNeedsUpdateConstraints
  void setNeedsUpdateConstraints() {
    objc.checkOsVersionInternal('UIView.setNeedsUpdateConstraints',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateConstraints);
  }
}

late final _sel_translatesAutoresizingMaskIntoConstraints =
    objc.registerName("translatesAutoresizingMaskIntoConstraints");
late final _sel_setTranslatesAutoresizingMaskIntoConstraints_ =
    objc.registerName("setTranslatesAutoresizingMaskIntoConstraints:");
late final _sel_requiresConstraintBasedLayout =
    objc.registerName("requiresConstraintBasedLayout");

/// UIConstraintBasedCompatibility
extension UIConstraintBasedCompatibility on UIView {
  /// translatesAutoresizingMaskIntoConstraints
  bool get translatesAutoresizingMaskIntoConstraints {
    objc.checkOsVersionInternal(
        'UIView.translatesAutoresizingMaskIntoConstraints',
        iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_translatesAutoresizingMaskIntoConstraints);
  }

  /// setTranslatesAutoresizingMaskIntoConstraints:
  set translatesAutoresizingMaskIntoConstraints(bool value) {
    objc.checkOsVersionInternal(
        'UIView.setTranslatesAutoresizingMaskIntoConstraints:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setTranslatesAutoresizingMaskIntoConstraints_, value);
  }

  /// requiresConstraintBasedLayout
  static bool getRequiresConstraintBasedLayout() {
    objc.checkOsVersionInternal('UIView.requiresConstraintBasedLayout',
        iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(
        _class_UIView, _sel_requiresConstraintBasedLayout);
  }
}

late final _sel_alignmentRectForFrame_ =
    objc.registerName("alignmentRectForFrame:");
final _objc_msgSend_1gn1s3d = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>>()
    .asFunction<
        objc.CGRect Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>();
final _objc_msgSend_1gn1s3dStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>();
late final _sel_frameForAlignmentRect_ =
    objc.registerName("frameForAlignmentRect:");
late final _sel_alignmentRectInsets = objc.registerName("alignmentRectInsets");
late final _sel_viewForBaselineLayout =
    objc.registerName("viewForBaselineLayout");
late final _sel_viewForFirstBaselineLayout =
    objc.registerName("viewForFirstBaselineLayout");
late final _sel_viewForLastBaselineLayout =
    objc.registerName("viewForLastBaselineLayout");
late final _sel_intrinsicContentSize =
    objc.registerName("intrinsicContentSize");
late final _sel_invalidateIntrinsicContentSize =
    objc.registerName("invalidateIntrinsicContentSize");

enum UILayoutConstraintAxis {
  UILayoutConstraintAxisHorizontal(0),
  UILayoutConstraintAxisVertical(1);

  final int value;
  const UILayoutConstraintAxis(this.value);

  static UILayoutConstraintAxis fromValue(int value) => switch (value) {
        0 => UILayoutConstraintAxisHorizontal,
        1 => UILayoutConstraintAxisVertical,
        _ => throw ArgumentError(
            'Unknown value for UILayoutConstraintAxis: $value'),
      };
}

late final _sel_contentHuggingPriorityForAxis_ =
    objc.registerName("contentHuggingPriorityForAxis:");
final _objc_msgSend_qigf85 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_qigf85Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setContentHuggingPriority_forAxis_ =
    objc.registerName("setContentHuggingPriority:forAxis:");
final _objc_msgSend_wd7esz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Float, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double, int)>();
late final _sel_contentCompressionResistancePriorityForAxis_ =
    objc.registerName("contentCompressionResistancePriorityForAxis:");
late final _sel_setContentCompressionResistancePriority_forAxis_ =
    objc.registerName("setContentCompressionResistancePriority:forAxis:");

/// UIConstraintBasedLayoutLayering
extension UIConstraintBasedLayoutLayering on UIView {
  /// alignmentRectForFrame:
  objc.CGRect alignmentRectForFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIView.alignmentRectForFrame:',
        iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            _ptr, this.ref.pointer, _sel_alignmentRectForFrame_, frame)
        : _ptr.ref = _objc_msgSend_1gn1s3d(
            this.ref.pointer, _sel_alignmentRectForFrame_, frame);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// frameForAlignmentRect:
  objc.CGRect frameForAlignmentRect(objc.CGRect alignmentRect) {
    objc.checkOsVersionInternal('UIView.frameForAlignmentRect:',
        iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            _ptr, this.ref.pointer, _sel_frameForAlignmentRect_, alignmentRect)
        : _ptr.ref = _objc_msgSend_1gn1s3d(
            this.ref.pointer, _sel_frameForAlignmentRect_, alignmentRect);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// alignmentRectInsets
  UIEdgeInsets get alignmentRectInsets {
    objc.checkOsVersionInternal('UIView.alignmentRectInsets',
        iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            _ptr, this.ref.pointer, _sel_alignmentRectInsets)
        : _ptr.ref =
            _objc_msgSend_ct4cu5(this.ref.pointer, _sel_alignmentRectInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// viewForBaselineLayout
  UIView viewForBaselineLayout() {
    objc.checkOsVersionInternal('UIView.viewForBaselineLayout',
        iOS: (false, (6, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_viewForBaselineLayout);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewForFirstBaselineLayout
  UIView get viewForFirstBaselineLayout {
    objc.checkOsVersionInternal('UIView.viewForFirstBaselineLayout',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_viewForFirstBaselineLayout);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewForLastBaselineLayout
  UIView get viewForLastBaselineLayout {
    objc.checkOsVersionInternal('UIView.viewForLastBaselineLayout',
        iOS: (false, (9, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_viewForLastBaselineLayout);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// intrinsicContentSize
  objc.CGSize get intrinsicContentSize {
    objc.checkOsVersionInternal('UIView.intrinsicContentSize',
        iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(
            _ptr, this.ref.pointer, _sel_intrinsicContentSize)
        : _ptr.ref =
            _objc_msgSend_1vdfken(this.ref.pointer, _sel_intrinsicContentSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// invalidateIntrinsicContentSize
  void invalidateIntrinsicContentSize() {
    objc.checkOsVersionInternal('UIView.invalidateIntrinsicContentSize',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_invalidateIntrinsicContentSize);
  }

  /// contentHuggingPriorityForAxis:
  double contentHuggingPriorityForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal('UIView.contentHuggingPriorityForAxis:',
        iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(
            this.ref.pointer, _sel_contentHuggingPriorityForAxis_, axis.value)
        : _objc_msgSend_qigf85(
            this.ref.pointer, _sel_contentHuggingPriorityForAxis_, axis.value);
  }

  /// setContentHuggingPriority:forAxis:
  void setContentHuggingPriority(double priority,
      {required UILayoutConstraintAxis forAxis}) {
    objc.checkOsVersionInternal('UIView.setContentHuggingPriority:forAxis:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_wd7esz(this.ref.pointer,
        _sel_setContentHuggingPriority_forAxis_, priority, forAxis.value);
  }

  /// contentCompressionResistancePriorityForAxis:
  double contentCompressionResistancePriorityForAxis(
      UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal(
        'UIView.contentCompressionResistancePriorityForAxis:',
        iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(this.ref.pointer,
            _sel_contentCompressionResistancePriorityForAxis_, axis.value)
        : _objc_msgSend_qigf85(this.ref.pointer,
            _sel_contentCompressionResistancePriorityForAxis_, axis.value);
  }

  /// setContentCompressionResistancePriority:forAxis:
  void setContentCompressionResistancePriority(double priority,
      {required UILayoutConstraintAxis forAxis}) {
    objc.checkOsVersionInternal(
        'UIView.setContentCompressionResistancePriority:forAxis:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_wd7esz(
        this.ref.pointer,
        _sel_setContentCompressionResistancePriority_forAxis_,
        priority,
        forAxis.value);
  }
}

late final _sel_systemLayoutSizeFittingSize_ =
    objc.registerName("systemLayoutSizeFittingSize:");
late final _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_ =
    objc.registerName(
        "systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:");
final _objc_msgSend_3fx2qn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGSize,
                ffi.Float,
                ffi.Float)>>()
    .asFunction<
        objc.CGSize Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGSize, double, double)>();
final _objc_msgSend_3fx2qnStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGSize,
                ffi.Float,
                ffi.Float)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGSize, double, double)>();

/// UIConstraintBasedLayoutFittingSize
extension UIConstraintBasedLayoutFittingSize on UIView {
  /// systemLayoutSizeFittingSize:
  objc.CGSize systemLayoutSizeFittingSize(objc.CGSize targetSize) {
    objc.checkOsVersionInternal('UIView.systemLayoutSizeFittingSize:',
        iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(_ptr, this.ref.pointer,
            _sel_systemLayoutSizeFittingSize_, targetSize)
        : _ptr.ref = _objc_msgSend_1owrp3b(
            this.ref.pointer, _sel_systemLayoutSizeFittingSize_, targetSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:
  objc.CGSize systemLayoutSizeFittingSize$1(objc.CGSize targetSize,
      {required double withHorizontalFittingPriority,
      required double verticalFittingPriority}) {
    objc.checkOsVersionInternal(
        'UIView.systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:',
        iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3fx2qnStret(
            _ptr,
            this.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority)
        : _ptr.ref = _objc_msgSend_3fx2qn(
            this.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }
}

late final _sel_layoutGuides = objc.registerName("layoutGuides");
late final _sel_addLayoutGuide_ = objc.registerName("addLayoutGuide:");
late final _sel_removeLayoutGuide_ = objc.registerName("removeLayoutGuide:");

/// UILayoutGuideSupport
extension UILayoutGuideSupport on UIView {
  /// layoutGuides
  objc.NSArray get layoutGuides {
    objc.checkOsVersionInternal('UIView.layoutGuides', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layoutGuides);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// addLayoutGuide:
  void addLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal('UIView.addLayoutGuide:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addLayoutGuide_, layoutGuide.ref.pointer);
  }

  /// removeLayoutGuide:
  void removeLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal('UIView.removeLayoutGuide:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeLayoutGuide_, layoutGuide.ref.pointer);
  }
}

/// WARNING: NSLayoutXAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutXAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutXAxisAnchor
class NSLayoutXAxisAnchor extends NSLayoutAnchor {
  NSLayoutXAxisAnchor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutXAxisAnchor',
        iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSLayoutXAxisAnchor] that points to the same underlying object as [other].
  NSLayoutXAxisAnchor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutXAxisAnchor] that wraps the given raw object pointer.
  NSLayoutXAxisAnchor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_leadingAnchor = objc.registerName("leadingAnchor");
late final _sel_trailingAnchor = objc.registerName("trailingAnchor");
late final _sel_leftAnchor = objc.registerName("leftAnchor");
late final _sel_rightAnchor = objc.registerName("rightAnchor");

/// WARNING: NSLayoutYAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutYAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutYAxisAnchor
class NSLayoutYAxisAnchor extends NSLayoutAnchor {
  NSLayoutYAxisAnchor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutYAxisAnchor',
        iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSLayoutYAxisAnchor] that points to the same underlying object as [other].
  NSLayoutYAxisAnchor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutYAxisAnchor] that wraps the given raw object pointer.
  NSLayoutYAxisAnchor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_topAnchor = objc.registerName("topAnchor");
late final _sel_bottomAnchor = objc.registerName("bottomAnchor");

/// WARNING: NSLayoutDimension is a stub. To generate bindings for this class, include
/// NSLayoutDimension in your config's objc-interfaces list.
///
/// NSLayoutDimension
class NSLayoutDimension extends NSLayoutAnchor {
  NSLayoutDimension._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutDimension',
        iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSLayoutDimension] that points to the same underlying object as [other].
  NSLayoutDimension.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutDimension] that wraps the given raw object pointer.
  NSLayoutDimension.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_widthAnchor = objc.registerName("widthAnchor");
late final _sel_heightAnchor = objc.registerName("heightAnchor");
late final _sel_centerXAnchor = objc.registerName("centerXAnchor");
late final _sel_centerYAnchor = objc.registerName("centerYAnchor");
late final _sel_firstBaselineAnchor = objc.registerName("firstBaselineAnchor");
late final _sel_lastBaselineAnchor = objc.registerName("lastBaselineAnchor");

/// UIViewLayoutConstraintCreation
extension UIViewLayoutConstraintCreation on UIView {
  /// leadingAnchor
  NSLayoutXAxisAnchor get leadingAnchor {
    objc.checkOsVersionInternal('UIView.leadingAnchor',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leadingAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// trailingAnchor
  NSLayoutXAxisAnchor get trailingAnchor {
    objc.checkOsVersionInternal('UIView.trailingAnchor',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_trailingAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// leftAnchor
  NSLayoutXAxisAnchor get leftAnchor {
    objc.checkOsVersionInternal('UIView.leftAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leftAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// rightAnchor
  NSLayoutXAxisAnchor get rightAnchor {
    objc.checkOsVersionInternal('UIView.rightAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rightAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// topAnchor
  NSLayoutYAxisAnchor get topAnchor {
    objc.checkOsVersionInternal('UIView.topAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_topAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// bottomAnchor
  NSLayoutYAxisAnchor get bottomAnchor {
    objc.checkOsVersionInternal('UIView.bottomAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_bottomAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// widthAnchor
  NSLayoutDimension get widthAnchor {
    objc.checkOsVersionInternal('UIView.widthAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_widthAnchor);
    return NSLayoutDimension.castFromPointer(_ret, retain: true, release: true);
  }

  /// heightAnchor
  NSLayoutDimension get heightAnchor {
    objc.checkOsVersionInternal('UIView.heightAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_heightAnchor);
    return NSLayoutDimension.castFromPointer(_ret, retain: true, release: true);
  }

  /// centerXAnchor
  NSLayoutXAxisAnchor get centerXAnchor {
    objc.checkOsVersionInternal('UIView.centerXAnchor',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_centerXAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// centerYAnchor
  NSLayoutYAxisAnchor get centerYAnchor {
    objc.checkOsVersionInternal('UIView.centerYAnchor',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_centerYAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// firstBaselineAnchor
  NSLayoutYAxisAnchor get firstBaselineAnchor {
    objc.checkOsVersionInternal('UIView.firstBaselineAnchor',
        iOS: (false, (9, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_firstBaselineAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// lastBaselineAnchor
  NSLayoutYAxisAnchor get lastBaselineAnchor {
    objc.checkOsVersionInternal('UIView.lastBaselineAnchor',
        iOS: (false, (9, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_lastBaselineAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_constraintsAffectingLayoutForAxis_ =
    objc.registerName("constraintsAffectingLayoutForAxis:");
final _objc_msgSend_5swr7b = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_hasAmbiguousLayout = objc.registerName("hasAmbiguousLayout");
late final _sel_exerciseAmbiguityInLayout =
    objc.registerName("exerciseAmbiguityInLayout");

/// UIConstraintBasedLayoutDebugging
extension UIConstraintBasedLayoutDebugging on UIView {
  /// constraintsAffectingLayoutForAxis:
  objc.NSArray constraintsAffectingLayoutForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal('UIView.constraintsAffectingLayoutForAxis:',
        iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_5swr7b(
        this.ref.pointer, _sel_constraintsAffectingLayoutForAxis_, axis.value);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// hasAmbiguousLayout
  bool get hasAmbiguousLayout {
    objc.checkOsVersionInternal('UIView.hasAmbiguousLayout',
        iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hasAmbiguousLayout);
  }

  /// exerciseAmbiguityInLayout
  void exerciseAmbiguityInLayout() {
    objc.checkOsVersionInternal('UIView.exerciseAmbiguityInLayout',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_exerciseAmbiguityInLayout);
  }
}

late final _sel_restorationIdentifier =
    objc.registerName("restorationIdentifier");
late final _sel_setRestorationIdentifier_ =
    objc.registerName("setRestorationIdentifier:");
late final _sel_encodeRestorableStateWithCoder_ =
    objc.registerName("encodeRestorableStateWithCoder:");
late final _sel_decodeRestorableStateWithCoder_ =
    objc.registerName("decodeRestorableStateWithCoder:");

/// UIStateRestoration
extension UIStateRestoration on UIView {
  /// restorationIdentifier
  objc.NSString? get restorationIdentifier {
    objc.checkOsVersionInternal('UIView.restorationIdentifier',
        iOS: (false, (6, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_restorationIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRestorationIdentifier:
  set restorationIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setRestorationIdentifier:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRestorationIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIView.encodeRestorableStateWithCoder:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeRestorableStateWithCoder_,
        coder.ref.pointer);
  }

  /// decodeRestorableStateWithCoder:
  void decodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIView.decodeRestorableStateWithCoder:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_decodeRestorableStateWithCoder_,
        coder.ref.pointer);
  }
}

late final _sel_snapshotViewAfterScreenUpdates_ =
    objc.registerName("snapshotViewAfterScreenUpdates:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_ =
    objc.registerName(
        "resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:");
final _objc_msgSend_qvletk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Bool,
                UIEdgeInsets)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGRect, bool, UIEdgeInsets)>();
late final _sel_drawViewHierarchyInRect_afterScreenUpdates_ =
    objc.registerName("drawViewHierarchyInRect:afterScreenUpdates:");
final _objc_msgSend_19ljaqg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGRect, ffi.Bool)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGRect, bool)>();

/// UISnapshotting
extension UISnapshotting on UIView {
  /// snapshotViewAfterScreenUpdates:
  UIView? snapshotViewAfterScreenUpdates(bool afterUpdates) {
    objc.checkOsVersionInternal('UIView.snapshotViewAfterScreenUpdates:',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_1t6aok9(
        this.ref.pointer, _sel_snapshotViewAfterScreenUpdates_, afterUpdates);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:
  UIView? resizableSnapshotViewFromRect(objc.CGRect rect,
      {required bool afterScreenUpdates, required UIEdgeInsets withCapInsets}) {
    objc.checkOsVersionInternal(
        'UIView.resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_qvletk(
        this.ref.pointer,
        _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_,
        rect,
        afterScreenUpdates,
        withCapInsets);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// drawViewHierarchyInRect:afterScreenUpdates:
  bool drawViewHierarchyInRect(objc.CGRect rect,
      {required bool afterScreenUpdates}) {
    objc.checkOsVersionInternal(
        'UIView.drawViewHierarchyInRect:afterScreenUpdates:',
        iOS: (false, (7, 0, 0)));
    return _objc_msgSend_19ljaqg(
        this.ref.pointer,
        _sel_drawViewHierarchyInRect_afterScreenUpdates_,
        rect,
        afterScreenUpdates);
  }
}

late final _sel_beginAnimations_context_ =
    objc.registerName("beginAnimations:context:");
final _objc_msgSend_1lzqwav = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Void>)>();
late final _sel_commitAnimations = objc.registerName("commitAnimations");
late final _sel_setAnimationDelegate_ =
    objc.registerName("setAnimationDelegate:");
late final _sel_setAnimationWillStartSelector_ =
    objc.registerName("setAnimationWillStartSelector:");
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAnimationDidStopSelector_ =
    objc.registerName("setAnimationDidStopSelector:");
late final _sel_setAnimationDuration_ =
    objc.registerName("setAnimationDuration:");
late final _sel_setAnimationDelay_ = objc.registerName("setAnimationDelay:");
late final _sel_setAnimationStartDate_ =
    objc.registerName("setAnimationStartDate:");

enum UIViewAnimationCurve {
  UIViewAnimationCurveEaseInOut(0),
  UIViewAnimationCurveEaseIn(1),
  UIViewAnimationCurveEaseOut(2),
  UIViewAnimationCurveLinear(3);

  final int value;
  const UIViewAnimationCurve(this.value);

  static UIViewAnimationCurve fromValue(int value) => switch (value) {
        0 => UIViewAnimationCurveEaseInOut,
        1 => UIViewAnimationCurveEaseIn,
        2 => UIViewAnimationCurveEaseOut,
        3 => UIViewAnimationCurveLinear,
        _ =>
          throw ArgumentError('Unknown value for UIViewAnimationCurve: $value'),
      };
}

late final _sel_setAnimationCurve_ = objc.registerName("setAnimationCurve:");
final _objc_msgSend_up32gn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setAnimationRepeatCount_ =
    objc.registerName("setAnimationRepeatCount:");
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Float)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_setAnimationRepeatAutoreverses_ =
    objc.registerName("setAnimationRepeatAutoreverses:");
late final _sel_setAnimationBeginsFromCurrentState_ =
    objc.registerName("setAnimationBeginsFromCurrentState:");

enum UIViewAnimationTransition {
  UIViewAnimationTransitionNone(0),
  UIViewAnimationTransitionFlipFromLeft(1),
  UIViewAnimationTransitionFlipFromRight(2),
  UIViewAnimationTransitionCurlUp(3),
  UIViewAnimationTransitionCurlDown(4);

  final int value;
  const UIViewAnimationTransition(this.value);

  static UIViewAnimationTransition fromValue(int value) => switch (value) {
        0 => UIViewAnimationTransitionNone,
        1 => UIViewAnimationTransitionFlipFromLeft,
        2 => UIViewAnimationTransitionFlipFromRight,
        3 => UIViewAnimationTransitionCurlUp,
        4 => UIViewAnimationTransitionCurlDown,
        _ => throw ArgumentError(
            'Unknown value for UIViewAnimationTransition: $value'),
      };
}

late final _sel_setAnimationTransition_forView_cache_ =
    objc.registerName("setAnimationTransition:forView:cache:");
final _objc_msgSend_1ftk3d5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();

/// DeprecatedAnimations
extension DeprecatedAnimations on UIView {
  /// beginAnimations:context:
  static void beginAnimations(objc.NSString? animationID,
      {required ffi.Pointer<ffi.Void> context}) {
    objc.checkOsVersionInternal('UIView.beginAnimations:context:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1lzqwav(_class_UIView, _sel_beginAnimations_context_,
        animationID?.ref.pointer ?? ffi.nullptr, context);
  }

  /// commitAnimations
  static void commitAnimations() {
    objc.checkOsVersionInternal('UIView.commitAnimations',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(_class_UIView, _sel_commitAnimations);
  }

  /// setAnimationDelegate:
  static void setAnimationDelegate(objc.ObjCObjectBase? delegate) {
    objc.checkOsVersionInternal('UIView.setAnimationDelegate:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(_class_UIView, _sel_setAnimationDelegate_,
        delegate?.ref.pointer ?? ffi.nullptr);
  }

  /// setAnimationWillStartSelector:
  static void setAnimationWillStartSelector(
      ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal('UIView.setAnimationWillStartSelector:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(
        _class_UIView, _sel_setAnimationWillStartSelector_, selector);
  }

  /// setAnimationDidStopSelector:
  static void setAnimationDidStopSelector(
      ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal('UIView.setAnimationDidStopSelector:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(
        _class_UIView, _sel_setAnimationDidStopSelector_, selector);
  }

  /// setAnimationDuration:
  static void setAnimationDuration(double duration) {
    objc.checkOsVersionInternal('UIView.setAnimationDuration:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDuration_, duration);
  }

  /// setAnimationDelay:
  static void setAnimationDelay(double delay) {
    objc.checkOsVersionInternal('UIView.setAnimationDelay:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDelay_, delay);
  }

  /// setAnimationStartDate:
  static void setAnimationStartDate(objc.NSDate startDate) {
    objc.checkOsVersionInternal('UIView.setAnimationStartDate:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        _class_UIView, _sel_setAnimationStartDate_, startDate.ref.pointer);
  }

  /// setAnimationCurve:
  static void setAnimationCurve(UIViewAnimationCurve curve) {
    objc.checkOsVersionInternal('UIView.setAnimationCurve:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_up32gn(_class_UIView, _sel_setAnimationCurve_, curve.value);
  }

  /// setAnimationRepeatCount:
  static void setAnimationRepeatCount(double repeatCount) {
    objc.checkOsVersionInternal('UIView.setAnimationRepeatCount:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_v5hmet(
        _class_UIView, _sel_setAnimationRepeatCount_, repeatCount);
  }

  /// setAnimationRepeatAutoreverses:
  static void setAnimationRepeatAutoreverses(bool repeatAutoreverses) {
    objc.checkOsVersionInternal('UIView.setAnimationRepeatAutoreverses:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationRepeatAutoreverses_,
        repeatAutoreverses);
  }

  /// setAnimationBeginsFromCurrentState:
  static void setAnimationBeginsFromCurrentState(bool fromCurrentState) {
    objc.checkOsVersionInternal('UIView.setAnimationBeginsFromCurrentState:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView,
        _sel_setAnimationBeginsFromCurrentState_, fromCurrentState);
  }

  /// setAnimationTransition:forView:cache:
  static void setAnimationTransition(UIViewAnimationTransition transition,
      {required UIView forView, required bool cache}) {
    objc.checkOsVersionInternal('UIView.setAnimationTransition:forView:cache:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1ftk3d5(
        _class_UIView,
        _sel_setAnimationTransition_forView_cache_,
        transition.value,
        forView.ref.pointer,
        cache);
  }
}

enum UIUserInterfaceStyle {
  UIUserInterfaceStyleUnspecified(0),
  UIUserInterfaceStyleLight(1),
  UIUserInterfaceStyleDark(2);

  final int value;
  const UIUserInterfaceStyle(this.value);

  static UIUserInterfaceStyle fromValue(int value) => switch (value) {
        0 => UIUserInterfaceStyleUnspecified,
        1 => UIUserInterfaceStyleLight,
        2 => UIUserInterfaceStyleDark,
        _ =>
          throw ArgumentError('Unknown value for UIUserInterfaceStyle: $value'),
      };
}

late final _sel_overrideUserInterfaceStyle =
    objc.registerName("overrideUserInterfaceStyle");
final _objc_msgSend_2x5ago = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setOverrideUserInterfaceStyle_ =
    objc.registerName("setOverrideUserInterfaceStyle:");
final _objc_msgSend_15dz1ky = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// UserInterfaceStyle
extension UserInterfaceStyle on UIView {
  /// overrideUserInterfaceStyle
  UIUserInterfaceStyle get overrideUserInterfaceStyle {
    objc.checkOsVersionInternal('UIView.overrideUserInterfaceStyle',
        iOS: (false, (13, 0, 0)));
    final _ret =
        _objc_msgSend_2x5ago(this.ref.pointer, _sel_overrideUserInterfaceStyle);
    return UIUserInterfaceStyle.fromValue(_ret);
  }

  /// setOverrideUserInterfaceStyle:
  set overrideUserInterfaceStyle(UIUserInterfaceStyle value) {
    objc.checkOsVersionInternal('UIView.setOverrideUserInterfaceStyle:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_15dz1ky(
        this.ref.pointer, _sel_setOverrideUserInterfaceStyle_, value.value);
  }
}

late final _sel_minimumContentSizeCategory =
    objc.registerName("minimumContentSizeCategory");
late final _sel_setMinimumContentSizeCategory_ =
    objc.registerName("setMinimumContentSizeCategory:");
late final _sel_maximumContentSizeCategory =
    objc.registerName("maximumContentSizeCategory");
late final _sel_setMaximumContentSizeCategory_ =
    objc.registerName("setMaximumContentSizeCategory:");
late final _sel_appliedContentSizeCategoryLimitsDescription =
    objc.registerName("appliedContentSizeCategoryLimitsDescription");

/// UIContentSizeCategoryLimit
extension UIContentSizeCategoryLimit on UIView {
  /// minimumContentSizeCategory
  objc.NSString? get minimumContentSizeCategory {
    objc.checkOsVersionInternal('UIView.minimumContentSizeCategory',
        iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_minimumContentSizeCategory);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMinimumContentSizeCategory:
  set minimumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setMinimumContentSizeCategory:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMinimumContentSizeCategory_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// maximumContentSizeCategory
  objc.NSString? get maximumContentSizeCategory {
    objc.checkOsVersionInternal('UIView.maximumContentSizeCategory',
        iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_maximumContentSizeCategory);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMaximumContentSizeCategory:
  set maximumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setMaximumContentSizeCategory:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMaximumContentSizeCategory_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// appliedContentSizeCategoryLimitsDescription
  objc.NSString get appliedContentSizeCategoryLimitsDescription {
    objc.checkOsVersionInternal(
        'UIView.appliedContentSizeCategoryLimitsDescription',
        iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_appliedContentSizeCategoryLimitsDescription);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

/// WARNING: UITraitChangeObservable is a stub. To generate bindings for this class, include
/// UITraitChangeObservable in your config's objc-protocols list.
///
/// UITraitChangeObservable
interface class UITraitChangeObservable extends objc.ObjCProtocolBase {
  UITraitChangeObservable._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UITraitChangeObservable] that points to the same underlying object as [other].
  UITraitChangeObservable.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitChangeObservable] that wraps the given raw object pointer.
  UITraitChangeObservable.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

///
extension unnamed on UIView {}

/// WARNING: UIInteraction is a stub. To generate bindings for this class, include
/// UIInteraction in your config's objc-protocols list.
///
/// UIInteraction
interface class UIInteraction extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIInteraction._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIInteraction] that points to the same underlying object as [other].
  UIInteraction.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIInteraction] that wraps the given raw object pointer.
  UIInteraction.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_addInteraction_ = objc.registerName("addInteraction:");
late final _sel_removeInteraction_ = objc.registerName("removeInteraction:");
late final _sel_interactions = objc.registerName("interactions");
late final _sel_setInteractions_ = objc.registerName("setInteractions:");

/// Interactions
extension Interactions on UIView {
  /// addInteraction:
  void addInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal('UIView.addInteraction:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addInteraction_, interaction.ref.pointer);
  }

  /// removeInteraction:
  void removeInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal('UIView.removeInteraction:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeInteraction_, interaction.ref.pointer);
  }

  /// interactions
  objc.NSArray get interactions {
    objc.checkOsVersionInternal('UIView.interactions',
        iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_interactions);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setInteractions:
  set interactions(objc.NSArray value) {
    objc.checkOsVersionInternal('UIView.setInteractions:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setInteractions_, value.ref.pointer);
  }
}

late final _sel_accessibilityIgnoresInvertColors =
    objc.registerName("accessibilityIgnoresInvertColors");
late final _sel_setAccessibilityIgnoresInvertColors_ =
    objc.registerName("setAccessibilityIgnoresInvertColors:");

/// UIAccessibilityInvertColors
extension UIAccessibilityInvertColors on UIView {
  /// accessibilityIgnoresInvertColors
  bool get accessibilityIgnoresInvertColors {
    objc.checkOsVersionInternal('UIView.accessibilityIgnoresInvertColors',
        iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_accessibilityIgnoresInvertColors);
  }

  /// setAccessibilityIgnoresInvertColors:
  set accessibilityIgnoresInvertColors(bool value) {
    objc.checkOsVersionInternal('UIView.setAccessibilityIgnoresInvertColors:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAccessibilityIgnoresInvertColors_, value);
  }
}

late final _sel_endEditing_ = objc.registerName("endEditing:");
final _objc_msgSend_41h7k3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();

/// UITextField
extension UITextField on UIView {
  /// endEditing:
  bool endEditing(bool force) {
    objc.checkOsVersionInternal('UIView.endEditing:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_41h7k3(this.ref.pointer, _sel_endEditing_, force);
  }
}

/// UIAccessibility
extension UIAccessibility$1 on UIView {
  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
    objc.checkOsVersionInternal('UIView.accessibilityIdentifier',
        iOS: (false, (5, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_accessibilityIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setAccessibilityIdentifier:',
        iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAccessibilityIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UILargeContentViewerItem is a stub. To generate bindings for this class, include
/// UILargeContentViewerItem in your config's objc-protocols list.
///
/// UILargeContentViewerItem
interface class UILargeContentViewerItem extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UILargeContentViewerItem._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UILargeContentViewerItem] that points to the same underlying object as [other].
  UILargeContentViewerItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILargeContentViewerItem] that wraps the given raw object pointer.
  UILargeContentViewerItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_showsLargeContentViewer =
    objc.registerName("showsLargeContentViewer");
late final _sel_setShowsLargeContentViewer_ =
    objc.registerName("setShowsLargeContentViewer:");
late final _sel_largeContentTitle = objc.registerName("largeContentTitle");
late final _sel_setLargeContentTitle_ =
    objc.registerName("setLargeContentTitle:");
late final _sel_largeContentImage = objc.registerName("largeContentImage");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIImage_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIImage_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIImage_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIImage_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIImage_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIImage_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIImage_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIImage_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromFunction(
          UIImage? Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_UIImage_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) =>
                  fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIImage_ffiVoid_CallExtension
    on objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> {
  UIImage? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIImage.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_setLargeContentImage_ =
    objc.registerName("setLargeContentImage:");
late final _sel_scalesLargeContentImage =
    objc.registerName("scalesLargeContentImage");
late final _sel_setScalesLargeContentImage_ =
    objc.registerName("setScalesLargeContentImage:");
late final _sel_largeContentImageInsets =
    objc.registerName("largeContentImageInsets");
UIEdgeInsets _ObjCBlock_UIEdgeInsets_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                UIEdgeInsets Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIEdgeInsets_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                UIEdgeInsets Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIEdgeInsets_ffiVoid_fnPtrTrampoline)
        .cast();
UIEdgeInsets _ObjCBlock_UIEdgeInsets_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as UIEdgeInsets Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIEdgeInsets_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                UIEdgeInsets Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIEdgeInsets_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIEdgeInsets_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      UIEdgeInsets Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIEdgeInsets_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIEdgeInsets Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_UIEdgeInsets_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIEdgeInsets_ffiVoid_CallExtension
    on objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)> {
  UIEdgeInsets call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              UIEdgeInsets Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          UIEdgeInsets Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_setLargeContentImageInsets_ =
    objc.registerName("setLargeContentImageInsets:");

/// UILargeContentViewer
extension UILargeContentViewer on UIView {
  /// showsLargeContentViewer
  bool get showsLargeContentViewer {
    objc.checkOsVersionInternal('UIView.showsLargeContentViewer',
        iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsLargeContentViewer);
  }

  /// setShowsLargeContentViewer:
  set showsLargeContentViewer$1(bool value) {
    objc.checkOsVersionInternal('UIView.setShowsLargeContentViewer:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setShowsLargeContentViewer_, value);
  }

  /// largeContentTitle
  objc.NSString? get largeContentTitle {
    objc.checkOsVersionInternal('UIView.largeContentTitle',
        iOS: (false, (13, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_largeContentTitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLargeContentTitle:
  set largeContentTitle$1(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setLargeContentTitle:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLargeContentTitle_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// largeContentImage
  UIImage? get largeContentImage {
    objc.checkOsVersionInternal('UIView.largeContentImage',
        iOS: (false, (13, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_largeContentImage);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLargeContentImage:
  set largeContentImage$1(UIImage? value) {
    objc.checkOsVersionInternal('UIView.setLargeContentImage:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLargeContentImage_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// scalesLargeContentImage
  bool get scalesLargeContentImage {
    objc.checkOsVersionInternal('UIView.scalesLargeContentImage',
        iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_scalesLargeContentImage);
  }

  /// setScalesLargeContentImage:
  set scalesLargeContentImage$1(bool value) {
    objc.checkOsVersionInternal('UIView.setScalesLargeContentImage:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setScalesLargeContentImage_, value);
  }

  /// largeContentImageInsets
  UIEdgeInsets get largeContentImageInsets {
    objc.checkOsVersionInternal('UIView.largeContentImageInsets',
        iOS: (false, (13, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            _ptr, this.ref.pointer, _sel_largeContentImageInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(
            this.ref.pointer, _sel_largeContentImageInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setLargeContentImageInsets:
  set largeContentImageInsets$1(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIView.setLargeContentImageInsets:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_1g8fos5(
        this.ref.pointer, _sel_setLargeContentImageInsets_, value);
  }
}

late final _class_UIHoverStyle = objc.getClass("UIHoverStyle");

/// WARNING: UIHoverEffect is a stub. To generate bindings for this class, include
/// UIHoverEffect in your config's objc-protocols list.
///
/// UIHoverEffect
interface class UIHoverEffect extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol, objc.NSCopying {
  UIHoverEffect._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIHoverEffect] that points to the same underlying object as [other].
  UIHoverEffect.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIHoverEffect] that wraps the given raw object pointer.
  UIHoverEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_effect = objc.registerName("effect");
late final _sel_setEffect_ = objc.registerName("setEffect:");

/// WARNING: UIShape is a stub. To generate bindings for this class, include
/// UIShape in your config's objc-interfaces list.
///
/// UIShape
class UIShape extends objc.NSObject implements UIShapeProvider, objc.NSCopying {
  UIShape._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIShape', iOS: (false, (17, 0, 0)));
  }

  /// Constructs a [UIShape] that points to the same underlying object as [other].
  UIShape.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIShape] that wraps the given raw object pointer.
  UIShape.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_shape = objc.registerName("shape");
late final _sel_setShape_ = objc.registerName("setShape:");
late final _sel_isEnabled = objc.registerName("isEnabled");
late final _sel_setEnabled_ = objc.registerName("setEnabled:");
late final _sel_styleWithEffect_shape_ =
    objc.registerName("styleWithEffect:shape:");
late final _sel_styleWithShape_ = objc.registerName("styleWithShape:");
late final _sel_automaticStyle = objc.registerName("automaticStyle");

/// UIHoverStyle
class UIHoverStyle extends objc.NSObject implements objc.NSCopying {
  UIHoverStyle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIHoverStyle', iOS: (false, (17, 0, 0)));
  }

  /// Constructs a [UIHoverStyle] that points to the same underlying object as [other].
  UIHoverStyle.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIHoverStyle] that wraps the given raw object pointer.
  UIHoverStyle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIHoverStyle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIHoverStyle);
  }

  /// effect
  UIHoverEffect get effect {
    objc.checkOsVersionInternal('UIHoverStyle.effect',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_effect);
    return UIHoverEffect.castFromPointer(_ret, retain: true, release: true);
  }

  /// setEffect:
  set effect(UIHoverEffect value) {
    objc.checkOsVersionInternal('UIHoverStyle.setEffect:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setEffect_, value.ref.pointer);
  }

  /// shape
  UIShape? get shape {
    objc.checkOsVersionInternal('UIHoverStyle.shape', iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shape);
    return _ret.address == 0
        ? null
        : UIShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// setShape:
  set shape(UIShape? value) {
    objc.checkOsVersionInternal('UIHoverStyle.setShape:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setShape_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// isEnabled
  bool get enabled {
    objc.checkOsVersionInternal('UIHoverStyle.isEnabled',
        iOS: (false, (17, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// setEnabled:
  set enabled(bool value) {
    objc.checkOsVersionInternal('UIHoverStyle.setEnabled:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// styleWithEffect:shape:
  static UIHoverStyle styleWithEffect(UIHoverEffect effect$1,
      {UIShape? shape$1}) {
    objc.checkOsVersionInternal('UIHoverStyle.styleWithEffect:shape:',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_UIHoverStyle,
        _sel_styleWithEffect_shape_,
        effect$1.ref.pointer,
        shape$1?.ref.pointer ?? ffi.nullptr);
    return UIHoverStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// styleWithShape:
  static UIHoverStyle styleWithShape(UIShape? shape$1) {
    objc.checkOsVersionInternal('UIHoverStyle.styleWithShape:',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIHoverStyle,
        _sel_styleWithShape_, shape$1?.ref.pointer ?? ffi.nullptr);
    return UIHoverStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// automaticStyle
  static UIHoverStyle automaticStyle() {
    objc.checkOsVersionInternal('UIHoverStyle.automaticStyle',
        iOS: (false, (17, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_UIHoverStyle, _sel_automaticStyle);
    return UIHoverStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  UIHoverStyle init() {
    objc.checkOsVersionInternal('UIHoverStyle.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIHoverStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIHoverStyle new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIHoverStyle, _sel_new);
    return UIHoverStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIHoverStyle allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_UIHoverStyle, _sel_allocWithZone_, zone);
    return UIHoverStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIHoverStyle alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIHoverStyle, _sel_alloc);
    return UIHoverStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIHoverStyle constructed with the default `new` method.
  factory UIHoverStyle() => new$();
}

late final _sel_hoverStyle = objc.registerName("hoverStyle");
late final _sel_setHoverStyle_ = objc.registerName("setHoverStyle:");

/// UIHoverStyle
extension UIHoverStyle$1 on UIView {
  /// hoverStyle
  UIHoverStyle? get hoverStyle {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_hoverStyle);
    return _ret.address == 0
        ? null
        : UIHoverStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// setHoverStyle:
  set hoverStyle(UIHoverStyle? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHoverStyle_,
        value?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UIPopoverPresentationControllerSourceItem is a stub. To generate bindings for this class, include
/// UIPopoverPresentationControllerSourceItem in your config's objc-protocols list.
///
/// UIPopoverPresentationControllerSourceItem
interface class UIPopoverPresentationControllerSourceItem
    extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIPopoverPresentationControllerSourceItem._(
      ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false,
      bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPopoverPresentationControllerSourceItem] that points to the same underlying object as [other].
  UIPopoverPresentationControllerSourceItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPopoverPresentationControllerSourceItem] that wraps the given raw object pointer.
  UIPopoverPresentationControllerSourceItem.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_frameInView_ = objc.registerName("frameInView:");
final _objc_msgSend_qrtfce = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGRect Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_qrtfceStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
objc.CGRect _ObjCBlock_CGRect_ffiVoid_UIView_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                objc.CGRect Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            objc.CGRect Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_UIView_fnPtrCallable =
    ffi.Pointer.fromFunction<
                objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_CGRect_ffiVoid_UIView_fnPtrTrampoline)
        .cast();
objc.CGRect _ObjCBlock_CGRect_ffiVoid_UIView_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as objc.CGRect Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_UIView_closureCallable =
    ffi.Pointer.fromFunction<
                objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_CGRect_ffiVoid_UIView_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_UIView {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          objc.CGRect Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
              objc.newPointerBlock(_ObjCBlock_CGRect_ffiVoid_UIView_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)> fromFunction(
          objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
          objc.newClosureBlock(
              _ObjCBlock_CGRect_ffiVoid_UIView_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, UIView.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>`.
extension ObjCBlock_CGRect_ffiVoid_UIView_CallExtension
    on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, UIView arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      objc.CGRect Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

/// UIPopoverPresentationControllerSourceItem
extension UIPopoverPresentationControllerSourceItem$1 on UIView {
  /// frameInView:
  objc.CGRect frameInView(UIView referenceView) {
    objc.checkOsVersionInternal('UIView.frameInView:',
        iOS: (false, (17, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qrtfceStret(_ptr, this.ref.pointer, _sel_frameInView_,
            referenceView.ref.pointer)
        : _ptr.ref = _objc_msgSend_qrtfce(
            this.ref.pointer, _sel_frameInView_, referenceView.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }
}

/// WARNING: UIViewPrintFormatter is a stub. To generate bindings for this class, include
/// UIViewPrintFormatter in your config's objc-interfaces list.
///
/// UIViewPrintFormatter
class UIViewPrintFormatter extends UIPrintFormatter$1 {
  UIViewPrintFormatter._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewPrintFormatter',
        iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UIViewPrintFormatter] that points to the same underlying object as [other].
  UIViewPrintFormatter.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewPrintFormatter] that wraps the given raw object pointer.
  UIViewPrintFormatter.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_viewPrintFormatter = objc.registerName("viewPrintFormatter");
late final _sel_drawRect_forViewPrintFormatter_ =
    objc.registerName("drawRect:forViewPrintFormatter:");

/// UIPrintFormatter
extension UIPrintFormatter on UIView {
  /// viewPrintFormatter
  UIViewPrintFormatter viewPrintFormatter() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_viewPrintFormatter);
    return UIViewPrintFormatter.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// drawRect:forViewPrintFormatter:
  void drawRect(objc.CGRect rect,
      {required UIViewPrintFormatter forViewPrintFormatter}) {
    _objc_msgSend_f227js(this.ref.pointer, _sel_drawRect_forViewPrintFormatter_,
        rect, forViewPrintFormatter.ref.pointer);
  }
}

late final _sel_layerClass = objc.registerName("layerClass");
late final _sel_initWithFrame_ = objc.registerName("initWithFrame:");
final _objc_msgSend_15yz4e6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>();
late final _sel_isUserInteractionEnabled =
    objc.registerName("isUserInteractionEnabled");
late final _sel_setUserInteractionEnabled_ =
    objc.registerName("setUserInteractionEnabled:");
late final _sel_tag = objc.registerName("tag");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTag_ = objc.registerName("setTag:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_layer = objc.registerName("layer");
late final _sel_canBecomeFocused = objc.registerName("canBecomeFocused");
late final _sel_isFocused = objc.registerName("isFocused");
late final _sel_focusGroupIdentifier =
    objc.registerName("focusGroupIdentifier");
late final _sel_setFocusGroupIdentifier_ =
    objc.registerName("setFocusGroupIdentifier:");
late final _sel_focusGroupPriority = objc.registerName("focusGroupPriority");
late final _sel_setFocusGroupPriority_ =
    objc.registerName("setFocusGroupPriority:");

/// WARNING: UIFocusEffect is a stub. To generate bindings for this class, include
/// UIFocusEffect in your config's objc-interfaces list.
///
/// UIFocusEffect
class UIFocusEffect extends objc.NSObject implements objc.NSCopying {
  UIFocusEffect._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusEffect', iOS: (false, (15, 0, 0)));
  }

  /// Constructs a [UIFocusEffect] that points to the same underlying object as [other].
  UIFocusEffect.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusEffect] that wraps the given raw object pointer.
  UIFocusEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_focusEffect = objc.registerName("focusEffect");
late final _sel_setFocusEffect_ = objc.registerName("setFocusEffect:");

enum UISemanticContentAttribute {
  UISemanticContentAttributeUnspecified(0),
  UISemanticContentAttributePlayback(1),
  UISemanticContentAttributeSpatial(2),
  UISemanticContentAttributeForceLeftToRight(3),
  UISemanticContentAttributeForceRightToLeft(4);

  final int value;
  const UISemanticContentAttribute(this.value);

  static UISemanticContentAttribute fromValue(int value) => switch (value) {
        0 => UISemanticContentAttributeUnspecified,
        1 => UISemanticContentAttributePlayback,
        2 => UISemanticContentAttributeSpatial,
        3 => UISemanticContentAttributeForceLeftToRight,
        4 => UISemanticContentAttributeForceRightToLeft,
        _ => throw ArgumentError(
            'Unknown value for UISemanticContentAttribute: $value'),
      };
}

late final _sel_semanticContentAttribute =
    objc.registerName("semanticContentAttribute");
final _objc_msgSend_i2u4x4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSemanticContentAttribute_ =
    objc.registerName("setSemanticContentAttribute:");
final _objc_msgSend_162qwxu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

enum UIUserInterfaceLayoutDirection {
  UIUserInterfaceLayoutDirectionLeftToRight(0),
  UIUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const UIUserInterfaceLayoutDirection(this.value);

  static UIUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
        0 => UIUserInterfaceLayoutDirectionLeftToRight,
        1 => UIUserInterfaceLayoutDirectionRightToLeft,
        _ => throw ArgumentError(
            'Unknown value for UIUserInterfaceLayoutDirection: $value'),
      };
}

late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_ = objc
    .registerName("userInterfaceLayoutDirectionForSemanticContentAttribute:");
final _objc_msgSend_racczx = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_ =
    objc.registerName(
        "userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:");
final _objc_msgSend_tz4p54 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Long)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_effectiveUserInterfaceLayoutDirection =
    objc.registerName("effectiveUserInterfaceLayoutDirection");
final _objc_msgSend_qj4fey = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_appearance = objc.registerName("appearance");
late final _sel_appearanceWhenContainedIn_ =
    objc.registerName("appearanceWhenContainedIn:");
instancetype
    _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    instancetype Function(ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                instancetype Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>, UIAppearanceContainer?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, arg1.address == 0 ? null : UIAppearanceContainer.castFromPointer(arg1, retain: true, release: true))
                          .ref
                          .retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  Dartinstancetype call(
          ffi.Pointer<ffi.Void> arg0, UIAppearanceContainer? arg1) =>
      objc.ObjCObjectBase(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          instancetype Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr),
          retain: true,
          release: true);
}

late final _sel_appearanceWhenContainedInInstancesOfClasses_ =
    objc.registerName("appearanceWhenContainedInInstancesOfClasses:");
instancetype _ObjCBlock_instancetype_ffiVoid_NSArray_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            instancetype Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSArray_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_NSArray_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSArray_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>, objc.NSArray)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                  objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      instancetype Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
          objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_NSArray_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSArray_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, objc.NSArray.castFromPointer(arg1, retain: true, release: true))
                          .ref
                          .retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_NSArray_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, objc.NSArray)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) =>
      objc.ObjCObjectBase(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          instancetype Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true);
}

/// WARNING: UITraitCollection is a stub. To generate bindings for this class, include
/// UITraitCollection in your config's objc-interfaces list.
///
/// UITraitCollection
class UITraitCollection extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  UITraitCollection._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITraitCollection', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UITraitCollection] that points to the same underlying object as [other].
  UITraitCollection.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitCollection] that wraps the given raw object pointer.
  UITraitCollection.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_appearanceForTraitCollection_ =
    objc.registerName("appearanceForTraitCollection:");
instancetype _ObjCBlock_instancetype_ffiVoid_UITraitCollection_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            instancetype Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_UITraitCollection_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_UITraitCollection_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>, UITraitCollection)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>, UITraitCollection)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>, UITraitCollection)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>, UITraitCollection)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_UITraitCollection_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_UITraitCollection_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, UITraitCollection.castFromPointer(arg1, retain: true, release: true))
                          .ref
                          .retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, UITraitCollection)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) =>
      objc.ObjCObjectBase(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          instancetype Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true);
}

late final _sel_appearanceForTraitCollection_whenContainedIn_ =
    objc.registerName("appearanceForTraitCollection:whenContainedIn:");
instancetype
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    instancetype Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                instancetype Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
              UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>,
                      UITraitCollection,
                      ffi.Pointer<objc.ObjCObject>?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
              UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                      UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>(
              objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIAppearanceContainer?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(arg0, UITraitCollection.castFromPointer(arg1, retain: true, release: true), arg2.address == 0 ? null : UIAppearanceContainer.castFromPointer(arg2, retain: true, release: true))
                          .ref
                          .retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
            UITraitCollection, ffi.Pointer<objc.ObjCObject>?)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1,
          UIAppearanceContainer? arg2) =>
      objc.ObjCObjectBase(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          instancetype Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>()
                  .asFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
              arg1.ref.pointer, arg2?.ref.pointer ?? ffi.nullptr),
          retain: true,
          release: true);
}

late final _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_ =
    objc.registerName(
        "appearanceForTraitCollection:whenContainedInInstancesOfClasses:");
instancetype
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    instancetype Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                instancetype Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<ffi.Void>,
                  UITraitCollection,
                  objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(
              objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(arg0, UITraitCollection.castFromPointer(arg1, retain: true, release: true), objc.NSArray.castFromPointer(arg2, retain: true, release: true))
                          .ref
                          .retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1,
          objc.NSArray arg2) =>
      objc.ObjCObjectBase(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          instancetype Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>()
                  .asFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true);
}

objc.CGPoint _ObjCBlock_CGPoint_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGPoint_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                objc.CGPoint Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGPoint_ffiVoid_fnPtrTrampoline)
        .cast();
objc.CGPoint _ObjCBlock_CGPoint_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as objc.CGPoint Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGPoint_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                objc.CGPoint Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGPoint_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGPoint_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_CGPoint_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.CGPoint Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(_ObjCBlock_CGPoint_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGPoint_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

void _ObjCBlock_ffiVoid_ffiVoid_CGPoint_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        objc.CGPoint arg1) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>>()
            .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>()(
        arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CGPoint_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, objc.CGPoint)>(
            _ObjCBlock_ffiVoid_ffiVoid_CGPoint_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CGPoint_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        objc.CGPoint arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CGPoint_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, objc.CGPoint)>(
            _ObjCBlock_ffiVoid_ffiVoid_CGPoint_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CGPoint_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, objc.CGPoint)>
    _ObjCBlock_ffiVoid_ffiVoid_CGPoint_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, objc.CGPoint)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CGPoint_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CGPoint_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)>
    _ObjCBlock_ffiVoid_ffiVoid_CGPoint_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                objc.CGPoint)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CGPoint_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)>
    _ObjCBlock_ffiVoid_ffiVoid_CGPoint_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                objc.CGPoint)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CGPoint_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGPoint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  objc.CGPoint)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(
                              ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CGPoint_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_CGPoint_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CGPoint_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1bktu2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CGPoint_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CGPoint_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1bktu2(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGPoint_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => ref
      .pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>,
              objc.CGPoint)>()(ref.pointer, arg0, arg1);
}

objc.CGRect _ObjCBlock_CGRect_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi
            .NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                objc.CGRect Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGRect_ffiVoid_fnPtrTrampoline)
        .cast();
objc.CGRect _ObjCBlock_CGRect_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as objc.CGRect Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                objc.CGRect Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGRect_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_CGRect_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.CGRect Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(_ObjCBlock_CGRect_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGRect_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

CGAffineTransform _ObjCBlock_CGAffineTransform_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGAffineTransform_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                CGAffineTransform Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGAffineTransform_ffiVoid_fnPtrTrampoline)
        .cast();
CGAffineTransform _ObjCBlock_CGAffineTransform_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as CGAffineTransform Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGAffineTransform_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                CGAffineTransform Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGAffineTransform_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGAffineTransform_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_CGAffineTransform_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>
      fromFunction(CGAffineTransform Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_CGAffineTransform_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGAffineTransform_ffiVoid_CallExtension
    on objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> {
  CGAffineTransform call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

void _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        CGAffineTransform arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>>()
        .asFunction<
            void Function(
                ffi.Pointer<ffi.Void>, CGAffineTransform)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, CGAffineTransform)>(
            _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        CGAffineTransform arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, CGAffineTransform)>(
            _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, CGAffineTransform)>
    _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, CGAffineTransform)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, CGAffineTransform)>
    _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                CGAffineTransform)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, CGAffineTransform)>
    _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                CGAffineTransform)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) =>
                  fn(arg0, arg1),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>
      listener(void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1lznlw3(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            CGAffineTransform)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>
      blocking(void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1lznlw3(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            CGAffineTransform)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> {
  void call(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  CGAffineTransform)>()(ref.pointer, arg0, arg1);
}

enum UIDynamicItemCollisionBoundsType {
  UIDynamicItemCollisionBoundsTypeRectangle(0),
  UIDynamicItemCollisionBoundsTypeEllipse(1),
  UIDynamicItemCollisionBoundsTypePath(2);

  final int value;
  const UIDynamicItemCollisionBoundsType(this.value);

  static UIDynamicItemCollisionBoundsType fromValue(int value) =>
      switch (value) {
        0 => UIDynamicItemCollisionBoundsTypeRectangle,
        1 => UIDynamicItemCollisionBoundsTypeEllipse,
        2 => UIDynamicItemCollisionBoundsTypePath,
        _ => throw ArgumentError(
            'Unknown value for UIDynamicItemCollisionBoundsType: $value'),
      };
}

late final _sel_collisionBoundsType = objc.registerName("collisionBoundsType");
final _objc_msgSend_k9iunc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
int _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunction(
          UIDynamicItemCollisionBoundsType Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  UIDynamicItemCollisionBoundsType call(ffi.Pointer<ffi.Void> arg0) =>
      UIDynamicItemCollisionBoundsType.fromValue(ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0));
}

late final _sel_collisionBoundingPath =
    objc.registerName("collisionBoundingPath");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIBezierPath_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIBezierPath_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIBezierPath_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIBezierPath_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIBezierPath_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIBezierPath_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIBezierPath_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIBezierPath_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIBezierPath Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_UIBezierPath_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIBezierPath_ffiVoid_CallExtension
    on objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> {
  UIBezierPath call(ffi.Pointer<ffi.Void> arg0) => UIBezierPath.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_traitCollection = objc.registerName("traitCollection");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UITraitCollection_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UITraitCollection_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UITraitCollection_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UITraitCollection_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UITraitCollection_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UITraitCollection_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UITraitCollection_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UITraitCollection_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UITraitCollection Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_UITraitCollection_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UITraitCollection_ffiVoid_CallExtension
    on objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> {
  UITraitCollection call(ffi.Pointer<ffi.Void> arg0) =>
      UITraitCollection.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_traitCollectionDidChange_ =
    objc.registerName("traitCollectionDidChange:");
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0,
                  arg1.address == 0
                      ? null
                      : UITraitCollection.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>
      listener(void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UITraitCollection.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UITraitCollection?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>
      blocking(void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UITraitCollection.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UITraitCollection.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UITraitCollection?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_convertPoint_toCoordinateSpace_ =
    objc.registerName("convertPoint:toCoordinateSpace:");
objc.CGPoint
    _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi
                .NativeFunction<
                    objc.CGPoint Function(
                        ffi.Pointer<ffi.Void> arg0,
                        objc.CGPoint arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_fnPtrCallable =
    ffi.Pointer.fromFunction<
                objc.CGPoint Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    objc.CGPoint,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_fnPtrTrampoline)
        .cast();
objc.CGPoint
    _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as objc.CGPoint Function(
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_closureCallable =
    ffi.Pointer.fromFunction<
                objc.CGPoint Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    objc.CGPoint,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint,
              ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint,
                      ffi.Pointer<objc.ObjCObject>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint,
                      ffi.Pointer<objc.ObjCObject>)>(
              objc.newPointerBlock(
                  _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>
      fromFunction(objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, UICoordinateSpace) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>(
              objc.newClosureBlock(
                  _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(arg0, arg1, UICoordinateSpace.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_CallExtension
    on objc.ObjCBlock<
        objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1,
          UICoordinateSpace arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      objc.CGPoint Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          objc.CGPoint arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  objc.CGPoint Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      objc.CGPoint,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertPoint_fromCoordinateSpace_ =
    objc.registerName("convertPoint:fromCoordinateSpace:");
late final _sel_convertRect_toCoordinateSpace_ =
    objc.registerName("convertRect:toCoordinateSpace:");
objc.CGRect
    _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    objc.CGRect Function(ffi.Pointer<ffi.Void> arg0,
                        objc.CGRect arg1, ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_fnPtrCallable =
    ffi.Pointer.fromFunction<
                objc.CGRect Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    objc.CGRect,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_fnPtrTrampoline)
        .cast();
objc.CGRect
    _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as objc.CGRect Function(
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_closureCallable =
    ffi.Pointer.fromFunction<
                objc.CGRect Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    objc.CGRect,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.CGRect Function(
              ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect,
                      ffi.Pointer<objc.ObjCObject>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect,
                      ffi.Pointer<objc.ObjCObject>)>(
              objc.newPointerBlock(
                  _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
      fromFunction(objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, UICoordinateSpace) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>(
              objc.newClosureBlock(
                  _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(arg0, arg1, UICoordinateSpace.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_CallExtension
    on objc.ObjCBlock<
        objc.CGRect Function(
            ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1,
          UICoordinateSpace arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      objc.CGRect Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          objc.CGRect arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  objc.CGRect Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      objc.CGRect,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertRect_fromCoordinateSpace_ =
    objc.registerName("convertRect:fromCoordinateSpace:");

enum UIFocusItemDeferralMode {
  UIFocusItemDeferralModeAutomatic(0),
  UIFocusItemDeferralModeAlways(1),
  UIFocusItemDeferralModeNever(2);

  final int value;
  const UIFocusItemDeferralMode(this.value);

  static UIFocusItemDeferralMode fromValue(int value) => switch (value) {
        0 => UIFocusItemDeferralModeAutomatic,
        1 => UIFocusItemDeferralModeAlways,
        2 => UIFocusItemDeferralModeNever,
        _ => throw ArgumentError(
            'Unknown value for UIFocusItemDeferralMode: $value'),
      };
}

late final _sel_focusItemDeferralMode =
    objc.registerName("focusItemDeferralMode");
final _objc_msgSend_1lv2zxu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
int _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIFocusItemDeferralMode_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
          UIFocusItemDeferralMode Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_UIFocusItemDeferralMode_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIFocusItemDeferralMode_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  UIFocusItemDeferralMode call(ffi.Pointer<ffi.Void> arg0) =>
      UIFocusItemDeferralMode.fromValue(ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0));
}

late final _sel_isTransparentFocusItem =
    objc.registerName("isTransparentFocusItem");

/// WARNING: UIFocusMovementHint is a stub. To generate bindings for this class, include
/// UIFocusMovementHint in your config's objc-interfaces list.
///
/// UIFocusMovementHint
class UIFocusMovementHint extends objc.NSObject implements objc.NSCopying {
  UIFocusMovementHint._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusMovementHint',
        iOS: (false, (12, 0, 0)));
  }

  /// Constructs a [UIFocusMovementHint] that points to the same underlying object as [other].
  UIFocusMovementHint.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusMovementHint] that wraps the given raw object pointer.
  UIFocusMovementHint.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_didHintFocusMovement_ =
    objc.registerName("didHintFocusMovement:");
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>
      listener(void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UIFocusMovementHint.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UIFocusMovementHint)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>
      blocking(void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UIFocusMovementHint.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UIFocusMovementHint.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UIFocusMovementHint)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusMovementHint arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_preferredFocusEnvironments =
    objc.registerName("preferredFocusEnvironments");

/// WARNING: UIFocusEnvironment is a stub. To generate bindings for this class, include
/// UIFocusEnvironment in your config's objc-protocols list.
///
/// UIFocusEnvironment
interface class UIFocusEnvironment extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIFocusEnvironment._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusEnvironment] that points to the same underlying object as [other].
  UIFocusEnvironment.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusEnvironment] that wraps the given raw object pointer.
  UIFocusEnvironment.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_parentFocusEnvironment =
    objc.registerName("parentFocusEnvironment");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusEnvironment_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIFocusEnvironment? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusEnvironment_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusEnvironment? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusEnvironment.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_focusItemContainer = objc.registerName("focusItemContainer");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusItemContainer_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIFocusItemContainer? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusItemContainer_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusItemContainer? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusItemContainer.castFromPointer(
          ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>().asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_setNeedsFocusUpdate = objc.registerName("setNeedsFocusUpdate");
void _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
      void Function(ffi.Pointer<ffi.Void>) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
      void Function(ffi.Pointer<ffi.Void>) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_ovsamd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_updateFocusIfNeeded = objc.registerName("updateFocusIfNeeded");

/// WARNING: UIFocusUpdateContext is a stub. To generate bindings for this class, include
/// UIFocusUpdateContext in your config's objc-interfaces list.
///
/// UIFocusUpdateContext
class UIFocusUpdateContext extends objc.NSObject {
  UIFocusUpdateContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusUpdateContext',
        iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusUpdateContext] that points to the same underlying object as [other].
  UIFocusUpdateContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusUpdateContext] that wraps the given raw object pointer.
  UIFocusUpdateContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_shouldUpdateFocusInContext_ =
    objc.registerName("shouldUpdateFocusInContext:");
bool _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_CallExtension on objc
    .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

/// WARNING: UIFocusAnimationCoordinator is a stub. To generate bindings for this class, include
/// UIFocusAnimationCoordinator in your config's objc-interfaces list.
///
/// UIFocusAnimationCoordinator
class UIFocusAnimationCoordinator extends objc.NSObject {
  UIFocusAnimationCoordinator._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusAnimationCoordinator',
        iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusAnimationCoordinator] that points to the same underlying object as [other].
  UIFocusAnimationCoordinator.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusAnimationCoordinator] that wraps the given raw object pointer.
  UIFocusAnimationCoordinator.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_didUpdateFocusInContext_withAnimationCoordinator_ =
    objc.registerName("didUpdateFocusInContext:withAnimationCoordinator:");
void
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
              UIFocusAnimationCoordinator)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
                      UIFocusAnimationCoordinator)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true),
                      UIFocusAnimationCoordinator.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
          UIFocusAnimationCoordinator)> listener(
      void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
              UIFocusAnimationCoordinator)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                UIFocusUpdateContext.castFromPointer(arg1,
                    retain: false, release: true),
                UIFocusAnimationCoordinator.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
                UIFocusAnimationCoordinator)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
          UIFocusAnimationCoordinator)> blocking(
      void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
              UIFocusAnimationCoordinator)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                UIFocusUpdateContext.castFromPointer(arg1,
                    retain: false, release: true),
                UIFocusAnimationCoordinator.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                UIFocusUpdateContext.castFromPointer(arg1,
                    retain: false, release: true),
                UIFocusAnimationCoordinator.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
                UIFocusAnimationCoordinator)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext,
            UIFocusAnimationCoordinator)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1,
          UIFocusAnimationCoordinator arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_soundIdentifierForFocusUpdateInContext_ =
    objc.registerName("soundIdentifierForFocusUpdateInContext:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  objc.NSString? Function(
                      ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
          objc.newPointerBlock(_ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>
      fromFunction(objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
              objc.newClosureBlock(
                  _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_CallExtension
    on objc.ObjCBlock<
        objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
                  (ref.pointer, arg0, arg1.ref.pointer)
                  .address ==
              0
          ? null
          : objc.NSString.castFromPointer(
              ref.pointer.ref.invoke
                  .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
              retain: true,
              release: true);
}

late final _sel_preferredFocusedView =
    objc.registerName("preferredFocusedView");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIView_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIView_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIView_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIView_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIView_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIView_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIView_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIView_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunction(
          UIView? Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_UIView_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) =>
                  fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIView_ffiVoid_CallExtension
    on objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> {
  UIView? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIView.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_coordinateSpace = objc.registerName("coordinateSpace");
ffi.Pointer<
    objc.ObjCObject> _ObjCBlock_idUICoordinateSpace_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUICoordinateSpace_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUICoordinateSpace_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUICoordinateSpace_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUICoordinateSpace_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUICoordinateSpace_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUICoordinateSpace_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_idUICoordinateSpace_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UICoordinateSpace Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUICoordinateSpace_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUICoordinateSpace_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  UICoordinateSpace call(ffi.Pointer<ffi.Void> arg0) =>
      UICoordinateSpace.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_focusItemsInRect_ = objc.registerName("focusItemsInRect:");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_CGRect_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        objc.CGRect arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>, objc.CGRect)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_CGRect_fnPtrCallable =
    ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                objc.CGRect)>(_ObjCBlock_NSArray_ffiVoid_CGRect_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSArray_ffiVoid_CGRect_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, objc.CGRect))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_CGRect_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    objc.CGRect)>(
            _ObjCBlock_NSArray_ffiVoid_CGRect_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_CGRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.NSArray Function(ffi.Pointer<ffi.Void>,
                  objc.CGRect)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
              objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_CGRect_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> fromFunction(
          objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
          objc.newClosureBlock(
              _ObjCBlock_NSArray_ffiVoid_CGRect_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) =>
                  fn(arg0, arg1).ref.retainAndAutorelease(),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
extension ObjCBlock_NSArray_ffiVoid_CGRect_CallExtension on objc
    .ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) =>
      objc.NSArray.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          objc.CGRect arg1)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      objc.CGRect)>()(ref.pointer, arg0, arg1),
          retain: true,
          release: true);
}

late final _sel_displayLayer_ = objc.registerName("displayLayer:");
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CALayer_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CALayer_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CALayer_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CALayer_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CALayer_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CALayer_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, CALayer) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_CALayer_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, CALayer.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
      listener(void Function(ffi.Pointer<ffi.Void>, CALayer) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
      blocking(void Function(ffi.Pointer<ffi.Void>, CALayer) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_drawLayer_inContext_ =
    objc.registerName("drawLayer:inContext:");
final _objc_msgSend_a4xp11 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGContext>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>)>();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<CGContext> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<CGContext> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGContext>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<CGContext>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<CGContext> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<CGContext>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<CGContext>)>(
            _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<CGContext> arg2) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>)>
    _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGContext>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<CGContext> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<CGContext>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>)>
    _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGContext>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>)>
    _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGContext>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<CGContext> arg2) =>
                      fn(arg0, CALayer.castFromPointer(arg1, retain: true, release: true), arg2),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> listener(
      void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<CGContext> arg2) =>
            fn(
                arg0,
                CALayer.castFromPointer(arg1, retain: false, release: true),
                arg2),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_qvcerx(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer,
            ffi.Pointer<CGContext>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> blocking(
      void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<CGContext> arg2) =>
            fn(
                arg0,
                CALayer.castFromPointer(arg1, retain: false, release: true),
                arg2),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<CGContext> arg2) =>
            fn(
                arg0,
                CALayer.castFromPointer(arg1, retain: false, release: true),
                arg2),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_qvcerx(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer,
            ffi.Pointer<CGContext>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1,
          ffi.Pointer<CGContext> arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<CGContext> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<CGContext>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2);
}

late final _sel_layerWillDraw_ = objc.registerName("layerWillDraw:");
late final _sel_layoutSublayersOfLayer_ =
    objc.registerName("layoutSublayersOfLayer:");
late final _sel_actionForLayer_forKey_ =
    objc.registerName("actionForLayer:forKey:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
abstract final class ObjCBlock_idCAAction_ffiVoid_CALayer_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject>? Function(
                  ffi.Pointer<ffi.Void>,
                  CALayer,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(
              objc.newPointerBlock(
                  _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)> fromFunction(
          CAAction? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(
          objc.newClosureBlock(
              _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2) =>
                  fn(arg0, CALayer.castFromPointer(arg1, retain: true, release: true), objc.NSString.castFromPointer(arg2, retain: true, release: true))?.ref.retainAndAutorelease() ??
                  ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
extension ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>, CALayer, objc.NSString)> {
  CAAction? call(ffi.Pointer<ffi.Void> arg0, CALayer arg1, objc.NSString arg2) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : CAAction.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true);
}

/// WARNING: UITraitOverrides is a stub. To generate bindings for this class, include
/// UITraitOverrides in your config's objc-protocols list.
///
/// UITraitOverrides
interface class UITraitOverrides extends objc.ObjCProtocolBase
    implements UIMutableTraits {
  UITraitOverrides._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UITraitOverrides] that points to the same underlying object as [other].
  UITraitOverrides.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitOverrides] that wraps the given raw object pointer.
  UITraitOverrides.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_traitOverrides = objc.registerName("traitOverrides");
late final _sel_updateTraitsIfNeeded =
    objc.registerName("updateTraitsIfNeeded");

/// WARNING: UITraitChangeRegistration is a stub. To generate bindings for this class, include
/// UITraitChangeRegistration in your config's objc-protocols list.
///
/// UITraitChangeRegistration
interface class UITraitChangeRegistration extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol, objc.NSCopying {
  UITraitChangeRegistration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UITraitChangeRegistration] that points to the same underlying object as [other].
  UITraitChangeRegistration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitChangeRegistration] that wraps the given raw object pointer.
  UITraitChangeRegistration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>`.
abstract final class ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCObject>, UITraitCollection)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)> fromFunction(
          void Function(UITraitEnvironment, UITraitCollection) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  UITraitEnvironment.castFromPointer(arg0, retain: true, release: true),
                  UITraitCollection.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>
      listener(void Function(UITraitEnvironment, UITraitCollection) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITraitEnvironment.castFromPointer(arg0,
                    retain: false, release: true),
                UITraitCollection.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
            UITraitCollection)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>
      blocking(void Function(UITraitEnvironment, UITraitCollection) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITraitEnvironment.castFromPointer(arg0,
                    retain: false, release: true),
                UITraitCollection.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITraitEnvironment.castFromPointer(arg0,
                    retain: false, release: true),
                UITraitCollection.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
            UITraitCollection)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>`.
extension ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)> {
  void call(UITraitEnvironment arg0, UITraitCollection arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

late final _sel_registerForTraitChanges_withHandler_ =
    objc.registerName("registerForTraitChanges:withHandler:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)>`.
abstract final class ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>,
              objc.NSArray,
              objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>,
                      objc.NSArray,
                      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>,
              objc.NSArray,
              objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>,
                      objc.NSArray,
                      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)>(
              objc.newPointerBlock(_ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)>
      fromFunction(UITraitChangeRegistration Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
                      fn(arg0, objc.NSArray.castFromPointer(arg1, retain: true, release: true), ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection.castFromPointer(arg2, retain: true, release: true)).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)>`.
extension ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_UITraitChangeHandler_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSArray,
            objc.ObjCBlock<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject>, UITraitCollection)>)> {
  UITraitChangeRegistration call(
          ffi.Pointer<ffi.Void> arg0,
          objc.NSArray arg1,
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, UITraitCollection)>
              arg2) =>
      UITraitChangeRegistration.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true);
}

late final _sel_registerForTraitChanges_withTarget_action_ =
    objc.registerName("registerForTraitChanges:withTarget:action:");
final _objc_msgSend_15l7zzi = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCSelector> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCSelector> arg3)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCSelector>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCSelector>)>(
            _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCSelector> arg3) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCSelector>)>(
            _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>`.
abstract final class ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>,
              objc.NSArray,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCSelector>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSArray,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCSelector>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<ffi.Void>,
              objc.NSArray,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCSelector>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCSelector> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<ffi.Void>,
                      objc.NSArray,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCSelector>)>(
              objc.newPointerBlock(_ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>
      fromFunction(UITraitChangeRegistration Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.ObjCObjectBase, ffi.Pointer<objc.ObjCSelector>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCSelector> arg3) =>
                      fn(arg0, objc.NSArray.castFromPointer(arg1, retain: true, release: true), objc.ObjCObjectBase(arg2, retain: true, release: true), arg3).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>`.
extension ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCObject_objcObjCSelector_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSArray,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)> {
  UITraitChangeRegistration call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1,
          objc.ObjCObjectBase arg2, ffi.Pointer<objc.ObjCSelector> arg3) =>
      UITraitChangeRegistration.castFromPointer(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2,
                              ffi.Pointer<objc.ObjCSelector> arg3)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCSelector>)>()(
              ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3),
          retain: true,
          release: true);
}

late final _sel_registerForTraitChanges_withAction_ =
    objc.registerName("registerForTraitChanges:withAction:");
final _objc_msgSend_836y90 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCSelector> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCSelector> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCSelector>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCSelector>)>(
            _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCSelector> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCSelector>)>(
            _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCSelector>)>`.
abstract final class ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
              objc.NSArray, ffi.Pointer<objc.ObjCSelector>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                      objc.NSArray, ffi.Pointer<objc.ObjCSelector>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
              objc.NSArray, ffi.Pointer<objc.ObjCSelector>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCSelector> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                      objc.NSArray, ffi.Pointer<objc.ObjCSelector>)>(
              objc.newPointerBlock(_ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCSelector>)>
      fromFunction(UITraitChangeRegistration Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCSelector>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCSelector>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCSelector> arg2) =>
                      fn(arg0, objc.NSArray.castFromPointer(arg1, retain: true, release: true), arg2)
                          .ref
                          .retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray, ffi.Pointer<objc.ObjCSelector>)>`.
extension ObjCBlock_idUITraitChangeRegistration_ffiVoid_NSArray_objcObjCSelector_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
            objc.NSArray, ffi.Pointer<objc.ObjCSelector>)> {
  UITraitChangeRegistration call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1,
          ffi.Pointer<objc.ObjCSelector> arg2) =>
      UITraitChangeRegistration.castFromPointer(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCSelector> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCSelector>)>()(
              ref.pointer, arg0, arg1.ref.pointer, arg2),
          retain: true,
          release: true);
}

late final _sel_unregisterForTraitChanges_ =
    objc.registerName("unregisterForTraitChanges:");
void _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, UITraitChangeRegistration) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, UITraitChangeRegistration.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> listener(
      void Function(ffi.Pointer<ffi.Void>, UITraitChangeRegistration) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UITraitChangeRegistration.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> blocking(
      void Function(ffi.Pointer<ffi.Void>, UITraitChangeRegistration) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UITraitChangeRegistration.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UITraitChangeRegistration.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_idUITraitChangeRegistration_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitChangeRegistration arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

/// UIView
class UIView extends UIResponder
    implements
        objc.NSCoding,
        UIAppearance,
        UIAppearanceContainer,
        UIDynamicItem,
        UITraitEnvironment,
        UICoordinateSpace,
        UIFocusItem,
        UIFocusItemContainer,
        CALayerDelegate {
  UIView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIView] that points to the same underlying object as [other].
  UIView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIView] that wraps the given raw object pointer.
  UIView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIView);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIView.layerClass', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIView, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithFrame:
  UIView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIView.initWithFrame:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIView? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// isUserInteractionEnabled
  bool get userInteractionEnabled {
    objc.checkOsVersionInternal('UIView.isUserInteractionEnabled',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_isUserInteractionEnabled);
  }

  /// setUserInteractionEnabled:
  set userInteractionEnabled(bool value) {
    objc.checkOsVersionInternal('UIView.setUserInteractionEnabled:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setUserInteractionEnabled_, value);
  }

  /// tag
  int get tag {
    objc.checkOsVersionInternal('UIView.tag', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_tag);
  }

  /// setTag:
  set tag(int value) {
    objc.checkOsVersionInternal('UIView.setTag:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setTag_, value);
  }

  /// layer
  CALayer get layer {
    objc.checkOsVersionInternal('UIView.layer', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layer);
    return CALayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// canBecomeFocused
  bool get canBecomeFocused {
    objc.checkOsVersionInternal('UIView.canBecomeFocused',
        iOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canBecomeFocused);
  }

  /// isFocused
  bool get focused {
    objc.checkOsVersionInternal('UIView.isFocused', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFocused);
  }

  /// focusGroupIdentifier
  objc.NSString? get focusGroupIdentifier {
    objc.checkOsVersionInternal('UIView.focusGroupIdentifier',
        iOS: (false, (14, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_focusGroupIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFocusGroupIdentifier:
  set focusGroupIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setFocusGroupIdentifier:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFocusGroupIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// focusGroupPriority
  int get focusGroupPriority {
    objc.checkOsVersionInternal('UIView.focusGroupPriority',
        iOS: (false, (15, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_focusGroupPriority);
  }

  /// setFocusGroupPriority:
  set focusGroupPriority(int value) {
    objc.checkOsVersionInternal('UIView.setFocusGroupPriority:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setFocusGroupPriority_, value);
  }

  /// focusEffect
  UIFocusEffect? get focusEffect {
    objc.checkOsVersionInternal('UIView.focusEffect', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusEffect);
    return _ret.address == 0
        ? null
        : UIFocusEffect.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFocusEffect:
  set focusEffect(UIFocusEffect? value) {
    objc.checkOsVersionInternal('UIView.setFocusEffect:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFocusEffect_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// semanticContentAttribute
  UISemanticContentAttribute get semanticContentAttribute {
    objc.checkOsVersionInternal('UIView.semanticContentAttribute',
        iOS: (false, (9, 0, 0)));
    final _ret =
        _objc_msgSend_i2u4x4(this.ref.pointer, _sel_semanticContentAttribute);
    return UISemanticContentAttribute.fromValue(_ret);
  }

  /// setSemanticContentAttribute:
  set semanticContentAttribute(UISemanticContentAttribute value) {
    objc.checkOsVersionInternal('UIView.setSemanticContentAttribute:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_162qwxu(
        this.ref.pointer, _sel_setSemanticContentAttribute_, value.value);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute(
          UISemanticContentAttribute attribute) {
    objc.checkOsVersionInternal(
        'UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_racczx(
        _class_UIView,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
        attribute.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute$1(
          UISemanticContentAttribute semanticContentAttribute$1,
          {required UIUserInterfaceLayoutDirection relativeToLayoutDirection}) {
    objc.checkOsVersionInternal(
        'UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
        iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_tz4p54(
        _class_UIView,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
        semanticContentAttribute$1.value,
        relativeToLayoutDirection.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// effectiveUserInterfaceLayoutDirection
  UIUserInterfaceLayoutDirection get effectiveUserInterfaceLayoutDirection {
    objc.checkOsVersionInternal('UIView.effectiveUserInterfaceLayoutDirection',
        iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_qj4fey(
        this.ref.pointer, _sel_effectiveUserInterfaceLayoutDirection);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// init
  UIView init() {
    objc.checkOsVersionInternal('UIView.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIView new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIView, _sel_new);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_UIView, _sel_allocWithZone_, zone);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIView alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIView, _sel_alloc);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// appearance
  static UIView appearance() {
    final _ret = _objc_msgSend_151sglz(_class_UIView, _sel_appearance);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UIView appearanceWhenContainedIn(
      UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UIView.appearanceWhenContainedIn:',
        iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_UIView,
        _sel_appearanceWhenContainedIn_,
        ContainerClass?.ref.pointer ?? ffi.nullptr);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UIView appearanceWhenContainedInInstancesOfClasses(
      objc.NSArray containerTypes) {
    objc.checkOsVersionInternal(
        'UIView.appearanceWhenContainedInInstancesOfClasses:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_UIView,
        _sel_appearanceWhenContainedInInstancesOfClasses_,
        containerTypes.ref.pointer);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UIView appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UIView.appearanceForTraitCollection:',
        iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_UIView, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UIView appearanceForTraitCollection$1(UITraitCollection trait,
      {UIAppearanceContainer? whenContainedIn}) {
    objc.checkOsVersionInternal(
        'UIView.appearanceForTraitCollection:whenContainedIn:',
        iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_UIView,
        _sel_appearanceForTraitCollection_whenContainedIn_,
        trait.ref.pointer,
        whenContainedIn?.ref.pointer ?? ffi.nullptr);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIView appearanceForTraitCollection$2(UITraitCollection trait,
      {required objc.NSArray whenContainedInInstancesOfClasses}) {
    objc.checkOsVersionInternal(
        'UIView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_UIView,
        _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
        trait.ref.pointer,
        whenContainedInInstancesOfClasses.ref.pointer);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// center
  objc.CGPoint get center {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(_ptr, this.ref.pointer, _sel_center)
        : _ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_center);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// setCenter:
  set center(objc.CGPoint value) {
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setCenter_, value);
  }

  /// bounds
  objc.CGRect get bounds {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_bounds)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_bounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// transform
  CGAffineTransform get transform {
    final _ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret(_ptr, this.ref.pointer, _sel_transform)
        : _ptr.ref = _objc_msgSend_5qswvj(this.ref.pointer, _sel_transform);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGAffineTransform>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGAffineTransform>(_finalizable);
  }

  /// setTransform:
  set transform(CGAffineTransform value) {
    _objc_msgSend_qgt66z(this.ref.pointer, _sel_setTransform_, value);
  }

  /// collisionBoundsType
  UIDynamicItemCollisionBoundsType get collisionBoundsType {
    objc.checkOsVersionInternal('UIView.collisionBoundsType',
        iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_collisionBoundsType)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'collisionBoundsType');
    }
    final _ret =
        _objc_msgSend_k9iunc(this.ref.pointer, _sel_collisionBoundsType);
    return UIDynamicItemCollisionBoundsType.fromValue(_ret);
  }

  /// collisionBoundingPath
  UIBezierPath get collisionBoundingPath {
    objc.checkOsVersionInternal('UIView.collisionBoundingPath',
        iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_collisionBoundingPath)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'collisionBoundingPath');
    }
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_collisionBoundingPath);
    return UIBezierPath.castFromPointer(_ret, retain: true, release: true);
  }

  /// traitCollection
  UITraitCollection get traitCollection {
    objc.checkOsVersionInternal('UIView.traitCollection',
        iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_traitCollection);
    return UITraitCollection.castFromPointer(_ret, retain: true, release: true);
  }

  /// traitCollectionDidChange:
  void traitCollectionDidChange(UITraitCollection? previousTraitCollection) {
    objc.checkOsVersionInternal('UIView.traitCollectionDidChange:',
        iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_traitCollectionDidChange_,
        previousTraitCollection?.ref.pointer ?? ffi.nullptr);
  }

  /// convertPoint:toCoordinateSpace:
  objc.CGPoint convertPoint(objc.CGPoint point,
      {required UICoordinateSpace toCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertPoint:toCoordinateSpace:',
        iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_toCoordinateSpace_,
            point,
            toCoordinateSpace.ref.pointer)
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_toCoordinateSpace_,
            point,
            toCoordinateSpace.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertPoint:fromCoordinateSpace:
  objc.CGPoint convertPoint$1(objc.CGPoint point,
      {required UICoordinateSpace fromCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertPoint:fromCoordinateSpace:',
        iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_fromCoordinateSpace_,
            point,
            fromCoordinateSpace.ref.pointer)
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_fromCoordinateSpace_,
            point,
            fromCoordinateSpace.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertRect:toCoordinateSpace:
  objc.CGRect convertRect(objc.CGRect rect,
      {required UICoordinateSpace toCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertRect:toCoordinateSpace:',
        iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_toCoordinateSpace_,
            rect,
            toCoordinateSpace.ref.pointer)
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_toCoordinateSpace_,
            rect,
            toCoordinateSpace.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// convertRect:fromCoordinateSpace:
  objc.CGRect convertRect$1(objc.CGRect rect,
      {required UICoordinateSpace fromCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertRect:fromCoordinateSpace:',
        iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_fromCoordinateSpace_,
            rect,
            fromCoordinateSpace.ref.pointer)
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_fromCoordinateSpace_,
            rect,
            fromCoordinateSpace.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (12, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_frame)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_frame);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// focusItemDeferralMode
  UIFocusItemDeferralMode get focusItemDeferralMode {
    objc.checkOsVersionInternal('UIView.focusItemDeferralMode',
        iOS: (false, (10, 0, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_focusItemDeferralMode)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'focusItemDeferralMode');
    }
    final _ret =
        _objc_msgSend_1lv2zxu(this.ref.pointer, _sel_focusItemDeferralMode);
    return UIFocusItemDeferralMode.fromValue(_ret);
  }

  /// isTransparentFocusItem
  bool get isTransparentFocusItem {
    objc.checkOsVersionInternal('UIView.isTransparentFocusItem',
        iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_isTransparentFocusItem)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'isTransparentFocusItem');
    }
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTransparentFocusItem);
  }

  /// didHintFocusMovement:
  void didHintFocusMovement(UIFocusMovementHint hint) {
    objc.checkOsVersionInternal('UIView.didHintFocusMovement:',
        iOS: (false, (12, 0, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_didHintFocusMovement_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'didHintFocusMovement:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_didHintFocusMovement_, hint.ref.pointer);
  }

  /// preferredFocusEnvironments
  objc.NSArray get preferredFocusEnvironments {
    objc.checkOsVersionInternal('UIView.preferredFocusEnvironments',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_preferredFocusEnvironments);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// parentFocusEnvironment
  UIFocusEnvironment? get parentFocusEnvironment {
    objc.checkOsVersionInternal('UIView.parentFocusEnvironment',
        iOS: (false, (12, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_parentFocusEnvironment);
    return _ret.address == 0
        ? null
        : UIFocusEnvironment.castFromPointer(_ret, retain: true, release: true);
  }

  /// focusItemContainer
  UIFocusItemContainer? get focusItemContainer {
    objc.checkOsVersionInternal('UIView.focusItemContainer',
        iOS: (false, (12, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_focusItemContainer);
    return _ret.address == 0
        ? null
        : UIFocusItemContainer.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setNeedsFocusUpdate
  void setNeedsFocusUpdate() {
    objc.checkOsVersionInternal('UIView.setNeedsFocusUpdate',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsFocusUpdate);
  }

  /// updateFocusIfNeeded
  void updateFocusIfNeeded() {
    objc.checkOsVersionInternal('UIView.updateFocusIfNeeded',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateFocusIfNeeded);
  }

  /// shouldUpdateFocusInContext:
  bool shouldUpdateFocusInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIView.shouldUpdateFocusInContext:',
        iOS: (false, (9, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer,
        _sel_shouldUpdateFocusInContext_, context.ref.pointer);
  }

  /// didUpdateFocusInContext:withAnimationCoordinator:
  void didUpdateFocusInContext(UIFocusUpdateContext context,
      {required UIFocusAnimationCoordinator withAnimationCoordinator}) {
    objc.checkOsVersionInternal(
        'UIView.didUpdateFocusInContext:withAnimationCoordinator:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_didUpdateFocusInContext_withAnimationCoordinator_,
        context.ref.pointer,
        withAnimationCoordinator.ref.pointer);
  }

  /// soundIdentifierForFocusUpdateInContext:
  objc.NSString? soundIdentifierForFocusUpdateInContext(
      UIFocusUpdateContext context) {
    objc.checkOsVersionInternal(
        'UIView.soundIdentifierForFocusUpdateInContext:',
        iOS: (true, null));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_soundIdentifierForFocusUpdateInContext_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'soundIdentifierForFocusUpdateInContext:');
    }
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_soundIdentifierForFocusUpdateInContext_, context.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredFocusedView
  UIView? get preferredFocusedView {
    objc.checkOsVersionInternal('UIView.preferredFocusedView',
        iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_preferredFocusedView)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'preferredFocusedView');
    }
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusedView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// coordinateSpace
  UICoordinateSpace get coordinateSpace {
    objc.checkOsVersionInternal('UIView.coordinateSpace',
        iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_coordinateSpace);
    return UICoordinateSpace.castFromPointer(_ret, retain: true, release: true);
  }

  /// focusItemsInRect:
  objc.NSArray focusItemsInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.focusItemsInRect:',
        iOS: (false, (12, 0, 0)));
    final _ret =
        _objc_msgSend_15yz4e6(this.ref.pointer, _sel_focusItemsInRect_, rect);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// displayLayer:
  void displayLayer(CALayer layer$1) {
    objc.checkOsVersionInternal('UIView.displayLayer:',
        iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_displayLayer_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'displayLayer:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_displayLayer_, layer$1.ref.pointer);
  }

  /// drawLayer:inContext:
  void drawLayer(CALayer layer$1, {required ffi.Pointer<CGContext> inContext}) {
    objc.checkOsVersionInternal('UIView.drawLayer:inContext:',
        iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_drawLayer_inContext_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'drawLayer:inContext:');
    }
    _objc_msgSend_a4xp11(this.ref.pointer, _sel_drawLayer_inContext_,
        layer$1.ref.pointer, inContext);
  }

  /// layerWillDraw:
  void layerWillDraw(CALayer layer$1) {
    objc.checkOsVersionInternal('UIView.layerWillDraw:',
        iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_layerWillDraw_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'layerWillDraw:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_layerWillDraw_, layer$1.ref.pointer);
  }

  /// layoutSublayersOfLayer:
  void layoutSublayersOfLayer(CALayer layer$1) {
    objc.checkOsVersionInternal('UIView.layoutSublayersOfLayer:',
        iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_layoutSublayersOfLayer_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'layoutSublayersOfLayer:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_layoutSublayersOfLayer_, layer$1.ref.pointer);
  }

  /// actionForLayer:forKey:
  CAAction? actionForLayer(CALayer layer$1, {required objc.NSString forKey}) {
    objc.checkOsVersionInternal('UIView.actionForLayer:forKey:',
        iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_actionForLayer_forKey_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIView', 'actionForLayer:forKey:');
    }
    final _ret = _objc_msgSend_15qeuct(this.ref.pointer,
        _sel_actionForLayer_forKey_, layer$1.ref.pointer, forKey.ref.pointer);
    return _ret.address == 0
        ? null
        : CAAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// traitOverrides
  UITraitOverrides get traitOverrides {
    objc.checkOsVersionInternal('UIView.traitOverrides',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_traitOverrides);
    return UITraitOverrides.castFromPointer(_ret, retain: true, release: true);
  }

  /// updateTraitsIfNeeded
  void updateTraitsIfNeeded() {
    objc.checkOsVersionInternal('UIView.updateTraitsIfNeeded',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateTraitsIfNeeded);
  }

  /// registerForTraitChanges:withHandler:
  UITraitChangeRegistration registerForTraitChanges(objc.NSArray traits,
      {required objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>, UITraitCollection)>
          withHandler}) {
    objc.checkOsVersionInternal('UIView.registerForTraitChanges:withHandler:',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_registerForTraitChanges_withHandler_,
        traits.ref.pointer,
        withHandler.ref.pointer);
    return UITraitChangeRegistration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// registerForTraitChanges:withTarget:action:
  UITraitChangeRegistration registerForTraitChanges$1(objc.NSArray traits,
      {required objc.ObjCObjectBase withTarget,
      required ffi.Pointer<objc.ObjCSelector> action}) {
    objc.checkOsVersionInternal(
        'UIView.registerForTraitChanges:withTarget:action:',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_15l7zzi(
        this.ref.pointer,
        _sel_registerForTraitChanges_withTarget_action_,
        traits.ref.pointer,
        withTarget.ref.pointer,
        action);
    return UITraitChangeRegistration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// registerForTraitChanges:withAction:
  UITraitChangeRegistration registerForTraitChanges$2(objc.NSArray traits,
      {required ffi.Pointer<objc.ObjCSelector> withAction}) {
    objc.checkOsVersionInternal('UIView.registerForTraitChanges:withAction:',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_836y90(
        this.ref.pointer,
        _sel_registerForTraitChanges_withAction_,
        traits.ref.pointer,
        withAction);
    return UITraitChangeRegistration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// unregisterForTraitChanges:
  void unregisterForTraitChanges(UITraitChangeRegistration registration) {
    objc.checkOsVersionInternal('UIView.unregisterForTraitChanges:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_unregisterForTraitChanges_,
        registration.ref.pointer);
  }

  /// Returns a new instance of UIView constructed with the default `new` method.
  factory UIView() => new$();
}

late final _sel_inputView = objc.registerName("inputView");
late final _sel_inputAccessoryView = objc.registerName("inputAccessoryView");

/// WARNING: UITextInputAssistantItem is a stub. To generate bindings for this class, include
/// UITextInputAssistantItem in your config's objc-interfaces list.
///
/// UITextInputAssistantItem
class UITextInputAssistantItem extends objc.NSObject {
  UITextInputAssistantItem._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputAssistantItem',
        iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UITextInputAssistantItem] that points to the same underlying object as [other].
  UITextInputAssistantItem.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputAssistantItem] that wraps the given raw object pointer.
  UITextInputAssistantItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_inputAssistantItem = objc.registerName("inputAssistantItem");

/// WARNING: UIInputViewController is a stub. To generate bindings for this class, include
/// UIInputViewController in your config's objc-interfaces list.
///
/// UIInputViewController
class UIInputViewController extends UIViewController
    implements UITextInputDelegate {
  UIInputViewController._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIInputViewController',
        iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UIInputViewController] that points to the same underlying object as [other].
  UIInputViewController.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIInputViewController] that wraps the given raw object pointer.
  UIInputViewController.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_inputViewController = objc.registerName("inputViewController");
late final _sel_inputAccessoryViewController =
    objc.registerName("inputAccessoryViewController");

/// WARNING: UITextInputMode is a stub. To generate bindings for this class, include
/// UITextInputMode in your config's objc-interfaces list.
///
/// UITextInputMode
class UITextInputMode extends objc.NSObject implements objc.NSSecureCoding {
  UITextInputMode._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UITextInputMode] that points to the same underlying object as [other].
  UITextInputMode.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputMode] that wraps the given raw object pointer.
  UITextInputMode.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_textInputMode = objc.registerName("textInputMode");
late final _sel_textInputContextIdentifier =
    objc.registerName("textInputContextIdentifier");
late final _sel_clearTextInputContextIdentifier_ =
    objc.registerName("clearTextInputContextIdentifier:");
late final _sel_reloadInputViews = objc.registerName("reloadInputViews");

/// UIResponderInputViewAdditions
extension UIResponderInputViewAdditions on UIResponder {
  /// inputView
  UIView? get inputView {
    objc.checkOsVersionInternal('UIResponder.inputView',
        iOS: (false, (3, 2, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// inputAccessoryView
  UIView? get inputAccessoryView {
    objc.checkOsVersionInternal('UIResponder.inputAccessoryView',
        iOS: (false, (3, 2, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_inputAccessoryView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// inputAssistantItem
  UITextInputAssistantItem get inputAssistantItem {
    objc.checkOsVersionInternal('UIResponder.inputAssistantItem',
        iOS: (false, (9, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_inputAssistantItem);
    return UITextInputAssistantItem.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// inputViewController
  UIInputViewController? get inputViewController {
    objc.checkOsVersionInternal('UIResponder.inputViewController',
        iOS: (false, (8, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_inputViewController);
    return _ret.address == 0
        ? null
        : UIInputViewController.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// inputAccessoryViewController
  UIInputViewController? get inputAccessoryViewController {
    objc.checkOsVersionInternal('UIResponder.inputAccessoryViewController',
        iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_inputAccessoryViewController);
    return _ret.address == 0
        ? null
        : UIInputViewController.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// textInputMode
  UITextInputMode? get textInputMode {
    objc.checkOsVersionInternal('UIResponder.textInputMode',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textInputMode);
    return _ret.address == 0
        ? null
        : UITextInputMode.castFromPointer(_ret, retain: true, release: true);
  }

  /// textInputContextIdentifier
  objc.NSString? get textInputContextIdentifier {
    objc.checkOsVersionInternal('UIResponder.textInputContextIdentifier',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_textInputContextIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// clearTextInputContextIdentifier:
  static void clearTextInputContextIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal('UIResponder.clearTextInputContextIdentifier:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(_class_UIResponder,
        _sel_clearTextInputContextIdentifier_, identifier.ref.pointer);
  }

  /// reloadInputViews
  void reloadInputViews() {
    objc.checkOsVersionInternal('UIResponder.reloadInputViews',
        iOS: (false, (3, 2, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_reloadInputViews);
  }
}

late final _sel_userActivity = objc.registerName("userActivity");
late final _sel_setUserActivity_ = objc.registerName("setUserActivity:");
late final _sel_updateUserActivityState_ =
    objc.registerName("updateUserActivityState:");
late final _sel_restoreUserActivityState_ =
    objc.registerName("restoreUserActivityState:");
void _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUserActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
          pointer,
          retain: retain,
          release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, NSUserActivity.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>
      listener(void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>
      blocking(void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSUserActivity arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

/// ActivityContinuation
extension ActivityContinuation on UIResponder {
  /// userActivity
  NSUserActivity? get userActivity {
    objc.checkOsVersionInternal('UIResponder.userActivity',
        iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_userActivity);
    return _ret.address == 0
        ? null
        : NSUserActivity.castFromPointer(_ret, retain: true, release: true);
  }

  /// setUserActivity:
  set userActivity(NSUserActivity? value) {
    objc.checkOsVersionInternal('UIResponder.setUserActivity:',
        iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setUserActivity_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// updateUserActivityState:
  void updateUserActivityState(NSUserActivity activity) {
    objc.checkOsVersionInternal('UIResponder.updateUserActivityState:',
        iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_updateUserActivityState_, activity.ref.pointer);
  }

  /// restoreUserActivityState:
  void restoreUserActivityState(NSUserActivity userActivity$1) {
    objc.checkOsVersionInternal('UIResponder.restoreUserActivityState:',
        iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_restoreUserActivityState_,
        userActivity$1.ref.pointer);
  }
}

/// WARNING: UIPasteConfiguration is a stub. To generate bindings for this class, include
/// UIPasteConfiguration in your config's objc-interfaces list.
///
/// UIPasteConfiguration
class UIPasteConfiguration extends objc.NSObject
    implements objc.NSSecureCoding, objc.NSCopying {
  UIPasteConfiguration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPasteConfiguration',
        iOS: (false, (11, 0, 0)));
  }

  /// Constructs a [UIPasteConfiguration] that points to the same underlying object as [other].
  UIPasteConfiguration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPasteConfiguration] that wraps the given raw object pointer.
  UIPasteConfiguration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_pasteConfiguration = objc.registerName("pasteConfiguration");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UIPasteConfiguration_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIPasteConfiguration_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIPasteConfiguration_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UIPasteConfiguration_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIPasteConfiguration_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIPasteConfiguration_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIPasteConfiguration_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIPasteConfiguration_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_UIPasteConfiguration_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIPasteConfiguration_ffiVoid_CallExtension
    on objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)> {
  UIPasteConfiguration? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIPasteConfiguration.castFromPointer(
          ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>().asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_setPasteConfiguration_ =
    objc.registerName("setPasteConfiguration:");
void _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0,
                  arg1.address == 0
                      ? null
                      : UIPasteConfiguration.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>
      listener(void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UIPasteConfiguration.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UIPasteConfiguration?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>
      blocking(void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UIPasteConfiguration.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UIPasteConfiguration.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UIPasteConfiguration?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIPasteConfiguration? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_pasteItemProviders_ = objc.registerName("pasteItemProviders:");
void _ObjCBlock_ffiVoid_ffiVoid_NSArray_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSArray_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSArray_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSArray_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSArray_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSArray_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSArray_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSArray_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSArray_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSArray_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSArray_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSArray_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSArray_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSArray_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSArray.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSArray_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSArray.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSArray_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSArray.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSArray_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSArray.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSArray_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_canPasteItemProviders_ =
    objc.registerName("canPasteItemProviders:");
bool _ObjCBlock_bool_ffiVoid_NSArray_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_NSArray_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_NSArray_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_NSArray_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<ffi.Void>,
                  objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
          objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_NSArray_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_NSArray_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSArray.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_bool_ffiVoid_NSArray_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  bool call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

/// UIPasteConfigurationSupporting
extension UIPasteConfigurationSupporting$1 on UIResponder {
  /// pasteConfiguration
  UIPasteConfiguration? get pasteConfiguration {
    objc.checkOsVersionInternal('UIResponder.pasteConfiguration',
        iOS: (false, (11, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_pasteConfiguration);
    return _ret.address == 0
        ? null
        : UIPasteConfiguration.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setPasteConfiguration:
  set pasteConfiguration(UIPasteConfiguration? value) {
    objc.checkOsVersionInternal('UIResponder.setPasteConfiguration:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPasteConfiguration_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteItemProviders:
  void pasteItemProviders(objc.NSArray itemProviders) {
    objc.checkOsVersionInternal('UIResponder.pasteItemProviders:',
        iOS: (false, (11, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteItemProviders_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'pasteItemProviders:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_pasteItemProviders_, itemProviders.ref.pointer);
  }

  /// canPasteItemProviders:
  bool canPasteItemProviders(objc.NSArray itemProviders) {
    objc.checkOsVersionInternal('UIResponder.canPasteItemProviders:',
        iOS: (false, (11, 0, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_canPasteItemProviders_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'canPasteItemProviders:');
    }
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_canPasteItemProviders_,
        itemProviders.ref.pointer);
  }
}

late final _sel_captureTextFromCamera_ =
    objc.registerName("captureTextFromCamera:");

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting on UIResponder {
  /// captureTextFromCamera:
  void captureTextFromCamera(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.captureTextFromCamera:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_captureTextFromCamera_,
        sender?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UIActivityItemsConfigurationProviding is a stub. To generate bindings for this class, include
/// UIActivityItemsConfigurationProviding in your config's objc-protocols list.
///
/// UIActivityItemsConfigurationProviding
interface class UIActivityItemsConfigurationProviding
    extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIActivityItemsConfigurationProviding._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIActivityItemsConfigurationProviding] that points to the same underlying object as [other].
  UIActivityItemsConfigurationProviding.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIActivityItemsConfigurationProviding] that wraps the given raw object pointer.
  UIActivityItemsConfigurationProviding.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UIActivityItemsConfigurationReading is a stub. To generate bindings for this class, include
/// UIActivityItemsConfigurationReading in your config's objc-protocols list.
///
/// UIActivityItemsConfigurationReading
interface class UIActivityItemsConfigurationReading
    extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIActivityItemsConfigurationReading._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIActivityItemsConfigurationReading] that points to the same underlying object as [other].
  UIActivityItemsConfigurationReading.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIActivityItemsConfigurationReading] that wraps the given raw object pointer.
  UIActivityItemsConfigurationReading.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_activityItemsConfiguration =
    objc.registerName("activityItemsConfiguration");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIActivityItemsConfigurationReading? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid_CallExtension
    on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIActivityItemsConfigurationReading? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
                  (ref.pointer, arg0)
                  .address ==
              0
          ? null
          : UIActivityItemsConfigurationReading.castFromPointer(
              ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>().asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
              retain: true,
              release: true);
}

late final _sel_setActivityItemsConfiguration_ =
    objc.registerName("setActivityItemsConfiguration:");

/// UIActivityItemsConfiguration
extension UIActivityItemsConfiguration on UIResponder {
  /// activityItemsConfiguration
  UIActivityItemsConfigurationReading? get activityItemsConfiguration {
    objc.checkOsVersionInternal('UIResponder.activityItemsConfiguration',
        iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_activityItemsConfiguration);
    return _ret.address == 0
        ? null
        : UIActivityItemsConfigurationReading.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setActivityItemsConfiguration:
  set activityItemsConfiguration$1(UIActivityItemsConfigurationReading? value) {
    objc.checkOsVersionInternal('UIResponder.setActivityItemsConfiguration:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setActivityItemsConfiguration_,
        value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_nextResponder = objc.registerName("nextResponder");
late final _sel_canBecomeFirstResponder =
    objc.registerName("canBecomeFirstResponder");
late final _sel_becomeFirstResponder =
    objc.registerName("becomeFirstResponder");
late final _sel_canResignFirstResponder =
    objc.registerName("canResignFirstResponder");
late final _sel_resignFirstResponder =
    objc.registerName("resignFirstResponder");
late final _sel_isFirstResponder = objc.registerName("isFirstResponder");
late final _sel_touchesBegan_withEvent_ =
    objc.registerName("touchesBegan:withEvent:");
late final _sel_touchesMoved_withEvent_ =
    objc.registerName("touchesMoved:withEvent:");
late final _sel_touchesEnded_withEvent_ =
    objc.registerName("touchesEnded:withEvent:");
late final _sel_touchesCancelled_withEvent_ =
    objc.registerName("touchesCancelled:withEvent:");
late final _sel_touchesEstimatedPropertiesUpdated_ =
    objc.registerName("touchesEstimatedPropertiesUpdated:");

/// WARNING: UIPressesEvent is a stub. To generate bindings for this class, include
/// UIPressesEvent in your config's objc-interfaces list.
///
/// UIPressesEvent
class UIPressesEvent extends UIEvent {
  UIPressesEvent._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPressesEvent', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIPressesEvent] that points to the same underlying object as [other].
  UIPressesEvent.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPressesEvent] that wraps the given raw object pointer.
  UIPressesEvent.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_pressesBegan_withEvent_ =
    objc.registerName("pressesBegan:withEvent:");
late final _sel_pressesChanged_withEvent_ =
    objc.registerName("pressesChanged:withEvent:");
late final _sel_pressesEnded_withEvent_ =
    objc.registerName("pressesEnded:withEvent:");
late final _sel_pressesCancelled_withEvent_ =
    objc.registerName("pressesCancelled:withEvent:");
late final _sel_motionBegan_withEvent_ =
    objc.registerName("motionBegan:withEvent:");
final _objc_msgSend_pov02z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_motionEnded_withEvent_ =
    objc.registerName("motionEnded:withEvent:");
late final _sel_motionCancelled_withEvent_ =
    objc.registerName("motionCancelled:withEvent:");
late final _sel_remoteControlReceivedWithEvent_ =
    objc.registerName("remoteControlReceivedWithEvent:");
late final _sel_canPerformAction_withSender_ =
    objc.registerName("canPerformAction:withSender:");
final _objc_msgSend_1f04296 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_targetForAction_withSender_ =
    objc.registerName("targetForAction:withSender:");
final _objc_msgSend_gx50so = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>)>();

/// WARNING: UIMenuBuilder is a stub. To generate bindings for this class, include
/// UIMenuBuilder in your config's objc-protocols list.
///
/// UIMenuBuilder
interface class UIMenuBuilder extends objc.ObjCProtocolBase {
  UIMenuBuilder._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIMenuBuilder] that points to the same underlying object as [other].
  UIMenuBuilder.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenuBuilder] that wraps the given raw object pointer.
  UIMenuBuilder.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_buildMenuWithBuilder_ =
    objc.registerName("buildMenuWithBuilder:");
late final _sel_validateCommand_ = objc.registerName("validateCommand:");
late final _sel_undoManager = objc.registerName("undoManager");
late final _sel_editingInteractionConfiguration =
    objc.registerName("editingInteractionConfiguration");
final _objc_msgSend_15pfzxv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_cut_ = objc.registerName("cut:");
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> listener(
      void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_copy_ = objc.registerName("copy:");
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<
              objc.Retained<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      objc.Retained<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> listener(
      void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            objc.Retained<ffi.Void> Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      objc.Retained<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            objc.Retained<ffi.Void> Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_CallExtension
    on objc.ObjCBlock<
        objc.Retained<ffi.Void> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_paste_ = objc.registerName("paste:");
late final _sel_pasteAndMatchStyle_ = objc.registerName("pasteAndMatchStyle:");
late final _sel_pasteAndGo_ = objc.registerName("pasteAndGo:");
late final _sel_pasteAndSearch_ = objc.registerName("pasteAndSearch:");
late final _sel_select_ = objc.registerName("select:");
late final _sel_selectAll_ = objc.registerName("selectAll:");
late final _sel_delete_ = objc.registerName("delete:");
late final _sel_makeTextWritingDirectionLeftToRight_ =
    objc.registerName("makeTextWritingDirectionLeftToRight:");
late final _sel_makeTextWritingDirectionRightToLeft_ =
    objc.registerName("makeTextWritingDirectionRightToLeft:");
late final _sel_toggleBoldface_ = objc.registerName("toggleBoldface:");
late final _sel_toggleItalics_ = objc.registerName("toggleItalics:");
late final _sel_toggleUnderline_ = objc.registerName("toggleUnderline:");
late final _sel_increaseSize_ = objc.registerName("increaseSize:");
late final _sel_decreaseSize_ = objc.registerName("decreaseSize:");
late final _sel_find_ = objc.registerName("find:");
late final _sel_findAndReplace_ = objc.registerName("findAndReplace:");
late final _sel_findNext_ = objc.registerName("findNext:");
late final _sel_findPrevious_ = objc.registerName("findPrevious:");
late final _sel_useSelectionForFind_ =
    objc.registerName("useSelectionForFind:");
late final _sel_updateTextAttributesWithConversionHandler_ =
    objc.registerName("updateTextAttributesWithConversionHandler:");
void _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
          void Function(objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                  ? null
                  : objc.NSError.castFromPointer(arg0,
                      retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
      void Function(objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
      void Function(objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

void
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCBlockImpl> arg1)>>()
            .asFunction<
                void Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
        (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCBlockImpl> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCBlockImpl> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
              fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
                  fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>
      listener(
          void Function(ffi.Pointer<ffi.Void>,
                  objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
              fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
            fn(
                arg0,
                ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1l4hxwm(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>,
                objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>
      blocking(
          void Function(ffi.Pointer<ffi.Void>,
                  objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
              fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
            fn(
                arg0,
                ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
            fn(
                arg0,
                ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1l4hxwm(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>,
                objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)> {
  void call(ffi.Pointer<ffi.Void> arg0,
          objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCBlockImpl> arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_print_ = objc.registerName("print:");
late final _sel_rename_ = objc.registerName("rename:");
late final _sel_duplicate_ = objc.registerName("duplicate:");
late final _sel_move_ = objc.registerName("move:");
late final _sel_export_ = objc.registerName("export:");
late final _sel_showWritingTools_ = objc.registerName("showWritingTools:");
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.ObjCObjectBase(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> listener(
      void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(arg0, objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> blocking(
      void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(arg0, objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(arg0, objc.ObjCObjectBase(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$2_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

/// UIResponder
class UIResponder extends objc.NSObject
    implements UIResponderStandardEditActions {
  UIResponder._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIResponder] that points to the same underlying object as [other].
  UIResponder.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIResponder] that wraps the given raw object pointer.
  UIResponder.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIResponder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIResponder);
  }

  /// nextResponder
  UIResponder? get nextResponder {
    objc.checkOsVersionInternal('UIResponder.nextResponder',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_nextResponder);
    return _ret.address == 0
        ? null
        : UIResponder.castFromPointer(_ret, retain: true, release: true);
  }

  /// canBecomeFirstResponder
  bool get canBecomeFirstResponder {
    objc.checkOsVersionInternal('UIResponder.canBecomeFirstResponder',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canBecomeFirstResponder);
  }

  /// becomeFirstResponder
  bool becomeFirstResponder() {
    objc.checkOsVersionInternal('UIResponder.becomeFirstResponder',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_becomeFirstResponder);
  }

  /// canResignFirstResponder
  bool get canResignFirstResponder {
    objc.checkOsVersionInternal('UIResponder.canResignFirstResponder',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canResignFirstResponder);
  }

  /// resignFirstResponder
  bool resignFirstResponder() {
    objc.checkOsVersionInternal('UIResponder.resignFirstResponder',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_resignFirstResponder);
  }

  /// isFirstResponder
  bool get isFirstResponder {
    objc.checkOsVersionInternal('UIResponder.isFirstResponder',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFirstResponder);
  }

  /// touchesBegan:withEvent:
  void touchesBegan(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesBegan:withEvent:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_touchesBegan_withEvent_,
        touches.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// touchesMoved:withEvent:
  void touchesMoved(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesMoved:withEvent:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_touchesMoved_withEvent_,
        touches.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// touchesEnded:withEvent:
  void touchesEnded(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesEnded:withEvent:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_touchesEnded_withEvent_,
        touches.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// touchesCancelled:withEvent:
  void touchesCancelled(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesCancelled:withEvent:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_touchesCancelled_withEvent_,
        touches.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// touchesEstimatedPropertiesUpdated:
  void touchesEstimatedPropertiesUpdated(objc.NSSet touches) {
    objc.checkOsVersionInternal(
        'UIResponder.touchesEstimatedPropertiesUpdated:',
        iOS: (false, (9, 1, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_touchesEstimatedPropertiesUpdated_, touches.ref.pointer);
  }

  /// pressesBegan:withEvent:
  void pressesBegan(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesBegan:withEvent:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_pressesBegan_withEvent_,
        presses.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// pressesChanged:withEvent:
  void pressesChanged(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesChanged:withEvent:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_pressesChanged_withEvent_,
        presses.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// pressesEnded:withEvent:
  void pressesEnded(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesEnded:withEvent:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_pressesEnded_withEvent_,
        presses.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// pressesCancelled:withEvent:
  void pressesCancelled(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesCancelled:withEvent:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_pressesCancelled_withEvent_,
        presses.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// motionBegan:withEvent:
  void motionBegan(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionBegan:withEvent:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(this.ref.pointer, _sel_motionBegan_withEvent_,
        motion.value, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// motionEnded:withEvent:
  void motionEnded(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionEnded:withEvent:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(this.ref.pointer, _sel_motionEnded_withEvent_,
        motion.value, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// motionCancelled:withEvent:
  void motionCancelled(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionCancelled:withEvent:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(this.ref.pointer, _sel_motionCancelled_withEvent_,
        motion.value, withEvent?.ref.pointer ?? ffi.nullptr);
  }

  /// remoteControlReceivedWithEvent:
  void remoteControlReceivedWithEvent(UIEvent? event) {
    objc.checkOsVersionInternal('UIResponder.remoteControlReceivedWithEvent:',
        iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_remoteControlReceivedWithEvent_,
        event?.ref.pointer ?? ffi.nullptr);
  }

  /// canPerformAction:withSender:
  bool canPerformAction(ffi.Pointer<objc.ObjCSelector> action,
      {objc.ObjCObjectBase? withSender}) {
    objc.checkOsVersionInternal('UIResponder.canPerformAction:withSender:',
        iOS: (false, (3, 0, 0)));
    return _objc_msgSend_1f04296(
        this.ref.pointer,
        _sel_canPerformAction_withSender_,
        action,
        withSender?.ref.pointer ?? ffi.nullptr);
  }

  /// targetForAction:withSender:
  objc.ObjCObjectBase? targetForAction(ffi.Pointer<objc.ObjCSelector> action,
      {objc.ObjCObjectBase? withSender}) {
    objc.checkOsVersionInternal('UIResponder.targetForAction:withSender:',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_gx50so(
        this.ref.pointer,
        _sel_targetForAction_withSender_,
        action,
        withSender?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// buildMenuWithBuilder:
  void buildMenuWithBuilder(UIMenuBuilder builder) {
    objc.checkOsVersionInternal('UIResponder.buildMenuWithBuilder:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_buildMenuWithBuilder_, builder.ref.pointer);
  }

  /// validateCommand:
  void validateCommand(UICommand command) {
    objc.checkOsVersionInternal('UIResponder.validateCommand:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_validateCommand_, command.ref.pointer);
  }

  /// undoManager
  NSUndoManager? get undoManager {
    objc.checkOsVersionInternal('UIResponder.undoManager',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_undoManager);
    return _ret.address == 0
        ? null
        : NSUndoManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// editingInteractionConfiguration
  UIEditingInteractionConfiguration get editingInteractionConfiguration {
    objc.checkOsVersionInternal('UIResponder.editingInteractionConfiguration',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_15pfzxv(
        this.ref.pointer, _sel_editingInteractionConfiguration);
    return UIEditingInteractionConfiguration.fromValue(_ret);
  }

  /// init
  UIResponder init() {
    objc.checkOsVersionInternal('UIResponder.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIResponder new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_new);
    return UIResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIResponder allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_UIResponder, _sel_allocWithZone_, zone);
    return UIResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIResponder alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_alloc);
    return UIResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// cut:
  void cut(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.cut:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_cut_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'cut:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_cut_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// copy:
  void copy2(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.copy:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_copy_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'copy:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_copy_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// paste:
  void paste(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.paste:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_paste_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'paste:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_paste_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndMatchStyle:
  void pasteAndMatchStyle(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndMatchStyle:',
        iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndMatchStyle_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'pasteAndMatchStyle:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_pasteAndMatchStyle_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndGo:
  void pasteAndGo(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndGo:',
        iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndGo_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'pasteAndGo:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_pasteAndGo_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndSearch:
  void pasteAndSearch(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndSearch:',
        iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndSearch_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'pasteAndSearch:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_pasteAndSearch_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// select:
  void select(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.select:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_select_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'select:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_select_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// selectAll:
  void selectAll(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.selectAll:',
        iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_selectAll_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'selectAll:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_selectAll_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// delete:
  void delete(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.delete:', iOS: (false, (3, 2, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_delete_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'delete:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_delete_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// makeTextWritingDirectionLeftToRight:
  void makeTextWritingDirectionLeftToRight(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal(
        'UIResponder.makeTextWritingDirectionLeftToRight:',
        iOS: (false, (5, 0, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_makeTextWritingDirectionLeftToRight_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'makeTextWritingDirectionLeftToRight:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer,
        _sel_makeTextWritingDirectionLeftToRight_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// makeTextWritingDirectionRightToLeft:
  void makeTextWritingDirectionRightToLeft(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal(
        'UIResponder.makeTextWritingDirectionRightToLeft:',
        iOS: (false, (5, 0, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_makeTextWritingDirectionRightToLeft_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'makeTextWritingDirectionRightToLeft:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer,
        _sel_makeTextWritingDirectionRightToLeft_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// toggleBoldface:
  void toggleBoldface(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleBoldface:',
        iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleBoldface_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'toggleBoldface:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleBoldface_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// toggleItalics:
  void toggleItalics(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleItalics:',
        iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleItalics_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'toggleItalics:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleItalics_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// toggleUnderline:
  void toggleUnderline(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleUnderline:',
        iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleUnderline_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'toggleUnderline:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleUnderline_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// increaseSize:
  void increaseSize(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.increaseSize:',
        iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_increaseSize_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'increaseSize:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_increaseSize_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// decreaseSize:
  void decreaseSize(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.decreaseSize:',
        iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_decreaseSize_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'decreaseSize:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_decreaseSize_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// find:
  void find(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.find:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_find_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'find:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_find_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// findAndReplace:
  void findAndReplace(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.findAndReplace:',
        iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_findAndReplace_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'findAndReplace:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_findAndReplace_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// findNext:
  void findNext(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.findNext:',
        iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_findNext_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'findNext:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_findNext_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// findPrevious:
  void findPrevious(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.findPrevious:',
        iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_findPrevious_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'findPrevious:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_findPrevious_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// useSelectionForFind:
  void useSelectionForFind(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.useSelectionForFind:',
        iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_useSelectionForFind_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'useSelectionForFind:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_useSelectionForFind_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// updateTextAttributesWithConversionHandler:
  void updateTextAttributesWithConversionHandler(
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
          conversionHandler) {
    objc.checkOsVersionInternal(
        'UIResponder.updateTextAttributesWithConversionHandler:',
        iOS: (false, (13, 0, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_updateTextAttributesWithConversionHandler_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'updateTextAttributesWithConversionHandler:');
    }
    _objc_msgSend_f167m6(
        this.ref.pointer,
        _sel_updateTextAttributesWithConversionHandler_,
        conversionHandler.ref.pointer);
  }

  /// print:
  void print(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.print:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_print_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'print:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_print_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// rename:
  void rename(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.rename:',
        iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_rename_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'rename:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_rename_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// duplicate:
  void duplicate(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.duplicate:',
        iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_duplicate_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'duplicate:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_duplicate_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// move:
  void move(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.move:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_move_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'move:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_move_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// export:
  void export$(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.export:',
        iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_export_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'export:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_export_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// showWritingTools:
  void showWritingTools(objc.ObjCObjectBase sender) {
    objc.checkOsVersionInternal('UIResponder.showWritingTools:',
        iOS: (false, (18, 2, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_showWritingTools_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UIResponder', 'showWritingTools:');
    }
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_showWritingTools_, sender.ref.pointer);
  }

  /// Returns a new instance of UIResponder constructed with the default `new` method.
  factory UIResponder() => new$();
}

enum UIBarStyle {
  UIBarStyleDefault(0),
  UIBarStyleBlack(1),
  UIBarStyleBlackTranslucent(2);

  static const UIBarStyleBlackOpaque = UIBarStyleBlack;

  final int value;
  const UIBarStyle(this.value);

  static UIBarStyle fromValue(int value) => switch (value) {
        0 => UIBarStyleDefault,
        1 => UIBarStyleBlack,
        2 => UIBarStyleBlackTranslucent,
        _ => throw ArgumentError('Unknown value for UIBarStyle: $value'),
      };

  @override
  String toString() {
    if (this == UIBarStyleBlack)
      return "UIBarStyle.UIBarStyleBlack, UIBarStyle.UIBarStyleBlackOpaque";
    return super.toString();
  }
}

enum UIUserInterfaceSizeClass {
  UIUserInterfaceSizeClassUnspecified(0),
  UIUserInterfaceSizeClassCompact(1),
  UIUserInterfaceSizeClassRegular(2);

  final int value;
  const UIUserInterfaceSizeClass(this.value);

  static UIUserInterfaceSizeClass fromValue(int value) => switch (value) {
        0 => UIUserInterfaceSizeClassUnspecified,
        1 => UIUserInterfaceSizeClassCompact,
        2 => UIUserInterfaceSizeClassRegular,
        _ => throw ArgumentError(
            'Unknown value for UIUserInterfaceSizeClass: $value'),
      };
}

enum UITraitEnvironmentLayoutDirection {
  UITraitEnvironmentLayoutDirectionUnspecified(-1),
  UITraitEnvironmentLayoutDirectionLeftToRight(0),
  UITraitEnvironmentLayoutDirectionRightToLeft(1);

  final int value;
  const UITraitEnvironmentLayoutDirection(this.value);

  static UITraitEnvironmentLayoutDirection fromValue(int value) =>
      switch (value) {
        -1 => UITraitEnvironmentLayoutDirectionUnspecified,
        0 => UITraitEnvironmentLayoutDirectionLeftToRight,
        1 => UITraitEnvironmentLayoutDirectionRightToLeft,
        _ => throw ArgumentError(
            'Unknown value for UITraitEnvironmentLayoutDirection: $value'),
      };
}

enum UIDisplayGamut {
  UIDisplayGamutUnspecified(-1),
  UIDisplayGamutSRGB(0),
  UIDisplayGamutP3(1);

  final int value;
  const UIDisplayGamut(this.value);

  static UIDisplayGamut fromValue(int value) => switch (value) {
        -1 => UIDisplayGamutUnspecified,
        0 => UIDisplayGamutSRGB,
        1 => UIDisplayGamutP3,
        _ => throw ArgumentError('Unknown value for UIDisplayGamut: $value'),
      };
}

enum UIAccessibilityContrast {
  UIAccessibilityContrastUnspecified(-1),
  UIAccessibilityContrastNormal(0),
  UIAccessibilityContrastHigh(1);

  final int value;
  const UIAccessibilityContrast(this.value);

  static UIAccessibilityContrast fromValue(int value) => switch (value) {
        -1 => UIAccessibilityContrastUnspecified,
        0 => UIAccessibilityContrastNormal,
        1 => UIAccessibilityContrastHigh,
        _ => throw ArgumentError(
            'Unknown value for UIAccessibilityContrast: $value'),
      };
}

enum UILegibilityWeight {
  UILegibilityWeightUnspecified(-1),
  UILegibilityWeightRegular(0),
  UILegibilityWeightBold(1);

  final int value;
  const UILegibilityWeight(this.value);

  static UILegibilityWeight fromValue(int value) => switch (value) {
        -1 => UILegibilityWeightUnspecified,
        0 => UILegibilityWeightRegular,
        1 => UILegibilityWeightBold,
        _ =>
          throw ArgumentError('Unknown value for UILegibilityWeight: $value'),
      };
}

enum UIUserInterfaceLevel {
  UIUserInterfaceLevelUnspecified(-1),
  UIUserInterfaceLevelBase(0),
  UIUserInterfaceLevelElevated(1);

  final int value;
  const UIUserInterfaceLevel(this.value);

  static UIUserInterfaceLevel fromValue(int value) => switch (value) {
        -1 => UIUserInterfaceLevelUnspecified,
        0 => UIUserInterfaceLevelBase,
        1 => UIUserInterfaceLevelElevated,
        _ =>
          throw ArgumentError('Unknown value for UIUserInterfaceLevel: $value'),
      };
}

enum UIUserInterfaceActiveAppearance {
  UIUserInterfaceActiveAppearanceUnspecified(-1),
  UIUserInterfaceActiveAppearanceInactive(0),
  UIUserInterfaceActiveAppearanceActive(1);

  final int value;
  const UIUserInterfaceActiveAppearance(this.value);

  static UIUserInterfaceActiveAppearance fromValue(int value) =>
      switch (value) {
        -1 => UIUserInterfaceActiveAppearanceUnspecified,
        0 => UIUserInterfaceActiveAppearanceInactive,
        1 => UIUserInterfaceActiveAppearanceActive,
        _ => throw ArgumentError(
            'Unknown value for UIUserInterfaceActiveAppearance: $value'),
      };
}

enum UINSToolbarItemPresentationSize {
  UINSToolbarItemPresentationSizeUnspecified(-1),
  UINSToolbarItemPresentationSizeRegular(0),
  UINSToolbarItemPresentationSizeSmall(1),
  UINSToolbarItemPresentationSizeLarge(3);

  final int value;
  const UINSToolbarItemPresentationSize(this.value);

  static UINSToolbarItemPresentationSize fromValue(int value) =>
      switch (value) {
        -1 => UINSToolbarItemPresentationSizeUnspecified,
        0 => UINSToolbarItemPresentationSizeRegular,
        1 => UINSToolbarItemPresentationSizeSmall,
        3 => UINSToolbarItemPresentationSizeLarge,
        _ => throw ArgumentError(
            'Unknown value for UINSToolbarItemPresentationSize: $value'),
      };
}

enum UIImageDynamicRange {
  UIImageDynamicRangeUnspecified(-1),
  UIImageDynamicRangeStandard(0),
  UIImageDynamicRangeConstrainedHigh(1),
  UIImageDynamicRangeHigh(2);

  final int value;
  const UIImageDynamicRange(this.value);

  static UIImageDynamicRange fromValue(int value) => switch (value) {
        -1 => UIImageDynamicRangeUnspecified,
        0 => UIImageDynamicRangeStandard,
        1 => UIImageDynamicRangeConstrainedHigh,
        2 => UIImageDynamicRangeHigh,
        _ =>
          throw ArgumentError('Unknown value for UIImageDynamicRange: $value'),
      };
}

enum NSLayoutRelation {
  NSLayoutRelationLessThanOrEqual(-1),
  NSLayoutRelationEqual(0),
  NSLayoutRelationGreaterThanOrEqual(1);

  final int value;
  const NSLayoutRelation(this.value);

  static NSLayoutRelation fromValue(int value) => switch (value) {
        -1 => NSLayoutRelationLessThanOrEqual,
        0 => NSLayoutRelationEqual,
        1 => NSLayoutRelationGreaterThanOrEqual,
        _ => throw ArgumentError('Unknown value for NSLayoutRelation: $value'),
      };
}

enum NSLayoutAttribute {
  NSLayoutAttributeLeft(1),
  NSLayoutAttributeRight(2),
  NSLayoutAttributeTop(3),
  NSLayoutAttributeBottom(4),
  NSLayoutAttributeLeading(5),
  NSLayoutAttributeTrailing(6),
  NSLayoutAttributeWidth(7),
  NSLayoutAttributeHeight(8),
  NSLayoutAttributeCenterX(9),
  NSLayoutAttributeCenterY(10),
  NSLayoutAttributeLastBaseline(11),
  NSLayoutAttributeFirstBaseline(12),
  NSLayoutAttributeLeftMargin(13),
  NSLayoutAttributeRightMargin(14),
  NSLayoutAttributeTopMargin(15),
  NSLayoutAttributeBottomMargin(16),
  NSLayoutAttributeLeadingMargin(17),
  NSLayoutAttributeTrailingMargin(18),
  NSLayoutAttributeCenterXWithinMargins(19),
  NSLayoutAttributeCenterYWithinMargins(20),
  NSLayoutAttributeNotAnAttribute(0);

  static const NSLayoutAttributeBaseline = NSLayoutAttributeLastBaseline;

  final int value;
  const NSLayoutAttribute(this.value);

  static NSLayoutAttribute fromValue(int value) => switch (value) {
        1 => NSLayoutAttributeLeft,
        2 => NSLayoutAttributeRight,
        3 => NSLayoutAttributeTop,
        4 => NSLayoutAttributeBottom,
        5 => NSLayoutAttributeLeading,
        6 => NSLayoutAttributeTrailing,
        7 => NSLayoutAttributeWidth,
        8 => NSLayoutAttributeHeight,
        9 => NSLayoutAttributeCenterX,
        10 => NSLayoutAttributeCenterY,
        11 => NSLayoutAttributeLastBaseline,
        12 => NSLayoutAttributeFirstBaseline,
        13 => NSLayoutAttributeLeftMargin,
        14 => NSLayoutAttributeRightMargin,
        15 => NSLayoutAttributeTopMargin,
        16 => NSLayoutAttributeBottomMargin,
        17 => NSLayoutAttributeLeadingMargin,
        18 => NSLayoutAttributeTrailingMargin,
        19 => NSLayoutAttributeCenterXWithinMargins,
        20 => NSLayoutAttributeCenterYWithinMargins,
        0 => NSLayoutAttributeNotAnAttribute,
        _ => throw ArgumentError('Unknown value for NSLayoutAttribute: $value'),
      };

  @override
  String toString() {
    if (this == NSLayoutAttributeLastBaseline)
      return "NSLayoutAttribute.NSLayoutAttributeLastBaseline, NSLayoutAttribute.NSLayoutAttributeBaseline";
    return super.toString();
  }
}

enum NSLayoutFormatOptions {
  NSLayoutFormatAlignAllLeft(2),
  NSLayoutFormatAlignAllRight(4),
  NSLayoutFormatAlignAllTop(8),
  NSLayoutFormatAlignAllBottom(16),
  NSLayoutFormatAlignAllLeading(32),
  NSLayoutFormatAlignAllTrailing(64),
  NSLayoutFormatAlignAllCenterX(512),
  NSLayoutFormatAlignAllCenterY(1024),
  NSLayoutFormatAlignAllLastBaseline(2048),
  NSLayoutFormatAlignAllFirstBaseline(4096),
  NSLayoutFormatAlignmentMask(65535),
  NSLayoutFormatDirectionLeadingToTrailing(0),
  NSLayoutFormatDirectionLeftToRight(65536),
  NSLayoutFormatDirectionRightToLeft(131072),
  NSLayoutFormatDirectionMask(196608),
  NSLayoutFormatSpacingBaselineToBaseline(524288);

  static const NSLayoutFormatAlignAllBaseline =
      NSLayoutFormatAlignAllLastBaseline;
  static const NSLayoutFormatSpacingEdgeToEdge =
      NSLayoutFormatDirectionLeadingToTrailing;
  static const NSLayoutFormatSpacingMask =
      NSLayoutFormatSpacingBaselineToBaseline;

  final int value;
  const NSLayoutFormatOptions(this.value);

  static NSLayoutFormatOptions fromValue(int value) => switch (value) {
        2 => NSLayoutFormatAlignAllLeft,
        4 => NSLayoutFormatAlignAllRight,
        8 => NSLayoutFormatAlignAllTop,
        16 => NSLayoutFormatAlignAllBottom,
        32 => NSLayoutFormatAlignAllLeading,
        64 => NSLayoutFormatAlignAllTrailing,
        512 => NSLayoutFormatAlignAllCenterX,
        1024 => NSLayoutFormatAlignAllCenterY,
        2048 => NSLayoutFormatAlignAllLastBaseline,
        4096 => NSLayoutFormatAlignAllFirstBaseline,
        65535 => NSLayoutFormatAlignmentMask,
        0 => NSLayoutFormatDirectionLeadingToTrailing,
        65536 => NSLayoutFormatDirectionLeftToRight,
        131072 => NSLayoutFormatDirectionRightToLeft,
        196608 => NSLayoutFormatDirectionMask,
        524288 => NSLayoutFormatSpacingBaselineToBaseline,
        _ => throw ArgumentError(
            'Unknown value for NSLayoutFormatOptions: $value'),
      };

  @override
  String toString() {
    if (this == NSLayoutFormatAlignAllLastBaseline)
      return "NSLayoutFormatOptions.NSLayoutFormatAlignAllLastBaseline, NSLayoutFormatOptions.NSLayoutFormatAlignAllBaseline";
    if (this == NSLayoutFormatDirectionLeadingToTrailing)
      return "NSLayoutFormatOptions.NSLayoutFormatDirectionLeadingToTrailing, NSLayoutFormatOptions.NSLayoutFormatSpacingEdgeToEdge";
    if (this == NSLayoutFormatSpacingBaselineToBaseline)
      return "NSLayoutFormatOptions.NSLayoutFormatSpacingBaselineToBaseline, NSLayoutFormatOptions.NSLayoutFormatSpacingMask";
    return super.toString();
  }
}

enum UIInterfaceOrientation {
  UIInterfaceOrientationUnknown(0),
  UIInterfaceOrientationPortrait(1),
  UIInterfaceOrientationPortraitUpsideDown(2),
  UIInterfaceOrientationLandscapeLeft(4),
  UIInterfaceOrientationLandscapeRight(3);

  final int value;
  const UIInterfaceOrientation(this.value);

  static UIInterfaceOrientation fromValue(int value) => switch (value) {
        0 => UIInterfaceOrientationUnknown,
        1 => UIInterfaceOrientationPortrait,
        2 => UIInterfaceOrientationPortraitUpsideDown,
        4 => UIInterfaceOrientationLandscapeLeft,
        3 => UIInterfaceOrientationLandscapeRight,
        _ => throw ArgumentError(
            'Unknown value for UIInterfaceOrientation: $value'),
      };
}

enum UIInterfaceOrientationMask {
  UIInterfaceOrientationMaskPortrait(2),
  UIInterfaceOrientationMaskLandscapeLeft(16),
  UIInterfaceOrientationMaskLandscapeRight(8),
  UIInterfaceOrientationMaskPortraitUpsideDown(4),
  UIInterfaceOrientationMaskLandscape(24),
  UIInterfaceOrientationMaskAll(30),
  UIInterfaceOrientationMaskAllButUpsideDown(26);

  final int value;
  const UIInterfaceOrientationMask(this.value);

  static UIInterfaceOrientationMask fromValue(int value) => switch (value) {
        2 => UIInterfaceOrientationMaskPortrait,
        16 => UIInterfaceOrientationMaskLandscapeLeft,
        8 => UIInterfaceOrientationMaskLandscapeRight,
        4 => UIInterfaceOrientationMaskPortraitUpsideDown,
        24 => UIInterfaceOrientationMaskLandscape,
        30 => UIInterfaceOrientationMaskAll,
        26 => UIInterfaceOrientationMaskAllButUpsideDown,
        _ => throw ArgumentError(
            'Unknown value for UIInterfaceOrientationMask: $value'),
      };
}

enum UIUserInterfaceIdiom {
  UIUserInterfaceIdiomUnspecified(-1),
  UIUserInterfaceIdiomPhone(0),
  UIUserInterfaceIdiomPad(1),
  UIUserInterfaceIdiomTV(2),
  UIUserInterfaceIdiomCarPlay(3),
  UIUserInterfaceIdiomMac(5),
  UIUserInterfaceIdiomVision(6);

  final int value;
  const UIUserInterfaceIdiom(this.value);

  static UIUserInterfaceIdiom fromValue(int value) => switch (value) {
        -1 => UIUserInterfaceIdiomUnspecified,
        0 => UIUserInterfaceIdiomPhone,
        1 => UIUserInterfaceIdiomPad,
        2 => UIUserInterfaceIdiomTV,
        3 => UIUserInterfaceIdiomCarPlay,
        5 => UIUserInterfaceIdiomMac,
        6 => UIUserInterfaceIdiomVision,
        _ =>
          throw ArgumentError('Unknown value for UIUserInterfaceIdiom: $value'),
      };
}

enum UITouchPhase {
  UITouchPhaseBegan(0),
  UITouchPhaseMoved(1),
  UITouchPhaseStationary(2),
  UITouchPhaseEnded(3),
  UITouchPhaseCancelled(4),
  UITouchPhaseRegionEntered(5),
  UITouchPhaseRegionMoved(6),
  UITouchPhaseRegionExited(7);

  final int value;
  const UITouchPhase(this.value);

  static UITouchPhase fromValue(int value) => switch (value) {
        0 => UITouchPhaseBegan,
        1 => UITouchPhaseMoved,
        2 => UITouchPhaseStationary,
        3 => UITouchPhaseEnded,
        4 => UITouchPhaseCancelled,
        5 => UITouchPhaseRegionEntered,
        6 => UITouchPhaseRegionMoved,
        7 => UITouchPhaseRegionExited,
        _ => throw ArgumentError('Unknown value for UITouchPhase: $value'),
      };
}

enum UIForceTouchCapability {
  UIForceTouchCapabilityUnknown(0),
  UIForceTouchCapabilityUnavailable(1),
  UIForceTouchCapabilityAvailable(2);

  final int value;
  const UIForceTouchCapability(this.value);

  static UIForceTouchCapability fromValue(int value) => switch (value) {
        0 => UIForceTouchCapabilityUnknown,
        1 => UIForceTouchCapabilityUnavailable,
        2 => UIForceTouchCapabilityAvailable,
        _ => throw ArgumentError(
            'Unknown value for UIForceTouchCapability: $value'),
      };
}

enum UITouchType {
  UITouchTypeDirect(0),
  UITouchTypeIndirect(1),
  UITouchTypePencil(2),
  UITouchTypeIndirectPointer(3);

  static const UITouchTypeStylus = UITouchTypePencil;

  final int value;
  const UITouchType(this.value);

  static UITouchType fromValue(int value) => switch (value) {
        0 => UITouchTypeDirect,
        1 => UITouchTypeIndirect,
        2 => UITouchTypePencil,
        3 => UITouchTypeIndirectPointer,
        _ => throw ArgumentError('Unknown value for UITouchType: $value'),
      };

  @override
  String toString() {
    if (this == UITouchTypePencil)
      return "UITouchType.UITouchTypePencil, UITouchType.UITouchTypeStylus";
    return super.toString();
  }
}

enum UITouchProperties {
  UITouchPropertyForce(1),
  UITouchPropertyAzimuth(2),
  UITouchPropertyAltitude(4),
  UITouchPropertyLocation(8),
  UITouchPropertyRoll(16);

  final int value;
  const UITouchProperties(this.value);

  static UITouchProperties fromValue(int value) => switch (value) {
        1 => UITouchPropertyForce,
        2 => UITouchPropertyAzimuth,
        4 => UITouchPropertyAltitude,
        8 => UITouchPropertyLocation,
        16 => UITouchPropertyRoll,
        _ => throw ArgumentError('Unknown value for UITouchProperties: $value'),
      };
}

/// WARNING: UITouch is a stub. To generate bindings for this class, include
/// UITouch in your config's objc-interfaces list.
///
/// UITouch
class UITouch extends objc.NSObject {
  UITouch._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITouch', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITouch] that points to the same underlying object as [other].
  UITouch.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITouch] that wraps the given raw object pointer.
  UITouch.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UISceneActivationState {
  UISceneActivationStateUnattached(-1),
  UISceneActivationStateForegroundActive(0),
  UISceneActivationStateForegroundInactive(1),
  UISceneActivationStateBackground(2);

  final int value;
  const UISceneActivationState(this.value);

  static UISceneActivationState fromValue(int value) => switch (value) {
        -1 => UISceneActivationStateUnattached,
        0 => UISceneActivationStateForegroundActive,
        1 => UISceneActivationStateForegroundInactive,
        2 => UISceneActivationStateBackground,
        _ => throw ArgumentError(
            'Unknown value for UISceneActivationState: $value'),
      };
}

enum UISceneCaptureState {
  UISceneCaptureStateUnspecified(-1),
  UISceneCaptureStateInactive(0),
  UISceneCaptureStateActive(1);

  final int value;
  const UISceneCaptureState(this.value);

  static UISceneCaptureState fromValue(int value) => switch (value) {
        -1 => UISceneCaptureStateUnspecified,
        0 => UISceneCaptureStateInactive,
        1 => UISceneCaptureStateActive,
        _ =>
          throw ArgumentError('Unknown value for UISceneCaptureState: $value'),
      };
}

enum UIListEnvironment {
  UIListEnvironmentUnspecified(0),
  UIListEnvironmentNone(1),
  UIListEnvironmentPlain(2),
  UIListEnvironmentGrouped(3),
  UIListEnvironmentInsetGrouped(4),
  UIListEnvironmentSidebar(5),
  UIListEnvironmentSidebarPlain(6);

  final int value;
  const UIListEnvironment(this.value);

  static UIListEnvironment fromValue(int value) => switch (value) {
        0 => UIListEnvironmentUnspecified,
        1 => UIListEnvironmentNone,
        2 => UIListEnvironmentPlain,
        3 => UIListEnvironmentGrouped,
        4 => UIListEnvironmentInsetGrouped,
        5 => UIListEnvironmentSidebar,
        6 => UIListEnvironmentSidebarPlain,
        _ => throw ArgumentError('Unknown value for UIListEnvironment: $value'),
      };
}

/// WARNING: UIMutableTraits is a stub. To generate bindings for this class, include
/// UIMutableTraits in your config's objc-protocols list.
///
/// UIMutableTraits
interface class UIMutableTraits extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIMutableTraits._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIMutableTraits] that points to the same underlying object as [other].
  UIMutableTraits.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMutableTraits] that wraps the given raw object pointer.
  UIMutableTraits.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_idUIMutableTraits_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_idUIMutableTraits_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_idUIMutableTraits_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_idUIMutableTraits_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_idUIMutableTraits_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_idUIMutableTraits_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_idUIMutableTraits_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idUIMutableTraits_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_idUIMutableTraits_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_idUIMutableTraits_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idUIMutableTraits_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_idUIMutableTraits_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idUIMutableTraits_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_idUIMutableTraits_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_idUIMutableTraits {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_idUIMutableTraits_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>)> fromFunction(
          void Function(UIMutableTraits) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_idUIMutableTraits_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) =>
                  fn(UIMutableTraits.castFromPointer(arg0, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>
      listener(void Function(UIMutableTraits) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idUIMutableTraits_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            UIMutableTraits.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>
      blocking(void Function(UIMutableTraits) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idUIMutableTraits_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            UIMutableTraits.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idUIMutableTraits_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            UIMutableTraits.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_idUIMutableTraits_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)> {
  void call(UIMutableTraits arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer);
}

enum UIFocusHeading {
  UIFocusHeadingNone(0),
  UIFocusHeadingUp(1),
  UIFocusHeadingDown(2),
  UIFocusHeadingLeft(4),
  UIFocusHeadingRight(8),
  UIFocusHeadingNext(16),
  UIFocusHeadingPrevious(32),
  UIFocusHeadingFirst(256),
  UIFocusHeadingLast(512);

  final int value;
  const UIFocusHeading(this.value);

  static UIFocusHeading fromValue(int value) => switch (value) {
        0 => UIFocusHeadingNone,
        1 => UIFocusHeadingUp,
        2 => UIFocusHeadingDown,
        4 => UIFocusHeadingLeft,
        8 => UIFocusHeadingRight,
        16 => UIFocusHeadingNext,
        32 => UIFocusHeadingPrevious,
        256 => UIFocusHeadingFirst,
        512 => UIFocusHeadingLast,
        _ => throw ArgumentError('Unknown value for UIFocusHeading: $value'),
      };
}

late final _class_UIAction = objc.getClass("UIAction");

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting$1 on UIAction {}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSString_ffiVoid$1_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSString_ffiVoid$1_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSString_ffiVoid$1_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSString_ffiVoid$1_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSString_ffiVoid$1_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSString_ffiVoid$1_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSString_ffiVoid$1_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSString Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSString_ffiVoid$1_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid$1_CallExtension
    on objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString call(ffi.Pointer<ffi.Void> arg0) =>
      objc.NSString.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_setTitle_ = objc.registerName("setTitle:");
void _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.NSString) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSString) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSString.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.NSString) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSString.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSString.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_setImage_ = objc.registerName("setImage:");
void _ObjCBlock_ffiVoid_ffiVoid_UIImage_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UIImage_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIImage_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIImage_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UIImage_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIImage_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIImage_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIImage_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIImage_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIImage_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIImage_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIImage_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UIImage_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIImage_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIImage {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_UIImage_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, UIImage?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_UIImage_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                      arg0,
                      arg1.address == 0
                          ? null
                          : UIImage.castFromPointer(arg1, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
      listener(void Function(ffi.Pointer<ffi.Void>, UIImage?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIImage_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UIImage.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
      blocking(void Function(ffi.Pointer<ffi.Void>, UIImage?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIImage_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UIImage.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIImage_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            arg1.address == 0
                ? null
                : UIImage.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIImage_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIImage? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_discoverabilityTitle =
    objc.registerName("discoverabilityTitle");
late final _sel_setDiscoverabilityTitle_ =
    objc.registerName("setDiscoverabilityTitle:");
late final _sel_attributes = objc.registerName("attributes");
final _objc_msgSend_kzdfm1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
int _ObjCBlock_UIMenuElementAttributes_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIMenuElementAttributes_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIMenuElementAttributes_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_UIMenuElementAttributes_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIMenuElementAttributes_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIMenuElementAttributes_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIMenuElementAttributes_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIMenuElementAttributes_ffiVoid_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      fromFunction(UIMenuElementAttributes Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_UIMenuElementAttributes_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIMenuElementAttributes_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  UIMenuElementAttributes call(ffi.Pointer<ffi.Void> arg0) =>
      UIMenuElementAttributes.fromValue(ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0));
}

late final _sel_setAttributes_ = objc.registerName("setAttributes:");
final _objc_msgSend_18kcki9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
void _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        int arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
        arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.UnsignedLong)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.UnsignedLong)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.UnsignedLong)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, UIMenuElementAttributes) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, int arg1) =>
                  fn(arg0, UIMenuElementAttributes.fromValue(arg1)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
      listener(void Function(ffi.Pointer<ffi.Void>, UIMenuElementAttributes) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) =>
            fn(arg0, UIMenuElementAttributes.fromValue(arg1)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1lmpkp(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
      blocking(void Function(ffi.Pointer<ffi.Void>, UIMenuElementAttributes) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) =>
            fn(arg0, UIMenuElementAttributes.fromValue(arg1)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) =>
            fn(arg0, UIMenuElementAttributes.fromValue(arg1)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1lmpkp(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes_CallExtension
    on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIMenuElementAttributes arg1) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, int)>()(ref.pointer, arg0, arg1.value);
}

late final _sel_state = objc.registerName("state");
final _objc_msgSend_13oxpc5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
int _ObjCBlock_UIMenuElementState_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIMenuElementState_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIMenuElementState_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_UIMenuElementState_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIMenuElementState_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_UIMenuElementState_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIMenuElementState_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_UIMenuElementState_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
          UIMenuElementState Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_UIMenuElementState_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIMenuElementState_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  UIMenuElementState call(ffi.Pointer<ffi.Void> arg0) =>
      UIMenuElementState.fromValue(ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0));
}

late final _sel_setState_ = objc.registerName("setState:");
final _objc_msgSend_1qgnjih = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
void _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Long)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        int arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
        arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Long)>(
            _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Long)>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Long)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Long)>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Long)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Long)>
    _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Long)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, UIMenuElementState) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, int arg1) =>
                      fn(arg0, UIMenuElementState.fromValue(arg1)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
      listener(void Function(ffi.Pointer<ffi.Void>, UIMenuElementState) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) =>
            fn(arg0, UIMenuElementState.fromValue(arg1)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_1mm4s9d(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
      blocking(void Function(ffi.Pointer<ffi.Void>, UIMenuElementState) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) =>
            fn(arg0, UIMenuElementState.fromValue(arg1)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) =>
            fn(arg0, UIMenuElementState.fromValue(arg1)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_1mm4s9d(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIMenuElementState arg1) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, int)>()(ref.pointer, arg0, arg1.value);
}

late final _sel_sender = objc.registerName("sender");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase? call(ffi.Pointer<ffi.Void> arg0) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_actionWithHandler_ = objc.registerName("actionWithHandler:");
final _objc_msgSend_nnxkei = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_actionWithTitle_image_identifier_handler_ =
    objc.registerName("actionWithTitle:image:identifier:handler:");
final _objc_msgSend_bpwlds = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_selectedImage = objc.registerName("selectedImage");
late final _sel_setSelectedImage_ = objc.registerName("setSelectedImage:");
late final _sel_presentationSourceItem =
    objc.registerName("presentationSourceItem");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(
              UIPopoverPresentationControllerSourceItem? Function(
                      ffi.Pointer<ffi.Void>)
                  fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid_CallExtension
    on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIPopoverPresentationControllerSourceItem? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
                  (ref.pointer, arg0)
                  .address ==
              0
          ? null
          : UIPopoverPresentationControllerSourceItem.castFromPointer(
              ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>().asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
              retain: true,
              release: true);
}

late final _sel_performWithSender_target_ =
    objc.registerName("performWithSender:target:");
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCObject>?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>?,
                      ffi.Pointer<objc.ObjCObject>?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCObject>?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>?,
                      ffi.Pointer<objc.ObjCObject>?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCObject>?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?, objc.ObjCObjectBase?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCObject>?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true),
                      arg2.address == 0 ? null : objc.ObjCObjectBase(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?,
          ffi.Pointer<objc.ObjCObject>?)> listener(
      void Function(
              ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?, objc.ObjCObjectBase?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg1, retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg2, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>?,
                ffi.Pointer<objc.ObjCObject>?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?,
          ffi.Pointer<objc.ObjCObject>?)> blocking(
      void Function(
              ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?, objc.ObjCObjectBase?)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg1, retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg2, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg1, retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg2, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>?,
                ffi.Pointer<objc.ObjCObject>?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_objcObjCObject_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?,
            ffi.Pointer<objc.ObjCObject>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase? arg1,
          objc.ObjCObjectBase? arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1?.ref.pointer ?? ffi.nullptr, arg2?.ref.pointer ?? ffi.nullptr);
}

late final _sel_captureTextFromCameraActionForResponder_identifier_ =
    objc.registerName("captureTextFromCameraActionForResponder:identifier:");

/// UIAction
class UIAction extends UIMenuElement implements UIMenuLeaf {
  UIAction._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAction', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIAction] that points to the same underlying object as [other].
  UIAction.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAction] that wraps the given raw object pointer.
  UIAction.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIAction].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIAction);
  }

  /// title
  objc.NSString get title {
    objc.checkOsVersionInternal('UIAction.title', iOS: (false, (16, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString value) {
    objc.checkOsVersionInternal('UIAction.setTitle:', iOS: (false, (16, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value.ref.pointer);
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal('UIAction.image', iOS: (false, (16, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setImage:
  set image(UIImage? value) {
    objc.checkOsVersionInternal('UIAction.setImage:', iOS: (false, (16, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// discoverabilityTitle
  objc.NSString? get discoverabilityTitle {
    objc.checkOsVersionInternal('UIAction.discoverabilityTitle',
        iOS: (false, (16, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_discoverabilityTitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setDiscoverabilityTitle:
  set discoverabilityTitle(objc.NSString? value) {
    objc.checkOsVersionInternal('UIAction.setDiscoverabilityTitle:',
        iOS: (false, (16, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDiscoverabilityTitle_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// identifier
  objc.NSString get identifier {
    objc.checkOsVersionInternal('UIAction.identifier',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// attributes
  UIMenuElementAttributes get attributes {
    objc.checkOsVersionInternal('UIAction.attributes',
        iOS: (false, (16, 0, 0)));
    final _ret = _objc_msgSend_kzdfm1(this.ref.pointer, _sel_attributes);
    return UIMenuElementAttributes.fromValue(_ret);
  }

  /// setAttributes:
  set attributes(UIMenuElementAttributes value) {
    objc.checkOsVersionInternal('UIAction.setAttributes:',
        iOS: (false, (16, 0, 0)));
    _objc_msgSend_18kcki9(this.ref.pointer, _sel_setAttributes_, value.value);
  }

  /// state
  UIMenuElementState get state {
    objc.checkOsVersionInternal('UIAction.state', iOS: (false, (16, 0, 0)));
    final _ret = _objc_msgSend_13oxpc5(this.ref.pointer, _sel_state);
    return UIMenuElementState.fromValue(_ret);
  }

  /// setState:
  set state(UIMenuElementState value) {
    objc.checkOsVersionInternal('UIAction.setState:', iOS: (false, (16, 0, 0)));
    _objc_msgSend_1qgnjih(this.ref.pointer, _sel_setState_, value.value);
  }

  /// sender
  objc.ObjCObjectBase? get sender {
    objc.checkOsVersionInternal('UIAction.sender', iOS: (false, (16, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sender);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// actionWithHandler:
  static UIAction actionWithHandler(
      objc.ObjCBlock<ffi.Void Function(UIAction)> handler) {
    objc.checkOsVersionInternal('UIAction.actionWithHandler:',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_nnxkei(
        _class_UIAction, _sel_actionWithHandler_, handler.ref.pointer);
    return UIAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// actionWithTitle:image:identifier:handler:
  static UIAction actionWithTitle(objc.NSString title$1,
      {UIImage? image$1,
      objc.NSString? identifier$1,
      required objc.ObjCBlock<ffi.Void Function(UIAction)> handler}) {
    final _ret = _objc_msgSend_bpwlds(
        _class_UIAction,
        _sel_actionWithTitle_image_identifier_handler_,
        title$1.ref.pointer,
        image$1?.ref.pointer ?? ffi.nullptr,
        identifier$1?.ref.pointer ?? ffi.nullptr,
        handler.ref.pointer);
    return UIAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  UIAction init() {
    objc.checkOsVersionInternal('UIAction.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIAction new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIAction, _sel_new);
    return UIAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIAction? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UIAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIAction allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_UIAction, _sel_allocWithZone_, zone);
    return UIAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIAction alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIAction, _sel_alloc);
    return UIAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIAction, _sel_supportsSecureCoding);
  }

  /// selectedImage
  UIImage? get selectedImage {
    objc.checkOsVersionInternal('UIAction.selectedImage',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedImage);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSelectedImage:
  set selectedImage(UIImage? value) {
    objc.checkOsVersionInternal('UIAction.setSelectedImage:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectedImage_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// presentationSourceItem
  UIPopoverPresentationControllerSourceItem? get presentationSourceItem {
    objc.checkOsVersionInternal('UIAction.presentationSourceItem',
        iOS: (false, (16, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_presentationSourceItem);
    return _ret.address == 0
        ? null
        : UIPopoverPresentationControllerSourceItem.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// performWithSender:target:
  void performWithSender(objc.ObjCObjectBase? sender$1,
      {objc.ObjCObjectBase? target}) {
    objc.checkOsVersionInternal('UIAction.performWithSender:target:',
        iOS: (false, (16, 0, 0)));
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_performWithSender_target_,
        sender$1?.ref.pointer ?? ffi.nullptr,
        target?.ref.pointer ?? ffi.nullptr);
  }

  /// captureTextFromCameraActionForResponder:identifier:
  static UIAction captureTextFromCameraActionForResponder(UIResponder responder,
      {objc.NSString? identifier$1}) {
    objc.checkOsVersionInternal(
        'UIAction.captureTextFromCameraActionForResponder:identifier:',
        iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_UIAction,
        _sel_captureTextFromCameraActionForResponder_identifier_,
        responder.ref.pointer,
        identifier$1?.ref.pointer ?? ffi.nullptr);
    return UIAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of UIAction constructed with the default `new` method.
  factory UIAction() => new$();
}

void _ObjCBlock_ffiVoid_UIAction_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIAction_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UIAction_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIAction_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIAction_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UIAction_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIAction_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIAction_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UIAction_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_UIAction_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIAction_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_UIAction_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIAction_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UIAction_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIAction)>`.
abstract final class ObjCBlock_ffiVoid_UIAction {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(UIAction)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(UIAction)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_UIAction_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> fromFunction(
          void Function(UIAction) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UIAction)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_UIAction_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                  UIAction.castFromPointer(arg0, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> listener(
      void Function(UIAction) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIAction_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(UIAction.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAction)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> blocking(
      void Function(UIAction) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIAction_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(UIAction.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIAction_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(UIAction.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAction)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIAction)>`.
extension ObjCBlock_ffiVoid_UIAction_CallExtension
    on objc.ObjCBlock<ffi.Void Function(UIAction)> {
  void call(UIAction arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer);
}

enum UIContextMenuConfigurationElementOrder {
  UIContextMenuConfigurationElementOrderAutomatic(0),
  UIContextMenuConfigurationElementOrderPriority(1),
  UIContextMenuConfigurationElementOrderFixed(2);

  final int value;
  const UIContextMenuConfigurationElementOrder(this.value);

  static UIContextMenuConfigurationElementOrder fromValue(int value) =>
      switch (value) {
        0 => UIContextMenuConfigurationElementOrderAutomatic,
        1 => UIContextMenuConfigurationElementOrderPriority,
        2 => UIContextMenuConfigurationElementOrderFixed,
        _ => throw ArgumentError(
            'Unknown value for UIContextMenuConfigurationElementOrder: $value'),
      };
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIMenu_NSArray_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIMenu_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIMenu_NSArray_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIMenu_NSArray_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIMenu_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIMenu_NSArray_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
abstract final class ObjCBlock_UIMenu_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
          objc.newPointerBlock(
              _ObjCBlock_UIMenu_NSArray_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunction(
          UIMenu? Function(objc.NSArray) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
          objc.newClosureBlock(
              _ObjCBlock_UIMenu_NSArray_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) =>
                  fn(objc.NSArray.castFromPointer(arg0, retain: true, release: true))
                      ?.ref
                      .retainAndAutorelease() ??
                  ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
extension ObjCBlock_UIMenu_NSArray_CallExtension
    on objc.ObjCBlock<UIMenu? Function(objc.NSArray)> {
  UIMenu? call(objc.NSArray arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : UIMenu.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true);
}

/// WARNING: UIViewController is a stub. To generate bindings for this class, include
/// UIViewController in your config's objc-interfaces list.
///
/// UIViewController
class UIViewController extends UIResponder
    implements
        objc.NSCoding,
        UIAppearanceContainer,
        UITraitEnvironment,
        UIContentContainer,
        UIFocusEnvironment {
  UIViewController._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewController', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIViewController] that points to the same underlying object as [other].
  UIViewController.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewController] that wraps the given raw object pointer.
  UIViewController.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIViewController_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function()>>()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function()>()();
ffi.Pointer<ffi.Void> _ObjCBlock_UIViewController_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_UIViewController_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIViewController_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function())();
ffi.Pointer<ffi.Void> _ObjCBlock_UIViewController_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_UIViewController_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIViewController? Function()>`.
abstract final class ObjCBlock_UIViewController {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIViewController? Function()> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<UIViewController? Function()>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIViewController? Function()> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function()>>
              ptr) =>
      objc.ObjCBlock<UIViewController? Function()>(
          objc.newPointerBlock(
              _ObjCBlock_UIViewController_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIViewController? Function()> fromFunction(
          UIViewController? Function() fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIViewController? Function()>(
          objc.newClosureBlock(
              _ObjCBlock_UIViewController_closureCallable,
              () => fn()?.ref.retainAndAutorelease() ?? ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<UIViewController? Function()>`.
extension ObjCBlock_UIViewController_CallExtension
    on objc.ObjCBlock<UIViewController? Function()> {
  UIViewController? call() => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
                ref.pointer,
              )
              .address ==
          0
      ? null
      : UIViewController.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
            ref.pointer,
          ),
          retain: true,
          release: true);
}

enum UIContextMenuInteractionCommitStyle {
  UIContextMenuInteractionCommitStyleDismiss(0),
  UIContextMenuInteractionCommitStylePop(1);

  final int value;
  const UIContextMenuInteractionCommitStyle(this.value);

  static UIContextMenuInteractionCommitStyle fromValue(int value) =>
      switch (value) {
        0 => UIContextMenuInteractionCommitStyleDismiss,
        1 => UIContextMenuInteractionCommitStylePop,
        _ => throw ArgumentError(
            'Unknown value for UIContextMenuInteractionCommitStyle: $value'),
      };
}

enum UIContextMenuInteractionAppearance {
  UIContextMenuInteractionAppearanceUnknown(0),
  UIContextMenuInteractionAppearanceRich(1),
  UIContextMenuInteractionAppearanceCompact(2);

  final int value;
  const UIContextMenuInteractionAppearance(this.value);

  static UIContextMenuInteractionAppearance fromValue(int value) =>
      switch (value) {
        0 => UIContextMenuInteractionAppearanceUnknown,
        1 => UIContextMenuInteractionAppearanceRich,
        2 => UIContextMenuInteractionAppearanceCompact,
        _ => throw ArgumentError(
            'Unknown value for UIContextMenuInteractionAppearance: $value'),
      };
}

enum UIControlEvents {
  UIControlEventTouchDown(1),
  UIControlEventTouchDownRepeat(2),
  UIControlEventTouchDragInside(4),
  UIControlEventTouchDragOutside(8),
  UIControlEventTouchDragEnter(16),
  UIControlEventTouchDragExit(32),
  UIControlEventTouchUpInside(64),
  UIControlEventTouchUpOutside(128),
  UIControlEventTouchCancel(256),
  UIControlEventValueChanged(4096),
  UIControlEventPrimaryActionTriggered(8192),
  UIControlEventMenuActionTriggered(16384),
  UIControlEventEditingDidBegin(65536),
  UIControlEventEditingChanged(131072),
  UIControlEventEditingDidEnd(262144),
  UIControlEventEditingDidEndOnExit(524288),
  UIControlEventAllTouchEvents(4095),
  UIControlEventAllEditingEvents(983040),
  UIControlEventApplicationReserved(251658240),
  UIControlEventSystemReserved(4026531840),
  UIControlEventAllEvents(4294967295);

  final int value;
  const UIControlEvents(this.value);

  static UIControlEvents fromValue(int value) => switch (value) {
        1 => UIControlEventTouchDown,
        2 => UIControlEventTouchDownRepeat,
        4 => UIControlEventTouchDragInside,
        8 => UIControlEventTouchDragOutside,
        16 => UIControlEventTouchDragEnter,
        32 => UIControlEventTouchDragExit,
        64 => UIControlEventTouchUpInside,
        128 => UIControlEventTouchUpOutside,
        256 => UIControlEventTouchCancel,
        4096 => UIControlEventValueChanged,
        8192 => UIControlEventPrimaryActionTriggered,
        16384 => UIControlEventMenuActionTriggered,
        65536 => UIControlEventEditingDidBegin,
        131072 => UIControlEventEditingChanged,
        262144 => UIControlEventEditingDidEnd,
        524288 => UIControlEventEditingDidEndOnExit,
        4095 => UIControlEventAllTouchEvents,
        983040 => UIControlEventAllEditingEvents,
        251658240 => UIControlEventApplicationReserved,
        4026531840 => UIControlEventSystemReserved,
        4294967295 => UIControlEventAllEvents,
        _ => throw ArgumentError('Unknown value for UIControlEvents: $value'),
      };
}

enum UIControlContentVerticalAlignment {
  UIControlContentVerticalAlignmentCenter(0),
  UIControlContentVerticalAlignmentTop(1),
  UIControlContentVerticalAlignmentBottom(2),
  UIControlContentVerticalAlignmentFill(3);

  final int value;
  const UIControlContentVerticalAlignment(this.value);

  static UIControlContentVerticalAlignment fromValue(int value) =>
      switch (value) {
        0 => UIControlContentVerticalAlignmentCenter,
        1 => UIControlContentVerticalAlignmentTop,
        2 => UIControlContentVerticalAlignmentBottom,
        3 => UIControlContentVerticalAlignmentFill,
        _ => throw ArgumentError(
            'Unknown value for UIControlContentVerticalAlignment: $value'),
      };
}

enum UIControlContentHorizontalAlignment {
  UIControlContentHorizontalAlignmentCenter(0),
  UIControlContentHorizontalAlignmentLeft(1),
  UIControlContentHorizontalAlignmentRight(2),
  UIControlContentHorizontalAlignmentFill(3),
  UIControlContentHorizontalAlignmentLeading(4),
  UIControlContentHorizontalAlignmentTrailing(5);

  final int value;
  const UIControlContentHorizontalAlignment(this.value);

  static UIControlContentHorizontalAlignment fromValue(int value) =>
      switch (value) {
        0 => UIControlContentHorizontalAlignmentCenter,
        1 => UIControlContentHorizontalAlignmentLeft,
        2 => UIControlContentHorizontalAlignmentRight,
        3 => UIControlContentHorizontalAlignmentFill,
        4 => UIControlContentHorizontalAlignmentLeading,
        5 => UIControlContentHorizontalAlignmentTrailing,
        _ => throw ArgumentError(
            'Unknown value for UIControlContentHorizontalAlignment: $value'),
      };
}

enum UIControlState {
  UIControlStateNormal(0),
  UIControlStateHighlighted(1),
  UIControlStateDisabled(2),
  UIControlStateSelected(4),
  UIControlStateFocused(8),
  UIControlStateApplication(16711680),
  UIControlStateReserved(4278190080);

  final int value;
  const UIControlState(this.value);

  static UIControlState fromValue(int value) => switch (value) {
        0 => UIControlStateNormal,
        1 => UIControlStateHighlighted,
        2 => UIControlStateDisabled,
        4 => UIControlStateSelected,
        8 => UIControlStateFocused,
        16711680 => UIControlStateApplication,
        4278190080 => UIControlStateReserved,
        _ => throw ArgumentError('Unknown value for UIControlState: $value'),
      };
}

/// WARNING: UIControl is a stub. To generate bindings for this class, include
/// UIControl in your config's objc-interfaces list.
///
/// UIControl
class UIControl extends UIView {
  UIControl._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIControl', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIControl] that points to the same underlying object as [other].
  UIControl.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIControl] that wraps the given raw object pointer.
  UIControl.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIScrollViewIndicatorStyle {
  UIScrollViewIndicatorStyleDefault(0),
  UIScrollViewIndicatorStyleBlack(1),
  UIScrollViewIndicatorStyleWhite(2);

  final int value;
  const UIScrollViewIndicatorStyle(this.value);

  static UIScrollViewIndicatorStyle fromValue(int value) => switch (value) {
        0 => UIScrollViewIndicatorStyleDefault,
        1 => UIScrollViewIndicatorStyleBlack,
        2 => UIScrollViewIndicatorStyleWhite,
        _ => throw ArgumentError(
            'Unknown value for UIScrollViewIndicatorStyle: $value'),
      };
}

enum UIScrollViewKeyboardDismissMode {
  UIScrollViewKeyboardDismissModeNone(0),
  UIScrollViewKeyboardDismissModeOnDrag(1),
  UIScrollViewKeyboardDismissModeInteractive(2),
  UIScrollViewKeyboardDismissModeOnDragWithAccessory(3),
  UIScrollViewKeyboardDismissModeInteractiveWithAccessory(4);

  final int value;
  const UIScrollViewKeyboardDismissMode(this.value);

  static UIScrollViewKeyboardDismissMode fromValue(int value) =>
      switch (value) {
        0 => UIScrollViewKeyboardDismissModeNone,
        1 => UIScrollViewKeyboardDismissModeOnDrag,
        2 => UIScrollViewKeyboardDismissModeInteractive,
        3 => UIScrollViewKeyboardDismissModeOnDragWithAccessory,
        4 => UIScrollViewKeyboardDismissModeInteractiveWithAccessory,
        _ => throw ArgumentError(
            'Unknown value for UIScrollViewKeyboardDismissMode: $value'),
      };
}

enum UIScrollViewIndexDisplayMode {
  UIScrollViewIndexDisplayModeAutomatic(0),
  UIScrollViewIndexDisplayModeAlwaysHidden(1);

  final int value;
  const UIScrollViewIndexDisplayMode(this.value);

  static UIScrollViewIndexDisplayMode fromValue(int value) => switch (value) {
        0 => UIScrollViewIndexDisplayModeAutomatic,
        1 => UIScrollViewIndexDisplayModeAlwaysHidden,
        _ => throw ArgumentError(
            'Unknown value for UIScrollViewIndexDisplayMode: $value'),
      };
}

enum UIScrollViewContentInsetAdjustmentBehavior {
  UIScrollViewContentInsetAdjustmentAutomatic(0),
  UIScrollViewContentInsetAdjustmentScrollableAxes(1),
  UIScrollViewContentInsetAdjustmentNever(2),
  UIScrollViewContentInsetAdjustmentAlways(3);

  final int value;
  const UIScrollViewContentInsetAdjustmentBehavior(this.value);

  static UIScrollViewContentInsetAdjustmentBehavior fromValue(int value) =>
      switch (value) {
        0 => UIScrollViewContentInsetAdjustmentAutomatic,
        1 => UIScrollViewContentInsetAdjustmentScrollableAxes,
        2 => UIScrollViewContentInsetAdjustmentNever,
        3 => UIScrollViewContentInsetAdjustmentAlways,
        _ => throw ArgumentError(
            'Unknown value for UIScrollViewContentInsetAdjustmentBehavior: $value'),
      };
}

enum UITextAutocapitalizationType {
  UITextAutocapitalizationTypeNone(0),
  UITextAutocapitalizationTypeWords(1),
  UITextAutocapitalizationTypeSentences(2),
  UITextAutocapitalizationTypeAllCharacters(3);

  final int value;
  const UITextAutocapitalizationType(this.value);

  static UITextAutocapitalizationType fromValue(int value) => switch (value) {
        0 => UITextAutocapitalizationTypeNone,
        1 => UITextAutocapitalizationTypeWords,
        2 => UITextAutocapitalizationTypeSentences,
        3 => UITextAutocapitalizationTypeAllCharacters,
        _ => throw ArgumentError(
            'Unknown value for UITextAutocapitalizationType: $value'),
      };
}

enum UITextAutocorrectionType {
  UITextAutocorrectionTypeDefault(0),
  UITextAutocorrectionTypeNo(1),
  UITextAutocorrectionTypeYes(2);

  final int value;
  const UITextAutocorrectionType(this.value);

  static UITextAutocorrectionType fromValue(int value) => switch (value) {
        0 => UITextAutocorrectionTypeDefault,
        1 => UITextAutocorrectionTypeNo,
        2 => UITextAutocorrectionTypeYes,
        _ => throw ArgumentError(
            'Unknown value for UITextAutocorrectionType: $value'),
      };
}

enum UITextSpellCheckingType {
  UITextSpellCheckingTypeDefault(0),
  UITextSpellCheckingTypeNo(1),
  UITextSpellCheckingTypeYes(2);

  final int value;
  const UITextSpellCheckingType(this.value);

  static UITextSpellCheckingType fromValue(int value) => switch (value) {
        0 => UITextSpellCheckingTypeDefault,
        1 => UITextSpellCheckingTypeNo,
        2 => UITextSpellCheckingTypeYes,
        _ => throw ArgumentError(
            'Unknown value for UITextSpellCheckingType: $value'),
      };
}

enum UITextSmartQuotesType {
  UITextSmartQuotesTypeDefault(0),
  UITextSmartQuotesTypeNo(1),
  UITextSmartQuotesTypeYes(2);

  final int value;
  const UITextSmartQuotesType(this.value);

  static UITextSmartQuotesType fromValue(int value) => switch (value) {
        0 => UITextSmartQuotesTypeDefault,
        1 => UITextSmartQuotesTypeNo,
        2 => UITextSmartQuotesTypeYes,
        _ => throw ArgumentError(
            'Unknown value for UITextSmartQuotesType: $value'),
      };
}

enum UITextSmartDashesType {
  UITextSmartDashesTypeDefault(0),
  UITextSmartDashesTypeNo(1),
  UITextSmartDashesTypeYes(2);

  final int value;
  const UITextSmartDashesType(this.value);

  static UITextSmartDashesType fromValue(int value) => switch (value) {
        0 => UITextSmartDashesTypeDefault,
        1 => UITextSmartDashesTypeNo,
        2 => UITextSmartDashesTypeYes,
        _ => throw ArgumentError(
            'Unknown value for UITextSmartDashesType: $value'),
      };
}

enum UITextSmartInsertDeleteType {
  UITextSmartInsertDeleteTypeDefault(0),
  UITextSmartInsertDeleteTypeNo(1),
  UITextSmartInsertDeleteTypeYes(2);

  final int value;
  const UITextSmartInsertDeleteType(this.value);

  static UITextSmartInsertDeleteType fromValue(int value) => switch (value) {
        0 => UITextSmartInsertDeleteTypeDefault,
        1 => UITextSmartInsertDeleteTypeNo,
        2 => UITextSmartInsertDeleteTypeYes,
        _ => throw ArgumentError(
            'Unknown value for UITextSmartInsertDeleteType: $value'),
      };
}

enum UITextInlinePredictionType {
  UITextInlinePredictionTypeDefault(0),
  UITextInlinePredictionTypeNo(1),
  UITextInlinePredictionTypeYes(2);

  final int value;
  const UITextInlinePredictionType(this.value);

  static UITextInlinePredictionType fromValue(int value) => switch (value) {
        0 => UITextInlinePredictionTypeDefault,
        1 => UITextInlinePredictionTypeNo,
        2 => UITextInlinePredictionTypeYes,
        _ => throw ArgumentError(
            'Unknown value for UITextInlinePredictionType: $value'),
      };
}

enum UITextMathExpressionCompletionType {
  UITextMathExpressionCompletionTypeDefault(0),
  UITextMathExpressionCompletionTypeNo(1),
  UITextMathExpressionCompletionTypeYes(2);

  final int value;
  const UITextMathExpressionCompletionType(this.value);

  static UITextMathExpressionCompletionType fromValue(int value) =>
      switch (value) {
        0 => UITextMathExpressionCompletionTypeDefault,
        1 => UITextMathExpressionCompletionTypeNo,
        2 => UITextMathExpressionCompletionTypeYes,
        _ => throw ArgumentError(
            'Unknown value for UITextMathExpressionCompletionType: $value'),
      };
}

enum UIKeyboardType {
  UIKeyboardTypeDefault(0),
  UIKeyboardTypeASCIICapable(1),
  UIKeyboardTypeNumbersAndPunctuation(2),
  UIKeyboardTypeURL(3),
  UIKeyboardTypeNumberPad(4),
  UIKeyboardTypePhonePad(5),
  UIKeyboardTypeNamePhonePad(6),
  UIKeyboardTypeEmailAddress(7),
  UIKeyboardTypeDecimalPad(8),
  UIKeyboardTypeTwitter(9),
  UIKeyboardTypeWebSearch(10),
  UIKeyboardTypeASCIICapableNumberPad(11);

  static const UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable;

  final int value;
  const UIKeyboardType(this.value);

  static UIKeyboardType fromValue(int value) => switch (value) {
        0 => UIKeyboardTypeDefault,
        1 => UIKeyboardTypeASCIICapable,
        2 => UIKeyboardTypeNumbersAndPunctuation,
        3 => UIKeyboardTypeURL,
        4 => UIKeyboardTypeNumberPad,
        5 => UIKeyboardTypePhonePad,
        6 => UIKeyboardTypeNamePhonePad,
        7 => UIKeyboardTypeEmailAddress,
        8 => UIKeyboardTypeDecimalPad,
        9 => UIKeyboardTypeTwitter,
        10 => UIKeyboardTypeWebSearch,
        11 => UIKeyboardTypeASCIICapableNumberPad,
        _ => throw ArgumentError('Unknown value for UIKeyboardType: $value'),
      };

  @override
  String toString() {
    if (this == UIKeyboardTypeASCIICapable)
      return "UIKeyboardType.UIKeyboardTypeASCIICapable, UIKeyboardType.UIKeyboardTypeAlphabet";
    return super.toString();
  }
}

enum UIKeyboardAppearance {
  UIKeyboardAppearanceDefault(0),
  UIKeyboardAppearanceDark(1),
  UIKeyboardAppearanceLight(2);

  static const UIKeyboardAppearanceAlert = UIKeyboardAppearanceDark;

  final int value;
  const UIKeyboardAppearance(this.value);

  static UIKeyboardAppearance fromValue(int value) => switch (value) {
        0 => UIKeyboardAppearanceDefault,
        1 => UIKeyboardAppearanceDark,
        2 => UIKeyboardAppearanceLight,
        _ =>
          throw ArgumentError('Unknown value for UIKeyboardAppearance: $value'),
      };

  @override
  String toString() {
    if (this == UIKeyboardAppearanceDark)
      return "UIKeyboardAppearance.UIKeyboardAppearanceDark, UIKeyboardAppearance.UIKeyboardAppearanceAlert";
    return super.toString();
  }
}

enum UIReturnKeyType {
  UIReturnKeyDefault(0),
  UIReturnKeyGo(1),
  UIReturnKeyGoogle(2),
  UIReturnKeyJoin(3),
  UIReturnKeyNext(4),
  UIReturnKeyRoute(5),
  UIReturnKeySearch(6),
  UIReturnKeySend(7),
  UIReturnKeyYahoo(8),
  UIReturnKeyDone(9),
  UIReturnKeyEmergencyCall(10),
  UIReturnKeyContinue(11);

  final int value;
  const UIReturnKeyType(this.value);

  static UIReturnKeyType fromValue(int value) => switch (value) {
        0 => UIReturnKeyDefault,
        1 => UIReturnKeyGo,
        2 => UIReturnKeyGoogle,
        3 => UIReturnKeyJoin,
        4 => UIReturnKeyNext,
        5 => UIReturnKeyRoute,
        6 => UIReturnKeySearch,
        7 => UIReturnKeySend,
        8 => UIReturnKeyYahoo,
        9 => UIReturnKeyDone,
        10 => UIReturnKeyEmergencyCall,
        11 => UIReturnKeyContinue,
        _ => throw ArgumentError('Unknown value for UIReturnKeyType: $value'),
      };
}

enum UIWritingToolsBehavior {
  UIWritingToolsBehaviorNone(-1),
  UIWritingToolsBehaviorDefault(0),
  UIWritingToolsBehaviorComplete(1),
  UIWritingToolsBehaviorLimited(2);

  final int value;
  const UIWritingToolsBehavior(this.value);

  static UIWritingToolsBehavior fromValue(int value) => switch (value) {
        -1 => UIWritingToolsBehaviorNone,
        0 => UIWritingToolsBehaviorDefault,
        1 => UIWritingToolsBehaviorComplete,
        2 => UIWritingToolsBehaviorLimited,
        _ => throw ArgumentError(
            'Unknown value for UIWritingToolsBehavior: $value'),
      };
}

enum UIWritingToolsResultOptions {
  UIWritingToolsResultDefault(0),
  UIWritingToolsResultPlainText(1),
  UIWritingToolsResultRichText(2),
  UIWritingToolsResultList(4),
  UIWritingToolsResultTable(8);

  final int value;
  const UIWritingToolsResultOptions(this.value);

  static UIWritingToolsResultOptions fromValue(int value) => switch (value) {
        0 => UIWritingToolsResultDefault,
        1 => UIWritingToolsResultPlainText,
        2 => UIWritingToolsResultRichText,
        4 => UIWritingToolsResultList,
        8 => UIWritingToolsResultTable,
        _ => throw ArgumentError(
            'Unknown value for UIWritingToolsResultOptions: $value'),
      };
}

enum UITextStorageDirection {
  UITextStorageDirectionForward(0),
  UITextStorageDirectionBackward(1);

  final int value;
  const UITextStorageDirection(this.value);

  static UITextStorageDirection fromValue(int value) => switch (value) {
        0 => UITextStorageDirectionForward,
        1 => UITextStorageDirectionBackward,
        _ => throw ArgumentError(
            'Unknown value for UITextStorageDirection: $value'),
      };
}

enum UITextLayoutDirection {
  UITextLayoutDirectionRight(2),
  UITextLayoutDirectionLeft(3),
  UITextLayoutDirectionUp(4),
  UITextLayoutDirectionDown(5);

  final int value;
  const UITextLayoutDirection(this.value);

  static UITextLayoutDirection fromValue(int value) => switch (value) {
        2 => UITextLayoutDirectionRight,
        3 => UITextLayoutDirectionLeft,
        4 => UITextLayoutDirectionUp,
        5 => UITextLayoutDirectionDown,
        _ => throw ArgumentError(
            'Unknown value for UITextLayoutDirection: $value'),
      };
}

enum UITextGranularity {
  UITextGranularityCharacter(0),
  UITextGranularityWord(1),
  UITextGranularitySentence(2),
  UITextGranularityParagraph(3),
  UITextGranularityLine(4),
  UITextGranularityDocument(5);

  final int value;
  const UITextGranularity(this.value);

  static UITextGranularity fromValue(int value) => switch (value) {
        0 => UITextGranularityCharacter,
        1 => UITextGranularityWord,
        2 => UITextGranularitySentence,
        3 => UITextGranularityParagraph,
        4 => UITextGranularityLine,
        5 => UITextGranularityDocument,
        _ => throw ArgumentError('Unknown value for UITextGranularity: $value'),
      };
}

enum UITextAlternativeStyle {
  UITextAlternativeStyleNone(0),
  UITextAlternativeStyleLowConfidence(1);

  final int value;
  const UITextAlternativeStyle(this.value);

  static UITextAlternativeStyle fromValue(int value) => switch (value) {
        0 => UITextAlternativeStyleNone,
        1 => UITextAlternativeStyleLowConfidence,
        _ => throw ArgumentError(
            'Unknown value for UITextAlternativeStyle: $value'),
      };
}

/// WARNING: UITextInputDelegate is a stub. To generate bindings for this class, include
/// UITextInputDelegate in your config's objc-protocols list.
///
/// UITextInputDelegate
interface class UITextInputDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UITextInputDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UITextInputDelegate] that points to the same underlying object as [other].
  UITextInputDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputDelegate] that wraps the given raw object pointer.
  UITextInputDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIBaselineAdjustment {
  UIBaselineAdjustmentAlignBaselines(0),
  UIBaselineAdjustmentAlignCenters(1),
  UIBaselineAdjustmentNone(2);

  final int value;
  const UIBaselineAdjustment(this.value);

  static UIBaselineAdjustment fromValue(int value) => switch (value) {
        0 => UIBaselineAdjustmentAlignBaselines,
        1 => UIBaselineAdjustmentAlignCenters,
        2 => UIBaselineAdjustmentNone,
        _ =>
          throw ArgumentError('Unknown value for UIBaselineAdjustment: $value'),
      };
}

late final _sel_sizeWithFont_ = objc.registerName("sizeWithFont:");
late final _sel_sizeWithFont_forWidth_lineBreakMode_ =
    objc.registerName("sizeWithFont:forWidth:lineBreakMode:");
final _objc_msgSend_kuoegl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Long)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            int)>();
final _objc_msgSend_kuoeglStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            int)>();
late final _sel_drawAtPoint_withFont_ =
    objc.registerName("drawAtPoint:withFont:");
final _objc_msgSend_17ogua4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_17ogua4Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_drawAtPoint_forWidth_withFont_lineBreakMode_ =
    objc.registerName("drawAtPoint:forWidth:withFont:lineBreakMode:");
final _objc_msgSend_vv6w34 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            double,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
final _objc_msgSend_vv6w34Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            double,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_sizeWithFont_constrainedToSize_ =
    objc.registerName("sizeWithFont:constrainedToSize:");
final _objc_msgSend_xq5db9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                objc.CGSize)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            objc.CGSize)>();
final _objc_msgSend_xq5db9Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                objc.CGSize)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            objc.CGSize)>();
late final _sel_sizeWithFont_constrainedToSize_lineBreakMode_ =
    objc.registerName("sizeWithFont:constrainedToSize:lineBreakMode:");
final _objc_msgSend_ryab2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                objc.CGSize,
                ffi.Long)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            objc.CGSize,
            int)>();
final _objc_msgSend_ryab2Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                objc.CGSize,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            objc.CGSize,
            int)>();
late final _sel_drawInRect_withFont_ =
    objc.registerName("drawInRect:withFont:");
final _objc_msgSend_1cqcuuc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_1cqcuucStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_drawInRect_withFont_lineBreakMode_ =
    objc.registerName("drawInRect:withFont:lineBreakMode:");
final _objc_msgSend_7bdf8d = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
final _objc_msgSend_7bdf8dStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_drawInRect_withFont_lineBreakMode_alignment_ =
    objc.registerName("drawInRect:withFont:lineBreakMode:alignment:");
final _objc_msgSend_1p7713g = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Long)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int)>();
final _objc_msgSend_1p7713gStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int)>();
late final _sel_sizeWithFont_minFontSize_actualFontSize_forWidth_lineBreakMode_ =
    objc.registerName(
        "sizeWithFont:minFontSize:actualFontSize:forWidth:lineBreakMode:");
final _objc_msgSend_15ap4e3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<ffi.Double>,
                ffi.Double,
                ffi.Long)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<ffi.Double>,
            double,
            int)>();
final _objc_msgSend_15ap4e3Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<ffi.Double>,
                ffi.Double,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<ffi.Double>,
            double,
            int)>();
late final _sel_drawAtPoint_forWidth_withFont_fontSize_lineBreakMode_baselineAdjustment_ =
    objc.registerName(
        "drawAtPoint:forWidth:withFont:fontSize:lineBreakMode:baselineAdjustment:");
final _objc_msgSend_rzrv5j = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Long,
                ffi.Long)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            double,
            ffi.Pointer<objc.ObjCObject>,
            double,
            int,
            int)>();
final _objc_msgSend_rzrv5jStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Long,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            double,
            ffi.Pointer<objc.ObjCObject>,
            double,
            int,
            int)>();
late final _sel_drawAtPoint_forWidth_withFont_minFontSize_actualFontSize_lineBreakMode_baselineAdjustment_ =
    objc.registerName(
        "drawAtPoint:forWidth:withFont:minFontSize:actualFontSize:lineBreakMode:baselineAdjustment:");
final _objc_msgSend_1hcmz6k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGSize Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<ffi.Double>,
                ffi.Long,
                ffi.Long)>>()
    .asFunction<
        objc.CGSize Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            double,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<ffi.Double>,
            int,
            int)>();
final _objc_msgSend_1hcmz6kStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGSize>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<ffi.Double>,
                ffi.Long,
                ffi.Long)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGSize>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            double,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<ffi.Double>,
            int,
            int)>();

/// UIStringDrawing
extension UIStringDrawing on objc.NSString {
  /// sizeWithFont:
  objc.CGSize sizeWithFont(UIFont font) {
    objc.checkOsVersionInternal('NSString.sizeWithFont:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18r320vStret(
            _ptr, this.ref.pointer, _sel_sizeWithFont_, font.ref.pointer)
        : _ptr.ref = _objc_msgSend_18r320v(
            this.ref.pointer, _sel_sizeWithFont_, font.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// sizeWithFont:forWidth:lineBreakMode:
  objc.CGSize sizeWithFont$1(UIFont font,
      {required double forWidth, required NSLineBreakMode lineBreakMode}) {
    objc.checkOsVersionInternal('NSString.sizeWithFont:forWidth:lineBreakMode:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_kuoeglStret(
            _ptr,
            this.ref.pointer,
            _sel_sizeWithFont_forWidth_lineBreakMode_,
            font.ref.pointer,
            forWidth,
            lineBreakMode.value)
        : _ptr.ref = _objc_msgSend_kuoegl(
            this.ref.pointer,
            _sel_sizeWithFont_forWidth_lineBreakMode_,
            font.ref.pointer,
            forWidth,
            lineBreakMode.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawAtPoint:withFont:
  objc.CGSize drawAtPoint(objc.CGPoint point, {required UIFont withFont}) {
    objc.checkOsVersionInternal('NSString.drawAtPoint:withFont:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_17ogua4Stret(_ptr, this.ref.pointer,
            _sel_drawAtPoint_withFont_, point, withFont.ref.pointer)
        : _ptr.ref = _objc_msgSend_17ogua4(this.ref.pointer,
            _sel_drawAtPoint_withFont_, point, withFont.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawAtPoint:forWidth:withFont:lineBreakMode:
  objc.CGSize drawAtPoint$1(objc.CGPoint point,
      {required double forWidth,
      required UIFont withFont,
      required NSLineBreakMode lineBreakMode}) {
    objc.checkOsVersionInternal(
        'NSString.drawAtPoint:forWidth:withFont:lineBreakMode:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_vv6w34Stret(
            _ptr,
            this.ref.pointer,
            _sel_drawAtPoint_forWidth_withFont_lineBreakMode_,
            point,
            forWidth,
            withFont.ref.pointer,
            lineBreakMode.value)
        : _ptr.ref = _objc_msgSend_vv6w34(
            this.ref.pointer,
            _sel_drawAtPoint_forWidth_withFont_lineBreakMode_,
            point,
            forWidth,
            withFont.ref.pointer,
            lineBreakMode.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// sizeWithFont:constrainedToSize:
  objc.CGSize sizeWithFont$2(UIFont font,
      {required objc.CGSize constrainedToSize}) {
    objc.checkOsVersionInternal('NSString.sizeWithFont:constrainedToSize:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_xq5db9Stret(
            _ptr,
            this.ref.pointer,
            _sel_sizeWithFont_constrainedToSize_,
            font.ref.pointer,
            constrainedToSize)
        : _ptr.ref = _objc_msgSend_xq5db9(
            this.ref.pointer,
            _sel_sizeWithFont_constrainedToSize_,
            font.ref.pointer,
            constrainedToSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// sizeWithFont:constrainedToSize:lineBreakMode:
  objc.CGSize sizeWithFont$3(UIFont font,
      {required objc.CGSize constrainedToSize,
      required NSLineBreakMode lineBreakMode}) {
    objc.checkOsVersionInternal(
        'NSString.sizeWithFont:constrainedToSize:lineBreakMode:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ryab2Stret(
            _ptr,
            this.ref.pointer,
            _sel_sizeWithFont_constrainedToSize_lineBreakMode_,
            font.ref.pointer,
            constrainedToSize,
            lineBreakMode.value)
        : _ptr.ref = _objc_msgSend_ryab2(
            this.ref.pointer,
            _sel_sizeWithFont_constrainedToSize_lineBreakMode_,
            font.ref.pointer,
            constrainedToSize,
            lineBreakMode.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawInRect:withFont:
  objc.CGSize drawInRect(objc.CGRect rect, {required UIFont withFont}) {
    objc.checkOsVersionInternal('NSString.drawInRect:withFont:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1cqcuucStret(_ptr, this.ref.pointer,
            _sel_drawInRect_withFont_, rect, withFont.ref.pointer)
        : _ptr.ref = _objc_msgSend_1cqcuuc(this.ref.pointer,
            _sel_drawInRect_withFont_, rect, withFont.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawInRect:withFont:lineBreakMode:
  objc.CGSize drawInRect$1(objc.CGRect rect,
      {required UIFont withFont, required NSLineBreakMode lineBreakMode}) {
    objc.checkOsVersionInternal('NSString.drawInRect:withFont:lineBreakMode:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_7bdf8dStret(
            _ptr,
            this.ref.pointer,
            _sel_drawInRect_withFont_lineBreakMode_,
            rect,
            withFont.ref.pointer,
            lineBreakMode.value)
        : _ptr.ref = _objc_msgSend_7bdf8d(
            this.ref.pointer,
            _sel_drawInRect_withFont_lineBreakMode_,
            rect,
            withFont.ref.pointer,
            lineBreakMode.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawInRect:withFont:lineBreakMode:alignment:
  objc.CGSize drawInRect$2(objc.CGRect rect,
      {required UIFont withFont,
      required NSLineBreakMode lineBreakMode,
      required NSTextAlignment alignment}) {
    objc.checkOsVersionInternal(
        'NSString.drawInRect:withFont:lineBreakMode:alignment:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1p7713gStret(
            _ptr,
            this.ref.pointer,
            _sel_drawInRect_withFont_lineBreakMode_alignment_,
            rect,
            withFont.ref.pointer,
            lineBreakMode.value,
            alignment.value)
        : _ptr.ref = _objc_msgSend_1p7713g(
            this.ref.pointer,
            _sel_drawInRect_withFont_lineBreakMode_alignment_,
            rect,
            withFont.ref.pointer,
            lineBreakMode.value,
            alignment.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// sizeWithFont:minFontSize:actualFontSize:forWidth:lineBreakMode:
  objc.CGSize sizeWithFont$4(UIFont font,
      {required double minFontSize,
      required ffi.Pointer<ffi.Double> actualFontSize,
      required double forWidth,
      required NSLineBreakMode lineBreakMode}) {
    objc.checkOsVersionInternal(
        'NSString.sizeWithFont:minFontSize:actualFontSize:forWidth:lineBreakMode:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_15ap4e3Stret(
            _ptr,
            this.ref.pointer,
            _sel_sizeWithFont_minFontSize_actualFontSize_forWidth_lineBreakMode_,
            font.ref.pointer,
            minFontSize,
            actualFontSize,
            forWidth,
            lineBreakMode.value)
        : _ptr.ref = _objc_msgSend_15ap4e3(
            this.ref.pointer,
            _sel_sizeWithFont_minFontSize_actualFontSize_forWidth_lineBreakMode_,
            font.ref.pointer,
            minFontSize,
            actualFontSize,
            forWidth,
            lineBreakMode.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawAtPoint:forWidth:withFont:fontSize:lineBreakMode:baselineAdjustment:
  objc.CGSize drawAtPoint$2(objc.CGPoint point,
      {required double forWidth,
      required UIFont withFont,
      required double fontSize,
      required NSLineBreakMode lineBreakMode,
      required UIBaselineAdjustment baselineAdjustment}) {
    objc.checkOsVersionInternal(
        'NSString.drawAtPoint:forWidth:withFont:fontSize:lineBreakMode:baselineAdjustment:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_rzrv5jStret(
            _ptr,
            this.ref.pointer,
            _sel_drawAtPoint_forWidth_withFont_fontSize_lineBreakMode_baselineAdjustment_,
            point,
            forWidth,
            withFont.ref.pointer,
            fontSize,
            lineBreakMode.value,
            baselineAdjustment.value)
        : _ptr.ref = _objc_msgSend_rzrv5j(
            this.ref.pointer,
            _sel_drawAtPoint_forWidth_withFont_fontSize_lineBreakMode_baselineAdjustment_,
            point,
            forWidth,
            withFont.ref.pointer,
            fontSize,
            lineBreakMode.value,
            baselineAdjustment.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// drawAtPoint:forWidth:withFont:minFontSize:actualFontSize:lineBreakMode:baselineAdjustment:
  objc.CGSize drawAtPoint$3(objc.CGPoint point,
      {required double forWidth,
      required UIFont withFont,
      required double minFontSize,
      required ffi.Pointer<ffi.Double> actualFontSize,
      required NSLineBreakMode lineBreakMode,
      required UIBaselineAdjustment baselineAdjustment}) {
    objc.checkOsVersionInternal(
        'NSString.drawAtPoint:forWidth:withFont:minFontSize:actualFontSize:lineBreakMode:baselineAdjustment:',
        iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1hcmz6kStret(
            _ptr,
            this.ref.pointer,
            _sel_drawAtPoint_forWidth_withFont_minFontSize_actualFontSize_lineBreakMode_baselineAdjustment_,
            point,
            forWidth,
            withFont.ref.pointer,
            minFontSize,
            actualFontSize,
            lineBreakMode.value,
            baselineAdjustment.value)
        : _ptr.ref = _objc_msgSend_1hcmz6k(
            this.ref.pointer,
            _sel_drawAtPoint_forWidth_withFont_minFontSize_actualFontSize_lineBreakMode_baselineAdjustment_,
            point,
            forWidth,
            withFont.ref.pointer,
            minFontSize,
            actualFontSize,
            lineBreakMode.value,
            baselineAdjustment.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }
}

enum UIDropOperation {
  UIDropOperationCancel(0),
  UIDropOperationForbidden(1),
  UIDropOperationCopy(2),
  UIDropOperationMove(3);

  final int value;
  const UIDropOperation(this.value);

  static UIDropOperation fromValue(int value) => switch (value) {
        0 => UIDropOperationCancel,
        1 => UIDropOperationForbidden,
        2 => UIDropOperationCopy,
        3 => UIDropOperationMove,
        _ => throw ArgumentError('Unknown value for UIDropOperation: $value'),
      };
}

enum UIViewAnimatingState {
  UIViewAnimatingStateInactive(0),
  UIViewAnimatingStateActive(1),
  UIViewAnimatingStateStopped(2);

  final int value;
  const UIViewAnimatingState(this.value);

  static UIViewAnimatingState fromValue(int value) => switch (value) {
        0 => UIViewAnimatingStateInactive,
        1 => UIViewAnimatingStateActive,
        2 => UIViewAnimatingStateStopped,
        _ =>
          throw ArgumentError('Unknown value for UIViewAnimatingState: $value'),
      };
}

enum UIViewAnimatingPosition {
  UIViewAnimatingPositionEnd(0),
  UIViewAnimatingPositionStart(1),
  UIViewAnimatingPositionCurrent(2);

  final int value;
  const UIViewAnimatingPosition(this.value);

  static UIViewAnimatingPosition fromValue(int value) => switch (value) {
        0 => UIViewAnimatingPositionEnd,
        1 => UIViewAnimatingPositionStart,
        2 => UIViewAnimatingPositionCurrent,
        _ => throw ArgumentError(
            'Unknown value for UIViewAnimatingPosition: $value'),
      };
}

enum UITextDragOptions {
  UITextDragOptionsNone(0),
  UITextDragOptionStripTextColorFromPreviews(1);

  final int value;
  const UITextDragOptions(this.value);

  static UITextDragOptions fromValue(int value) => switch (value) {
        0 => UITextDragOptionsNone,
        1 => UITextDragOptionStripTextColorFromPreviews,
        _ => throw ArgumentError('Unknown value for UITextDragOptions: $value'),
      };
}

enum UITextDropAction {
  UITextDropActionInsert(0),
  UITextDropActionReplaceSelection(1),
  UITextDropActionReplaceAll(2);

  final int value;
  const UITextDropAction(this.value);

  static UITextDropAction fromValue(int value) => switch (value) {
        0 => UITextDropActionInsert,
        1 => UITextDropActionReplaceSelection,
        2 => UITextDropActionReplaceAll,
        _ => throw ArgumentError('Unknown value for UITextDropAction: $value'),
      };
}

enum UITextDropProgressMode {
  UITextDropProgressModeSystem(0),
  UITextDropProgressModeCustom(1);

  final int value;
  const UITextDropProgressMode(this.value);

  static UITextDropProgressMode fromValue(int value) => switch (value) {
        0 => UITextDropProgressModeSystem,
        1 => UITextDropProgressModeCustom,
        _ => throw ArgumentError(
            'Unknown value for UITextDropProgressMode: $value'),
      };
}

enum UITextDropPerformer {
  UITextDropPerformerView(0),
  UITextDropPerformerDelegate(1);

  final int value;
  const UITextDropPerformer(this.value);

  static UITextDropPerformer fromValue(int value) => switch (value) {
        0 => UITextDropPerformerView,
        1 => UITextDropPerformerDelegate,
        _ =>
          throw ArgumentError('Unknown value for UITextDropPerformer: $value'),
      };
}

enum UITextDropEditability {
  UITextDropEditabilityNo(0),
  UITextDropEditabilityTemporary(1),
  UITextDropEditabilityYes(2);

  final int value;
  const UITextDropEditability(this.value);

  static UITextDropEditability fromValue(int value) => switch (value) {
        0 => UITextDropEditabilityNo,
        1 => UITextDropEditabilityTemporary,
        2 => UITextDropEditabilityYes,
        _ => throw ArgumentError(
            'Unknown value for UITextDropEditability: $value'),
      };
}

/// WARNING: UIContentSizeCategoryAdjusting is a stub. To generate bindings for this class, include
/// UIContentSizeCategoryAdjusting in your config's objc-protocols list.
///
/// UIContentSizeCategoryAdjusting
interface class UIContentSizeCategoryAdjusting extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIContentSizeCategoryAdjusting._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIContentSizeCategoryAdjusting] that points to the same underlying object as [other].
  UIContentSizeCategoryAdjusting.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContentSizeCategoryAdjusting] that wraps the given raw object pointer.
  UIContentSizeCategoryAdjusting.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UILetterformAwareSizingRule {
  UILetterformAwareSizingRuleTypographic(0),
  UILetterformAwareSizingRuleOversize(1);

  final int value;
  const UILetterformAwareSizingRule(this.value);

  static UILetterformAwareSizingRule fromValue(int value) => switch (value) {
        0 => UILetterformAwareSizingRuleTypographic,
        1 => UILetterformAwareSizingRuleOversize,
        _ => throw ArgumentError(
            'Unknown value for UILetterformAwareSizingRule: $value'),
      };
}

/// WARNING: UILetterformAwareAdjusting is a stub. To generate bindings for this class, include
/// UILetterformAwareAdjusting in your config's objc-protocols list.
///
/// UILetterformAwareAdjusting
interface class UILetterformAwareAdjusting extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UILetterformAwareAdjusting._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UILetterformAwareAdjusting] that points to the same underlying object as [other].
  UILetterformAwareAdjusting.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILetterformAwareAdjusting] that wraps the given raw object pointer.
  UILetterformAwareAdjusting.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UITextBorderStyle {
  UITextBorderStyleNone(0),
  UITextBorderStyleLine(1),
  UITextBorderStyleBezel(2),
  UITextBorderStyleRoundedRect(3);

  final int value;
  const UITextBorderStyle(this.value);

  static UITextBorderStyle fromValue(int value) => switch (value) {
        0 => UITextBorderStyleNone,
        1 => UITextBorderStyleLine,
        2 => UITextBorderStyleBezel,
        3 => UITextBorderStyleRoundedRect,
        _ => throw ArgumentError('Unknown value for UITextBorderStyle: $value'),
      };
}

enum UITextFieldViewMode {
  UITextFieldViewModeNever(0),
  UITextFieldViewModeWhileEditing(1),
  UITextFieldViewModeUnlessEditing(2),
  UITextFieldViewModeAlways(3);

  final int value;
  const UITextFieldViewMode(this.value);

  static UITextFieldViewMode fromValue(int value) => switch (value) {
        0 => UITextFieldViewModeNever,
        1 => UITextFieldViewModeWhileEditing,
        2 => UITextFieldViewModeUnlessEditing,
        3 => UITextFieldViewModeAlways,
        _ =>
          throw ArgumentError('Unknown value for UITextFieldViewMode: $value'),
      };
}

enum UITextFieldDidEndEditingReason {
  UITextFieldDidEndEditingReasonCommitted(0),
  UITextFieldDidEndEditingReasonCancelled(1);

  final int value;
  const UITextFieldDidEndEditingReason(this.value);

  static UITextFieldDidEndEditingReason fromValue(int value) => switch (value) {
        0 => UITextFieldDidEndEditingReasonCommitted,
        1 => UITextFieldDidEndEditingReasonCancelled,
        _ => throw ArgumentError(
            'Unknown value for UITextFieldDidEndEditingReason: $value'),
      };
}

enum UIStatusBarStyle {
  UIStatusBarStyleDefault(0),
  UIStatusBarStyleLightContent(1),
  UIStatusBarStyleDarkContent(3),
  UIStatusBarStyleBlackOpaque(2);

  static const UIStatusBarStyleBlackTranslucent = UIStatusBarStyleLightContent;

  final int value;
  const UIStatusBarStyle(this.value);

  static UIStatusBarStyle fromValue(int value) => switch (value) {
        0 => UIStatusBarStyleDefault,
        1 => UIStatusBarStyleLightContent,
        3 => UIStatusBarStyleDarkContent,
        2 => UIStatusBarStyleBlackOpaque,
        _ => throw ArgumentError('Unknown value for UIStatusBarStyle: $value'),
      };

  @override
  String toString() {
    if (this == UIStatusBarStyleLightContent)
      return "UIStatusBarStyle.UIStatusBarStyleLightContent, UIStatusBarStyle.UIStatusBarStyleBlackTranslucent";
    return super.toString();
  }
}

enum UIStatusBarAnimation {
  UIStatusBarAnimationNone(0),
  UIStatusBarAnimationFade(1),
  UIStatusBarAnimationSlide(2);

  final int value;
  const UIStatusBarAnimation(this.value);

  static UIStatusBarAnimation fromValue(int value) => switch (value) {
        0 => UIStatusBarAnimationNone,
        1 => UIStatusBarAnimationFade,
        2 => UIStatusBarAnimationSlide,
        _ =>
          throw ArgumentError('Unknown value for UIStatusBarAnimation: $value'),
      };
}

enum UIModalTransitionStyle {
  UIModalTransitionStyleCoverVertical(0),
  UIModalTransitionStyleFlipHorizontal(1),
  UIModalTransitionStyleCrossDissolve(2),
  UIModalTransitionStylePartialCurl(3);

  final int value;
  const UIModalTransitionStyle(this.value);

  static UIModalTransitionStyle fromValue(int value) => switch (value) {
        0 => UIModalTransitionStyleCoverVertical,
        1 => UIModalTransitionStyleFlipHorizontal,
        2 => UIModalTransitionStyleCrossDissolve,
        3 => UIModalTransitionStylePartialCurl,
        _ => throw ArgumentError(
            'Unknown value for UIModalTransitionStyle: $value'),
      };
}

enum UIModalPresentationStyle {
  UIModalPresentationFullScreen(0),
  UIModalPresentationPageSheet(1),
  UIModalPresentationFormSheet(2),
  UIModalPresentationCurrentContext(3),
  UIModalPresentationCustom(4),
  UIModalPresentationOverFullScreen(5),
  UIModalPresentationOverCurrentContext(6),
  UIModalPresentationPopover(7),
  UIModalPresentationBlurOverFullScreen(8),
  UIModalPresentationNone(-1),
  UIModalPresentationAutomatic(-2);

  final int value;
  const UIModalPresentationStyle(this.value);

  static UIModalPresentationStyle fromValue(int value) => switch (value) {
        0 => UIModalPresentationFullScreen,
        1 => UIModalPresentationPageSheet,
        2 => UIModalPresentationFormSheet,
        3 => UIModalPresentationCurrentContext,
        4 => UIModalPresentationCustom,
        5 => UIModalPresentationOverFullScreen,
        6 => UIModalPresentationOverCurrentContext,
        7 => UIModalPresentationPopover,
        8 => UIModalPresentationBlurOverFullScreen,
        -1 => UIModalPresentationNone,
        -2 => UIModalPresentationAutomatic,
        _ => throw ArgumentError(
            'Unknown value for UIModalPresentationStyle: $value'),
      };
}

/// WARNING: UIContentContainer is a stub. To generate bindings for this class, include
/// UIContentContainer in your config's objc-protocols list.
///
/// UIContentContainer
interface class UIContentContainer extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIContentContainer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIContentContainer] that points to the same underlying object as [other].
  UIContentContainer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContentContainer] that wraps the given raw object pointer.
  UIContentContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIContainerBackgroundStyle {
  UIContainerBackgroundStyleAutomatic(0),
  UIContainerBackgroundStyleGlass(1),
  UIContainerBackgroundStyleHidden(2);

  final int value;
  const UIContainerBackgroundStyle(this.value);

  static UIContainerBackgroundStyle fromValue(int value) => switch (value) {
        0 => UIContainerBackgroundStyleAutomatic,
        1 => UIContainerBackgroundStyleGlass,
        2 => UIContainerBackgroundStyleHidden,
        _ => throw ArgumentError(
            'Unknown value for UIContainerBackgroundStyle: $value'),
      };
}

/// WARNING: UISymbolEffectCompletionContext is a stub. To generate bindings for this class, include
/// UISymbolEffectCompletionContext in your config's objc-interfaces list.
///
/// UISymbolEffectCompletionContext
class UISymbolEffectCompletionContext extends objc.NSObject {
  UISymbolEffectCompletionContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UISymbolEffectCompletionContext',
        iOS: (false, (17, 0, 0)));
  }

  /// Constructs a [UISymbolEffectCompletionContext] that points to the same underlying object as [other].
  UISymbolEffectCompletionContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISymbolEffectCompletionContext] that wraps the given raw object pointer.
  UISymbolEffectCompletionContext.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>`.
abstract final class ObjCBlock_ffiVoid_UISymbolEffectCompletionContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
      fromFunction(void Function(UISymbolEffectCompletionContext) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                      UISymbolEffectCompletionContext.castFromPointer(arg0,
                          retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
      listener(void Function(UISymbolEffectCompletionContext) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            UISymbolEffectCompletionContext.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
      blocking(void Function(UISymbolEffectCompletionContext) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            UISymbolEffectCompletionContext.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            UISymbolEffectCompletionContext.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>`.
extension ObjCBlock_ffiVoid_UISymbolEffectCompletionContext_CallExtension
    on objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)> {
  void call(UISymbolEffectCompletionContext arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer);
}

/// WARNING: NSSymbolEffectOptions is a stub. To generate bindings for this class, include
/// NSSymbolEffectOptions in your config's objc-interfaces list.
///
/// NSSymbolEffectOptions
class NSSymbolEffectOptions extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSSymbolEffectOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSSymbolEffectOptions',
        iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }

  /// Constructs a [NSSymbolEffectOptions] that points to the same underlying object as [other].
  NSSymbolEffectOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSSymbolEffectOptions] that wraps the given raw object pointer.
  NSSymbolEffectOptions.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSSymbolEffect is a stub. To generate bindings for this class, include
/// NSSymbolEffect in your config's objc-interfaces list.
///
/// NSSymbolEffect
class NSSymbolEffect extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSSymbolEffect._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSSymbolEffect',
        iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }

  /// Constructs a [NSSymbolEffect] that points to the same underlying object as [other].
  NSSymbolEffect.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSSymbolEffect] that wraps the given raw object pointer.
  NSSymbolEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSSymbolContentTransition is a stub. To generate bindings for this class, include
/// NSSymbolContentTransition in your config's objc-interfaces list.
///
/// NSSymbolContentTransition
class NSSymbolContentTransition extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSSymbolContentTransition._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSSymbolContentTransition',
        iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }

  /// Constructs a [NSSymbolContentTransition] that points to the same underlying object as [other].
  NSSymbolContentTransition.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSSymbolContentTransition] that wraps the given raw object pointer.
  NSSymbolContentTransition.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_UIImageView = objc.getClass("UIImageView");

///
extension unnamed$1 on UIImageView {}

/// WARNING: UIAccessibilityContentSizeCategoryImageAdjusting is a stub. To generate bindings for this class, include
/// UIAccessibilityContentSizeCategoryImageAdjusting in your config's objc-protocols list.
///
/// UIAccessibilityContentSizeCategoryImageAdjusting
interface class UIAccessibilityContentSizeCategoryImageAdjusting
    extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIAccessibilityContentSizeCategoryImageAdjusting._(
      ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false,
      bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAccessibilityContentSizeCategoryImageAdjusting] that points to the same underlying object as [other].
  UIAccessibilityContentSizeCategoryImageAdjusting.castFrom(
      objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAccessibilityContentSizeCategoryImageAdjusting] that wraps the given raw object pointer.
  UIAccessibilityContentSizeCategoryImageAdjusting.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_adjustsImageSizeForAccessibilityContentSizeCategory =
    objc.registerName("adjustsImageSizeForAccessibilityContentSizeCategory");
late final _sel_setAdjustsImageSizeForAccessibilityContentSizeCategory_ = objc
    .registerName("setAdjustsImageSizeForAccessibilityContentSizeCategory:");
void _ObjCBlock_ffiVoid_ffiVoid_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        bool arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>, bool)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Bool)>(_ObjCBlock_ffiVoid_ffiVoid_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        bool arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(
        arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_bool_closureCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Bool)>(_ObjCBlock_ffiVoid_ffiVoid_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    bool arg1) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(
      arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_ffiVoid_bool_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Bool)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    bool arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_ffiVoid_bool_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Bool)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_ffiVoid_bool_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Bool)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(
                              ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_bool_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, bool) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_bool_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
      listener(void Function(ffi.Pointer<ffi.Void>, bool) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_bool_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_10lndml(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
      blocking(void Function(ffi.Pointer<ffi.Void>, bool) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_bool_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_bool_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_10lndml(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_ffiVoid_bool_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> {
  void call(ffi.Pointer<ffi.Void> arg0, bool arg1) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>,
              bool)>()(ref.pointer, arg0, arg1);
}

/// UIAccessibilityContentSizeCategoryImageAdjusting
extension UIAccessibilityContentSizeCategoryImageAdjusting$1 on UIImageView {
  /// adjustsImageSizeForAccessibilityContentSizeCategory
  bool get adjustsImageSizeForAccessibilityContentSizeCategory {
    objc.checkOsVersionInternal(
        'UIImageView.adjustsImageSizeForAccessibilityContentSizeCategory',
        iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer,
        _sel_adjustsImageSizeForAccessibilityContentSizeCategory);
  }

  /// setAdjustsImageSizeForAccessibilityContentSizeCategory:
  set adjustsImageSizeForAccessibilityContentSizeCategory(bool value) {
    objc.checkOsVersionInternal(
        'UIImageView.setAdjustsImageSizeForAccessibilityContentSizeCategory:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setAdjustsImageSizeForAccessibilityContentSizeCategory_, value);
  }
}

late final _sel_initWithImage_ = objc.registerName("initWithImage:");
late final _sel_initWithImage_highlightedImage_ =
    objc.registerName("initWithImage:highlightedImage:");
late final _sel_highlightedImage = objc.registerName("highlightedImage");
late final _sel_setHighlightedImage_ =
    objc.registerName("setHighlightedImage:");
late final _sel_preferredSymbolConfiguration =
    objc.registerName("preferredSymbolConfiguration");
late final _sel_setPreferredSymbolConfiguration_ =
    objc.registerName("setPreferredSymbolConfiguration:");
late final _sel_isHighlighted = objc.registerName("isHighlighted");
late final _sel_setHighlighted_ = objc.registerName("setHighlighted:");
late final _sel_animationImages = objc.registerName("animationImages");
late final _sel_setAnimationImages_ = objc.registerName("setAnimationImages:");
late final _sel_highlightedAnimationImages =
    objc.registerName("highlightedAnimationImages");
late final _sel_setHighlightedAnimationImages_ =
    objc.registerName("setHighlightedAnimationImages:");
late final _sel_animationDuration = objc.registerName("animationDuration");
late final _sel_animationRepeatCount =
    objc.registerName("animationRepeatCount");
late final _sel_startAnimating = objc.registerName("startAnimating");
late final _sel_stopAnimating = objc.registerName("stopAnimating");
late final _sel_isAnimating = objc.registerName("isAnimating");
late final _sel_preferredImageDynamicRange =
    objc.registerName("preferredImageDynamicRange");
final _objc_msgSend_xfd0s2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPreferredImageDynamicRange_ =
    objc.registerName("setPreferredImageDynamicRange:");
final _objc_msgSend_141mpu0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_imageDynamicRange = objc.registerName("imageDynamicRange");
late final _sel_adjustsImageWhenAncestorFocused =
    objc.registerName("adjustsImageWhenAncestorFocused");
late final _sel_setAdjustsImageWhenAncestorFocused_ =
    objc.registerName("setAdjustsImageWhenAncestorFocused:");
late final _sel_focusedFrameGuide = objc.registerName("focusedFrameGuide");
late final _sel_overlayContentView = objc.registerName("overlayContentView");
late final _sel_masksFocusEffectToContents =
    objc.registerName("masksFocusEffectToContents");
late final _sel_setMasksFocusEffectToContents_ =
    objc.registerName("setMasksFocusEffectToContents:");
late final _sel_addSymbolEffect_ = objc.registerName("addSymbolEffect:");
late final _sel_addSymbolEffect_options_ =
    objc.registerName("addSymbolEffect:options:");
late final _sel_addSymbolEffect_options_animated_ =
    objc.registerName("addSymbolEffect:options:animated:");
final _objc_msgSend_1lhy15d = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_addSymbolEffect_options_animated_completion_ =
    objc.registerName("addSymbolEffect:options:animated:completion:");
final _objc_msgSend_1imhooq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_removeSymbolEffectOfType_ =
    objc.registerName("removeSymbolEffectOfType:");
late final _sel_removeSymbolEffectOfType_options_ =
    objc.registerName("removeSymbolEffectOfType:options:");
late final _sel_removeSymbolEffectOfType_options_animated_ =
    objc.registerName("removeSymbolEffectOfType:options:animated:");
late final _sel_removeSymbolEffectOfType_options_animated_completion_ =
    objc.registerName("removeSymbolEffectOfType:options:animated:completion:");
late final _sel_removeAllSymbolEffects =
    objc.registerName("removeAllSymbolEffects");
late final _sel_removeAllSymbolEffectsWithOptions_ =
    objc.registerName("removeAllSymbolEffectsWithOptions:");
late final _sel_removeAllSymbolEffectsWithOptions_animated_ =
    objc.registerName("removeAllSymbolEffectsWithOptions:animated:");
final _objc_msgSend_6p7ndb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_setSymbolImage_withContentTransition_ =
    objc.registerName("setSymbolImage:withContentTransition:");
late final _sel_setSymbolImage_withContentTransition_options_ =
    objc.registerName("setSymbolImage:withContentTransition:options:");
late final _sel_setSymbolImage_withContentTransition_options_completion_ = objc
    .registerName("setSymbolImage:withContentTransition:options:completion:");
final _objc_msgSend_m7tls4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// UIImageView
class UIImageView extends UIView {
  UIImageView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImageView', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIImageView] that points to the same underlying object as [other].
  UIImageView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIImageView] that wraps the given raw object pointer.
  UIImageView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIImageView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIImageView);
  }

  /// initWithImage:
  UIImageView initWithImage(UIImage? image) {
    objc.checkOsVersionInternal('UIImageView.initWithImage:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithImage_, image?.ref.pointer ?? ffi.nullptr);
    return UIImageView.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithImage:highlightedImage:
  UIImageView initWithImage$1(UIImage? image, {UIImage? highlightedImage}) {
    objc.checkOsVersionInternal('UIImageView.initWithImage:highlightedImage:',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithImage_highlightedImage_,
        image?.ref.pointer ?? ffi.nullptr,
        highlightedImage?.ref.pointer ?? ffi.nullptr);
    return UIImageView.castFromPointer(_ret, retain: false, release: true);
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal('UIImageView.image', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setImage:
  set image(UIImage? value) {
    objc.checkOsVersionInternal('UIImageView.setImage:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// highlightedImage
  UIImage? get highlightedImage {
    objc.checkOsVersionInternal('UIImageView.highlightedImage',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_highlightedImage);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setHighlightedImage:
  set highlightedImage(UIImage? value) {
    objc.checkOsVersionInternal('UIImageView.setHighlightedImage:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHighlightedImage_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// preferredSymbolConfiguration
  UIImageSymbolConfiguration? get preferredSymbolConfiguration {
    objc.checkOsVersionInternal('UIImageView.preferredSymbolConfiguration',
        iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_preferredSymbolConfiguration);
    return _ret.address == 0
        ? null
        : UIImageSymbolConfiguration.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setPreferredSymbolConfiguration:
  set preferredSymbolConfiguration(UIImageSymbolConfiguration? value) {
    objc.checkOsVersionInternal('UIImageView.setPreferredSymbolConfiguration:',
        iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer,
        _sel_setPreferredSymbolConfiguration_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// isUserInteractionEnabled
  bool get userInteractionEnabled {
    objc.checkOsVersionInternal('UIImageView.isUserInteractionEnabled',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_isUserInteractionEnabled);
  }

  /// setUserInteractionEnabled:
  set userInteractionEnabled(bool value) {
    objc.checkOsVersionInternal('UIImageView.setUserInteractionEnabled:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setUserInteractionEnabled_, value);
  }

  /// isHighlighted
  bool get highlighted {
    objc.checkOsVersionInternal('UIImageView.isHighlighted',
        iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHighlighted);
  }

  /// setHighlighted:
  set highlighted(bool value) {
    objc.checkOsVersionInternal('UIImageView.setHighlighted:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHighlighted_, value);
  }

  /// animationImages
  objc.NSArray? get animationImages {
    objc.checkOsVersionInternal('UIImageView.animationImages',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_animationImages);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAnimationImages:
  set animationImages(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIImageView.setAnimationImages:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAnimationImages_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// highlightedAnimationImages
  objc.NSArray? get highlightedAnimationImages {
    objc.checkOsVersionInternal('UIImageView.highlightedAnimationImages',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_highlightedAnimationImages);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setHighlightedAnimationImages:
  set highlightedAnimationImages(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIImageView.setHighlightedAnimationImages:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHighlightedAnimationImages_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// animationDuration
  double get animationDuration {
    objc.checkOsVersionInternal('UIImageView.animationDuration',
        iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_animationDuration)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_animationDuration);
  }

  /// setAnimationDuration:
  set animationDuration(double value) {
    objc.checkOsVersionInternal('UIImageView.setAnimationDuration:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setAnimationDuration_, value);
  }

  /// animationRepeatCount
  int get animationRepeatCount {
    objc.checkOsVersionInternal('UIImageView.animationRepeatCount',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_animationRepeatCount);
  }

  /// setAnimationRepeatCount:
  set animationRepeatCount(int value) {
    objc.checkOsVersionInternal('UIImageView.setAnimationRepeatCount:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(
        this.ref.pointer, _sel_setAnimationRepeatCount_, value);
  }

  /// tintColor
  UIColor get tintColor {
    objc.checkOsVersionInternal('UIImageView.tintColor',
        iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tintColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTintColor:
  set tintColor(UIColor value) {
    objc.checkOsVersionInternal('UIImageView.setTintColor:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTintColor_, value.ref.pointer);
  }

  /// startAnimating
  void startAnimating() {
    objc.checkOsVersionInternal('UIImageView.startAnimating',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_startAnimating);
  }

  /// stopAnimating
  void stopAnimating() {
    objc.checkOsVersionInternal('UIImageView.stopAnimating',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_stopAnimating);
  }

  /// isAnimating
  bool get animating {
    objc.checkOsVersionInternal('UIImageView.isAnimating',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isAnimating);
  }

  /// preferredImageDynamicRange
  UIImageDynamicRange get preferredImageDynamicRange {
    objc.checkOsVersionInternal('UIImageView.preferredImageDynamicRange',
        iOS: (false, (2, 0, 0)));
    final _ret =
        _objc_msgSend_xfd0s2(this.ref.pointer, _sel_preferredImageDynamicRange);
    return UIImageDynamicRange.fromValue(_ret);
  }

  /// setPreferredImageDynamicRange:
  set preferredImageDynamicRange(UIImageDynamicRange value) {
    objc.checkOsVersionInternal('UIImageView.setPreferredImageDynamicRange:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_141mpu0(
        this.ref.pointer, _sel_setPreferredImageDynamicRange_, value.value);
  }

  /// imageDynamicRange
  UIImageDynamicRange get imageDynamicRange {
    objc.checkOsVersionInternal('UIImageView.imageDynamicRange',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_xfd0s2(this.ref.pointer, _sel_imageDynamicRange);
    return UIImageDynamicRange.fromValue(_ret);
  }

  /// adjustsImageWhenAncestorFocused
  bool get adjustsImageWhenAncestorFocused {
    objc.checkOsVersionInternal('UIImageView.adjustsImageWhenAncestorFocused',
        iOS: (true, null));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_adjustsImageWhenAncestorFocused);
  }

  /// setAdjustsImageWhenAncestorFocused:
  set adjustsImageWhenAncestorFocused(bool value) {
    objc.checkOsVersionInternal(
        'UIImageView.setAdjustsImageWhenAncestorFocused:',
        iOS: (true, null));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAdjustsImageWhenAncestorFocused_, value);
  }

  /// focusedFrameGuide
  UILayoutGuide get focusedFrameGuide {
    objc.checkOsVersionInternal('UIImageView.focusedFrameGuide',
        iOS: (true, null));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_focusedFrameGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// overlayContentView
  UIView get overlayContentView {
    objc.checkOsVersionInternal('UIImageView.overlayContentView',
        iOS: (true, null));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_overlayContentView);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// masksFocusEffectToContents
  bool get masksFocusEffectToContents {
    objc.checkOsVersionInternal('UIImageView.masksFocusEffectToContents',
        iOS: (true, null));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_masksFocusEffectToContents);
  }

  /// setMasksFocusEffectToContents:
  set masksFocusEffectToContents(bool value) {
    objc.checkOsVersionInternal('UIImageView.setMasksFocusEffectToContents:',
        iOS: (true, null));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setMasksFocusEffectToContents_, value);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIImageView.layerClass',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIImageView, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithFrame:
  UIImageView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIImageView.initWithFrame:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIImageView.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIImageView? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIImageView.initWithCoder:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UIImageView.castFromPointer(_ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute(
          UISemanticContentAttribute attribute) {
    objc.checkOsVersionInternal(
        'UIImageView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_racczx(
        _class_UIImageView,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
        attribute.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute$1(
          UISemanticContentAttribute semanticContentAttribute$1,
          {required UIUserInterfaceLayoutDirection relativeToLayoutDirection}) {
    objc.checkOsVersionInternal(
        'UIImageView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
        iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_tz4p54(
        _class_UIImageView,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
        semanticContentAttribute$1.value,
        relativeToLayoutDirection.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// addSymbolEffect:
  void addSymbolEffect(NSSymbolEffect symbolEffect) {
    objc.checkOsVersionInternal('UIImageView.addSymbolEffect:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addSymbolEffect_, symbolEffect.ref.pointer);
  }

  /// addSymbolEffect:options:
  void addSymbolEffect$1(NSSymbolEffect symbolEffect,
      {required NSSymbolEffectOptions options}) {
    objc.checkOsVersionInternal('UIImageView.addSymbolEffect:options:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_addSymbolEffect_options_,
        symbolEffect.ref.pointer, options.ref.pointer);
  }

  /// addSymbolEffect:options:animated:
  void addSymbolEffect$2(NSSymbolEffect symbolEffect,
      {required NSSymbolEffectOptions options, required bool animated}) {
    objc.checkOsVersionInternal('UIImageView.addSymbolEffect:options:animated:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_1lhy15d(
        this.ref.pointer,
        _sel_addSymbolEffect_options_animated_,
        symbolEffect.ref.pointer,
        options.ref.pointer,
        animated);
  }

  /// addSymbolEffect:options:animated:completion:
  void addSymbolEffect$3(NSSymbolEffect symbolEffect,
      {required NSSymbolEffectOptions options,
      required bool animated,
      objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>?
          completion}) {
    objc.checkOsVersionInternal(
        'UIImageView.addSymbolEffect:options:animated:completion:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_1imhooq(
        this.ref.pointer,
        _sel_addSymbolEffect_options_animated_completion_,
        symbolEffect.ref.pointer,
        options.ref.pointer,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// removeSymbolEffectOfType:
  void removeSymbolEffectOfType(NSSymbolEffect symbolEffect) {
    objc.checkOsVersionInternal('UIImageView.removeSymbolEffectOfType:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeSymbolEffectOfType_,
        symbolEffect.ref.pointer);
  }

  /// removeSymbolEffectOfType:options:
  void removeSymbolEffectOfType$1(NSSymbolEffect symbolEffect,
      {required NSSymbolEffectOptions options}) {
    objc.checkOsVersionInternal('UIImageView.removeSymbolEffectOfType:options:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_removeSymbolEffectOfType_options_,
        symbolEffect.ref.pointer,
        options.ref.pointer);
  }

  /// removeSymbolEffectOfType:options:animated:
  void removeSymbolEffectOfType$2(NSSymbolEffect symbolEffect,
      {required NSSymbolEffectOptions options, required bool animated}) {
    objc.checkOsVersionInternal(
        'UIImageView.removeSymbolEffectOfType:options:animated:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_1lhy15d(
        this.ref.pointer,
        _sel_removeSymbolEffectOfType_options_animated_,
        symbolEffect.ref.pointer,
        options.ref.pointer,
        animated);
  }

  /// removeSymbolEffectOfType:options:animated:completion:
  void removeSymbolEffectOfType$3(NSSymbolEffect symbolEffect,
      {required NSSymbolEffectOptions options,
      required bool animated,
      objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>?
          completion}) {
    objc.checkOsVersionInternal(
        'UIImageView.removeSymbolEffectOfType:options:animated:completion:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_1imhooq(
        this.ref.pointer,
        _sel_removeSymbolEffectOfType_options_animated_completion_,
        symbolEffect.ref.pointer,
        options.ref.pointer,
        animated,
        completion?.ref.pointer ?? ffi.nullptr);
  }

  /// removeAllSymbolEffects
  void removeAllSymbolEffects() {
    objc.checkOsVersionInternal('UIImageView.removeAllSymbolEffects',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeAllSymbolEffects);
  }

  /// removeAllSymbolEffectsWithOptions:
  void removeAllSymbolEffectsWithOptions(NSSymbolEffectOptions options) {
    objc.checkOsVersionInternal(
        'UIImageView.removeAllSymbolEffectsWithOptions:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_removeAllSymbolEffectsWithOptions_, options.ref.pointer);
  }

  /// removeAllSymbolEffectsWithOptions:animated:
  void removeAllSymbolEffectsWithOptions$1(NSSymbolEffectOptions options,
      {required bool animated}) {
    objc.checkOsVersionInternal(
        'UIImageView.removeAllSymbolEffectsWithOptions:animated:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_6p7ndb(
        this.ref.pointer,
        _sel_removeAllSymbolEffectsWithOptions_animated_,
        options.ref.pointer,
        animated);
  }

  /// setSymbolImage:withContentTransition:
  void setSymbolImage(UIImage symbolImage,
      {required NSSymbolContentTransition withContentTransition}) {
    objc.checkOsVersionInternal(
        'UIImageView.setSymbolImage:withContentTransition:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_setSymbolImage_withContentTransition_,
        symbolImage.ref.pointer,
        withContentTransition.ref.pointer);
  }

  /// setSymbolImage:withContentTransition:options:
  void setSymbolImage$1(UIImage symbolImage,
      {required NSSymbolContentTransition withContentTransition,
      required NSSymbolEffectOptions options}) {
    objc.checkOsVersionInternal(
        'UIImageView.setSymbolImage:withContentTransition:options:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_r8gdi7(
        this.ref.pointer,
        _sel_setSymbolImage_withContentTransition_options_,
        symbolImage.ref.pointer,
        withContentTransition.ref.pointer,
        options.ref.pointer);
  }

  /// setSymbolImage:withContentTransition:options:completion:
  void setSymbolImage$2(UIImage symbolImage,
      {required NSSymbolContentTransition withContentTransition,
      required NSSymbolEffectOptions options,
      objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>?
          completion}) {
    objc.checkOsVersionInternal(
        'UIImageView.setSymbolImage:withContentTransition:options:completion:',
        iOS: (false, (17, 0, 0)));
    _objc_msgSend_m7tls4(
        this.ref.pointer,
        _sel_setSymbolImage_withContentTransition_options_completion_,
        symbolImage.ref.pointer,
        withContentTransition.ref.pointer,
        options.ref.pointer,
        completion?.ref.pointer ?? ffi.nullptr);
  }
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIColor_UIColor_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIColor_UIColor_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIColor_UIColor_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIColor_UIColor_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIColor_UIColor_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIColor_UIColor_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIColor Function(UIColor)>`.
abstract final class ObjCBlock_UIColor_UIColor {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIColor Function(UIColor)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<UIColor Function(UIColor)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIColor Function(UIColor)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<UIColor Function(UIColor)>(
          objc.newPointerBlock(
              _ObjCBlock_UIColor_UIColor_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIColor Function(UIColor)> fromFunction(
          UIColor Function(UIColor) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIColor Function(UIColor)>(
          objc.newClosureBlock(
              _ObjCBlock_UIColor_UIColor_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) =>
                  fn(UIColor.castFromPointer(arg0, retain: true, release: true))
                      .ref
                      .retainAndAutorelease(),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<UIColor Function(UIColor)>`.
extension ObjCBlock_UIColor_UIColor_CallExtension
    on objc.ObjCBlock<UIColor Function(UIColor)> {
  UIColor call(UIColor arg0) => UIColor.castFromPointer(
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.ref.pointer),
      retain: true,
      release: true);
}

/// WARNING: UIBackgroundConfiguration is a stub. To generate bindings for this class, include
/// UIBackgroundConfiguration in your config's objc-interfaces list.
///
/// UIBackgroundConfiguration
class UIBackgroundConfiguration extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  UIBackgroundConfiguration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBackgroundConfiguration',
        iOS: (false, (14, 0, 0)));
  }

  /// Constructs a [UIBackgroundConfiguration] that points to the same underlying object as [other].
  UIBackgroundConfiguration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBackgroundConfiguration] that wraps the given raw object pointer.
  UIBackgroundConfiguration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIButtonConfigurationSize {
  UIButtonConfigurationSizeMedium(0),
  UIButtonConfigurationSizeSmall(1),
  UIButtonConfigurationSizeMini(2),
  UIButtonConfigurationSizeLarge(3);

  final int value;
  const UIButtonConfigurationSize(this.value);

  static UIButtonConfigurationSize fromValue(int value) => switch (value) {
        0 => UIButtonConfigurationSizeMedium,
        1 => UIButtonConfigurationSizeSmall,
        2 => UIButtonConfigurationSizeMini,
        3 => UIButtonConfigurationSizeLarge,
        _ => throw ArgumentError(
            'Unknown value for UIButtonConfigurationSize: $value'),
      };
}

enum UIButtonConfigurationTitleAlignment {
  UIButtonConfigurationTitleAlignmentAutomatic(0),
  UIButtonConfigurationTitleAlignmentLeading(1),
  UIButtonConfigurationTitleAlignmentCenter(2),
  UIButtonConfigurationTitleAlignmentTrailing(3);

  final int value;
  const UIButtonConfigurationTitleAlignment(this.value);

  static UIButtonConfigurationTitleAlignment fromValue(int value) =>
      switch (value) {
        0 => UIButtonConfigurationTitleAlignmentAutomatic,
        1 => UIButtonConfigurationTitleAlignmentLeading,
        2 => UIButtonConfigurationTitleAlignmentCenter,
        3 => UIButtonConfigurationTitleAlignmentTrailing,
        _ => throw ArgumentError(
            'Unknown value for UIButtonConfigurationTitleAlignment: $value'),
      };
}

enum UIButtonConfigurationCornerStyle {
  UIButtonConfigurationCornerStyleFixed(-1),
  UIButtonConfigurationCornerStyleDynamic(0),
  UIButtonConfigurationCornerStyleSmall(1),
  UIButtonConfigurationCornerStyleMedium(2),
  UIButtonConfigurationCornerStyleLarge(3),
  UIButtonConfigurationCornerStyleCapsule(4);

  final int value;
  const UIButtonConfigurationCornerStyle(this.value);

  static UIButtonConfigurationCornerStyle fromValue(int value) =>
      switch (value) {
        -1 => UIButtonConfigurationCornerStyleFixed,
        0 => UIButtonConfigurationCornerStyleDynamic,
        1 => UIButtonConfigurationCornerStyleSmall,
        2 => UIButtonConfigurationCornerStyleMedium,
        3 => UIButtonConfigurationCornerStyleLarge,
        4 => UIButtonConfigurationCornerStyleCapsule,
        _ => throw ArgumentError(
            'Unknown value for UIButtonConfigurationCornerStyle: $value'),
      };
}

enum UIButtonConfigurationMacIdiomStyle {
  UIButtonConfigurationMacIdiomStyleAutomatic(0),
  UIButtonConfigurationMacIdiomStyleBordered(1),
  UIButtonConfigurationMacIdiomStyleBorderless(2),
  UIButtonConfigurationMacIdiomStyleBorderlessTinted(3);

  final int value;
  const UIButtonConfigurationMacIdiomStyle(this.value);

  static UIButtonConfigurationMacIdiomStyle fromValue(int value) =>
      switch (value) {
        0 => UIButtonConfigurationMacIdiomStyleAutomatic,
        1 => UIButtonConfigurationMacIdiomStyleBordered,
        2 => UIButtonConfigurationMacIdiomStyleBorderless,
        3 => UIButtonConfigurationMacIdiomStyleBorderlessTinted,
        _ => throw ArgumentError(
            'Unknown value for UIButtonConfigurationMacIdiomStyle: $value'),
      };
}

enum UIButtonConfigurationIndicator {
  UIButtonConfigurationIndicatorAutomatic(0),
  UIButtonConfigurationIndicatorNone(1),
  UIButtonConfigurationIndicatorPopup(2);

  final int value;
  const UIButtonConfigurationIndicator(this.value);

  static UIButtonConfigurationIndicator fromValue(int value) => switch (value) {
        0 => UIButtonConfigurationIndicatorAutomatic,
        1 => UIButtonConfigurationIndicatorNone,
        2 => UIButtonConfigurationIndicatorPopup,
        _ => throw ArgumentError(
            'Unknown value for UIButtonConfigurationIndicator: $value'),
      };
}

enum UIButtonType {
  UIButtonTypeCustom(0),
  UIButtonTypeSystem(1),
  UIButtonTypeDetailDisclosure(2),
  UIButtonTypeInfoLight(3),
  UIButtonTypeInfoDark(4),
  UIButtonTypeContactAdd(5),
  UIButtonTypePlain(6),
  UIButtonTypeClose(7);

  static const UIButtonTypeRoundedRect = UIButtonTypeSystem;

  final int value;
  const UIButtonType(this.value);

  static UIButtonType fromValue(int value) => switch (value) {
        0 => UIButtonTypeCustom,
        1 => UIButtonTypeSystem,
        2 => UIButtonTypeDetailDisclosure,
        3 => UIButtonTypeInfoLight,
        4 => UIButtonTypeInfoDark,
        5 => UIButtonTypeContactAdd,
        6 => UIButtonTypePlain,
        7 => UIButtonTypeClose,
        _ => throw ArgumentError('Unknown value for UIButtonType: $value'),
      };

  @override
  String toString() {
    if (this == UIButtonTypeSystem)
      return "UIButtonType.UIButtonTypeSystem, UIButtonType.UIButtonTypeRoundedRect";
    return super.toString();
  }
}

enum UIButtonRole {
  UIButtonRoleNormal(0),
  UIButtonRolePrimary(1),
  UIButtonRoleCancel(2),
  UIButtonRoleDestructive(3);

  final int value;
  const UIButtonRole(this.value);

  static UIButtonRole fromValue(int value) => switch (value) {
        0 => UIButtonRoleNormal,
        1 => UIButtonRolePrimary,
        2 => UIButtonRoleCancel,
        3 => UIButtonRoleDestructive,
        _ => throw ArgumentError('Unknown value for UIButtonRole: $value'),
      };
}

late final _class_UIPointerStyle = objc.getClass("UIPointerStyle");
late final _sel_accessories = objc.registerName("accessories");
late final _sel_setAccessories_ = objc.registerName("setAccessories:");
late final _class_UIPointerShape = objc.getClass("UIPointerShape");
late final _sel_shapeWithPath_ = objc.registerName("shapeWithPath:");
late final _sel_shapeWithRoundedRect_ =
    objc.registerName("shapeWithRoundedRect:");
late final _sel_shapeWithRoundedRect_cornerRadius_ =
    objc.registerName("shapeWithRoundedRect:cornerRadius:");
final _objc_msgSend_1k439hd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGRect, ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGRect, double)>();
late final _sel_beamWithPreferredLength_axis_ =
    objc.registerName("beamWithPreferredLength:axis:");
final _objc_msgSend_h14qyr = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double, int)>();

/// UIPointerShape
class UIPointerShape extends objc.NSObject implements objc.NSCopying {
  UIPointerShape._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPointerShape', iOS: (false, (13, 4, 0)));
  }

  /// Constructs a [UIPointerShape] that points to the same underlying object as [other].
  UIPointerShape.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPointerShape] that wraps the given raw object pointer.
  UIPointerShape.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIPointerShape].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIPointerShape);
  }

  /// shapeWithPath:
  static UIPointerShape shapeWithPath(UIBezierPath path) {
    objc.checkOsVersionInternal('UIPointerShape.shapeWithPath:',
        iOS: (false, (13, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_UIPointerShape, _sel_shapeWithPath_, path.ref.pointer);
    return UIPointerShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// shapeWithRoundedRect:
  static UIPointerShape shapeWithRoundedRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIPointerShape.shapeWithRoundedRect:',
        iOS: (false, (13, 4, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        _class_UIPointerShape, _sel_shapeWithRoundedRect_, rect);
    return UIPointerShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// shapeWithRoundedRect:cornerRadius:
  static UIPointerShape shapeWithRoundedRect$1(objc.CGRect rect,
      {required double cornerRadius}) {
    objc.checkOsVersionInternal(
        'UIPointerShape.shapeWithRoundedRect:cornerRadius:',
        iOS: (false, (13, 4, 0)));
    final _ret = _objc_msgSend_1k439hd(_class_UIPointerShape,
        _sel_shapeWithRoundedRect_cornerRadius_, rect, cornerRadius);
    return UIPointerShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// beamWithPreferredLength:axis:
  static UIPointerShape beamWithPreferredLength(double length,
      {required UIAxis axis}) {
    objc.checkOsVersionInternal('UIPointerShape.beamWithPreferredLength:axis:',
        iOS: (false, (13, 4, 0)));
    final _ret = _objc_msgSend_h14qyr(_class_UIPointerShape,
        _sel_beamWithPreferredLength_axis_, length, axis.value);
    return UIPointerShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  UIPointerShape init() {
    objc.checkOsVersionInternal('UIPointerShape.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIPointerShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIPointerShape new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIPointerShape, _sel_new);
    return UIPointerShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIPointerShape allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_UIPointerShape, _sel_allocWithZone_, zone);
    return UIPointerShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIPointerShape alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIPointerShape, _sel_alloc);
    return UIPointerShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  UIPointerShape self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return UIPointerShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  UIPointerShape retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return UIPointerShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  UIPointerShape autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return UIPointerShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of UIPointerShape constructed with the default `new` method.
  factory UIPointerShape() => new$();
}

late final _sel_styleWithShape_constrainedAxes_ =
    objc.registerName("styleWithShape:constrainedAxes:");
final _objc_msgSend_tuvlta = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_hiddenPointerStyle = objc.registerName("hiddenPointerStyle");
late final _sel_systemPointerStyle = objc.registerName("systemPointerStyle");

/// UIPointerStyle
class UIPointerStyle extends UIHoverStyle implements objc.NSCopying {
  UIPointerStyle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPointerStyle', iOS: (false, (13, 4, 0)));
  }

  /// Constructs a [UIPointerStyle] that points to the same underlying object as [other].
  UIPointerStyle.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPointerStyle] that wraps the given raw object pointer.
  UIPointerStyle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIPointerStyle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIPointerStyle);
  }

  /// accessories
  objc.NSArray get accessories {
    objc.checkOsVersionInternal('UIPointerStyle.accessories',
        iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_accessories);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAccessories:
  set accessories(objc.NSArray value) {
    objc.checkOsVersionInternal('UIPointerStyle.setAccessories:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAccessories_, value.ref.pointer);
  }

  /// styleWithEffect:shape:
  static UIPointerStyle styleWithEffect(UIHoverEffect effect$1,
      {UIShape? shape$1}) {
    objc.checkOsVersionInternal('UIPointerStyle.styleWithEffect:shape:',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_UIPointerStyle,
        _sel_styleWithEffect_shape_,
        effect$1.ref.pointer,
        shape$1?.ref.pointer ?? ffi.nullptr);
    return UIPointerStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// styleWithShape:constrainedAxes:
  static UIPointerStyle styleWithShape(UIPointerShape shape,
      {required UIAxis constrainedAxes}) {
    objc.checkOsVersionInternal(
        'UIPointerStyle.styleWithShape:constrainedAxes:',
        iOS: (false, (13, 4, 0)));
    final _ret = _objc_msgSend_tuvlta(
        _class_UIPointerStyle,
        _sel_styleWithShape_constrainedAxes_,
        shape.ref.pointer,
        constrainedAxes.value);
    return UIPointerStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// hiddenPointerStyle
  static UIPointerStyle hiddenPointerStyle() {
    objc.checkOsVersionInternal('UIPointerStyle.hiddenPointerStyle',
        iOS: (false, (13, 4, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_hiddenPointerStyle);
    return UIPointerStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemPointerStyle
  static UIPointerStyle systemPointerStyle() {
    objc.checkOsVersionInternal('UIPointerStyle.systemPointerStyle',
        iOS: (false, (15, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_systemPointerStyle);
    return UIPointerStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  UIPointerStyle init() {
    objc.checkOsVersionInternal('UIPointerStyle.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIPointerStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIPointerStyle new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_new);
    return UIPointerStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// styleWithShape:
  static UIPointerStyle styleWithShape2(UIShape? shape$1) {
    objc.checkOsVersionInternal('UIPointerStyle.styleWithShape:',
        iOS: (false, (17, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIPointerStyle,
        _sel_styleWithShape_, shape$1?.ref.pointer ?? ffi.nullptr);
    return UIPointerStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// automaticStyle
  static UIPointerStyle automaticStyle() {
    objc.checkOsVersionInternal('UIPointerStyle.automaticStyle',
        iOS: (false, (17, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_automaticStyle);
    return UIPointerStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// allocWithZone:
  static UIPointerStyle allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_UIPointerStyle, _sel_allocWithZone_, zone);
    return UIPointerStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIPointerStyle alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_alloc);
    return UIPointerStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIPointerStyle constructed with the default `new` method.
  factory UIPointerStyle() => new$();
}

/// WARNING: UIButton is a stub. To generate bindings for this class, include
/// UIButton in your config's objc-interfaces list.
///
/// UIButton
class UIButton extends UIControl implements objc.NSCoding {
  UIButton._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIButton', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIButton] that points to the same underlying object as [other].
  UIButton.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIButton] that wraps the given raw object pointer.
  UIButton.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_UIPointerEffect = objc.getClass("UIPointerEffect");

/// WARNING: UITargetedPreview is a stub. To generate bindings for this class, include
/// UITargetedPreview in your config's objc-interfaces list.
///
/// UITargetedPreview
class UITargetedPreview extends objc.NSObject implements objc.NSCopying {
  UITargetedPreview._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITargetedPreview', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UITargetedPreview] that points to the same underlying object as [other].
  UITargetedPreview.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITargetedPreview] that wraps the given raw object pointer.
  UITargetedPreview.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_preview = objc.registerName("preview");
late final _sel_effectWithPreview_ = objc.registerName("effectWithPreview:");

/// UIPointerEffect
class UIPointerEffect extends objc.NSObject
    implements objc.NSCopying, UIHoverEffect {
  UIPointerEffect._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPointerEffect', iOS: (false, (13, 4, 0)));
  }

  /// Constructs a [UIPointerEffect] that points to the same underlying object as [other].
  UIPointerEffect.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPointerEffect] that wraps the given raw object pointer.
  UIPointerEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIPointerEffect].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIPointerEffect);
  }

  /// preview
  UITargetedPreview get preview {
    objc.checkOsVersionInternal('UIPointerEffect.preview',
        iOS: (false, (13, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preview);
    return UITargetedPreview.castFromPointer(_ret, retain: true, release: true);
  }

  /// effectWithPreview:
  static UIPointerEffect effectWithPreview(UITargetedPreview preview$1) {
    objc.checkOsVersionInternal('UIPointerEffect.effectWithPreview:',
        iOS: (false, (13, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_UIPointerEffect, _sel_effectWithPreview_, preview$1.ref.pointer);
    return UIPointerEffect.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  UIPointerEffect init() {
    objc.checkOsVersionInternal('UIPointerEffect.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIPointerEffect.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static UIPointerEffect new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIPointerEffect, _sel_new);
    return UIPointerEffect.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIPointerEffect allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_UIPointerEffect, _sel_allocWithZone_, zone);
    return UIPointerEffect.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIPointerEffect alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIPointerEffect, _sel_alloc);
    return UIPointerEffect.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  UIPointerEffect self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return UIPointerEffect.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  UIPointerEffect retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return UIPointerEffect.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  UIPointerEffect autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return UIPointerEffect.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of UIPointerEffect constructed with the default `new` method.
  factory UIPointerEffect() => new$();
}

ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>`.
abstract final class ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              UIPointerStyle? Function(UIButton, UIPointerEffect,
                  UIPointerShape)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCObject> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>(
              objc.newPointerBlock(_ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>
      fromFunction(UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>(
              objc.newClosureBlock(
                  _ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(UIButton.castFromPointer(arg0, retain: true, release: true), UIPointerEffect.castFromPointer(arg1, retain: true, release: true), UIPointerShape.castFromPointer(arg2, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>`.
extension ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape_CallExtension
    on objc.ObjCBlock<
        UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)> {
  UIPointerStyle? call(UIButton arg0, UIPointerEffect arg1, UIPointerShape arg2) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : UIPointerStyle.castFromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>().asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer), retain: true, release: true);
}

void _ObjCBlock_ffiVoid_UIButton_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIButton_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UIButton_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIButton_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIButton_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UIButton_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIButton_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIButton_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UIButton_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_UIButton_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIButton_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_UIButton_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIButton_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UIButton_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIButton)>`.
abstract final class ObjCBlock_ffiVoid_UIButton {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(UIButton)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(UIButton)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_UIButton_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> fromFunction(
          void Function(UIButton) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UIButton)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_UIButton_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                  UIButton.castFromPointer(arg0, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> listener(
      void Function(UIButton) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIButton_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(UIButton.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIButton)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> blocking(
      void Function(UIButton) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIButton_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(UIButton.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIButton_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(UIButton.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIButton)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIButton)>`.
extension ObjCBlock_ffiVoid_UIButton_CallExtension
    on objc.ObjCBlock<ffi.Void Function(UIButton)> {
  void call(UIButton arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer);
}

enum UIBarMetrics {
  UIBarMetricsDefault(0),
  UIBarMetricsCompact(1),
  UIBarMetricsDefaultPrompt(101),
  UIBarMetricsCompactPrompt(102);

  static const UIBarMetricsLandscapePhone = UIBarMetricsCompact;
  static const UIBarMetricsLandscapePhonePrompt = UIBarMetricsCompactPrompt;

  final int value;
  const UIBarMetrics(this.value);

  static UIBarMetrics fromValue(int value) => switch (value) {
        0 => UIBarMetricsDefault,
        1 => UIBarMetricsCompact,
        101 => UIBarMetricsDefaultPrompt,
        102 => UIBarMetricsCompactPrompt,
        _ => throw ArgumentError('Unknown value for UIBarMetrics: $value'),
      };

  @override
  String toString() {
    if (this == UIBarMetricsCompact)
      return "UIBarMetrics.UIBarMetricsCompact, UIBarMetrics.UIBarMetricsLandscapePhone";
    if (this == UIBarMetricsCompactPrompt)
      return "UIBarMetrics.UIBarMetricsCompactPrompt, UIBarMetrics.UIBarMetricsLandscapePhonePrompt";
    return super.toString();
  }
}

enum UIBarPosition {
  UIBarPositionAny(0),
  UIBarPositionBottom(1),
  UIBarPositionTop(2),
  UIBarPositionTopAttached(3);

  final int value;
  const UIBarPosition(this.value);

  static UIBarPosition fromValue(int value) => switch (value) {
        0 => UIBarPositionAny,
        1 => UIBarPositionBottom,
        2 => UIBarPositionTop,
        3 => UIBarPositionTopAttached,
        _ => throw ArgumentError('Unknown value for UIBarPosition: $value'),
      };
}

enum UIBarButtonItemStyle {
  UIBarButtonItemStylePlain(0),
  UIBarButtonItemStyleBordered(1),
  UIBarButtonItemStyleDone(2);

  final int value;
  const UIBarButtonItemStyle(this.value);

  static UIBarButtonItemStyle fromValue(int value) => switch (value) {
        0 => UIBarButtonItemStylePlain,
        1 => UIBarButtonItemStyleBordered,
        2 => UIBarButtonItemStyleDone,
        _ =>
          throw ArgumentError('Unknown value for UIBarButtonItemStyle: $value'),
      };
}

enum UIBarButtonSystemItem {
  UIBarButtonSystemItemDone(0),
  UIBarButtonSystemItemCancel(1),
  UIBarButtonSystemItemEdit(2),
  UIBarButtonSystemItemSave(3),
  UIBarButtonSystemItemAdd(4),
  UIBarButtonSystemItemFlexibleSpace(5),
  UIBarButtonSystemItemFixedSpace(6),
  UIBarButtonSystemItemCompose(7),
  UIBarButtonSystemItemReply(8),
  UIBarButtonSystemItemAction(9),
  UIBarButtonSystemItemOrganize(10),
  UIBarButtonSystemItemBookmarks(11),
  UIBarButtonSystemItemSearch(12),
  UIBarButtonSystemItemRefresh(13),
  UIBarButtonSystemItemStop(14),
  UIBarButtonSystemItemCamera(15),
  UIBarButtonSystemItemTrash(16),
  UIBarButtonSystemItemPlay(17),
  UIBarButtonSystemItemPause(18),
  UIBarButtonSystemItemRewind(19),
  UIBarButtonSystemItemFastForward(20),
  UIBarButtonSystemItemUndo(21),
  UIBarButtonSystemItemRedo(22),
  UIBarButtonSystemItemPageCurl(23),
  UIBarButtonSystemItemClose(24),
  UIBarButtonSystemItemWritingTools(25);

  final int value;
  const UIBarButtonSystemItem(this.value);

  static UIBarButtonSystemItem fromValue(int value) => switch (value) {
        0 => UIBarButtonSystemItemDone,
        1 => UIBarButtonSystemItemCancel,
        2 => UIBarButtonSystemItemEdit,
        3 => UIBarButtonSystemItemSave,
        4 => UIBarButtonSystemItemAdd,
        5 => UIBarButtonSystemItemFlexibleSpace,
        6 => UIBarButtonSystemItemFixedSpace,
        7 => UIBarButtonSystemItemCompose,
        8 => UIBarButtonSystemItemReply,
        9 => UIBarButtonSystemItemAction,
        10 => UIBarButtonSystemItemOrganize,
        11 => UIBarButtonSystemItemBookmarks,
        12 => UIBarButtonSystemItemSearch,
        13 => UIBarButtonSystemItemRefresh,
        14 => UIBarButtonSystemItemStop,
        15 => UIBarButtonSystemItemCamera,
        16 => UIBarButtonSystemItemTrash,
        17 => UIBarButtonSystemItemPlay,
        18 => UIBarButtonSystemItemPause,
        19 => UIBarButtonSystemItemRewind,
        20 => UIBarButtonSystemItemFastForward,
        21 => UIBarButtonSystemItemUndo,
        22 => UIBarButtonSystemItemRedo,
        23 => UIBarButtonSystemItemPageCurl,
        24 => UIBarButtonSystemItemClose,
        25 => UIBarButtonSystemItemWritingTools,
        _ => throw ArgumentError(
            'Unknown value for UIBarButtonSystemItem: $value'),
      };
}

enum UIGestureRecognizerState {
  UIGestureRecognizerStatePossible(0),
  UIGestureRecognizerStateBegan(1),
  UIGestureRecognizerStateChanged(2),
  UIGestureRecognizerStateEnded(3),
  UIGestureRecognizerStateCancelled(4),
  UIGestureRecognizerStateFailed(5);

  static const UIGestureRecognizerStateRecognized =
      UIGestureRecognizerStateEnded;

  final int value;
  const UIGestureRecognizerState(this.value);

  static UIGestureRecognizerState fromValue(int value) => switch (value) {
        0 => UIGestureRecognizerStatePossible,
        1 => UIGestureRecognizerStateBegan,
        2 => UIGestureRecognizerStateChanged,
        3 => UIGestureRecognizerStateEnded,
        4 => UIGestureRecognizerStateCancelled,
        5 => UIGestureRecognizerStateFailed,
        _ => throw ArgumentError(
            'Unknown value for UIGestureRecognizerState: $value'),
      };

  @override
  String toString() {
    if (this == UIGestureRecognizerStateEnded)
      return "UIGestureRecognizerState.UIGestureRecognizerStateEnded, UIGestureRecognizerState.UIGestureRecognizerStateRecognized";
    return super.toString();
  }
}

/// WARNING: UIGestureRecognizerDelegate is a stub. To generate bindings for this class, include
/// UIGestureRecognizerDelegate in your config's objc-protocols list.
///
/// UIGestureRecognizerDelegate
interface class UIGestureRecognizerDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIGestureRecognizerDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIGestureRecognizerDelegate] that points to the same underlying object as [other].
  UIGestureRecognizerDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIGestureRecognizerDelegate] that wraps the given raw object pointer.
  UIGestureRecognizerDelegate.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UITableViewCellStyle {
  UITableViewCellStyleDefault(0),
  UITableViewCellStyleValue1(1),
  UITableViewCellStyleValue2(2),
  UITableViewCellStyleSubtitle(3);

  final int value;
  const UITableViewCellStyle(this.value);

  static UITableViewCellStyle fromValue(int value) => switch (value) {
        0 => UITableViewCellStyleDefault,
        1 => UITableViewCellStyleValue1,
        2 => UITableViewCellStyleValue2,
        3 => UITableViewCellStyleSubtitle,
        _ =>
          throw ArgumentError('Unknown value for UITableViewCellStyle: $value'),
      };
}

enum UITableViewCellSeparatorStyle {
  UITableViewCellSeparatorStyleNone(0),
  UITableViewCellSeparatorStyleSingleLine(1),
  UITableViewCellSeparatorStyleSingleLineEtched(2);

  final int value;
  const UITableViewCellSeparatorStyle(this.value);

  static UITableViewCellSeparatorStyle fromValue(int value) => switch (value) {
        0 => UITableViewCellSeparatorStyleNone,
        1 => UITableViewCellSeparatorStyleSingleLine,
        2 => UITableViewCellSeparatorStyleSingleLineEtched,
        _ => throw ArgumentError(
            'Unknown value for UITableViewCellSeparatorStyle: $value'),
      };
}

enum UITableViewCellSelectionStyle {
  UITableViewCellSelectionStyleNone(0),
  UITableViewCellSelectionStyleBlue(1),
  UITableViewCellSelectionStyleGray(2),
  UITableViewCellSelectionStyleDefault(3);

  final int value;
  const UITableViewCellSelectionStyle(this.value);

  static UITableViewCellSelectionStyle fromValue(int value) => switch (value) {
        0 => UITableViewCellSelectionStyleNone,
        1 => UITableViewCellSelectionStyleBlue,
        2 => UITableViewCellSelectionStyleGray,
        3 => UITableViewCellSelectionStyleDefault,
        _ => throw ArgumentError(
            'Unknown value for UITableViewCellSelectionStyle: $value'),
      };
}

enum UITableViewCellFocusStyle {
  UITableViewCellFocusStyleDefault(0),
  UITableViewCellFocusStyleCustom(1);

  final int value;
  const UITableViewCellFocusStyle(this.value);

  static UITableViewCellFocusStyle fromValue(int value) => switch (value) {
        0 => UITableViewCellFocusStyleDefault,
        1 => UITableViewCellFocusStyleCustom,
        _ => throw ArgumentError(
            'Unknown value for UITableViewCellFocusStyle: $value'),
      };
}

enum UITableViewCellEditingStyle {
  UITableViewCellEditingStyleNone(0),
  UITableViewCellEditingStyleDelete(1),
  UITableViewCellEditingStyleInsert(2);

  final int value;
  const UITableViewCellEditingStyle(this.value);

  static UITableViewCellEditingStyle fromValue(int value) => switch (value) {
        0 => UITableViewCellEditingStyleNone,
        1 => UITableViewCellEditingStyleDelete,
        2 => UITableViewCellEditingStyleInsert,
        _ => throw ArgumentError(
            'Unknown value for UITableViewCellEditingStyle: $value'),
      };
}

enum UITableViewCellAccessoryType {
  UITableViewCellAccessoryNone(0),
  UITableViewCellAccessoryDisclosureIndicator(1),
  UITableViewCellAccessoryDetailDisclosureButton(2),
  UITableViewCellAccessoryCheckmark(3),
  UITableViewCellAccessoryDetailButton(4);

  final int value;
  const UITableViewCellAccessoryType(this.value);

  static UITableViewCellAccessoryType fromValue(int value) => switch (value) {
        0 => UITableViewCellAccessoryNone,
        1 => UITableViewCellAccessoryDisclosureIndicator,
        2 => UITableViewCellAccessoryDetailDisclosureButton,
        3 => UITableViewCellAccessoryCheckmark,
        4 => UITableViewCellAccessoryDetailButton,
        _ => throw ArgumentError(
            'Unknown value for UITableViewCellAccessoryType: $value'),
      };
}

enum UITableViewCellStateMask {
  UITableViewCellStateDefaultMask(0),
  UITableViewCellStateShowingEditControlMask(1),
  UITableViewCellStateShowingDeleteConfirmationMask(2);

  final int value;
  const UITableViewCellStateMask(this.value);

  static UITableViewCellStateMask fromValue(int value) => switch (value) {
        0 => UITableViewCellStateDefaultMask,
        1 => UITableViewCellStateShowingEditControlMask,
        2 => UITableViewCellStateShowingDeleteConfirmationMask,
        _ => throw ArgumentError(
            'Unknown value for UITableViewCellStateMask: $value'),
      };
}

enum UITableViewCellDragState {
  UITableViewCellDragStateNone(0),
  UITableViewCellDragStateLifting(1),
  UITableViewCellDragStateDragging(2);

  final int value;
  const UITableViewCellDragState(this.value);

  static UITableViewCellDragState fromValue(int value) => switch (value) {
        0 => UITableViewCellDragStateNone,
        1 => UITableViewCellDragStateLifting,
        2 => UITableViewCellDragStateDragging,
        _ => throw ArgumentError(
            'Unknown value for UITableViewCellDragState: $value'),
      };
}

late final _class_UITableViewCell = objc.getClass("UITableViewCell");
late final _sel_initWithFrame_reuseIdentifier_ =
    objc.registerName("initWithFrame:reuseIdentifier:");
final _objc_msgSend_gxusyk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_text = objc.registerName("text");
late final _sel_setText_ = objc.registerName("setText:");
late final _sel_font = objc.registerName("font");
late final _sel_setFont_ = objc.registerName("setFont:");
late final _sel_textAlignment = objc.registerName("textAlignment");
final _objc_msgSend_buxwfm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTextAlignment_ = objc.registerName("setTextAlignment:");
final _objc_msgSend_12huos = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_lineBreakMode = objc.registerName("lineBreakMode");
final _objc_msgSend_ybsdio = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLineBreakMode_ = objc.registerName("setLineBreakMode:");
final _objc_msgSend_1kdet46 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_textColor = objc.registerName("textColor");
late final _sel_setTextColor_ = objc.registerName("setTextColor:");
late final _sel_selectedTextColor = objc.registerName("selectedTextColor");
late final _sel_setSelectedTextColor_ =
    objc.registerName("setSelectedTextColor:");
late final _sel_hidesAccessoryWhenEditing =
    objc.registerName("hidesAccessoryWhenEditing");
late final _sel_setHidesAccessoryWhenEditing_ =
    objc.registerName("setHidesAccessoryWhenEditing:");
late final _sel_target = objc.registerName("target");
late final _sel_setTarget_ = objc.registerName("setTarget:");
late final _sel_editAction = objc.registerName("editAction");
final _objc_msgSend_1ovaulg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCSelector> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCSelector> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setEditAction_ = objc.registerName("setEditAction:");
late final _sel_accessoryAction = objc.registerName("accessoryAction");
late final _sel_setAccessoryAction_ = objc.registerName("setAccessoryAction:");

/// UIDeprecated
extension UIDeprecated on UITableViewCell {
  /// initWithFrame:reuseIdentifier:
  objc.ObjCObjectBase initWithFrame(objc.CGRect frame,
      {objc.NSString? reuseIdentifier}) {
    objc.checkOsVersionInternal(
        'UITableViewCell.initWithFrame:reuseIdentifier:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_gxusyk(
        this.ref.retainAndReturnPointer(),
        _sel_initWithFrame_reuseIdentifier_,
        frame,
        reuseIdentifier?.ref.pointer ?? ffi.nullptr);
    return objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// text
  objc.NSString? get text {
    objc.checkOsVersionInternal('UITableViewCell.text',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_text);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setText:
  set text(objc.NSString? value) {
    objc.checkOsVersionInternal('UITableViewCell.setText:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setText_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// font
  UIFont? get font {
    objc.checkOsVersionInternal('UITableViewCell.font',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_font);
    return _ret.address == 0
        ? null
        : UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFont:
  set font(UIFont? value) {
    objc.checkOsVersionInternal('UITableViewCell.setFont:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFont_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// textAlignment
  NSTextAlignment get textAlignment {
    objc.checkOsVersionInternal('UITableViewCell.textAlignment',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_buxwfm(this.ref.pointer, _sel_textAlignment);
    return NSTextAlignment.fromValue(_ret);
  }

  /// setTextAlignment:
  set textAlignment(NSTextAlignment value) {
    objc.checkOsVersionInternal('UITableViewCell.setTextAlignment:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_12huos(this.ref.pointer, _sel_setTextAlignment_, value.value);
  }

  /// lineBreakMode
  NSLineBreakMode get lineBreakMode {
    objc.checkOsVersionInternal('UITableViewCell.lineBreakMode',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_ybsdio(this.ref.pointer, _sel_lineBreakMode);
    return NSLineBreakMode.fromValue(_ret);
  }

  /// setLineBreakMode:
  set lineBreakMode(NSLineBreakMode value) {
    objc.checkOsVersionInternal('UITableViewCell.setLineBreakMode:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1kdet46(
        this.ref.pointer, _sel_setLineBreakMode_, value.value);
  }

  /// textColor
  UIColor? get textColor {
    objc.checkOsVersionInternal('UITableViewCell.textColor',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textColor);
    return _ret.address == 0
        ? null
        : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextColor:
  set textColor(UIColor? value) {
    objc.checkOsVersionInternal('UITableViewCell.setTextColor:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTextColor_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// selectedTextColor
  UIColor? get selectedTextColor {
    objc.checkOsVersionInternal('UITableViewCell.selectedTextColor',
        iOS: (false, (2, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedTextColor);
    return _ret.address == 0
        ? null
        : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSelectedTextColor:
  set selectedTextColor(UIColor? value) {
    objc.checkOsVersionInternal('UITableViewCell.setSelectedTextColor:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectedTextColor_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal('UITableViewCell.image',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setImage:
  set image(UIImage? value) {
    objc.checkOsVersionInternal('UITableViewCell.setImage:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// selectedImage
  UIImage? get selectedImage {
    objc.checkOsVersionInternal('UITableViewCell.selectedImage',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedImage);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSelectedImage:
  set selectedImage(UIImage? value) {
    objc.checkOsVersionInternal('UITableViewCell.setSelectedImage:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectedImage_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// hidesAccessoryWhenEditing
  bool get hidesAccessoryWhenEditing {
    objc.checkOsVersionInternal('UITableViewCell.hidesAccessoryWhenEditing',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_hidesAccessoryWhenEditing);
  }

  /// setHidesAccessoryWhenEditing:
  set hidesAccessoryWhenEditing(bool value) {
    objc.checkOsVersionInternal('UITableViewCell.setHidesAccessoryWhenEditing:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setHidesAccessoryWhenEditing_, value);
  }

  /// target
  objc.ObjCObjectBase? get target {
    objc.checkOsVersionInternal('UITableViewCell.target',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_target);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setTarget:
  set target(objc.ObjCObjectBase? value) {
    objc.checkOsVersionInternal('UITableViewCell.setTarget:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTarget_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// editAction
  ffi.Pointer<objc.ObjCSelector> get editAction {
    objc.checkOsVersionInternal('UITableViewCell.editAction',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1ovaulg(this.ref.pointer, _sel_editAction);
  }

  /// setEditAction:
  set editAction(ffi.Pointer<objc.ObjCSelector> value) {
    objc.checkOsVersionInternal('UITableViewCell.setEditAction:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(this.ref.pointer, _sel_setEditAction_, value);
  }

  /// accessoryAction
  ffi.Pointer<objc.ObjCSelector> get accessoryAction {
    objc.checkOsVersionInternal('UITableViewCell.accessoryAction',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1ovaulg(this.ref.pointer, _sel_accessoryAction);
  }

  /// setAccessoryAction:
  set accessoryAction(ffi.Pointer<objc.ObjCSelector> value) {
    objc.checkOsVersionInternal('UITableViewCell.setAccessoryAction:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(this.ref.pointer, _sel_setAccessoryAction_, value);
  }
}

late final _sel_initWithStyle_reuseIdentifier_ =
    objc.registerName("initWithStyle:reuseIdentifier:");
final _objc_msgSend_96u4vv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _class_UIViewConfigurationState =
    objc.getClass("UIViewConfigurationState");

/// WARNING: UIConfigurationState is a stub. To generate bindings for this class, include
/// UIConfigurationState in your config's objc-protocols list.
///
/// UIConfigurationState
interface class UIConfigurationState extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol, objc.NSCopying, objc.NSSecureCoding {
  UIConfigurationState._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIConfigurationState] that points to the same underlying object as [other].
  UIConfigurationState.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIConfigurationState] that wraps the given raw object pointer.
  UIConfigurationState.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_initWithTraitCollection_ =
    objc.registerName("initWithTraitCollection:");
instancetype
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    instancetype Function(ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                instancetype Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
              ffi.Pointer<ffi.Void>, UITraitCollection)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>, UITraitCollection)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
              ffi.Pointer<ffi.Void>, UITraitCollection)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>, UITraitCollection)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>, UITraitCollection)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, UITraitCollection.castFromPointer(arg1, retain: true, release: true)).ref.retainAndReturnPointer(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection$1_CallExtension
    on objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
            ffi.Pointer<ffi.Void>, UITraitCollection)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) =>
      objc.ObjCObjectBase(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          instancetype Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true);
}

late final _sel_setTraitCollection_ = objc.registerName("setTraitCollection:");
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, UITraitCollection.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
      listener(void Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UITraitCollection.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UITraitCollection)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
      blocking(void Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UITraitCollection.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            UITraitCollection.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            UITraitCollection)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_isDisabled = objc.registerName("isDisabled");
late final _sel_setDisabled_ = objc.registerName("setDisabled:");
late final _sel_isSelected = objc.registerName("isSelected");
late final _sel_setSelected_ = objc.registerName("setSelected:");
late final _sel_setFocused_ = objc.registerName("setFocused:");
late final _sel_isPinned = objc.registerName("isPinned");
late final _sel_setPinned_ = objc.registerName("setPinned:");
late final _sel_customStateForKey_ = objc.registerName("customStateForKey:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      fromFunction(objc.ObjCObjectBase? Function(ffi.Pointer<ffi.Void>, objc.NSString) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.ObjCObjectBase? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
                  (ref.pointer, arg0, arg1.ref.pointer)
                  .address ==
              0
          ? null
          : objc.ObjCObjectBase(
              ref.pointer.ref.invoke
                  .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
              retain: true,
              release: true);
}

late final _sel_setCustomState_forKey_ =
    objc.registerName("setCustomState:forKey:");
void
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, objc.NSString)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>?, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>?,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, objc.NSString)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>?, objc.NSString)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, objc.NSString)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?, objc.NSString) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, objc.NSString)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true),
                      objc.NSString.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?,
          objc.NSString)> listener(
      void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?, objc.NSString)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.NSString.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?,
            objc.NSString)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?,
          objc.NSString)> blocking(
      void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?, objc.NSString)
          fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.NSString.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.NSString.castFromPointer(arg2,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_fjrv01(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?,
            objc.NSString)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?, objc.NSString)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_UIConfigurationStateCustomKey_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?,
            objc.NSString)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase? arg1,
          objc.NSString arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1?.ref.pointer ?? ffi.nullptr, arg2.ref.pointer);
}

late final _sel_objectForKeyedSubscript_ =
    objc.registerName("objectForKeyedSubscript:");
late final _sel_setObject_forKeyedSubscript_ =
    objc.registerName("setObject:forKeyedSubscript:");

/// UIViewConfigurationState
class UIViewConfigurationState extends objc.NSObject
    implements UIConfigurationState {
  UIViewConfigurationState._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewConfigurationState',
        iOS: (false, (14, 0, 0)));
  }

  /// Constructs a [UIViewConfigurationState] that points to the same underlying object as [other].
  UIViewConfigurationState.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewConfigurationState] that wraps the given raw object pointer.
  UIViewConfigurationState.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIViewConfigurationState].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UIViewConfigurationState);
  }

  /// initWithTraitCollection:
  UIViewConfigurationState initWithTraitCollection(
      UITraitCollection traitCollection) {
    objc.checkOsVersionInternal(
        'UIViewConfigurationState.initWithTraitCollection:',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithTraitCollection_, traitCollection.ref.pointer);
    return UIViewConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithCoder:
  UIViewConfigurationState? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UIViewConfigurationState.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// init
  UIViewConfigurationState init() {
    objc.checkOsVersionInternal('UIViewConfigurationState.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIViewConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static UIViewConfigurationState new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_UIViewConfigurationState, _sel_new);
    return UIViewConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// traitCollection
  UITraitCollection get traitCollection {
    objc.checkOsVersionInternal('UIViewConfigurationState.traitCollection',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_traitCollection);
    return UITraitCollection.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTraitCollection:
  set traitCollection(UITraitCollection value) {
    objc.checkOsVersionInternal('UIViewConfigurationState.setTraitCollection:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTraitCollection_, value.ref.pointer);
  }

  /// isDisabled
  bool get disabled {
    objc.checkOsVersionInternal('UIViewConfigurationState.isDisabled',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDisabled);
  }

  /// setDisabled:
  set disabled(bool value) {
    objc.checkOsVersionInternal('UIViewConfigurationState.setDisabled:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDisabled_, value);
  }

  /// isHighlighted
  bool get highlighted {
    objc.checkOsVersionInternal('UIViewConfigurationState.isHighlighted',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHighlighted);
  }

  /// setHighlighted:
  set highlighted(bool value) {
    objc.checkOsVersionInternal('UIViewConfigurationState.setHighlighted:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHighlighted_, value);
  }

  /// isSelected
  bool get selected {
    objc.checkOsVersionInternal('UIViewConfigurationState.isSelected',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isSelected);
  }

  /// setSelected:
  set selected(bool value) {
    objc.checkOsVersionInternal('UIViewConfigurationState.setSelected:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setSelected_, value);
  }

  /// isFocused
  bool get focused {
    objc.checkOsVersionInternal('UIViewConfigurationState.isFocused',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFocused);
  }

  /// setFocused:
  set focused(bool value) {
    objc.checkOsVersionInternal('UIViewConfigurationState.setFocused:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setFocused_, value);
  }

  /// isPinned
  bool get pinned {
    objc.checkOsVersionInternal('UIViewConfigurationState.isPinned',
        iOS: (false, (15, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isPinned);
  }

  /// setPinned:
  set pinned(bool value) {
    objc.checkOsVersionInternal('UIViewConfigurationState.setPinned:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setPinned_, value);
  }

  /// allocWithZone:
  static UIViewConfigurationState allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_UIViewConfigurationState, _sel_allocWithZone_, zone);
    return UIViewConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static UIViewConfigurationState alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_UIViewConfigurationState, _sel_alloc);
    return UIViewConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// customStateForKey:
  objc.ObjCObjectBase? customStateForKey(objc.NSString key) {
    objc.checkOsVersionInternal('UIViewConfigurationState.customStateForKey:',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_customStateForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setCustomState:forKey:
  void setCustomState(objc.ObjCObjectBase? customState,
      {required objc.NSString forKey}) {
    objc.checkOsVersionInternal(
        'UIViewConfigurationState.setCustomState:forKey:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setCustomState_forKey_,
        customState?.ref.pointer ?? ffi.nullptr, forKey.ref.pointer);
  }

  /// objectForKeyedSubscript:
  objc.ObjCObjectBase? objectForKeyedSubscript(objc.NSString key) {
    objc.checkOsVersionInternal(
        'UIViewConfigurationState.objectForKeyedSubscript:',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_objectForKeyedSubscript_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setObject:forKeyedSubscript:
  void setObject(objc.ObjCObjectBase? obj,
      {required objc.NSString forKeyedSubscript}) {
    objc.checkOsVersionInternal(
        'UIViewConfigurationState.setObject:forKeyedSubscript:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setObject_forKeyedSubscript_,
        obj?.ref.pointer ?? ffi.nullptr, forKeyedSubscript.ref.pointer);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_UIViewConfigurationState, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// Returns a new instance of UIViewConfigurationState constructed with the default `new` method.
  factory UIViewConfigurationState() => new$();
}

late final _class_UICellConfigurationState =
    objc.getClass("UICellConfigurationState");
late final _sel_isEditing = objc.registerName("isEditing");
late final _sel_setEditing_ = objc.registerName("setEditing:");
late final _sel_isExpanded = objc.registerName("isExpanded");
late final _sel_setExpanded_ = objc.registerName("setExpanded:");
late final _sel_isSwiped = objc.registerName("isSwiped");
late final _sel_setSwiped_ = objc.registerName("setSwiped:");
late final _sel_isReordering = objc.registerName("isReordering");
late final _sel_setReordering_ = objc.registerName("setReordering:");

enum UICellConfigurationDragState {
  UICellConfigurationDragStateNone(0),
  UICellConfigurationDragStateLifting(1),
  UICellConfigurationDragStateDragging(2);

  final int value;
  const UICellConfigurationDragState(this.value);

  static UICellConfigurationDragState fromValue(int value) => switch (value) {
        0 => UICellConfigurationDragStateNone,
        1 => UICellConfigurationDragStateLifting,
        2 => UICellConfigurationDragStateDragging,
        _ => throw ArgumentError(
            'Unknown value for UICellConfigurationDragState: $value'),
      };
}

late final _sel_cellDragState = objc.registerName("cellDragState");
final _objc_msgSend_10i7aka = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCellDragState_ = objc.registerName("setCellDragState:");
final _objc_msgSend_1murqn0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

enum UICellConfigurationDropState {
  UICellConfigurationDropStateNone(0),
  UICellConfigurationDropStateNotTargeted(1),
  UICellConfigurationDropStateTargeted(2);

  final int value;
  const UICellConfigurationDropState(this.value);

  static UICellConfigurationDropState fromValue(int value) => switch (value) {
        0 => UICellConfigurationDropStateNone,
        1 => UICellConfigurationDropStateNotTargeted,
        2 => UICellConfigurationDropStateTargeted,
        _ => throw ArgumentError(
            'Unknown value for UICellConfigurationDropState: $value'),
      };
}

late final _sel_cellDropState = objc.registerName("cellDropState");
final _objc_msgSend_1g9qrcf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCellDropState_ = objc.registerName("setCellDropState:");
final _objc_msgSend_9t0hj7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// UICellConfigurationState
class UICellConfigurationState extends UIViewConfigurationState {
  UICellConfigurationState._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UICellConfigurationState',
        iOS: (false, (14, 0, 0)));
  }

  /// Constructs a [UICellConfigurationState] that points to the same underlying object as [other].
  UICellConfigurationState.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UICellConfigurationState] that wraps the given raw object pointer.
  UICellConfigurationState.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UICellConfigurationState].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UICellConfigurationState);
  }

  /// isEditing
  bool get editing {
    objc.checkOsVersionInternal('UICellConfigurationState.isEditing',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEditing);
  }

  /// setEditing:
  set editing(bool value) {
    objc.checkOsVersionInternal('UICellConfigurationState.setEditing:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEditing_, value);
  }

  /// isExpanded
  bool get expanded {
    objc.checkOsVersionInternal('UICellConfigurationState.isExpanded',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isExpanded);
  }

  /// setExpanded:
  set expanded(bool value) {
    objc.checkOsVersionInternal('UICellConfigurationState.setExpanded:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setExpanded_, value);
  }

  /// isSwiped
  bool get swiped {
    objc.checkOsVersionInternal('UICellConfigurationState.isSwiped',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isSwiped);
  }

  /// setSwiped:
  set swiped(bool value) {
    objc.checkOsVersionInternal('UICellConfigurationState.setSwiped:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setSwiped_, value);
  }

  /// isReordering
  bool get reordering {
    objc.checkOsVersionInternal('UICellConfigurationState.isReordering',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isReordering);
  }

  /// setReordering:
  set reordering(bool value) {
    objc.checkOsVersionInternal('UICellConfigurationState.setReordering:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setReordering_, value);
  }

  /// cellDragState
  UICellConfigurationDragState get cellDragState {
    final _ret = _objc_msgSend_10i7aka(this.ref.pointer, _sel_cellDragState);
    return UICellConfigurationDragState.fromValue(_ret);
  }

  /// setCellDragState:
  set cellDragState(UICellConfigurationDragState value) {
    _objc_msgSend_1murqn0(
        this.ref.pointer, _sel_setCellDragState_, value.value);
  }

  /// cellDropState
  UICellConfigurationDropState get cellDropState {
    final _ret = _objc_msgSend_1g9qrcf(this.ref.pointer, _sel_cellDropState);
    return UICellConfigurationDropState.fromValue(_ret);
  }

  /// setCellDropState:
  set cellDropState(UICellConfigurationDropState value) {
    _objc_msgSend_9t0hj7(this.ref.pointer, _sel_setCellDropState_, value.value);
  }

  /// initWithTraitCollection:
  UICellConfigurationState initWithTraitCollection(
      UITraitCollection traitCollection) {
    objc.checkOsVersionInternal(
        'UICellConfigurationState.initWithTraitCollection:',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithTraitCollection_, traitCollection.ref.pointer);
    return UICellConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithCoder:
  UICellConfigurationState? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UICellConfigurationState.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// init
  UICellConfigurationState init() {
    objc.checkOsVersionInternal('UICellConfigurationState.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UICellConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static UICellConfigurationState new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_UICellConfigurationState, _sel_new);
    return UICellConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static UICellConfigurationState allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_UICellConfigurationState, _sel_allocWithZone_, zone);
    return UICellConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static UICellConfigurationState alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_UICellConfigurationState, _sel_alloc);
    return UICellConfigurationState.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_UICellConfigurationState, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UICellConfigurationState constructed with the default `new` method.
  factory UICellConfigurationState() => new$();
}

late final _sel_configurationState = objc.registerName("configurationState");
late final _sel_setNeedsUpdateConfiguration =
    objc.registerName("setNeedsUpdateConfiguration");
late final _sel_updateConfigurationUsingState_ =
    objc.registerName("updateConfigurationUsingState:");
late final _sel_configurationUpdateHandler =
    objc.registerName("configurationUpdateHandler");
late final _sel_setConfigurationUpdateHandler_ =
    objc.registerName("setConfigurationUpdateHandler:");

/// WARNING: UIListContentConfiguration is a stub. To generate bindings for this class, include
/// UIListContentConfiguration in your config's objc-interfaces list.
///
/// UIListContentConfiguration
class UIListContentConfiguration extends objc.NSObject
    implements UIContentConfiguration, objc.NSSecureCoding {
  UIListContentConfiguration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIListContentConfiguration',
        iOS: (false, (14, 0, 0)));
  }

  /// Constructs a [UIListContentConfiguration] that points to the same underlying object as [other].
  UIListContentConfiguration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIListContentConfiguration] that wraps the given raw object pointer.
  UIListContentConfiguration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_defaultContentConfiguration =
    objc.registerName("defaultContentConfiguration");

/// WARNING: UIContentConfiguration is a stub. To generate bindings for this class, include
/// UIContentConfiguration in your config's objc-protocols list.
///
/// UIContentConfiguration
interface class UIContentConfiguration extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol, objc.NSCopying {
  UIContentConfiguration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIContentConfiguration] that points to the same underlying object as [other].
  UIContentConfiguration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContentConfiguration] that wraps the given raw object pointer.
  UIContentConfiguration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_contentConfiguration =
    objc.registerName("contentConfiguration");
late final _sel_setContentConfiguration_ =
    objc.registerName("setContentConfiguration:");
late final _sel_automaticallyUpdatesContentConfiguration =
    objc.registerName("automaticallyUpdatesContentConfiguration");
late final _sel_setAutomaticallyUpdatesContentConfiguration_ =
    objc.registerName("setAutomaticallyUpdatesContentConfiguration:");
late final _sel_contentView = objc.registerName("contentView");
late final _sel_imageView = objc.registerName("imageView");

/// WARNING: UILabel is a stub. To generate bindings for this class, include
/// UILabel in your config's objc-interfaces list.
///
/// UILabel
class UILabel extends UIView
    implements
        objc.NSCoding,
        UIContentSizeCategoryAdjusting,
        UILetterformAwareAdjusting {
  UILabel._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILabel', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UILabel] that points to the same underlying object as [other].
  UILabel.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILabel] that wraps the given raw object pointer.
  UILabel.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_textLabel = objc.registerName("textLabel");
late final _sel_detailTextLabel = objc.registerName("detailTextLabel");
late final _sel_defaultBackgroundConfiguration =
    objc.registerName("defaultBackgroundConfiguration");
late final _sel_backgroundConfiguration =
    objc.registerName("backgroundConfiguration");
late final _sel_setBackgroundConfiguration_ =
    objc.registerName("setBackgroundConfiguration:");
late final _sel_automaticallyUpdatesBackgroundConfiguration =
    objc.registerName("automaticallyUpdatesBackgroundConfiguration");
late final _sel_setAutomaticallyUpdatesBackgroundConfiguration_ =
    objc.registerName("setAutomaticallyUpdatesBackgroundConfiguration:");
late final _sel_backgroundView = objc.registerName("backgroundView");
late final _sel_setBackgroundView_ = objc.registerName("setBackgroundView:");
late final _sel_selectedBackgroundView =
    objc.registerName("selectedBackgroundView");
late final _sel_setSelectedBackgroundView_ =
    objc.registerName("setSelectedBackgroundView:");
late final _sel_multipleSelectionBackgroundView =
    objc.registerName("multipleSelectionBackgroundView");
late final _sel_setMultipleSelectionBackgroundView_ =
    objc.registerName("setMultipleSelectionBackgroundView:");
late final _sel_reuseIdentifier = objc.registerName("reuseIdentifier");
late final _sel_prepareForReuse = objc.registerName("prepareForReuse");
late final _sel_selectionStyle = objc.registerName("selectionStyle");
final _objc_msgSend_1d2lxkb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSelectionStyle_ = objc.registerName("setSelectionStyle:");
final _objc_msgSend_1uwq2nz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setSelected_animated_ =
    objc.registerName("setSelected:animated:");
final _objc_msgSend_14iqu8t = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool, bool)>();
late final _sel_setHighlighted_animated_ =
    objc.registerName("setHighlighted:animated:");
late final _sel_editingStyle = objc.registerName("editingStyle");
final _objc_msgSend_rz99rt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_showsReorderControl = objc.registerName("showsReorderControl");
late final _sel_setShowsReorderControl_ =
    objc.registerName("setShowsReorderControl:");
late final _sel_shouldIndentWhileEditing =
    objc.registerName("shouldIndentWhileEditing");
late final _sel_setShouldIndentWhileEditing_ =
    objc.registerName("setShouldIndentWhileEditing:");
late final _sel_accessoryType = objc.registerName("accessoryType");
final _objc_msgSend_1vg5j0q = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAccessoryType_ = objc.registerName("setAccessoryType:");
final _objc_msgSend_c8nyto = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_accessoryView = objc.registerName("accessoryView");
late final _sel_setAccessoryView_ = objc.registerName("setAccessoryView:");
late final _sel_editingAccessoryType =
    objc.registerName("editingAccessoryType");
late final _sel_setEditingAccessoryType_ =
    objc.registerName("setEditingAccessoryType:");
late final _sel_editingAccessoryView =
    objc.registerName("editingAccessoryView");
late final _sel_setEditingAccessoryView_ =
    objc.registerName("setEditingAccessoryView:");
late final _sel_indentationLevel = objc.registerName("indentationLevel");
late final _sel_setIndentationLevel_ =
    objc.registerName("setIndentationLevel:");
late final _sel_indentationWidth = objc.registerName("indentationWidth");
late final _sel_setIndentationWidth_ =
    objc.registerName("setIndentationWidth:");
late final _sel_separatorInset = objc.registerName("separatorInset");
late final _sel_setSeparatorInset_ = objc.registerName("setSeparatorInset:");
late final _sel_setEditing_animated_ =
    objc.registerName("setEditing:animated:");
late final _sel_showingDeleteConfirmation =
    objc.registerName("showingDeleteConfirmation");
late final _sel_focusStyle = objc.registerName("focusStyle");
final _objc_msgSend_1o6ymet = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setFocusStyle_ = objc.registerName("setFocusStyle:");
final _objc_msgSend_tbdrv1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_willTransitionToState_ =
    objc.registerName("willTransitionToState:");
final _objc_msgSend_ipxvh9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_didTransitionToState_ =
    objc.registerName("didTransitionToState:");
late final _sel_dragStateDidChange_ = objc.registerName("dragStateDidChange:");
final _objc_msgSend_c54vyn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_userInteractionEnabledWhileDragging =
    objc.registerName("userInteractionEnabledWhileDragging");
late final _sel_setUserInteractionEnabledWhileDragging_ =
    objc.registerName("setUserInteractionEnabledWhileDragging:");
bool _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void>, UIGestureRecognizer)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Bool Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>(
          objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_UIGestureRecognizer_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, UIGestureRecognizer.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_CallExtension on objc
    .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_ =
    objc.registerName(
        "gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:");
final _objc_msgSend_1lsax7n = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
bool
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                bool Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_fnPtrTrampoline,
            false)
        .cast();
bool
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer,
                      UIGestureRecognizer)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>(
          objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>
      fromFunction(bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>(
              objc.newClosureBlock(
                  _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      UIGestureRecognizer.castFromPointer(arg1, retain: true, release: true),
                      UIGestureRecognizer.castFromPointer(arg2, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(
            ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1,
          UIGestureRecognizer arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_ =
    objc.registerName(
        "gestureRecognizer:shouldRequireFailureOfGestureRecognizer:");
late final _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_ =
    objc.registerName(
        "gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:");
late final _sel_gestureRecognizer_shouldReceiveTouch_ =
    objc.registerName("gestureRecognizer:shouldReceiveTouch:");
bool _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer,
                  UITouch)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>(
          objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  UIGestureRecognizer.castFromPointer(arg1, retain: true, release: true),
                  UITouch.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(
            ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)> {
  bool call(
          ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1, UITouch arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

/// WARNING: UIPress is a stub. To generate bindings for this class, include
/// UIPress in your config's objc-interfaces list.
///
/// UIPress
class UIPress extends objc.NSObject {
  UIPress._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPress', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIPress] that points to the same underlying object as [other].
  UIPress.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPress] that wraps the given raw object pointer.
  UIPress.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_gestureRecognizer_shouldReceivePress_ =
    objc.registerName("gestureRecognizer:shouldReceivePress:");
bool _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer,
                  UIPress)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>(
          objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  UIGestureRecognizer.castFromPointer(arg1, retain: true, release: true),
                  UIPress.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(
            ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)> {
  bool call(
          ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1, UIPress arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_gestureRecognizer_shouldReceiveEvent_ =
    objc.registerName("gestureRecognizer:shouldReceiveEvent:");
bool _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer,
                  UIEvent)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>(
          objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  arg0,
                  UIGestureRecognizer.castFromPointer(arg1, retain: true, release: true),
                  UIEvent.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(
            ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)> {
  bool call(
          ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1, UIEvent arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

/// UITableViewCell
class UITableViewCell extends UIView
    implements objc.NSCoding, UIGestureRecognizerDelegate {
  UITableViewCell._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITableViewCell', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITableViewCell] that points to the same underlying object as [other].
  UITableViewCell.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITableViewCell] that wraps the given raw object pointer.
  UITableViewCell.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UITableViewCell].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_UITableViewCell);
  }

  /// initWithStyle:reuseIdentifier:
  UITableViewCell initWithStyle(UITableViewCellStyle style,
      {objc.NSString? reuseIdentifier}) {
    objc.checkOsVersionInternal(
        'UITableViewCell.initWithStyle:reuseIdentifier:',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_96u4vv(
        this.ref.retainAndReturnPointer(),
        _sel_initWithStyle_reuseIdentifier_,
        style.value,
        reuseIdentifier?.ref.pointer ?? ffi.nullptr);
    return UITableViewCell.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UITableViewCell? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UITableViewCell.castFromPointer(_ret, retain: false, release: true);
  }

  /// configurationState
  UICellConfigurationState get configurationState {
    objc.checkOsVersionInternal('UITableViewCell.configurationState',
        iOS: (false, (14, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_configurationState);
    return UICellConfigurationState.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setNeedsUpdateConfiguration
  void setNeedsUpdateConfiguration() {
    objc.checkOsVersionInternal('UITableViewCell.setNeedsUpdateConfiguration',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateConfiguration);
  }

  /// updateConfigurationUsingState:
  void updateConfigurationUsingState(UICellConfigurationState state) {
    objc.checkOsVersionInternal(
        'UITableViewCell.updateConfigurationUsingState:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_updateConfigurationUsingState_,
        state.ref.pointer);
  }

  /// configurationUpdateHandler
  objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>?
      get configurationUpdateHandler {
    objc.checkOsVersionInternal('UITableViewCell.configurationUpdateHandler',
        iOS: (false, (15, 0, 0)));
    final _ret =
        _objc_msgSend_uwvaik(this.ref.pointer, _sel_configurationUpdateHandler);
    return _ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState
            .castFromPointer(_ret, retain: true, release: true);
  }

  /// setConfigurationUpdateHandler:
  set configurationUpdateHandler(
      objc.ObjCBlock<
              ffi.Void Function(UITableViewCell, UICellConfigurationState)>?
          value) {
    objc.checkOsVersionInternal(
        'UITableViewCell.setConfigurationUpdateHandler:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_f167m6(this.ref.pointer, _sel_setConfigurationUpdateHandler_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// defaultContentConfiguration
  UIListContentConfiguration defaultContentConfiguration() {
    objc.checkOsVersionInternal('UITableViewCell.defaultContentConfiguration',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_defaultContentConfiguration);
    return UIListContentConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// contentConfiguration
  UIContentConfiguration? get contentConfiguration {
    objc.checkOsVersionInternal('UITableViewCell.contentConfiguration',
        iOS: (false, (14, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_contentConfiguration);
    return _ret.address == 0
        ? null
        : UIContentConfiguration.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setContentConfiguration:
  set contentConfiguration(UIContentConfiguration? value) {
    objc.checkOsVersionInternal('UITableViewCell.setContentConfiguration:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setContentConfiguration_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// automaticallyUpdatesContentConfiguration
  bool get automaticallyUpdatesContentConfiguration {
    objc.checkOsVersionInternal(
        'UITableViewCell.automaticallyUpdatesContentConfiguration',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_automaticallyUpdatesContentConfiguration);
  }

  /// setAutomaticallyUpdatesContentConfiguration:
  set automaticallyUpdatesContentConfiguration(bool value) {
    objc.checkOsVersionInternal(
        'UITableViewCell.setAutomaticallyUpdatesContentConfiguration:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setAutomaticallyUpdatesContentConfiguration_, value);
  }

  /// contentView
  UIView get contentView {
    objc.checkOsVersionInternal('UITableViewCell.contentView',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_contentView);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageView
  UIImageView? get imageView {
    objc.checkOsVersionInternal('UITableViewCell.imageView',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_imageView);
    return _ret.address == 0
        ? null
        : UIImageView.castFromPointer(_ret, retain: true, release: true);
  }

  /// textLabel
  UILabel? get textLabel {
    objc.checkOsVersionInternal('UITableViewCell.textLabel',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textLabel);
    return _ret.address == 0
        ? null
        : UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// detailTextLabel
  UILabel? get detailTextLabel {
    objc.checkOsVersionInternal('UITableViewCell.detailTextLabel',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_detailTextLabel);
    return _ret.address == 0
        ? null
        : UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// defaultBackgroundConfiguration
  UIBackgroundConfiguration defaultBackgroundConfiguration() {
    objc.checkOsVersionInternal(
        'UITableViewCell.defaultBackgroundConfiguration',
        iOS: (false, (16, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_defaultBackgroundConfiguration);
    return UIBackgroundConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// backgroundConfiguration
  UIBackgroundConfiguration? get backgroundConfiguration {
    objc.checkOsVersionInternal('UITableViewCell.backgroundConfiguration',
        iOS: (false, (14, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundConfiguration);
    return _ret.address == 0
        ? null
        : UIBackgroundConfiguration.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setBackgroundConfiguration:
  set backgroundConfiguration(UIBackgroundConfiguration? value) {
    objc.checkOsVersionInternal('UITableViewCell.setBackgroundConfiguration:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundConfiguration_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// automaticallyUpdatesBackgroundConfiguration
  bool get automaticallyUpdatesBackgroundConfiguration {
    objc.checkOsVersionInternal(
        'UITableViewCell.automaticallyUpdatesBackgroundConfiguration',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_automaticallyUpdatesBackgroundConfiguration);
  }

  /// setAutomaticallyUpdatesBackgroundConfiguration:
  set automaticallyUpdatesBackgroundConfiguration(bool value) {
    objc.checkOsVersionInternal(
        'UITableViewCell.setAutomaticallyUpdatesBackgroundConfiguration:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setAutomaticallyUpdatesBackgroundConfiguration_, value);
  }

  /// backgroundView
  UIView? get backgroundView {
    objc.checkOsVersionInternal('UITableViewCell.backgroundView',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackgroundView:
  set backgroundView(UIView? value) {
    objc.checkOsVersionInternal('UITableViewCell.setBackgroundView:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundView_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// selectedBackgroundView
  UIView? get selectedBackgroundView {
    objc.checkOsVersionInternal('UITableViewCell.selectedBackgroundView',
        iOS: (false, (2, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedBackgroundView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSelectedBackgroundView:
  set selectedBackgroundView(UIView? value) {
    objc.checkOsVersionInternal('UITableViewCell.setSelectedBackgroundView:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectedBackgroundView_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// multipleSelectionBackgroundView
  UIView? get multipleSelectionBackgroundView {
    objc.checkOsVersionInternal(
        'UITableViewCell.multipleSelectionBackgroundView',
        iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_multipleSelectionBackgroundView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMultipleSelectionBackgroundView:
  set multipleSelectionBackgroundView(UIView? value) {
    objc.checkOsVersionInternal(
        'UITableViewCell.setMultipleSelectionBackgroundView:',
        iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer,
        _sel_setMultipleSelectionBackgroundView_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// reuseIdentifier
  objc.NSString? get reuseIdentifier {
    objc.checkOsVersionInternal('UITableViewCell.reuseIdentifier',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_reuseIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// prepareForReuse
  void prepareForReuse() {
    objc.checkOsVersionInternal('UITableViewCell.prepareForReuse',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_prepareForReuse);
  }

  /// selectionStyle
  UITableViewCellSelectionStyle get selectionStyle {
    objc.checkOsVersionInternal('UITableViewCell.selectionStyle',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1d2lxkb(this.ref.pointer, _sel_selectionStyle);
    return UITableViewCellSelectionStyle.fromValue(_ret);
  }

  /// setSelectionStyle:
  set selectionStyle(UITableViewCellSelectionStyle value) {
    objc.checkOsVersionInternal('UITableViewCell.setSelectionStyle:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1uwq2nz(
        this.ref.pointer, _sel_setSelectionStyle_, value.value);
  }

  /// isSelected
  bool get selected {
    objc.checkOsVersionInternal('UITableViewCell.isSelected',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isSelected);
  }

  /// setSelected:
  set selected(bool value) {
    objc.checkOsVersionInternal('UITableViewCell.setSelected:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setSelected_, value);
  }

  /// isHighlighted
  bool get highlighted {
    objc.checkOsVersionInternal('UITableViewCell.isHighlighted',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHighlighted);
  }

  /// setHighlighted:
  set highlighted(bool value) {
    objc.checkOsVersionInternal('UITableViewCell.setHighlighted:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHighlighted_, value);
  }

  /// setSelected:animated:
  void setSelected(bool selected$1, {required bool animated}) {
    objc.checkOsVersionInternal('UITableViewCell.setSelected:animated:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(
        this.ref.pointer, _sel_setSelected_animated_, selected$1, animated);
  }

  /// setHighlighted:animated:
  void setHighlighted(bool highlighted$1, {required bool animated}) {
    objc.checkOsVersionInternal('UITableViewCell.setHighlighted:animated:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setHighlighted_animated_,
        highlighted$1, animated);
  }

  /// editingStyle
  UITableViewCellEditingStyle get editingStyle {
    objc.checkOsVersionInternal('UITableViewCell.editingStyle',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_rz99rt(this.ref.pointer, _sel_editingStyle);
    return UITableViewCellEditingStyle.fromValue(_ret);
  }

  /// showsReorderControl
  bool get showsReorderControl {
    objc.checkOsVersionInternal('UITableViewCell.showsReorderControl',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsReorderControl);
  }

  /// setShowsReorderControl:
  set showsReorderControl(bool value) {
    objc.checkOsVersionInternal('UITableViewCell.setShowsReorderControl:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setShowsReorderControl_, value);
  }

  /// shouldIndentWhileEditing
  bool get shouldIndentWhileEditing {
    objc.checkOsVersionInternal('UITableViewCell.shouldIndentWhileEditing',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_shouldIndentWhileEditing);
  }

  /// setShouldIndentWhileEditing:
  set shouldIndentWhileEditing(bool value) {
    objc.checkOsVersionInternal('UITableViewCell.setShouldIndentWhileEditing:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setShouldIndentWhileEditing_, value);
  }

  /// accessoryType
  UITableViewCellAccessoryType get accessoryType {
    objc.checkOsVersionInternal('UITableViewCell.accessoryType',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1vg5j0q(this.ref.pointer, _sel_accessoryType);
    return UITableViewCellAccessoryType.fromValue(_ret);
  }

  /// setAccessoryType:
  set accessoryType(UITableViewCellAccessoryType value) {
    objc.checkOsVersionInternal('UITableViewCell.setAccessoryType:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_c8nyto(this.ref.pointer, _sel_setAccessoryType_, value.value);
  }

  /// accessoryView
  UIView? get accessoryView {
    objc.checkOsVersionInternal('UITableViewCell.accessoryView',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_accessoryView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAccessoryView:
  set accessoryView(UIView? value) {
    objc.checkOsVersionInternal('UITableViewCell.setAccessoryView:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAccessoryView_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// editingAccessoryType
  UITableViewCellAccessoryType get editingAccessoryType {
    objc.checkOsVersionInternal('UITableViewCell.editingAccessoryType',
        iOS: (false, (2, 0, 0)));
    final _ret =
        _objc_msgSend_1vg5j0q(this.ref.pointer, _sel_editingAccessoryType);
    return UITableViewCellAccessoryType.fromValue(_ret);
  }

  /// setEditingAccessoryType:
  set editingAccessoryType(UITableViewCellAccessoryType value) {
    objc.checkOsVersionInternal('UITableViewCell.setEditingAccessoryType:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_c8nyto(
        this.ref.pointer, _sel_setEditingAccessoryType_, value.value);
  }

  /// editingAccessoryView
  UIView? get editingAccessoryView {
    objc.checkOsVersionInternal('UITableViewCell.editingAccessoryView',
        iOS: (false, (2, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_editingAccessoryView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setEditingAccessoryView:
  set editingAccessoryView(UIView? value) {
    objc.checkOsVersionInternal('UITableViewCell.setEditingAccessoryView:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setEditingAccessoryView_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// indentationLevel
  int get indentationLevel {
    objc.checkOsVersionInternal('UITableViewCell.indentationLevel',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_indentationLevel);
  }

  /// setIndentationLevel:
  set indentationLevel(int value) {
    objc.checkOsVersionInternal('UITableViewCell.setIndentationLevel:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setIndentationLevel_, value);
  }

  /// indentationWidth
  double get indentationWidth {
    objc.checkOsVersionInternal('UITableViewCell.indentationWidth',
        iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_indentationWidth)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_indentationWidth);
  }

  /// setIndentationWidth:
  set indentationWidth(double value) {
    objc.checkOsVersionInternal('UITableViewCell.setIndentationWidth:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setIndentationWidth_, value);
  }

  /// separatorInset
  UIEdgeInsets get separatorInset {
    objc.checkOsVersionInternal('UITableViewCell.separatorInset',
        iOS: (false, (7, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_separatorInset)
        : _ptr.ref =
            _objc_msgSend_ct4cu5(this.ref.pointer, _sel_separatorInset);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setSeparatorInset:
  set separatorInset(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UITableViewCell.setSeparatorInset:',
        iOS: (false, (7, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setSeparatorInset_, value);
  }

  /// isEditing
  bool get editing {
    objc.checkOsVersionInternal('UITableViewCell.isEditing',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEditing);
  }

  /// setEditing:
  set editing(bool value) {
    objc.checkOsVersionInternal('UITableViewCell.setEditing:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEditing_, value);
  }

  /// setEditing:animated:
  void setEditing(bool editing$1, {required bool animated}) {
    objc.checkOsVersionInternal('UITableViewCell.setEditing:animated:',
        iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(
        this.ref.pointer, _sel_setEditing_animated_, editing$1, animated);
  }

  /// showingDeleteConfirmation
  bool get showingDeleteConfirmation {
    objc.checkOsVersionInternal('UITableViewCell.showingDeleteConfirmation',
        iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_showingDeleteConfirmation);
  }

  /// focusStyle
  UITableViewCellFocusStyle get focusStyle {
    objc.checkOsVersionInternal('UITableViewCell.focusStyle',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_1o6ymet(this.ref.pointer, _sel_focusStyle);
    return UITableViewCellFocusStyle.fromValue(_ret);
  }

  /// setFocusStyle:
  set focusStyle(UITableViewCellFocusStyle value) {
    objc.checkOsVersionInternal('UITableViewCell.setFocusStyle:',
        iOS: (false, (9, 0, 0)));
    _objc_msgSend_tbdrv1(this.ref.pointer, _sel_setFocusStyle_, value.value);
  }

  /// willTransitionToState:
  void willTransitionToState(UITableViewCellStateMask state) {
    objc.checkOsVersionInternal('UITableViewCell.willTransitionToState:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_ipxvh9(
        this.ref.pointer, _sel_willTransitionToState_, state.value);
  }

  /// didTransitionToState:
  void didTransitionToState(UITableViewCellStateMask state) {
    objc.checkOsVersionInternal('UITableViewCell.didTransitionToState:',
        iOS: (false, (3, 0, 0)));
    _objc_msgSend_ipxvh9(
        this.ref.pointer, _sel_didTransitionToState_, state.value);
  }

  /// dragStateDidChange:
  void dragStateDidChange(UITableViewCellDragState dragState) {
    objc.checkOsVersionInternal('UITableViewCell.dragStateDidChange:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_c54vyn(
        this.ref.pointer, _sel_dragStateDidChange_, dragState.value);
  }

  /// userInteractionEnabledWhileDragging
  bool get userInteractionEnabledWhileDragging {
    objc.checkOsVersionInternal(
        'UITableViewCell.userInteractionEnabledWhileDragging',
        iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_userInteractionEnabledWhileDragging);
  }

  /// setUserInteractionEnabledWhileDragging:
  set userInteractionEnabledWhileDragging(bool value) {
    objc.checkOsVersionInternal(
        'UITableViewCell.setUserInteractionEnabledWhileDragging:',
        iOS: (false, (11, 0, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setUserInteractionEnabledWhileDragging_, value);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UITableViewCell.layerClass',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithFrame:
  UITableViewCell initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UITableViewCell.initWithFrame:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UITableViewCell.castFromPointer(_ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute(
          UISemanticContentAttribute attribute) {
    objc.checkOsVersionInternal(
        'UITableViewCell.userInterfaceLayoutDirectionForSemanticContentAttribute:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_racczx(
        _class_UITableViewCell,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
        attribute.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute$1(
          UISemanticContentAttribute semanticContentAttribute$1,
          {required UIUserInterfaceLayoutDirection relativeToLayoutDirection}) {
    objc.checkOsVersionInternal(
        'UITableViewCell.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
        iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_tz4p54(
        _class_UITableViewCell,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
        semanticContentAttribute$1.value,
        relativeToLayoutDirection.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_gestureRecognizerShouldBegin_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UITableViewCell', 'gestureRecognizerShouldBegin:');
    }
    return _objc_msgSend_19nvye5(this.ref.pointer,
        _sel_gestureRecognizerShouldBegin_, gestureRecognizer.ref.pointer);
  }

  /// gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:
  bool gestureRecognizer(UIGestureRecognizer gestureRecognizer$1,
      {required UIGestureRecognizer
          shouldRecognizeSimultaneouslyWithGestureRecognizer}) {
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell',
          'gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:');
    }
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_,
        gestureRecognizer$1.ref.pointer,
        shouldRecognizeSimultaneouslyWithGestureRecognizer.ref.pointer);
  }

  /// gestureRecognizer:shouldRequireFailureOfGestureRecognizer:
  bool gestureRecognizer$1(UIGestureRecognizer gestureRecognizer$2,
      {required UIGestureRecognizer shouldRequireFailureOfGestureRecognizer}) {
    objc.checkOsVersionInternal(
        'UITableViewCell.gestureRecognizer:shouldRequireFailureOfGestureRecognizer:',
        iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell',
          'gestureRecognizer:shouldRequireFailureOfGestureRecognizer:');
    }
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_,
        gestureRecognizer$2.ref.pointer,
        shouldRequireFailureOfGestureRecognizer.ref.pointer);
  }

  /// gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:
  bool gestureRecognizer$2(UIGestureRecognizer gestureRecognizer$3,
      {required UIGestureRecognizer
          shouldBeRequiredToFailByGestureRecognizer}) {
    objc.checkOsVersionInternal(
        'UITableViewCell.gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:',
        iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell',
          'gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:');
    }
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_,
        gestureRecognizer$3.ref.pointer,
        shouldBeRequiredToFailByGestureRecognizer.ref.pointer);
  }

  /// gestureRecognizer:shouldReceiveTouch:
  bool gestureRecognizer$3(UIGestureRecognizer gestureRecognizer$4,
      {required UITouch shouldReceiveTouch}) {
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_gestureRecognizer_shouldReceiveTouch_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UITableViewCell', 'gestureRecognizer:shouldReceiveTouch:');
    }
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_gestureRecognizer_shouldReceiveTouch_,
        gestureRecognizer$4.ref.pointer,
        shouldReceiveTouch.ref.pointer);
  }

  /// gestureRecognizer:shouldReceivePress:
  bool gestureRecognizer$4(UIGestureRecognizer gestureRecognizer$5,
      {required UIPress shouldReceivePress}) {
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_gestureRecognizer_shouldReceivePress_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UITableViewCell', 'gestureRecognizer:shouldReceivePress:');
    }
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_gestureRecognizer_shouldReceivePress_,
        gestureRecognizer$5.ref.pointer,
        shouldReceivePress.ref.pointer);
  }

  /// gestureRecognizer:shouldReceiveEvent:
  bool gestureRecognizer$5(UIGestureRecognizer gestureRecognizer$6,
      {required UIEvent shouldReceiveEvent}) {
    objc.checkOsVersionInternal(
        'UITableViewCell.gestureRecognizer:shouldReceiveEvent:',
        iOS: (false, (13, 4, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_gestureRecognizer_shouldReceiveEvent_)) {
      throw objc.UnimplementedOptionalMethodException(
          'UITableViewCell', 'gestureRecognizer:shouldReceiveEvent:');
    }
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_gestureRecognizer_shouldReceiveEvent_,
        gestureRecognizer$6.ref.pointer,
        shouldReceiveEvent.ref.pointer);
  }
}

void
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                void Function(ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>`.
abstract final class ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(UITableViewCell, UICellConfigurationState)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> fromFunction(
          void Function(UITableViewCell, UICellConfigurationState) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  UITableViewCell.castFromPointer(arg0, retain: true, release: true),
                  UICellConfigurationState.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>
      listener(void Function(UITableViewCell, UICellConfigurationState) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITableViewCell.castFromPointer(arg0,
                    retain: false, release: true),
                UICellConfigurationState.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(UITableViewCell,
            UICellConfigurationState)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>
      blocking(void Function(UITableViewCell, UICellConfigurationState) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITableViewCell.castFromPointer(arg0,
                    retain: false, release: true),
                UICellConfigurationState.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITableViewCell.castFromPointer(arg0,
                    retain: false, release: true),
                UICellConfigurationState.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(UITableViewCell,
            UICellConfigurationState)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>`.
extension ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState_CallExtension
    on objc
    .ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> {
  void call(UITableViewCell arg0, UICellConfigurationState arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

enum UITableViewStyle {
  UITableViewStylePlain(0),
  UITableViewStyleGrouped(1),
  UITableViewStyleInsetGrouped(2);

  final int value;
  const UITableViewStyle(this.value);

  static UITableViewStyle fromValue(int value) => switch (value) {
        0 => UITableViewStylePlain,
        1 => UITableViewStyleGrouped,
        2 => UITableViewStyleInsetGrouped,
        _ => throw ArgumentError('Unknown value for UITableViewStyle: $value'),
      };
}

enum UITableViewScrollPosition {
  UITableViewScrollPositionNone(0),
  UITableViewScrollPositionTop(1),
  UITableViewScrollPositionMiddle(2),
  UITableViewScrollPositionBottom(3);

  final int value;
  const UITableViewScrollPosition(this.value);

  static UITableViewScrollPosition fromValue(int value) => switch (value) {
        0 => UITableViewScrollPositionNone,
        1 => UITableViewScrollPositionTop,
        2 => UITableViewScrollPositionMiddle,
        3 => UITableViewScrollPositionBottom,
        _ => throw ArgumentError(
            'Unknown value for UITableViewScrollPosition: $value'),
      };
}

enum UITableViewRowAnimation {
  UITableViewRowAnimationFade(0),
  UITableViewRowAnimationRight(1),
  UITableViewRowAnimationLeft(2),
  UITableViewRowAnimationTop(3),
  UITableViewRowAnimationBottom(4),
  UITableViewRowAnimationNone(5),
  UITableViewRowAnimationMiddle(6),
  UITableViewRowAnimationAutomatic(100);

  final int value;
  const UITableViewRowAnimation(this.value);

  static UITableViewRowAnimation fromValue(int value) => switch (value) {
        0 => UITableViewRowAnimationFade,
        1 => UITableViewRowAnimationRight,
        2 => UITableViewRowAnimationLeft,
        3 => UITableViewRowAnimationTop,
        4 => UITableViewRowAnimationBottom,
        5 => UITableViewRowAnimationNone,
        6 => UITableViewRowAnimationMiddle,
        100 => UITableViewRowAnimationAutomatic,
        _ => throw ArgumentError(
            'Unknown value for UITableViewRowAnimation: $value'),
      };
}

enum UITableViewContentHuggingElements {
  UITableViewContentHuggingElementsNone(0),
  UITableViewContentHuggingElementsSectionHeaders(1);

  final int value;
  const UITableViewContentHuggingElements(this.value);

  static UITableViewContentHuggingElements fromValue(int value) =>
      switch (value) {
        0 => UITableViewContentHuggingElementsNone,
        1 => UITableViewContentHuggingElementsSectionHeaders,
        _ => throw ArgumentError(
            'Unknown value for UITableViewContentHuggingElements: $value'),
      };
}

enum UITableViewSeparatorInsetReference {
  UITableViewSeparatorInsetFromCellEdges(0),
  UITableViewSeparatorInsetFromAutomaticInsets(1);

  final int value;
  const UITableViewSeparatorInsetReference(this.value);

  static UITableViewSeparatorInsetReference fromValue(int value) =>
      switch (value) {
        0 => UITableViewSeparatorInsetFromCellEdges,
        1 => UITableViewSeparatorInsetFromAutomaticInsets,
        _ => throw ArgumentError(
            'Unknown value for UITableViewSeparatorInsetReference: $value'),
      };
}

enum UITableViewSelfSizingInvalidation {
  UITableViewSelfSizingInvalidationDisabled(0),
  UITableViewSelfSizingInvalidationEnabled(1),
  UITableViewSelfSizingInvalidationEnabledIncludingConstraints(2);

  final int value;
  const UITableViewSelfSizingInvalidation(this.value);

  static UITableViewSelfSizingInvalidation fromValue(int value) =>
      switch (value) {
        0 => UITableViewSelfSizingInvalidationDisabled,
        1 => UITableViewSelfSizingInvalidationEnabled,
        2 => UITableViewSelfSizingInvalidationEnabledIncludingConstraints,
        _ => throw ArgumentError(
            'Unknown value for UITableViewSelfSizingInvalidation: $value'),
      };
}

enum UITableViewDropIntent {
  UITableViewDropIntentUnspecified(0),
  UITableViewDropIntentInsertAtDestinationIndexPath(1),
  UITableViewDropIntentInsertIntoDestinationIndexPath(2),
  UITableViewDropIntentAutomatic(3);

  final int value;
  const UITableViewDropIntent(this.value);

  static UITableViewDropIntent fromValue(int value) => switch (value) {
        0 => UITableViewDropIntentUnspecified,
        1 => UITableViewDropIntentInsertAtDestinationIndexPath,
        2 => UITableViewDropIntentInsertIntoDestinationIndexPath,
        3 => UITableViewDropIntentAutomatic,
        _ => throw ArgumentError(
            'Unknown value for UITableViewDropIntent: $value'),
      };
}

enum UIListContentTextAlignment {
  UIListContentTextAlignmentNatural(0),
  UIListContentTextAlignmentCenter(1),
  UIListContentTextAlignmentJustified(2);

  final int value;
  const UIListContentTextAlignment(this.value);

  static UIListContentTextAlignment fromValue(int value) => switch (value) {
        0 => UIListContentTextAlignmentNatural,
        1 => UIListContentTextAlignmentCenter,
        2 => UIListContentTextAlignmentJustified,
        _ => throw ArgumentError(
            'Unknown value for UIListContentTextAlignment: $value'),
      };
}

enum UIListContentTextTransform {
  UIListContentTextTransformNone(0),
  UIListContentTextTransformUppercase(1),
  UIListContentTextTransformLowercase(2),
  UIListContentTextTransformCapitalized(3);

  final int value;
  const UIListContentTextTransform(this.value);

  static UIListContentTextTransform fromValue(int value) => switch (value) {
        0 => UIListContentTextTransformNone,
        1 => UIListContentTextTransformUppercase,
        2 => UIListContentTextTransformLowercase,
        3 => UIListContentTextTransformCapitalized,
        _ => throw ArgumentError(
            'Unknown value for UIListContentTextTransform: $value'),
      };
}

enum UIKeyboardHIDUsage {
  UIKeyboardHIDUsageKeyboardErrorRollOver(1),
  UIKeyboardHIDUsageKeyboardPOSTFail(2),
  UIKeyboardHIDUsageKeyboardErrorUndefined(3),
  UIKeyboardHIDUsageKeyboardA(4),
  UIKeyboardHIDUsageKeyboardB(5),
  UIKeyboardHIDUsageKeyboardC(6),
  UIKeyboardHIDUsageKeyboardD(7),
  UIKeyboardHIDUsageKeyboardE(8),
  UIKeyboardHIDUsageKeyboardF(9),
  UIKeyboardHIDUsageKeyboardG(10),
  UIKeyboardHIDUsageKeyboardH(11),
  UIKeyboardHIDUsageKeyboardI(12),
  UIKeyboardHIDUsageKeyboardJ(13),
  UIKeyboardHIDUsageKeyboardK(14),
  UIKeyboardHIDUsageKeyboardL(15),
  UIKeyboardHIDUsageKeyboardM(16),
  UIKeyboardHIDUsageKeyboardN(17),
  UIKeyboardHIDUsageKeyboardO(18),
  UIKeyboardHIDUsageKeyboardP(19),
  UIKeyboardHIDUsageKeyboardQ(20),
  UIKeyboardHIDUsageKeyboardR(21),
  UIKeyboardHIDUsageKeyboardS(22),
  UIKeyboardHIDUsageKeyboardT(23),
  UIKeyboardHIDUsageKeyboardU(24),
  UIKeyboardHIDUsageKeyboardV(25),
  UIKeyboardHIDUsageKeyboardW(26),
  UIKeyboardHIDUsageKeyboardX(27),
  UIKeyboardHIDUsageKeyboardY(28),
  UIKeyboardHIDUsageKeyboardZ(29),
  UIKeyboardHIDUsageKeyboard1(30),
  UIKeyboardHIDUsageKeyboard2(31),
  UIKeyboardHIDUsageKeyboard3(32),
  UIKeyboardHIDUsageKeyboard4(33),
  UIKeyboardHIDUsageKeyboard5(34),
  UIKeyboardHIDUsageKeyboard6(35),
  UIKeyboardHIDUsageKeyboard7(36),
  UIKeyboardHIDUsageKeyboard8(37),
  UIKeyboardHIDUsageKeyboard9(38),
  UIKeyboardHIDUsageKeyboard0(39),
  UIKeyboardHIDUsageKeyboardReturnOrEnter(40),
  UIKeyboardHIDUsageKeyboardEscape(41),
  UIKeyboardHIDUsageKeyboardDeleteOrBackspace(42),
  UIKeyboardHIDUsageKeyboardTab(43),
  UIKeyboardHIDUsageKeyboardSpacebar(44),
  UIKeyboardHIDUsageKeyboardHyphen(45),
  UIKeyboardHIDUsageKeyboardEqualSign(46),
  UIKeyboardHIDUsageKeyboardOpenBracket(47),
  UIKeyboardHIDUsageKeyboardCloseBracket(48),
  UIKeyboardHIDUsageKeyboardBackslash(49),
  UIKeyboardHIDUsageKeyboardNonUSPound(50),
  UIKeyboardHIDUsageKeyboardSemicolon(51),
  UIKeyboardHIDUsageKeyboardQuote(52),
  UIKeyboardHIDUsageKeyboardGraveAccentAndTilde(53),
  UIKeyboardHIDUsageKeyboardComma(54),
  UIKeyboardHIDUsageKeyboardPeriod(55),
  UIKeyboardHIDUsageKeyboardSlash(56),
  UIKeyboardHIDUsageKeyboardCapsLock(57),
  UIKeyboardHIDUsageKeyboardF1(58),
  UIKeyboardHIDUsageKeyboardF2(59),
  UIKeyboardHIDUsageKeyboardF3(60),
  UIKeyboardHIDUsageKeyboardF4(61),
  UIKeyboardHIDUsageKeyboardF5(62),
  UIKeyboardHIDUsageKeyboardF6(63),
  UIKeyboardHIDUsageKeyboardF7(64),
  UIKeyboardHIDUsageKeyboardF8(65),
  UIKeyboardHIDUsageKeyboardF9(66),
  UIKeyboardHIDUsageKeyboardF10(67),
  UIKeyboardHIDUsageKeyboardF11(68),
  UIKeyboardHIDUsageKeyboardF12(69),
  UIKeyboardHIDUsageKeyboardPrintScreen(70),
  UIKeyboardHIDUsageKeyboardScrollLock(71),
  UIKeyboardHIDUsageKeyboardPause(72),
  UIKeyboardHIDUsageKeyboardInsert(73),
  UIKeyboardHIDUsageKeyboardHome(74),
  UIKeyboardHIDUsageKeyboardPageUp(75),
  UIKeyboardHIDUsageKeyboardDeleteForward(76),
  UIKeyboardHIDUsageKeyboardEnd(77),
  UIKeyboardHIDUsageKeyboardPageDown(78),
  UIKeyboardHIDUsageKeyboardRightArrow(79),
  UIKeyboardHIDUsageKeyboardLeftArrow(80),
  UIKeyboardHIDUsageKeyboardDownArrow(81),
  UIKeyboardHIDUsageKeyboardUpArrow(82),
  UIKeyboardHIDUsageKeypadNumLock(83),
  UIKeyboardHIDUsageKeypadSlash(84),
  UIKeyboardHIDUsageKeypadAsterisk(85),
  UIKeyboardHIDUsageKeypadHyphen(86),
  UIKeyboardHIDUsageKeypadPlus(87),
  UIKeyboardHIDUsageKeypadEnter(88),
  UIKeyboardHIDUsageKeypad1(89),
  UIKeyboardHIDUsageKeypad2(90),
  UIKeyboardHIDUsageKeypad3(91),
  UIKeyboardHIDUsageKeypad4(92),
  UIKeyboardHIDUsageKeypad5(93),
  UIKeyboardHIDUsageKeypad6(94),
  UIKeyboardHIDUsageKeypad7(95),
  UIKeyboardHIDUsageKeypad8(96),
  UIKeyboardHIDUsageKeypad9(97),
  UIKeyboardHIDUsageKeypad0(98),
  UIKeyboardHIDUsageKeypadPeriod(99),
  UIKeyboardHIDUsageKeyboardNonUSBackslash(100),
  UIKeyboardHIDUsageKeyboardApplication(101),
  UIKeyboardHIDUsageKeyboardPower(102),
  UIKeyboardHIDUsageKeypadEqualSign(103),
  UIKeyboardHIDUsageKeyboardF13(104),
  UIKeyboardHIDUsageKeyboardF14(105),
  UIKeyboardHIDUsageKeyboardF15(106),
  UIKeyboardHIDUsageKeyboardF16(107),
  UIKeyboardHIDUsageKeyboardF17(108),
  UIKeyboardHIDUsageKeyboardF18(109),
  UIKeyboardHIDUsageKeyboardF19(110),
  UIKeyboardHIDUsageKeyboardF20(111),
  UIKeyboardHIDUsageKeyboardF21(112),
  UIKeyboardHIDUsageKeyboardF22(113),
  UIKeyboardHIDUsageKeyboardF23(114),
  UIKeyboardHIDUsageKeyboardF24(115),
  UIKeyboardHIDUsageKeyboardExecute(116),
  UIKeyboardHIDUsageKeyboardHelp(117),
  UIKeyboardHIDUsageKeyboardMenu(118),
  UIKeyboardHIDUsageKeyboardSelect(119),
  UIKeyboardHIDUsageKeyboardStop(120),
  UIKeyboardHIDUsageKeyboardAgain(121),
  UIKeyboardHIDUsageKeyboardUndo(122),
  UIKeyboardHIDUsageKeyboardCut(123),
  UIKeyboardHIDUsageKeyboardCopy(124),
  UIKeyboardHIDUsageKeyboardPaste(125),
  UIKeyboardHIDUsageKeyboardFind(126),
  UIKeyboardHIDUsageKeyboardMute(127),
  UIKeyboardHIDUsageKeyboardVolumeUp(128),
  UIKeyboardHIDUsageKeyboardVolumeDown(129),
  UIKeyboardHIDUsageKeyboardLockingCapsLock(130),
  UIKeyboardHIDUsageKeyboardLockingNumLock(131),
  UIKeyboardHIDUsageKeyboardLockingScrollLock(132),
  UIKeyboardHIDUsageKeypadComma(133),
  UIKeyboardHIDUsageKeypadEqualSignAS400(134),
  UIKeyboardHIDUsageKeyboardInternational1(135),
  UIKeyboardHIDUsageKeyboardInternational2(136),
  UIKeyboardHIDUsageKeyboardInternational3(137),
  UIKeyboardHIDUsageKeyboardInternational4(138),
  UIKeyboardHIDUsageKeyboardInternational5(139),
  UIKeyboardHIDUsageKeyboardInternational6(140),
  UIKeyboardHIDUsageKeyboardInternational7(141),
  UIKeyboardHIDUsageKeyboardInternational8(142),
  UIKeyboardHIDUsageKeyboardInternational9(143),
  UIKeyboardHIDUsageKeyboardLANG1(144),
  UIKeyboardHIDUsageKeyboardLANG2(145),
  UIKeyboardHIDUsageKeyboardLANG3(146),
  UIKeyboardHIDUsageKeyboardLANG4(147),
  UIKeyboardHIDUsageKeyboardLANG5(148),
  UIKeyboardHIDUsageKeyboardLANG6(149),
  UIKeyboardHIDUsageKeyboardLANG7(150),
  UIKeyboardHIDUsageKeyboardLANG8(151),
  UIKeyboardHIDUsageKeyboardLANG9(152),
  UIKeyboardHIDUsageKeyboardAlternateErase(153),
  UIKeyboardHIDUsageKeyboardSysReqOrAttention(154),
  UIKeyboardHIDUsageKeyboardCancel(155),
  UIKeyboardHIDUsageKeyboardClear(156),
  UIKeyboardHIDUsageKeyboardPrior(157),
  UIKeyboardHIDUsageKeyboardReturn(158),
  UIKeyboardHIDUsageKeyboardSeparator(159),
  UIKeyboardHIDUsageKeyboardOut(160),
  UIKeyboardHIDUsageKeyboardOper(161),
  UIKeyboardHIDUsageKeyboardClearOrAgain(162),
  UIKeyboardHIDUsageKeyboardCrSelOrProps(163),
  UIKeyboardHIDUsageKeyboardExSel(164),
  UIKeyboardHIDUsageKeyboardLeftControl(224),
  UIKeyboardHIDUsageKeyboardLeftShift(225),
  UIKeyboardHIDUsageKeyboardLeftAlt(226),
  UIKeyboardHIDUsageKeyboardLeftGUI(227),
  UIKeyboardHIDUsageKeyboardRightControl(228),
  UIKeyboardHIDUsageKeyboardRightShift(229),
  UIKeyboardHIDUsageKeyboardRightAlt(230),
  UIKeyboardHIDUsageKeyboardRightGUI(231),
  UIKeyboardHIDUsageKeyboard_Reserved(65535);

  static const UIKeyboardHIDUsageKeyboardHangul =
      UIKeyboardHIDUsageKeyboardLANG1;
  static const UIKeyboardHIDUsageKeyboardHanja =
      UIKeyboardHIDUsageKeyboardLANG2;
  static const UIKeyboardHIDUsageKeyboardKanaSwitch =
      UIKeyboardHIDUsageKeyboardLANG1;
  static const UIKeyboardHIDUsageKeyboardAlphanumericSwitch =
      UIKeyboardHIDUsageKeyboardLANG2;
  static const UIKeyboardHIDUsageKeyboardKatakana =
      UIKeyboardHIDUsageKeyboardLANG3;
  static const UIKeyboardHIDUsageKeyboardHiragana =
      UIKeyboardHIDUsageKeyboardLANG4;
  static const UIKeyboardHIDUsageKeyboardZenkakuHankakuKanji =
      UIKeyboardHIDUsageKeyboardLANG5;

  final int value;
  const UIKeyboardHIDUsage(this.value);

  static UIKeyboardHIDUsage fromValue(int value) => switch (value) {
        1 => UIKeyboardHIDUsageKeyboardErrorRollOver,
        2 => UIKeyboardHIDUsageKeyboardPOSTFail,
        3 => UIKeyboardHIDUsageKeyboardErrorUndefined,
        4 => UIKeyboardHIDUsageKeyboardA,
        5 => UIKeyboardHIDUsageKeyboardB,
        6 => UIKeyboardHIDUsageKeyboardC,
        7 => UIKeyboardHIDUsageKeyboardD,
        8 => UIKeyboardHIDUsageKeyboardE,
        9 => UIKeyboardHIDUsageKeyboardF,
        10 => UIKeyboardHIDUsageKeyboardG,
        11 => UIKeyboardHIDUsageKeyboardH,
        12 => UIKeyboardHIDUsageKeyboardI,
        13 => UIKeyboardHIDUsageKeyboardJ,
        14 => UIKeyboardHIDUsageKeyboardK,
        15 => UIKeyboardHIDUsageKeyboardL,
        16 => UIKeyboardHIDUsageKeyboardM,
        17 => UIKeyboardHIDUsageKeyboardN,
        18 => UIKeyboardHIDUsageKeyboardO,
        19 => UIKeyboardHIDUsageKeyboardP,
        20 => UIKeyboardHIDUsageKeyboardQ,
        21 => UIKeyboardHIDUsageKeyboardR,
        22 => UIKeyboardHIDUsageKeyboardS,
        23 => UIKeyboardHIDUsageKeyboardT,
        24 => UIKeyboardHIDUsageKeyboardU,
        25 => UIKeyboardHIDUsageKeyboardV,
        26 => UIKeyboardHIDUsageKeyboardW,
        27 => UIKeyboardHIDUsageKeyboardX,
        28 => UIKeyboardHIDUsageKeyboardY,
        29 => UIKeyboardHIDUsageKeyboardZ,
        30 => UIKeyboardHIDUsageKeyboard1,
        31 => UIKeyboardHIDUsageKeyboard2,
        32 => UIKeyboardHIDUsageKeyboard3,
        33 => UIKeyboardHIDUsageKeyboard4,
        34 => UIKeyboardHIDUsageKeyboard5,
        35 => UIKeyboardHIDUsageKeyboard6,
        36 => UIKeyboardHIDUsageKeyboard7,
        37 => UIKeyboardHIDUsageKeyboard8,
        38 => UIKeyboardHIDUsageKeyboard9,
        39 => UIKeyboardHIDUsageKeyboard0,
        40 => UIKeyboardHIDUsageKeyboardReturnOrEnter,
        41 => UIKeyboardHIDUsageKeyboardEscape,
        42 => UIKeyboardHIDUsageKeyboardDeleteOrBackspace,
        43 => UIKeyboardHIDUsageKeyboardTab,
        44 => UIKeyboardHIDUsageKeyboardSpacebar,
        45 => UIKeyboardHIDUsageKeyboardHyphen,
        46 => UIKeyboardHIDUsageKeyboardEqualSign,
        47 => UIKeyboardHIDUsageKeyboardOpenBracket,
        48 => UIKeyboardHIDUsageKeyboardCloseBracket,
        49 => UIKeyboardHIDUsageKeyboardBackslash,
        50 => UIKeyboardHIDUsageKeyboardNonUSPound,
        51 => UIKeyboardHIDUsageKeyboardSemicolon,
        52 => UIKeyboardHIDUsageKeyboardQuote,
        53 => UIKeyboardHIDUsageKeyboardGraveAccentAndTilde,
        54 => UIKeyboardHIDUsageKeyboardComma,
        55 => UIKeyboardHIDUsageKeyboardPeriod,
        56 => UIKeyboardHIDUsageKeyboardSlash,
        57 => UIKeyboardHIDUsageKeyboardCapsLock,
        58 => UIKeyboardHIDUsageKeyboardF1,
        59 => UIKeyboardHIDUsageKeyboardF2,
        60 => UIKeyboardHIDUsageKeyboardF3,
        61 => UIKeyboardHIDUsageKeyboardF4,
        62 => UIKeyboardHIDUsageKeyboardF5,
        63 => UIKeyboardHIDUsageKeyboardF6,
        64 => UIKeyboardHIDUsageKeyboardF7,
        65 => UIKeyboardHIDUsageKeyboardF8,
        66 => UIKeyboardHIDUsageKeyboardF9,
        67 => UIKeyboardHIDUsageKeyboardF10,
        68 => UIKeyboardHIDUsageKeyboardF11,
        69 => UIKeyboardHIDUsageKeyboardF12,
        70 => UIKeyboardHIDUsageKeyboardPrintScreen,
        71 => UIKeyboardHIDUsageKeyboardScrollLock,
        72 => UIKeyboardHIDUsageKeyboardPause,
        73 => UIKeyboardHIDUsageKeyboardInsert,
        74 => UIKeyboardHIDUsageKeyboardHome,
        75 => UIKeyboardHIDUsageKeyboardPageUp,
        76 => UIKeyboardHIDUsageKeyboardDeleteForward,
        77 => UIKeyboardHIDUsageKeyboardEnd,
        78 => UIKeyboardHIDUsageKeyboardPageDown,
        79 => UIKeyboardHIDUsageKeyboardRightArrow,
        80 => UIKeyboardHIDUsageKeyboardLeftArrow,
        81 => UIKeyboardHIDUsageKeyboardDownArrow,
        82 => UIKeyboardHIDUsageKeyboardUpArrow,
        83 => UIKeyboardHIDUsageKeypadNumLock,
        84 => UIKeyboardHIDUsageKeypadSlash,
        85 => UIKeyboardHIDUsageKeypadAsterisk,
        86 => UIKeyboardHIDUsageKeypadHyphen,
        87 => UIKeyboardHIDUsageKeypadPlus,
        88 => UIKeyboardHIDUsageKeypadEnter,
        89 => UIKeyboardHIDUsageKeypad1,
        90 => UIKeyboardHIDUsageKeypad2,
        91 => UIKeyboardHIDUsageKeypad3,
        92 => UIKeyboardHIDUsageKeypad4,
        93 => UIKeyboardHIDUsageKeypad5,
        94 => UIKeyboardHIDUsageKeypad6,
        95 => UIKeyboardHIDUsageKeypad7,
        96 => UIKeyboardHIDUsageKeypad8,
        97 => UIKeyboardHIDUsageKeypad9,
        98 => UIKeyboardHIDUsageKeypad0,
        99 => UIKeyboardHIDUsageKeypadPeriod,
        100 => UIKeyboardHIDUsageKeyboardNonUSBackslash,
        101 => UIKeyboardHIDUsageKeyboardApplication,
        102 => UIKeyboardHIDUsageKeyboardPower,
        103 => UIKeyboardHIDUsageKeypadEqualSign,
        104 => UIKeyboardHIDUsageKeyboardF13,
        105 => UIKeyboardHIDUsageKeyboardF14,
        106 => UIKeyboardHIDUsageKeyboardF15,
        107 => UIKeyboardHIDUsageKeyboardF16,
        108 => UIKeyboardHIDUsageKeyboardF17,
        109 => UIKeyboardHIDUsageKeyboardF18,
        110 => UIKeyboardHIDUsageKeyboardF19,
        111 => UIKeyboardHIDUsageKeyboardF20,
        112 => UIKeyboardHIDUsageKeyboardF21,
        113 => UIKeyboardHIDUsageKeyboardF22,
        114 => UIKeyboardHIDUsageKeyboardF23,
        115 => UIKeyboardHIDUsageKeyboardF24,
        116 => UIKeyboardHIDUsageKeyboardExecute,
        117 => UIKeyboardHIDUsageKeyboardHelp,
        118 => UIKeyboardHIDUsageKeyboardMenu,
        119 => UIKeyboardHIDUsageKeyboardSelect,
        120 => UIKeyboardHIDUsageKeyboardStop,
        121 => UIKeyboardHIDUsageKeyboardAgain,
        122 => UIKeyboardHIDUsageKeyboardUndo,
        123 => UIKeyboardHIDUsageKeyboardCut,
        124 => UIKeyboardHIDUsageKeyboardCopy,
        125 => UIKeyboardHIDUsageKeyboardPaste,
        126 => UIKeyboardHIDUsageKeyboardFind,
        127 => UIKeyboardHIDUsageKeyboardMute,
        128 => UIKeyboardHIDUsageKeyboardVolumeUp,
        129 => UIKeyboardHIDUsageKeyboardVolumeDown,
        130 => UIKeyboardHIDUsageKeyboardLockingCapsLock,
        131 => UIKeyboardHIDUsageKeyboardLockingNumLock,
        132 => UIKeyboardHIDUsageKeyboardLockingScrollLock,
        133 => UIKeyboardHIDUsageKeypadComma,
        134 => UIKeyboardHIDUsageKeypadEqualSignAS400,
        135 => UIKeyboardHIDUsageKeyboardInternational1,
        136 => UIKeyboardHIDUsageKeyboardInternational2,
        137 => UIKeyboardHIDUsageKeyboardInternational3,
        138 => UIKeyboardHIDUsageKeyboardInternational4,
        139 => UIKeyboardHIDUsageKeyboardInternational5,
        140 => UIKeyboardHIDUsageKeyboardInternational6,
        141 => UIKeyboardHIDUsageKeyboardInternational7,
        142 => UIKeyboardHIDUsageKeyboardInternational8,
        143 => UIKeyboardHIDUsageKeyboardInternational9,
        144 => UIKeyboardHIDUsageKeyboardLANG1,
        145 => UIKeyboardHIDUsageKeyboardLANG2,
        146 => UIKeyboardHIDUsageKeyboardLANG3,
        147 => UIKeyboardHIDUsageKeyboardLANG4,
        148 => UIKeyboardHIDUsageKeyboardLANG5,
        149 => UIKeyboardHIDUsageKeyboardLANG6,
        150 => UIKeyboardHIDUsageKeyboardLANG7,
        151 => UIKeyboardHIDUsageKeyboardLANG8,
        152 => UIKeyboardHIDUsageKeyboardLANG9,
        153 => UIKeyboardHIDUsageKeyboardAlternateErase,
        154 => UIKeyboardHIDUsageKeyboardSysReqOrAttention,
        155 => UIKeyboardHIDUsageKeyboardCancel,
        156 => UIKeyboardHIDUsageKeyboardClear,
        157 => UIKeyboardHIDUsageKeyboardPrior,
        158 => UIKeyboardHIDUsageKeyboardReturn,
        159 => UIKeyboardHIDUsageKeyboardSeparator,
        160 => UIKeyboardHIDUsageKeyboardOut,
        161 => UIKeyboardHIDUsageKeyboardOper,
        162 => UIKeyboardHIDUsageKeyboardClearOrAgain,
        163 => UIKeyboardHIDUsageKeyboardCrSelOrProps,
        164 => UIKeyboardHIDUsageKeyboardExSel,
        224 => UIKeyboardHIDUsageKeyboardLeftControl,
        225 => UIKeyboardHIDUsageKeyboardLeftShift,
        226 => UIKeyboardHIDUsageKeyboardLeftAlt,
        227 => UIKeyboardHIDUsageKeyboardLeftGUI,
        228 => UIKeyboardHIDUsageKeyboardRightControl,
        229 => UIKeyboardHIDUsageKeyboardRightShift,
        230 => UIKeyboardHIDUsageKeyboardRightAlt,
        231 => UIKeyboardHIDUsageKeyboardRightGUI,
        65535 => UIKeyboardHIDUsageKeyboard_Reserved,
        _ =>
          throw ArgumentError('Unknown value for UIKeyboardHIDUsage: $value'),
      };

  @override
  String toString() {
    if (this == UIKeyboardHIDUsageKeyboardLANG1)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG1, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardHangul, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardKanaSwitch";
    if (this == UIKeyboardHIDUsageKeyboardLANG2)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG2, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardHanja, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardAlphanumericSwitch";
    if (this == UIKeyboardHIDUsageKeyboardLANG3)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG3, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardKatakana";
    if (this == UIKeyboardHIDUsageKeyboardLANG4)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG4, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardHiragana";
    if (this == UIKeyboardHIDUsageKeyboardLANG5)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG5, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardZenkakuHankakuKanji";
    return super.toString();
  }
}

enum UINavigationItemLargeTitleDisplayMode {
  UINavigationItemLargeTitleDisplayModeAutomatic(0),
  UINavigationItemLargeTitleDisplayModeAlways(1),
  UINavigationItemLargeTitleDisplayModeNever(2),
  UINavigationItemLargeTitleDisplayModeInline(3);

  final int value;
  const UINavigationItemLargeTitleDisplayMode(this.value);

  static UINavigationItemLargeTitleDisplayMode fromValue(int value) =>
      switch (value) {
        0 => UINavigationItemLargeTitleDisplayModeAutomatic,
        1 => UINavigationItemLargeTitleDisplayModeAlways,
        2 => UINavigationItemLargeTitleDisplayModeNever,
        3 => UINavigationItemLargeTitleDisplayModeInline,
        _ => throw ArgumentError(
            'Unknown value for UINavigationItemLargeTitleDisplayMode: $value'),
      };
}

enum UINavigationItemBackButtonDisplayMode {
  UINavigationItemBackButtonDisplayModeDefault(0),
  UINavigationItemBackButtonDisplayModeGeneric(1),
  UINavigationItemBackButtonDisplayModeMinimal(2);

  final int value;
  const UINavigationItemBackButtonDisplayMode(this.value);

  static UINavigationItemBackButtonDisplayMode fromValue(int value) =>
      switch (value) {
        0 => UINavigationItemBackButtonDisplayModeDefault,
        1 => UINavigationItemBackButtonDisplayModeGeneric,
        2 => UINavigationItemBackButtonDisplayModeMinimal,
        _ => throw ArgumentError(
            'Unknown value for UINavigationItemBackButtonDisplayMode: $value'),
      };
}

enum UINavigationItemSearchBarPlacement {
  UINavigationItemSearchBarPlacementAutomatic(0),
  UINavigationItemSearchBarPlacementInline(1),
  UINavigationItemSearchBarPlacementStacked(2);

  final int value;
  const UINavigationItemSearchBarPlacement(this.value);

  static UINavigationItemSearchBarPlacement fromValue(int value) =>
      switch (value) {
        0 => UINavigationItemSearchBarPlacementAutomatic,
        1 => UINavigationItemSearchBarPlacementInline,
        2 => UINavigationItemSearchBarPlacementStacked,
        _ => throw ArgumentError(
            'Unknown value for UINavigationItemSearchBarPlacement: $value'),
      };
}

enum UINavigationItemStyle {
  UINavigationItemStyleNavigator(0),
  UINavigationItemStyleBrowser(1),
  UINavigationItemStyleEditor(2);

  final int value;
  const UINavigationItemStyle(this.value);

  static UINavigationItemStyle fromValue(int value) => switch (value) {
        0 => UINavigationItemStyleNavigator,
        1 => UINavigationItemStyleBrowser,
        2 => UINavigationItemStyleEditor,
        _ => throw ArgumentError(
            'Unknown value for UINavigationItemStyle: $value'),
      };
}

enum UIBlurEffectStyle {
  UIBlurEffectStyleExtraLight(0),
  UIBlurEffectStyleLight(1),
  UIBlurEffectStyleDark(2),
  UIBlurEffectStyleExtraDark(3),
  UIBlurEffectStyleRegular(4),
  UIBlurEffectStyleProminent(5),
  UIBlurEffectStyleSystemUltraThinMaterial(6),
  UIBlurEffectStyleSystemThinMaterial(7),
  UIBlurEffectStyleSystemMaterial(8),
  UIBlurEffectStyleSystemThickMaterial(9),
  UIBlurEffectStyleSystemChromeMaterial(10),
  UIBlurEffectStyleSystemUltraThinMaterialLight(11),
  UIBlurEffectStyleSystemThinMaterialLight(12),
  UIBlurEffectStyleSystemMaterialLight(13),
  UIBlurEffectStyleSystemThickMaterialLight(14),
  UIBlurEffectStyleSystemChromeMaterialLight(15),
  UIBlurEffectStyleSystemUltraThinMaterialDark(16),
  UIBlurEffectStyleSystemThinMaterialDark(17),
  UIBlurEffectStyleSystemMaterialDark(18),
  UIBlurEffectStyleSystemThickMaterialDark(19),
  UIBlurEffectStyleSystemChromeMaterialDark(20);

  final int value;
  const UIBlurEffectStyle(this.value);

  static UIBlurEffectStyle fromValue(int value) => switch (value) {
        0 => UIBlurEffectStyleExtraLight,
        1 => UIBlurEffectStyleLight,
        2 => UIBlurEffectStyleDark,
        3 => UIBlurEffectStyleExtraDark,
        4 => UIBlurEffectStyleRegular,
        5 => UIBlurEffectStyleProminent,
        6 => UIBlurEffectStyleSystemUltraThinMaterial,
        7 => UIBlurEffectStyleSystemThinMaterial,
        8 => UIBlurEffectStyleSystemMaterial,
        9 => UIBlurEffectStyleSystemThickMaterial,
        10 => UIBlurEffectStyleSystemChromeMaterial,
        11 => UIBlurEffectStyleSystemUltraThinMaterialLight,
        12 => UIBlurEffectStyleSystemThinMaterialLight,
        13 => UIBlurEffectStyleSystemMaterialLight,
        14 => UIBlurEffectStyleSystemThickMaterialLight,
        15 => UIBlurEffectStyleSystemChromeMaterialLight,
        16 => UIBlurEffectStyleSystemUltraThinMaterialDark,
        17 => UIBlurEffectStyleSystemThinMaterialDark,
        18 => UIBlurEffectStyleSystemMaterialDark,
        19 => UIBlurEffectStyleSystemThickMaterialDark,
        20 => UIBlurEffectStyleSystemChromeMaterialDark,
        _ => throw ArgumentError('Unknown value for UIBlurEffectStyle: $value'),
      };
}

enum UIGraphicsImageRendererFormatRange {
  UIGraphicsImageRendererFormatRangeUnspecified(-1),
  UIGraphicsImageRendererFormatRangeAutomatic(0),
  UIGraphicsImageRendererFormatRangeExtended(1),
  UIGraphicsImageRendererFormatRangeStandard(2);

  final int value;
  const UIGraphicsImageRendererFormatRange(this.value);

  static UIGraphicsImageRendererFormatRange fromValue(int value) =>
      switch (value) {
        -1 => UIGraphicsImageRendererFormatRangeUnspecified,
        0 => UIGraphicsImageRendererFormatRangeAutomatic,
        1 => UIGraphicsImageRendererFormatRangeExtended,
        2 => UIGraphicsImageRendererFormatRangeStandard,
        _ => throw ArgumentError(
            'Unknown value for UIGraphicsImageRendererFormatRange: $value'),
      };
}

enum UIScrollTypeMask {
  UIScrollTypeMaskDiscrete(1),
  UIScrollTypeMaskContinuous(2),
  UIScrollTypeMaskAll(3);

  final int value;
  const UIScrollTypeMask(this.value);

  static UIScrollTypeMask fromValue(int value) => switch (value) {
        1 => UIScrollTypeMaskDiscrete,
        2 => UIScrollTypeMaskContinuous,
        3 => UIScrollTypeMaskAll,
        _ => throw ArgumentError('Unknown value for UIScrollTypeMask: $value'),
      };
}

enum UINavigationControllerOperation {
  UINavigationControllerOperationNone(0),
  UINavigationControllerOperationPush(1),
  UINavigationControllerOperationPop(2);

  final int value;
  const UINavigationControllerOperation(this.value);

  static UINavigationControllerOperation fromValue(int value) =>
      switch (value) {
        0 => UINavigationControllerOperationNone,
        1 => UINavigationControllerOperationPush,
        2 => UINavigationControllerOperationPop,
        _ => throw ArgumentError(
            'Unknown value for UINavigationControllerOperation: $value'),
      };
}

enum UIInputViewStyle {
  UIInputViewStyleDefault(0),
  UIInputViewStyleKeyboard(1);

  final int value;
  const UIInputViewStyle(this.value);

  static UIInputViewStyle fromValue(int value) => switch (value) {
        0 => UIInputViewStyleDefault,
        1 => UIInputViewStyleKeyboard,
        _ => throw ArgumentError('Unknown value for UIInputViewStyle: $value'),
      };
}

enum UILabelVibrancy {
  UILabelVibrancyNone(0),
  UILabelVibrancyAutomatic(1);

  final int value;
  const UILabelVibrancy(this.value);

  static UILabelVibrancy fromValue(int value) => switch (value) {
        0 => UILabelVibrancyNone,
        1 => UILabelVibrancyAutomatic,
        _ => throw ArgumentError('Unknown value for UILabelVibrancy: $value'),
      };
}

enum UIApplicationShortcutIconType {
  UIApplicationShortcutIconTypeCompose(0),
  UIApplicationShortcutIconTypePlay(1),
  UIApplicationShortcutIconTypePause(2),
  UIApplicationShortcutIconTypeAdd(3),
  UIApplicationShortcutIconTypeLocation(4),
  UIApplicationShortcutIconTypeSearch(5),
  UIApplicationShortcutIconTypeShare(6),
  UIApplicationShortcutIconTypeProhibit(7),
  UIApplicationShortcutIconTypeContact(8),
  UIApplicationShortcutIconTypeHome(9),
  UIApplicationShortcutIconTypeMarkLocation(10),
  UIApplicationShortcutIconTypeFavorite(11),
  UIApplicationShortcutIconTypeLove(12),
  UIApplicationShortcutIconTypeCloud(13),
  UIApplicationShortcutIconTypeInvitation(14),
  UIApplicationShortcutIconTypeConfirmation(15),
  UIApplicationShortcutIconTypeMail(16),
  UIApplicationShortcutIconTypeMessage(17),
  UIApplicationShortcutIconTypeDate(18),
  UIApplicationShortcutIconTypeTime(19),
  UIApplicationShortcutIconTypeCapturePhoto(20),
  UIApplicationShortcutIconTypeCaptureVideo(21),
  UIApplicationShortcutIconTypeTask(22),
  UIApplicationShortcutIconTypeTaskCompleted(23),
  UIApplicationShortcutIconTypeAlarm(24),
  UIApplicationShortcutIconTypeBookmark(25),
  UIApplicationShortcutIconTypeShuffle(26),
  UIApplicationShortcutIconTypeAudio(27),
  UIApplicationShortcutIconTypeUpdate(28);

  final int value;
  const UIApplicationShortcutIconType(this.value);

  static UIApplicationShortcutIconType fromValue(int value) => switch (value) {
        0 => UIApplicationShortcutIconTypeCompose,
        1 => UIApplicationShortcutIconTypePlay,
        2 => UIApplicationShortcutIconTypePause,
        3 => UIApplicationShortcutIconTypeAdd,
        4 => UIApplicationShortcutIconTypeLocation,
        5 => UIApplicationShortcutIconTypeSearch,
        6 => UIApplicationShortcutIconTypeShare,
        7 => UIApplicationShortcutIconTypeProhibit,
        8 => UIApplicationShortcutIconTypeContact,
        9 => UIApplicationShortcutIconTypeHome,
        10 => UIApplicationShortcutIconTypeMarkLocation,
        11 => UIApplicationShortcutIconTypeFavorite,
        12 => UIApplicationShortcutIconTypeLove,
        13 => UIApplicationShortcutIconTypeCloud,
        14 => UIApplicationShortcutIconTypeInvitation,
        15 => UIApplicationShortcutIconTypeConfirmation,
        16 => UIApplicationShortcutIconTypeMail,
        17 => UIApplicationShortcutIconTypeMessage,
        18 => UIApplicationShortcutIconTypeDate,
        19 => UIApplicationShortcutIconTypeTime,
        20 => UIApplicationShortcutIconTypeCapturePhoto,
        21 => UIApplicationShortcutIconTypeCaptureVideo,
        22 => UIApplicationShortcutIconTypeTask,
        23 => UIApplicationShortcutIconTypeTaskCompleted,
        24 => UIApplicationShortcutIconTypeAlarm,
        25 => UIApplicationShortcutIconTypeBookmark,
        26 => UIApplicationShortcutIconTypeShuffle,
        27 => UIApplicationShortcutIconTypeAudio,
        28 => UIApplicationShortcutIconTypeUpdate,
        _ => throw ArgumentError(
            'Unknown value for UIApplicationShortcutIconType: $value'),
      };
}

enum UICornerCurve {
  UICornerCurveAutomatic(0),
  UICornerCurveCircular(1),
  UICornerCurveContinuous(2);

  final int value;
  const UICornerCurve(this.value);

  static UICornerCurve fromValue(int value) => switch (value) {
        0 => UICornerCurveAutomatic,
        1 => UICornerCurveCircular,
        2 => UICornerCurveContinuous,
        _ => throw ArgumentError('Unknown value for UICornerCurve: $value'),
      };
}

/// WARNING: UIShapeProvider is a stub. To generate bindings for this class, include
/// UIShapeProvider in your config's objc-protocols list.
///
/// UIShapeProvider
interface class UIShapeProvider extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  UIShapeProvider._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [UIShapeProvider] that points to the same underlying object as [other].
  UIShapeProvider.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIShapeProvider] that wraps the given raw object pointer.
  UIShapeProvider.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIBehavioralStyle {
  UIBehavioralStyleAutomatic(0),
  UIBehavioralStylePad(1),
  UIBehavioralStyleMac(2);

  final int value;
  const UIBehavioralStyle(this.value);

  static UIBehavioralStyle fromValue(int value) => switch (value) {
        0 => UIBehavioralStyleAutomatic,
        1 => UIBehavioralStylePad,
        2 => UIBehavioralStyleMac,
        _ => throw ArgumentError('Unknown value for UIBehavioralStyle: $value'),
      };
}

enum UINavigationBarNSToolbarSection {
  UINavigationBarNSToolbarSectionNone(0),
  UINavigationBarNSToolbarSectionSidebar(1),
  UINavigationBarNSToolbarSectionSupplementary(2),
  UINavigationBarNSToolbarSectionContent(3);

  final int value;
  const UINavigationBarNSToolbarSection(this.value);

  static UINavigationBarNSToolbarSection fromValue(int value) =>
      switch (value) {
        0 => UINavigationBarNSToolbarSectionNone,
        1 => UINavigationBarNSToolbarSectionSidebar,
        2 => UINavigationBarNSToolbarSectionSupplementary,
        3 => UINavigationBarNSToolbarSectionContent,
        _ => throw ArgumentError(
            'Unknown value for UINavigationBarNSToolbarSection: $value'),
      };
}

enum UIPopoverArrowDirection {
  UIPopoverArrowDirectionUp(1),
  UIPopoverArrowDirectionDown(2),
  UIPopoverArrowDirectionLeft(4),
  UIPopoverArrowDirectionRight(8),
  UIPopoverArrowDirectionAny(15),
  UIPopoverArrowDirectionUnknown(-1);

  final int value;
  const UIPopoverArrowDirection(this.value);

  static UIPopoverArrowDirection fromValue(int value) => switch (value) {
        1 => UIPopoverArrowDirectionUp,
        2 => UIPopoverArrowDirectionDown,
        4 => UIPopoverArrowDirectionLeft,
        8 => UIPopoverArrowDirectionRight,
        15 => UIPopoverArrowDirectionAny,
        -1 => UIPopoverArrowDirectionUnknown,
        _ => throw ArgumentError(
            'Unknown value for UIPopoverArrowDirection: $value'),
      };
}

enum UIPressPhase {
  UIPressPhaseBegan(0),
  UIPressPhaseChanged(1),
  UIPressPhaseStationary(2),
  UIPressPhaseEnded(3),
  UIPressPhaseCancelled(4);

  final int value;
  const UIPressPhase(this.value);

  static UIPressPhase fromValue(int value) => switch (value) {
        0 => UIPressPhaseBegan,
        1 => UIPressPhaseChanged,
        2 => UIPressPhaseStationary,
        3 => UIPressPhaseEnded,
        4 => UIPressPhaseCancelled,
        _ => throw ArgumentError('Unknown value for UIPressPhase: $value'),
      };
}

enum UIPressType {
  UIPressTypeUpArrow(0),
  UIPressTypeDownArrow(1),
  UIPressTypeLeftArrow(2),
  UIPressTypeRightArrow(3),
  UIPressTypeSelect(4),
  UIPressTypeMenu(5),
  UIPressTypePlayPause(6),
  UIPressTypePageUp(30),
  UIPressTypePageDown(31),
  UIPressTypeTVRemoteOneTwoThree(32),
  UIPressTypeTVRemoteFourColors(33);

  final int value;
  const UIPressType(this.value);

  static UIPressType fromValue(int value) => switch (value) {
        0 => UIPressTypeUpArrow,
        1 => UIPressTypeDownArrow,
        2 => UIPressTypeLeftArrow,
        3 => UIPressTypeRightArrow,
        4 => UIPressTypeSelect,
        5 => UIPressTypeMenu,
        6 => UIPressTypePlayPause,
        30 => UIPressTypePageUp,
        31 => UIPressTypePageDown,
        32 => UIPressTypeTVRemoteOneTwoThree,
        33 => UIPressTypeTVRemoteFourColors,
        _ => throw ArgumentError('Unknown value for UIPressType: $value'),
      };
}

enum UIScreenOverscanCompensation {
  UIScreenOverscanCompensationScale(0),
  UIScreenOverscanCompensationInsetBounds(1),
  UIScreenOverscanCompensationNone(2);

  static const UIScreenOverscanCompensationInsetApplicationFrame =
      UIScreenOverscanCompensationNone;

  final int value;
  const UIScreenOverscanCompensation(this.value);

  static UIScreenOverscanCompensation fromValue(int value) => switch (value) {
        0 => UIScreenOverscanCompensationScale,
        1 => UIScreenOverscanCompensationInsetBounds,
        2 => UIScreenOverscanCompensationNone,
        _ => throw ArgumentError(
            'Unknown value for UIScreenOverscanCompensation: $value'),
      };

  @override
  String toString() {
    if (this == UIScreenOverscanCompensationNone)
      return "UIScreenOverscanCompensation.UIScreenOverscanCompensationNone, UIScreenOverscanCompensation.UIScreenOverscanCompensationInsetApplicationFrame";
    return super.toString();
  }
}

enum UIScreenReferenceDisplayModeStatus {
  UIScreenReferenceDisplayModeStatusNotSupported(0),
  UIScreenReferenceDisplayModeStatusNotEnabled(1),
  UIScreenReferenceDisplayModeStatusLimited(2),
  UIScreenReferenceDisplayModeStatusEnabled(3);

  final int value;
  const UIScreenReferenceDisplayModeStatus(this.value);

  static UIScreenReferenceDisplayModeStatus fromValue(int value) =>
      switch (value) {
        0 => UIScreenReferenceDisplayModeStatusNotSupported,
        1 => UIScreenReferenceDisplayModeStatusNotEnabled,
        2 => UIScreenReferenceDisplayModeStatusLimited,
        3 => UIScreenReferenceDisplayModeStatusEnabled,
        _ => throw ArgumentError(
            'Unknown value for UIScreenReferenceDisplayModeStatus: $value'),
      };
}

enum UISearchBarIcon {
  UISearchBarIconSearch(0),
  UISearchBarIconClear(1),
  UISearchBarIconBookmark(2),
  UISearchBarIconResultsList(3);

  final int value;
  const UISearchBarIcon(this.value);

  static UISearchBarIcon fromValue(int value) => switch (value) {
        0 => UISearchBarIconSearch,
        1 => UISearchBarIconClear,
        2 => UISearchBarIconBookmark,
        3 => UISearchBarIconResultsList,
        _ => throw ArgumentError('Unknown value for UISearchBarIcon: $value'),
      };
}

enum UISearchBarStyle {
  UISearchBarStyleDefault(0),
  UISearchBarStyleProminent(1),
  UISearchBarStyleMinimal(2);

  final int value;
  const UISearchBarStyle(this.value);

  static UISearchBarStyle fromValue(int value) => switch (value) {
        0 => UISearchBarStyleDefault,
        1 => UISearchBarStyleProminent,
        2 => UISearchBarStyleMinimal,
        _ => throw ArgumentError('Unknown value for UISearchBarStyle: $value'),
      };
}

enum UITimingCurveType {
  UITimingCurveTypeBuiltin(0),
  UITimingCurveTypeCubic(1),
  UITimingCurveTypeSpring(2),
  UITimingCurveTypeComposed(3);

  final int value;
  const UITimingCurveType(this.value);

  static UITimingCurveType fromValue(int value) => switch (value) {
        0 => UITimingCurveTypeBuiltin,
        1 => UITimingCurveTypeCubic,
        2 => UITimingCurveTypeSpring,
        3 => UITimingCurveTypeComposed,
        _ => throw ArgumentError('Unknown value for UITimingCurveType: $value'),
      };
}

enum UISearchControllerScopeBarActivation {
  UISearchControllerScopeBarActivationAutomatic(0),
  UISearchControllerScopeBarActivationManual(1),
  UISearchControllerScopeBarActivationOnTextEntry(2),
  UISearchControllerScopeBarActivationOnSearchActivation(3);

  final int value;
  const UISearchControllerScopeBarActivation(this.value);

  static UISearchControllerScopeBarActivation fromValue(int value) =>
      switch (value) {
        0 => UISearchControllerScopeBarActivationAutomatic,
        1 => UISearchControllerScopeBarActivationManual,
        2 => UISearchControllerScopeBarActivationOnTextEntry,
        3 => UISearchControllerScopeBarActivationOnSearchActivation,
        _ => throw ArgumentError(
            'Unknown value for UISearchControllerScopeBarActivation: $value'),
      };
}

enum UISplitViewControllerDisplayMode {
  UISplitViewControllerDisplayModeAutomatic(0),
  UISplitViewControllerDisplayModeSecondaryOnly(1),
  UISplitViewControllerDisplayModeOneBesideSecondary(2),
  UISplitViewControllerDisplayModeOneOverSecondary(3),
  UISplitViewControllerDisplayModeTwoBesideSecondary(4),
  UISplitViewControllerDisplayModeTwoOverSecondary(5),
  UISplitViewControllerDisplayModeTwoDisplaceSecondary(6);

  static const UISplitViewControllerDisplayModePrimaryHidden =
      UISplitViewControllerDisplayModeSecondaryOnly;
  static const UISplitViewControllerDisplayModeAllVisible =
      UISplitViewControllerDisplayModeOneBesideSecondary;
  static const UISplitViewControllerDisplayModePrimaryOverlay =
      UISplitViewControllerDisplayModeOneOverSecondary;

  final int value;
  const UISplitViewControllerDisplayMode(this.value);

  static UISplitViewControllerDisplayMode fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerDisplayModeAutomatic,
        1 => UISplitViewControllerDisplayModeSecondaryOnly,
        2 => UISplitViewControllerDisplayModeOneBesideSecondary,
        3 => UISplitViewControllerDisplayModeOneOverSecondary,
        4 => UISplitViewControllerDisplayModeTwoBesideSecondary,
        5 => UISplitViewControllerDisplayModeTwoOverSecondary,
        6 => UISplitViewControllerDisplayModeTwoDisplaceSecondary,
        _ => throw ArgumentError(
            'Unknown value for UISplitViewControllerDisplayMode: $value'),
      };

  @override
  String toString() {
    if (this == UISplitViewControllerDisplayModeSecondaryOnly)
      return "UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModeSecondaryOnly, UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModePrimaryHidden";
    if (this == UISplitViewControllerDisplayModeOneBesideSecondary)
      return "UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModeOneBesideSecondary, UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModeAllVisible";
    if (this == UISplitViewControllerDisplayModeOneOverSecondary)
      return "UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModeOneOverSecondary, UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModePrimaryOverlay";
    return super.toString();
  }
}

enum UISplitViewControllerPrimaryEdge {
  UISplitViewControllerPrimaryEdgeLeading(0),
  UISplitViewControllerPrimaryEdgeTrailing(1);

  final int value;
  const UISplitViewControllerPrimaryEdge(this.value);

  static UISplitViewControllerPrimaryEdge fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerPrimaryEdgeLeading,
        1 => UISplitViewControllerPrimaryEdgeTrailing,
        _ => throw ArgumentError(
            'Unknown value for UISplitViewControllerPrimaryEdge: $value'),
      };
}

enum UISplitViewControllerBackgroundStyle {
  UISplitViewControllerBackgroundStyleNone(0),
  UISplitViewControllerBackgroundStyleSidebar(1);

  final int value;
  const UISplitViewControllerBackgroundStyle(this.value);

  static UISplitViewControllerBackgroundStyle fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerBackgroundStyleNone,
        1 => UISplitViewControllerBackgroundStyleSidebar,
        _ => throw ArgumentError(
            'Unknown value for UISplitViewControllerBackgroundStyle: $value'),
      };
}

enum UISplitViewControllerStyle {
  UISplitViewControllerStyleUnspecified(0),
  UISplitViewControllerStyleDoubleColumn(1),
  UISplitViewControllerStyleTripleColumn(2);

  final int value;
  const UISplitViewControllerStyle(this.value);

  static UISplitViewControllerStyle fromValue(int value) => switch (value) {
        0 => UISplitViewControllerStyleUnspecified,
        1 => UISplitViewControllerStyleDoubleColumn,
        2 => UISplitViewControllerStyleTripleColumn,
        _ => throw ArgumentError(
            'Unknown value for UISplitViewControllerStyle: $value'),
      };
}

enum UISplitViewControllerColumn {
  UISplitViewControllerColumnPrimary(0),
  UISplitViewControllerColumnSupplementary(1),
  UISplitViewControllerColumnSecondary(2),
  UISplitViewControllerColumnCompact(3);

  final int value;
  const UISplitViewControllerColumn(this.value);

  static UISplitViewControllerColumn fromValue(int value) => switch (value) {
        0 => UISplitViewControllerColumnPrimary,
        1 => UISplitViewControllerColumnSupplementary,
        2 => UISplitViewControllerColumnSecondary,
        3 => UISplitViewControllerColumnCompact,
        _ => throw ArgumentError(
            'Unknown value for UISplitViewControllerColumn: $value'),
      };
}

enum UISplitViewControllerSplitBehavior {
  UISplitViewControllerSplitBehaviorAutomatic(0),
  UISplitViewControllerSplitBehaviorTile(1),
  UISplitViewControllerSplitBehaviorOverlay(2),
  UISplitViewControllerSplitBehaviorDisplace(3);

  final int value;
  const UISplitViewControllerSplitBehavior(this.value);

  static UISplitViewControllerSplitBehavior fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerSplitBehaviorAutomatic,
        1 => UISplitViewControllerSplitBehaviorTile,
        2 => UISplitViewControllerSplitBehaviorOverlay,
        3 => UISplitViewControllerSplitBehaviorDisplace,
        _ => throw ArgumentError(
            'Unknown value for UISplitViewControllerSplitBehavior: $value'),
      };
}

enum UISplitViewControllerDisplayModeButtonVisibility {
  UISplitViewControllerDisplayModeButtonVisibilityAutomatic(0),
  UISplitViewControllerDisplayModeButtonVisibilityNever(1),
  UISplitViewControllerDisplayModeButtonVisibilityAlways(2);

  final int value;
  const UISplitViewControllerDisplayModeButtonVisibility(this.value);

  static UISplitViewControllerDisplayModeButtonVisibility fromValue(
          int value) =>
      switch (value) {
        0 => UISplitViewControllerDisplayModeButtonVisibilityAutomatic,
        1 => UISplitViewControllerDisplayModeButtonVisibilityNever,
        2 => UISplitViewControllerDisplayModeButtonVisibilityAlways,
        _ => throw ArgumentError(
            'Unknown value for UISplitViewControllerDisplayModeButtonVisibility: $value'),
      };
}

ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UIViewController_NSCoder_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIViewController_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIViewController_NSCoder_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_UIViewController_NSCoder_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIViewController_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_UIViewController_NSCoder_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>`.
abstract final class ObjCBlock_UIViewController_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCObject> arg0)>>
                  ptr) =>
          objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(
              objc.newPointerBlock(
                  _ObjCBlock_UIViewController_NSCoder_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> fromFunction(
          UIViewController? Function(objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_UIViewController_NSCoder_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) =>
                  fn(objc.NSCoder.castFromPointer(arg0, retain: true, release: true))
                      ?.ref
                      .retainAndAutorelease() ??
                  ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>`.
extension ObjCBlock_UIViewController_NSCoder_CallExtension
    on objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> {
  UIViewController? call(objc.NSCoder arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : UIViewController.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true);
}

enum UITabBarItemPositioning {
  UITabBarItemPositioningAutomatic(0),
  UITabBarItemPositioningFill(1),
  UITabBarItemPositioningCentered(2);

  final int value;
  const UITabBarItemPositioning(this.value);

  static UITabBarItemPositioning fromValue(int value) => switch (value) {
        0 => UITabBarItemPositioningAutomatic,
        1 => UITabBarItemPositioningFill,
        2 => UITabBarItemPositioningCentered,
        _ => throw ArgumentError(
            'Unknown value for UITabBarItemPositioning: $value'),
      };
}

enum UITabBarControllerMode {
  UITabBarControllerModeAutomatic(0),
  UITabBarControllerModeTabBar(1),
  UITabBarControllerModeTabSidebar(2);

  final int value;
  const UITabBarControllerMode(this.value);

  static UITabBarControllerMode fromValue(int value) => switch (value) {
        0 => UITabBarControllerModeAutomatic,
        1 => UITabBarControllerModeTabBar,
        2 => UITabBarControllerModeTabSidebar,
        _ => throw ArgumentError(
            'Unknown value for UITabBarControllerMode: $value'),
      };
}

enum UITabBarSystemItem {
  UITabBarSystemItemMore(0),
  UITabBarSystemItemFavorites(1),
  UITabBarSystemItemFeatured(2),
  UITabBarSystemItemTopRated(3),
  UITabBarSystemItemRecents(4),
  UITabBarSystemItemContacts(5),
  UITabBarSystemItemHistory(6),
  UITabBarSystemItemBookmarks(7),
  UITabBarSystemItemSearch(8),
  UITabBarSystemItemDownloads(9),
  UITabBarSystemItemMostRecent(10),
  UITabBarSystemItemMostViewed(11);

  final int value;
  const UITabBarSystemItem(this.value);

  static UITabBarSystemItem fromValue(int value) => switch (value) {
        0 => UITabBarSystemItemMore,
        1 => UITabBarSystemItemFavorites,
        2 => UITabBarSystemItemFeatured,
        3 => UITabBarSystemItemTopRated,
        4 => UITabBarSystemItemRecents,
        5 => UITabBarSystemItemContacts,
        6 => UITabBarSystemItemHistory,
        7 => UITabBarSystemItemBookmarks,
        8 => UITabBarSystemItemSearch,
        9 => UITabBarSystemItemDownloads,
        10 => UITabBarSystemItemMostRecent,
        11 => UITabBarSystemItemMostViewed,
        _ =>
          throw ArgumentError('Unknown value for UITabBarSystemItem: $value'),
      };
}

late final _class_UITableViewHeaderFooterView =
    objc.getClass("UITableViewHeaderFooterView");
late final _sel_initWithReuseIdentifier_ =
    objc.registerName("initWithReuseIdentifier:");

/// UITableViewHeaderFooterView
class UITableViewHeaderFooterView extends UIView {
  UITableViewHeaderFooterView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView',
        iOS: (false, (6, 0, 0)));
  }

  /// Constructs a [UITableViewHeaderFooterView] that points to the same underlying object as [other].
  UITableViewHeaderFooterView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITableViewHeaderFooterView] that wraps the given raw object pointer.
  UITableViewHeaderFooterView.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UITableViewHeaderFooterView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_UITableViewHeaderFooterView);
  }

  /// initWithReuseIdentifier:
  UITableViewHeaderFooterView initWithReuseIdentifier(
      objc.NSString? reuseIdentifier) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.initWithReuseIdentifier:',
        iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.retainAndReturnPointer(),
        _sel_initWithReuseIdentifier_,
        reuseIdentifier?.ref.pointer ?? ffi.nullptr);
    return UITableViewHeaderFooterView.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithCoder:
  UITableViewHeaderFooterView? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.initWithCoder:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : UITableViewHeaderFooterView.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// configurationState
  UIViewConfigurationState get configurationState {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.configurationState',
        iOS: (false, (14, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_configurationState);
    return UIViewConfigurationState.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setNeedsUpdateConfiguration
  void setNeedsUpdateConfiguration() {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.setNeedsUpdateConfiguration',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateConfiguration);
  }

  /// updateConfigurationUsingState:
  void updateConfigurationUsingState(UIViewConfigurationState state) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.updateConfigurationUsingState:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_updateConfigurationUsingState_,
        state.ref.pointer);
  }

  /// configurationUpdateHandler
  objc.ObjCBlock<
          ffi.Void Function(
              UITableViewHeaderFooterView, UIViewConfigurationState)>?
      get configurationUpdateHandler {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.configurationUpdateHandler',
        iOS: (false, (15, 0, 0)));
    final _ret =
        _objc_msgSend_uwvaik(this.ref.pointer, _sel_configurationUpdateHandler);
    return _ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState
            .castFromPointer(_ret, retain: true, release: true);
  }

  /// setConfigurationUpdateHandler:
  set configurationUpdateHandler(
      objc.ObjCBlock<
              ffi.Void Function(
                  UITableViewHeaderFooterView, UIViewConfigurationState)>?
          value) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.setConfigurationUpdateHandler:',
        iOS: (false, (15, 0, 0)));
    _objc_msgSend_f167m6(this.ref.pointer, _sel_setConfigurationUpdateHandler_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// defaultContentConfiguration
  UIListContentConfiguration defaultContentConfiguration() {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.defaultContentConfiguration',
        iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_defaultContentConfiguration);
    return UIListContentConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// contentConfiguration
  UIContentConfiguration? get contentConfiguration {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.contentConfiguration',
        iOS: (false, (14, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_contentConfiguration);
    return _ret.address == 0
        ? null
        : UIContentConfiguration.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setContentConfiguration:
  set contentConfiguration(UIContentConfiguration? value) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.setContentConfiguration:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setContentConfiguration_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// automaticallyUpdatesContentConfiguration
  bool get automaticallyUpdatesContentConfiguration {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.automaticallyUpdatesContentConfiguration',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_automaticallyUpdatesContentConfiguration);
  }

  /// setAutomaticallyUpdatesContentConfiguration:
  set automaticallyUpdatesContentConfiguration(bool value) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.setAutomaticallyUpdatesContentConfiguration:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setAutomaticallyUpdatesContentConfiguration_, value);
  }

  /// contentView
  UIView get contentView {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.contentView',
        iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_contentView);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// textLabel
  UILabel? get textLabel {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.textLabel',
        iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textLabel);
    return _ret.address == 0
        ? null
        : UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// detailTextLabel
  UILabel? get detailTextLabel {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.detailTextLabel',
        iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_detailTextLabel);
    return _ret.address == 0
        ? null
        : UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// defaultBackgroundConfiguration
  UIBackgroundConfiguration defaultBackgroundConfiguration() {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.defaultBackgroundConfiguration',
        iOS: (false, (16, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_defaultBackgroundConfiguration);
    return UIBackgroundConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// backgroundConfiguration
  UIBackgroundConfiguration? get backgroundConfiguration {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.backgroundConfiguration',
        iOS: (false, (14, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundConfiguration);
    return _ret.address == 0
        ? null
        : UIBackgroundConfiguration.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setBackgroundConfiguration:
  set backgroundConfiguration(UIBackgroundConfiguration? value) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.setBackgroundConfiguration:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundConfiguration_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// automaticallyUpdatesBackgroundConfiguration
  bool get automaticallyUpdatesBackgroundConfiguration {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.automaticallyUpdatesBackgroundConfiguration',
        iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_automaticallyUpdatesBackgroundConfiguration);
  }

  /// setAutomaticallyUpdatesBackgroundConfiguration:
  set automaticallyUpdatesBackgroundConfiguration(bool value) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.setAutomaticallyUpdatesBackgroundConfiguration:',
        iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setAutomaticallyUpdatesBackgroundConfiguration_, value);
  }

  /// backgroundView
  UIView? get backgroundView {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.backgroundView',
        iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundView);
    return _ret.address == 0
        ? null
        : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackgroundView:
  set backgroundView(UIView? value) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.setBackgroundView:',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundView_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// reuseIdentifier
  objc.NSString? get reuseIdentifier {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.reuseIdentifier',
        iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_reuseIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// prepareForReuse
  void prepareForReuse() {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.prepareForReuse',
        iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_prepareForReuse);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.layerClass',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_UITableViewHeaderFooterView, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithFrame:
  UITableViewHeaderFooterView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView.initWithFrame:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UITableViewHeaderFooterView.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute(
          UISemanticContentAttribute attribute) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_racczx(
        _class_UITableViewHeaderFooterView,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
        attribute.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute$1(
          UISemanticContentAttribute semanticContentAttribute$1,
          {required UIUserInterfaceLayoutDirection relativeToLayoutDirection}) {
    objc.checkOsVersionInternal(
        'UITableViewHeaderFooterView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
        iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_tz4p54(
        _class_UITableViewHeaderFooterView,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
        semanticContentAttribute$1.value,
        relativeToLayoutDirection.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }
}

void
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                void Function(ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>`.
abstract final class ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              UITableViewHeaderFooterView, UIViewConfigurationState)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      UITableViewHeaderFooterView, UIViewConfigurationState)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>
      fromFunction(void Function(UITableViewHeaderFooterView, UIViewConfigurationState) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                      UITableViewHeaderFooterView.castFromPointer(arg0, retain: true, release: true),
                      UIViewConfigurationState.castFromPointer(arg1, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          UITableViewHeaderFooterView, UIViewConfigurationState)> listener(
      void Function(UITableViewHeaderFooterView, UIViewConfigurationState) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITableViewHeaderFooterView.castFromPointer(arg0,
                    retain: false, release: true),
                UIViewConfigurationState.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(UITableViewHeaderFooterView,
            UIViewConfigurationState)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          UITableViewHeaderFooterView, UIViewConfigurationState)> blocking(
      void Function(UITableViewHeaderFooterView, UIViewConfigurationState) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITableViewHeaderFooterView.castFromPointer(arg0,
                    retain: false, release: true),
                UIViewConfigurationState.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                UITableViewHeaderFooterView.castFromPointer(arg0,
                    retain: false, release: true),
                UIViewConfigurationState.castFromPointer(arg1,
                    retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(UITableViewHeaderFooterView,
            UIViewConfigurationState)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>`.
extension ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            UITableViewHeaderFooterView, UIViewConfigurationState)> {
  void call(UITableViewHeaderFooterView arg0, UIViewConfigurationState arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

enum UIDropSessionProgressIndicatorStyle {
  UIDropSessionProgressIndicatorStyleNone(0),
  UIDropSessionProgressIndicatorStyleDefault(1);

  final int value;
  const UIDropSessionProgressIndicatorStyle(this.value);

  static UIDropSessionProgressIndicatorStyle fromValue(int value) =>
      switch (value) {
        0 => UIDropSessionProgressIndicatorStyleNone,
        1 => UIDropSessionProgressIndicatorStyleDefault,
        _ => throw ArgumentError(
            'Unknown value for UIDropSessionProgressIndicatorStyle: $value'),
      };
}

enum UISpringLoadedInteractionEffectState {
  UISpringLoadedInteractionEffectStateInactive(0),
  UISpringLoadedInteractionEffectStatePossible(1),
  UISpringLoadedInteractionEffectStateActivating(2),
  UISpringLoadedInteractionEffectStateActivated(3);

  final int value;
  const UISpringLoadedInteractionEffectState(this.value);

  static UISpringLoadedInteractionEffectState fromValue(int value) =>
      switch (value) {
        0 => UISpringLoadedInteractionEffectStateInactive,
        1 => UISpringLoadedInteractionEffectStatePossible,
        2 => UISpringLoadedInteractionEffectStateActivating,
        3 => UISpringLoadedInteractionEffectStateActivated,
        _ => throw ArgumentError(
            'Unknown value for UISpringLoadedInteractionEffectState: $value'),
      };
}

enum UITabBarItemAppearanceStyle {
  UITabBarItemAppearanceStyleStacked(0),
  UITabBarItemAppearanceStyleInline(1),
  UITabBarItemAppearanceStyleCompactInline(2);

  final int value;
  const UITabBarItemAppearanceStyle(this.value);

  static UITabBarItemAppearanceStyle fromValue(int value) => switch (value) {
        0 => UITabBarItemAppearanceStyleStacked,
        1 => UITabBarItemAppearanceStyleInline,
        2 => UITabBarItemAppearanceStyleCompactInline,
        _ => throw ArgumentError(
            'Unknown value for UITabBarItemAppearanceStyle: $value'),
      };
}

/// WARNING: NSLayoutAnchor is a stub. To generate bindings for this class, include
/// NSLayoutAnchor in your config's objc-interfaces list.
///
/// NSLayoutAnchor
class NSLayoutAnchor extends objc.NSObject
    implements objc.NSCopying, objc.NSCoding {
  NSLayoutAnchor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutAnchor',
        iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSLayoutAnchor] that points to the same underlying object as [other].
  NSLayoutAnchor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutAnchor] that wraps the given raw object pointer.
  NSLayoutAnchor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: UITrackingLayoutGuide is a stub. To generate bindings for this class, include
/// UITrackingLayoutGuide in your config's objc-interfaces list.
///
/// UITrackingLayoutGuide
class UITrackingLayoutGuide extends UILayoutGuide {
  UITrackingLayoutGuide._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITrackingLayoutGuide',
        iOS: (false, (15, 0, 0)));
  }

  /// Constructs a [UITrackingLayoutGuide] that points to the same underlying object as [other].
  UITrackingLayoutGuide.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITrackingLayoutGuide] that wraps the given raw object pointer.
  UITrackingLayoutGuide.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum NSTextStorageEditActions {
  NSTextStorageEditedAttributes(1),
  NSTextStorageEditedCharacters(2);

  final int value;
  const NSTextStorageEditActions(this.value);

  static NSTextStorageEditActions fromValue(int value) => switch (value) {
        1 => NSTextStorageEditedAttributes,
        2 => NSTextStorageEditedCharacters,
        _ => throw ArgumentError(
            'Unknown value for NSTextStorageEditActions: $value'),
      };
}

enum NSTextLayoutOrientation {
  NSTextLayoutOrientationHorizontal(0),
  NSTextLayoutOrientationVertical(1);

  final int value;
  const NSTextLayoutOrientation(this.value);

  static NSTextLayoutOrientation fromValue(int value) => switch (value) {
        0 => NSTextLayoutOrientationHorizontal,
        1 => NSTextLayoutOrientationVertical,
        _ => throw ArgumentError(
            'Unknown value for NSTextLayoutOrientation: $value'),
      };
}

enum NSGlyphProperty {
  NSGlyphPropertyNull(1),
  NSGlyphPropertyControlCharacter(2),
  NSGlyphPropertyElastic(4),
  NSGlyphPropertyNonBaseCharacter(8);

  final int value;
  const NSGlyphProperty(this.value);

  static NSGlyphProperty fromValue(int value) => switch (value) {
        1 => NSGlyphPropertyNull,
        2 => NSGlyphPropertyControlCharacter,
        4 => NSGlyphPropertyElastic,
        8 => NSGlyphPropertyNonBaseCharacter,
        _ => throw ArgumentError('Unknown value for NSGlyphProperty: $value'),
      };
}

enum NSControlCharacterAction {
  NSControlCharacterActionZeroAdvancement(1),
  NSControlCharacterActionWhitespace(2),
  NSControlCharacterActionHorizontalTab(4),
  NSControlCharacterActionLineBreak(8),
  NSControlCharacterActionParagraphBreak(16),
  NSControlCharacterActionContainerBreak(32);

  final int value;
  const NSControlCharacterAction(this.value);

  static NSControlCharacterAction fromValue(int value) => switch (value) {
        1 => NSControlCharacterActionZeroAdvancement,
        2 => NSControlCharacterActionWhitespace,
        4 => NSControlCharacterActionHorizontalTab,
        8 => NSControlCharacterActionLineBreak,
        16 => NSControlCharacterActionParagraphBreak,
        32 => NSControlCharacterActionContainerBreak,
        _ => throw ArgumentError(
            'Unknown value for NSControlCharacterAction: $value'),
      };
}

enum UIWindowSceneResizingRestrictions {
  UIWindowSceneResizingRestrictionsUnspecified(0),
  UIWindowSceneResizingRestrictionsNone(1),
  UIWindowSceneResizingRestrictionsUniform(2),
  UIWindowSceneResizingRestrictionsFreeform(3);

  final int value;
  const UIWindowSceneResizingRestrictions(this.value);

  static UIWindowSceneResizingRestrictions fromValue(int value) =>
      switch (value) {
        0 => UIWindowSceneResizingRestrictionsUnspecified,
        1 => UIWindowSceneResizingRestrictionsNone,
        2 => UIWindowSceneResizingRestrictionsUniform,
        3 => UIWindowSceneResizingRestrictionsFreeform,
        _ => throw ArgumentError(
            'Unknown value for UIWindowSceneResizingRestrictions: $value'),
      };
}

enum UITabPlacement {
  UITabPlacementAutomatic(0),
  UITabPlacementDefault(1),
  UITabPlacementOptional(2),
  UITabPlacementMovable(3),
  UITabPlacementPinned(4),
  UITabPlacementFixed(5),
  UITabPlacementSidebarOnly(6);

  final int value;
  const UITabPlacement(this.value);

  static UITabPlacement fromValue(int value) => switch (value) {
        0 => UITabPlacementAutomatic,
        1 => UITabPlacementDefault,
        2 => UITabPlacementOptional,
        3 => UITabPlacementMovable,
        4 => UITabPlacementPinned,
        5 => UITabPlacementFixed,
        6 => UITabPlacementSidebarOnly,
        _ => throw ArgumentError('Unknown value for UITabPlacement: $value'),
      };
}

enum UITabGroupSidebarAppearance {
  UITabGroupSidebarAppearanceAutomatic(0),
  UITabGroupSidebarAppearanceInline(1),
  UITabGroupSidebarAppearanceRootSection(2);

  final int value;
  const UITabGroupSidebarAppearance(this.value);

  static UITabGroupSidebarAppearance fromValue(int value) => switch (value) {
        0 => UITabGroupSidebarAppearanceAutomatic,
        1 => UITabGroupSidebarAppearanceInline,
        2 => UITabGroupSidebarAppearanceRootSection,
        _ => throw ArgumentError(
            'Unknown value for UITabGroupSidebarAppearance: $value'),
      };
}

enum UITabBarControllerSidebarLayout {
  UITabBarControllerSidebarLayoutAutomatic(0),
  UITabBarControllerSidebarLayoutOverlap(1),
  UITabBarControllerSidebarLayoutTile(2);

  final int value;
  const UITabBarControllerSidebarLayout(this.value);

  static UITabBarControllerSidebarLayout fromValue(int value) =>
      switch (value) {
        0 => UITabBarControllerSidebarLayoutAutomatic,
        1 => UITabBarControllerSidebarLayoutOverlap,
        2 => UITabBarControllerSidebarLayoutTile,
        _ => throw ArgumentError(
            'Unknown value for UITabBarControllerSidebarLayout: $value'),
      };
}

/// WARNING: CTAdaptiveImageProviding is a stub. To generate bindings for this class, include
/// CTAdaptiveImageProviding in your config's objc-protocols list.
///
/// CTAdaptiveImageProviding
interface class CTAdaptiveImageProviding extends objc.ObjCProtocolBase {
  CTAdaptiveImageProviding._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CTAdaptiveImageProviding] that points to the same underlying object as [other].
  CTAdaptiveImageProviding.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CTAdaptiveImageProviding] that wraps the given raw object pointer.
  CTAdaptiveImageProviding.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum NSTextSelectionGranularity {
  NSTextSelectionGranularityCharacter(0),
  NSTextSelectionGranularityWord(1),
  NSTextSelectionGranularityParagraph(2),
  NSTextSelectionGranularityLine(3),
  NSTextSelectionGranularitySentence(4);

  final int value;
  const NSTextSelectionGranularity(this.value);

  static NSTextSelectionGranularity fromValue(int value) => switch (value) {
        0 => NSTextSelectionGranularityCharacter,
        1 => NSTextSelectionGranularityWord,
        2 => NSTextSelectionGranularityParagraph,
        3 => NSTextSelectionGranularityLine,
        4 => NSTextSelectionGranularitySentence,
        _ => throw ArgumentError(
            'Unknown value for NSTextSelectionGranularity: $value'),
      };
}

enum NSTextSelectionAffinity {
  NSTextSelectionAffinityUpstream(0),
  NSTextSelectionAffinityDownstream(1);

  final int value;
  const NSTextSelectionAffinity(this.value);

  static NSTextSelectionAffinity fromValue(int value) => switch (value) {
        0 => NSTextSelectionAffinityUpstream,
        1 => NSTextSelectionAffinityDownstream,
        _ => throw ArgumentError(
            'Unknown value for NSTextSelectionAffinity: $value'),
      };
}

enum NSTextSelectionNavigationDirection {
  NSTextSelectionNavigationDirectionForward(0),
  NSTextSelectionNavigationDirectionBackward(1),
  NSTextSelectionNavigationDirectionRight(2),
  NSTextSelectionNavigationDirectionLeft(3),
  NSTextSelectionNavigationDirectionUp(4),
  NSTextSelectionNavigationDirectionDown(5);

  final int value;
  const NSTextSelectionNavigationDirection(this.value);

  static NSTextSelectionNavigationDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationDirectionForward,
        1 => NSTextSelectionNavigationDirectionBackward,
        2 => NSTextSelectionNavigationDirectionRight,
        3 => NSTextSelectionNavigationDirectionLeft,
        4 => NSTextSelectionNavigationDirectionUp,
        5 => NSTextSelectionNavigationDirectionDown,
        _ => throw ArgumentError(
            'Unknown value for NSTextSelectionNavigationDirection: $value'),
      };
}

enum NSTextSelectionNavigationDestination {
  NSTextSelectionNavigationDestinationCharacter(0),
  NSTextSelectionNavigationDestinationWord(1),
  NSTextSelectionNavigationDestinationLine(2),
  NSTextSelectionNavigationDestinationSentence(3),
  NSTextSelectionNavigationDestinationParagraph(4),
  NSTextSelectionNavigationDestinationContainer(5),
  NSTextSelectionNavigationDestinationDocument(6);

  final int value;
  const NSTextSelectionNavigationDestination(this.value);

  static NSTextSelectionNavigationDestination fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationDestinationCharacter,
        1 => NSTextSelectionNavigationDestinationWord,
        2 => NSTextSelectionNavigationDestinationLine,
        3 => NSTextSelectionNavigationDestinationSentence,
        4 => NSTextSelectionNavigationDestinationParagraph,
        5 => NSTextSelectionNavigationDestinationContainer,
        6 => NSTextSelectionNavigationDestinationDocument,
        _ => throw ArgumentError(
            'Unknown value for NSTextSelectionNavigationDestination: $value'),
      };
}

enum NSTextSelectionNavigationModifier {
  NSTextSelectionNavigationModifierExtend(1),
  NSTextSelectionNavigationModifierVisual(2),
  NSTextSelectionNavigationModifierMultiple(4);

  final int value;
  const NSTextSelectionNavigationModifier(this.value);

  static NSTextSelectionNavigationModifier fromValue(int value) =>
      switch (value) {
        1 => NSTextSelectionNavigationModifierExtend,
        2 => NSTextSelectionNavigationModifierVisual,
        4 => NSTextSelectionNavigationModifierMultiple,
        _ => throw ArgumentError(
            'Unknown value for NSTextSelectionNavigationModifier: $value'),
      };
}

enum NSTextSelectionNavigationWritingDirection {
  NSTextSelectionNavigationWritingDirectionLeftToRight(0),
  NSTextSelectionNavigationWritingDirectionRightToLeft(1);

  final int value;
  const NSTextSelectionNavigationWritingDirection(this.value);

  static NSTextSelectionNavigationWritingDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationWritingDirectionLeftToRight,
        1 => NSTextSelectionNavigationWritingDirectionRightToLeft,
        _ => throw ArgumentError(
            'Unknown value for NSTextSelectionNavigationWritingDirection: $value'),
      };
}

enum NSTextSelectionNavigationLayoutOrientation {
  NSTextSelectionNavigationLayoutOrientationHorizontal(0),
  NSTextSelectionNavigationLayoutOrientationVertical(1);

  final int value;
  const NSTextSelectionNavigationLayoutOrientation(this.value);

  static NSTextSelectionNavigationLayoutOrientation fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationLayoutOrientationHorizontal,
        1 => NSTextSelectionNavigationLayoutOrientationVertical,
        _ => throw ArgumentError(
            'Unknown value for NSTextSelectionNavigationLayoutOrientation: $value'),
      };
}

enum NSTextContentManagerEnumerationOptions {
  NSTextContentManagerEnumerationOptionsNone(0),
  NSTextContentManagerEnumerationOptionsReverse(1);

  final int value;
  const NSTextContentManagerEnumerationOptions(this.value);

  static NSTextContentManagerEnumerationOptions fromValue(int value) =>
      switch (value) {
        0 => NSTextContentManagerEnumerationOptionsNone,
        1 => NSTextContentManagerEnumerationOptionsReverse,
        _ => throw ArgumentError(
            'Unknown value for NSTextContentManagerEnumerationOptions: $value'),
      };
}

enum NSTextLayoutFragmentEnumerationOptions {
  NSTextLayoutFragmentEnumerationOptionsNone(0),
  NSTextLayoutFragmentEnumerationOptionsReverse(1),
  NSTextLayoutFragmentEnumerationOptionsEstimatesSize(2),
  NSTextLayoutFragmentEnumerationOptionsEnsuresLayout(4),
  NSTextLayoutFragmentEnumerationOptionsEnsuresExtraLineFragment(8);

  final int value;
  const NSTextLayoutFragmentEnumerationOptions(this.value);

  static NSTextLayoutFragmentEnumerationOptions fromValue(int value) =>
      switch (value) {
        0 => NSTextLayoutFragmentEnumerationOptionsNone,
        1 => NSTextLayoutFragmentEnumerationOptionsReverse,
        2 => NSTextLayoutFragmentEnumerationOptionsEstimatesSize,
        4 => NSTextLayoutFragmentEnumerationOptionsEnsuresLayout,
        8 => NSTextLayoutFragmentEnumerationOptionsEnsuresExtraLineFragment,
        _ => throw ArgumentError(
            'Unknown value for NSTextLayoutFragmentEnumerationOptions: $value'),
      };
}

enum NSTextLayoutFragmentState {
  NSTextLayoutFragmentStateNone(0),
  NSTextLayoutFragmentStateEstimatedUsageBounds(1),
  NSTextLayoutFragmentStateCalculatedUsageBounds(2),
  NSTextLayoutFragmentStateLayoutAvailable(3);

  final int value;
  const NSTextLayoutFragmentState(this.value);

  static NSTextLayoutFragmentState fromValue(int value) => switch (value) {
        0 => NSTextLayoutFragmentStateNone,
        1 => NSTextLayoutFragmentStateEstimatedUsageBounds,
        2 => NSTextLayoutFragmentStateCalculatedUsageBounds,
        3 => NSTextLayoutFragmentStateLayoutAvailable,
        _ => throw ArgumentError(
            'Unknown value for NSTextLayoutFragmentState: $value'),
      };
}

enum NSTextLayoutManagerSegmentType {
  NSTextLayoutManagerSegmentTypeStandard(0),
  NSTextLayoutManagerSegmentTypeSelection(1),
  NSTextLayoutManagerSegmentTypeHighlight(2);

  final int value;
  const NSTextLayoutManagerSegmentType(this.value);

  static NSTextLayoutManagerSegmentType fromValue(int value) => switch (value) {
        0 => NSTextLayoutManagerSegmentTypeStandard,
        1 => NSTextLayoutManagerSegmentTypeSelection,
        2 => NSTextLayoutManagerSegmentTypeHighlight,
        _ => throw ArgumentError(
            'Unknown value for NSTextLayoutManagerSegmentType: $value'),
      };
}

enum NSTextLayoutManagerSegmentOptions {
  NSTextLayoutManagerSegmentOptionsNone(0),
  NSTextLayoutManagerSegmentOptionsRangeNotRequired(1),
  NSTextLayoutManagerSegmentOptionsMiddleFragmentsExcluded(2),
  NSTextLayoutManagerSegmentOptionsHeadSegmentExtended(4),
  NSTextLayoutManagerSegmentOptionsTailSegmentExtended(8),
  NSTextLayoutManagerSegmentOptionsUpstreamAffinity(16);

  final int value;
  const NSTextLayoutManagerSegmentOptions(this.value);

  static NSTextLayoutManagerSegmentOptions fromValue(int value) =>
      switch (value) {
        0 => NSTextLayoutManagerSegmentOptionsNone,
        1 => NSTextLayoutManagerSegmentOptionsRangeNotRequired,
        2 => NSTextLayoutManagerSegmentOptionsMiddleFragmentsExcluded,
        4 => NSTextLayoutManagerSegmentOptionsHeadSegmentExtended,
        8 => NSTextLayoutManagerSegmentOptionsTailSegmentExtended,
        16 => NSTextLayoutManagerSegmentOptionsUpstreamAffinity,
        _ => throw ArgumentError(
            'Unknown value for NSTextLayoutManagerSegmentOptions: $value'),
      };
}

enum UIActivitySectionTypes {
  UIActivitySectionTypesNone(0),
  UIActivitySectionTypesPeopleSuggestions(1);

  final int value;
  const UIActivitySectionTypes(this.value);

  static UIActivitySectionTypes fromValue(int value) => switch (value) {
        0 => UIActivitySectionTypesNone,
        1 => UIActivitySectionTypesPeopleSuggestions,
        _ => throw ArgumentError(
            'Unknown value for UIActivitySectionTypes: $value'),
      };
}

void _ObjCBlock_ffiVoid_UIActivityType_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        bool arg1) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject> arg0, ffi.Bool arg1)>>()
            .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, bool)>()(
        arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIActivityType_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>, ffi.Bool)>(
            _ObjCBlock_ffiVoid_UIActivityType_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIActivityType_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        bool arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>, bool))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIActivityType_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>, ffi.Bool)>(
            _ObjCBlock_ffiVoid_UIActivityType_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIActivityType_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    bool arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, bool))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Bool)> _ObjCBlock_ffiVoid_UIActivityType_bool_listenerCallable = ffi
    .NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Bool)>.listener(
    _ObjCBlock_ffiVoid_UIActivityType_bool_listenerTrampoline)
  ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_UIActivityType_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    bool arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>, bool))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Bool)> _ObjCBlock_ffiVoid_UIActivityType_bool_blockingCallable = ffi
    .NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool)>.isolateLocal(
    _ObjCBlock_ffiVoid_UIActivityType_bool_blockingTrampoline)
  ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Bool)>
    _ObjCBlock_ffiVoid_UIActivityType_bool_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>.listener(
        _ObjCBlock_ffiVoid_UIActivityType_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_UIActivityType_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCObject> arg0, ffi.Bool arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_UIActivityType_bool_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> fromFunction(
          void Function(objc.NSString?, bool) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_UIActivityType_bool_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, bool arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSString.castFromPointer(arg0, retain: true, release: true),
                  arg1),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> listener(
      void Function(objc.NSString?, bool) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIActivityType_bool_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, bool arg1) => fn(
            arg0.address == 0
                ? null
                : objc.NSString.castFromPointer(arg0,
                    retain: false, release: true),
            arg1),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_6p7ndb(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> blocking(
      void Function(objc.NSString?, bool) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIActivityType_bool_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, bool arg1) => fn(
            arg0.address == 0
                ? null
                : objc.NSString.castFromPointer(arg0,
                    retain: false, release: true),
            arg1),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIActivityType_bool_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, bool arg1) => fn(
            arg0.address == 0
                ? null
                : objc.NSString.castFromPointer(arg0,
                    retain: false, release: true),
            arg1),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_6p7ndb(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_UIActivityType_bool_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> {
  void call(objc.NSString? arg0, bool arg1) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0, ffi.Bool arg1)>>()
      .asFunction<
          void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              bool)>()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1);
}

void _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Bool arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<objc.ObjCObject> arg3)>>()
        .asFunction<
            void Function(
                ffi.Pointer<objc.ObjCObject>,
                bool,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Bool,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        bool,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Bool,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>,
      bool,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        bool,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Bool arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> fromFunction(
          void Function(objc.NSString?, bool, objc.NSArray?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, bool arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3) => fn(
                  arg0.address == 0 ? null : objc.NSString.castFromPointer(arg0, retain: true, release: true),
                  arg1,
                  arg2.address == 0 ? null : objc.NSArray.castFromPointer(arg2, retain: true, release: true),
                  arg3.address == 0 ? null : objc.NSError.castFromPointer(arg3, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(
          objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> listener(
      void Function(objc.NSString?, bool, objc.NSArray?, objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                bool arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2.address == 0
                    ? null
                    : objc.NSArray.castFromPointer(arg2,
                        retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_13x5jor(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> blocking(
      void Function(objc.NSString?, bool, objc.NSArray?, objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                bool arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2.address == 0
                    ? null
                    : objc.NSArray.castFromPointer(arg2,
                        retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                bool arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2.address == 0
                    ? null
                    : objc.NSArray.castFromPointer(arg2,
                        retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_13x5jor(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> {
  void call(objc.NSString? arg0, bool arg1, objc.NSArray? arg2,
          objc.NSError? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Bool arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      bool,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0?.ref.pointer ?? ffi.nullptr,
          arg1,
          arg2?.ref.pointer ?? ffi.nullptr,
          arg3?.ref.pointer ?? ffi.nullptr);
}

/// WARNING: UIPrintFormatter$1 is a stub. To generate bindings for this class, include
/// UIPrintFormatter in your config's objc-interfaces list.
///
/// UIPrintFormatter
class UIPrintFormatter$1 extends objc.NSObject implements objc.NSCopying {
  UIPrintFormatter$1._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPrintFormatter', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UIPrintFormatter$1] that points to the same underlying object as [other].
  UIPrintFormatter$1.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPrintFormatter$1] that wraps the given raw object pointer.
  UIPrintFormatter$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

enum UIPrintRenderingQuality {
  UIPrintRenderingQualityBest(0),
  UIPrintRenderingQualityResponsive(1);

  final int value;
  const UIPrintRenderingQuality(this.value);

  static UIPrintRenderingQuality fromValue(int value) => switch (value) {
        0 => UIPrintRenderingQualityBest,
        1 => UIPrintRenderingQualityResponsive,
        _ => throw ArgumentError(
            'Unknown value for UIPrintRenderingQuality: $value'),
      };
}

late final _class_MLNBackendResource = objc.getClass("MLNBackendResource");

/// MLNBackendResource
class MLNBackendResource extends objc.NSObject {
  MLNBackendResource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNBackendResource] that points to the same underlying object as [other].
  MLNBackendResource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNBackendResource] that wraps the given raw object pointer.
  MLNBackendResource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNBackendResource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNBackendResource);
  }

  /// init
  MLNBackendResource init() {
    objc.checkOsVersionInternal('MLNBackendResource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNBackendResource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNBackendResource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNBackendResource, _sel_new);
    return MLNBackendResource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNBackendResource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNBackendResource, _sel_allocWithZone_, zone);
    return MLNBackendResource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNBackendResource alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNBackendResource, _sel_alloc);
    return MLNBackendResource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNBackendResource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNBackendResource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNBackendResource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNBackendResource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNBackendResource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNBackendResource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNBackendResource constructed with the default `new` method.
  factory MLNBackendResource() => new$();
}

/// Options for enabling debugging features in an ``MLNMapView`` instance.
enum MLNMapDebugMaskOptions {
  /// Edges of tile boundaries are shown as thick, red lines to help diagnose
  /// tile clipping issues.
  MLNMapDebugTileBoundariesMask(2),

  /// Each tile shows its tile coordinate (x/y/z) in the upper-left corner.
  MLNMapDebugTileInfoMask(4),

  /// Each tile shows a timestamp indicating when it was loaded.
  MLNMapDebugTimestampsMask(8),

  /// Edges of glyphs and symbols are shown as faint, green lines to help
  /// diagnose collision and label placement issues.
  MLNMapDebugCollisionBoxesMask(16),

  /// Each drawing operation is replaced by a translucent fill. Overlapping
  /// drawing operations appear more prominent to help diagnose overdrawing.
  /// > Note: This option does nothing in Release builds of the SDK.
  MLNMapDebugOverdrawVisualizationMask(32);

  final int value;
  const MLNMapDebugMaskOptions(this.value);

  static MLNMapDebugMaskOptions fromValue(int value) => switch (value) {
        2 => MLNMapDebugTileBoundariesMask,
        4 => MLNMapDebugTileInfoMask,
        8 => MLNMapDebugTimestampsMask,
        16 => MLNMapDebugCollisionBoxesMask,
        32 => MLNMapDebugOverdrawVisualizationMask,
        _ => throw ArgumentError(
            'Unknown value for MLNMapDebugMaskOptions: $value'),
      };
}

/// A structure containing information about a transition.
final class MLNTransition extends ffi.Struct {
  /// The amount of time the animation should take, not including the delay.
  @ffi.Double()
  external double duration;

  /// The amount of time in seconds to wait before beginning the animation.
  @ffi.Double()
  external double delay;
}

/// Constants indicating the visibility of different map ornaments.
enum MLNOrnamentVisibility {
  /// A constant indicating that the ornament adapts to the current map state.
  MLNOrnamentVisibilityAdaptive(0),

  /// A constant indicating that the ornament is always hidden.
  MLNOrnamentVisibilityHidden(1),

  /// A constant indicating that the ornament is always visible.
  MLNOrnamentVisibilityVisible(2);

  final int value;
  const MLNOrnamentVisibility(this.value);

  static MLNOrnamentVisibility fromValue(int value) => switch (value) {
        0 => MLNOrnamentVisibilityAdaptive,
        1 => MLNOrnamentVisibilityHidden,
        2 => MLNOrnamentVisibilityVisible,
        _ => throw ArgumentError(
            'Unknown value for MLNOrnamentVisibility: $value'),
      };
}

late final _class_MLNCompassButton = objc.getClass("MLNCompassButton");
late final _sel_compassVisibility = objc.registerName("compassVisibility");
final _objc_msgSend_1hoz5da = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCompassVisibility_ =
    objc.registerName("setCompassVisibility:");
final _objc_msgSend_1khwzis = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// A specialized view that displays the current compass heading for its associated map.
class MLNCompassButton extends UIImageView {
  MLNCompassButton._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNCompassButton] that points to the same underlying object as [other].
  MLNCompassButton.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNCompassButton] that wraps the given raw object pointer.
  MLNCompassButton.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNCompassButton].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNCompassButton);
  }

  /// The visibility of the compass button.
  ///
  /// You can configure a compass button to be visible all the time or only when the compass heading
  /// changes.
  MLNOrnamentVisibility get compassVisibility {
    final _ret =
        _objc_msgSend_1hoz5da(this.ref.pointer, _sel_compassVisibility);
    return MLNOrnamentVisibility.fromValue(_ret);
  }

  /// The visibility of the compass button.
  ///
  /// You can configure a compass button to be visible all the time or only when the compass heading
  /// changes.
  set compassVisibility(MLNOrnamentVisibility value) {
    _objc_msgSend_1khwzis(
        this.ref.pointer, _sel_setCompassVisibility_, value.value);
  }

  /// initWithImage:
  MLNCompassButton initWithImage(UIImage? image) {
    objc.checkOsVersionInternal('MLNCompassButton.initWithImage:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithImage_, image?.ref.pointer ?? ffi.nullptr);
    return MLNCompassButton.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithImage:highlightedImage:
  MLNCompassButton initWithImage$1(UIImage? image,
      {UIImage? highlightedImage}) {
    objc.checkOsVersionInternal(
        'MLNCompassButton.initWithImage:highlightedImage:',
        iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithImage_highlightedImage_,
        image?.ref.pointer ?? ffi.nullptr,
        highlightedImage?.ref.pointer ?? ffi.nullptr);
    return MLNCompassButton.castFromPointer(_ret, retain: false, release: true);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('MLNCompassButton.layerClass',
        iOS: (false, (2, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_MLNCompassButton, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithFrame:
  MLNCompassButton initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('MLNCompassButton.initWithFrame:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return MLNCompassButton.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  MLNCompassButton? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('MLNCompassButton.initWithCoder:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNCompassButton.castFromPointer(_ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute(
          UISemanticContentAttribute attribute) {
    objc.checkOsVersionInternal(
        'MLNCompassButton.userInterfaceLayoutDirectionForSemanticContentAttribute:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_racczx(
        _class_MLNCompassButton,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
        attribute.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute$1(
          UISemanticContentAttribute semanticContentAttribute$1,
          {required UIUserInterfaceLayoutDirection relativeToLayoutDirection}) {
    objc.checkOsVersionInternal(
        'MLNCompassButton.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
        iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_tz4p54(
        _class_MLNCompassButton,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
        semanticContentAttribute$1.value,
        relativeToLayoutDirection.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }
}

final class CLLocationCoordinate2D extends ffi.Struct {
  @ffi.Double()
  external double latitude;

  @ffi.Double()
  external double longitude;
}

/// A rectangular area as measured on a two-dimensional map projection.
final class MLNCoordinateBounds extends ffi.Struct {
  /// Coordinate at the southwest corner.
  external CLLocationCoordinate2D sw;

  /// Coordinate at the northeast corner.
  external CLLocationCoordinate2D ne;
}

/// A quadrilateral area as measured on a two-dimensional map projection.
/// ``MLNCoordinateQuad`` differs from ``MLNCoordinateQuad`` in that it allows
/// representation of non-axis aligned bounds and non-rectangular quadrilaterals.
/// The coordinates are described in counter clockwise order from top left.
final class MLNCoordinateQuad extends ffi.Struct {
  /// Coordinate at the top left corner.
  external CLLocationCoordinate2D topLeft;

  /// Coordinate at the bottom left corner.
  external CLLocationCoordinate2D bottomLeft;

  /// Coordinate at the bottom right corner.
  external CLLocationCoordinate2D bottomRight;

  /// Coordinate at the top right corner.
  external CLLocationCoordinate2D topRight;
}

late final _class_MLNMapCamera = objc.getClass("MapLibre.MLNMapCamera");
late final _sel_centerCoordinate = objc.registerName("centerCoordinate");
final _objc_msgSend_18o5nok = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CLLocationCoordinate2D Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_18o5nokStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CLLocationCoordinate2D>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCenterCoordinate_ =
    objc.registerName("setCenterCoordinate:");
final _objc_msgSend_1zv0am = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>();
late final _sel_heading = objc.registerName("heading");
late final _sel_setHeading_ = objc.registerName("setHeading:");
late final _sel_pitch = objc.registerName("pitch");
late final _sel_setPitch_ = objc.registerName("setPitch:");
late final _sel_altitude = objc.registerName("altitude");
late final _sel_setAltitude_ = objc.registerName("setAltitude:");
late final _sel_viewingDistance = objc.registerName("viewingDistance");
late final _sel_setViewingDistance_ = objc.registerName("setViewingDistance:");
late final _sel_camera = objc.registerName("camera");
late final _sel_cameraLookingAtCenterCoordinate_fromEyeCoordinate_eyeAltitude_ =
    objc.registerName(
        "cameraLookingAtCenterCoordinate:fromEyeCoordinate:eyeAltitude:");
final _objc_msgSend_2d68z4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                CLLocationCoordinate2D,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            CLLocationCoordinate2D,
            double)>();
late final _sel_cameraLookingAtCenterCoordinate_acrossDistance_pitch_heading_ =
    objc.registerName(
        "cameraLookingAtCenterCoordinate:acrossDistance:pitch:heading:");
final _objc_msgSend_x3m0f9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Double,
                ffi.Double,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            double,
            double,
            double)>();
late final _sel_cameraLookingAtCenterCoordinate_altitude_pitch_heading_ = objc
    .registerName("cameraLookingAtCenterCoordinate:altitude:pitch:heading:");
late final _sel_cameraLookingAtCenterCoordinate_fromDistance_pitch_heading_ =
    objc.registerName(
        "cameraLookingAtCenterCoordinate:fromDistance:pitch:heading:");
late final _sel_isEqualToMapCamera_ = objc.registerName("isEqualToMapCamera:");

/// An ``MLNMapCamera`` object represents a viewpoint from which the user observes
/// some point on an ``MLNMapView``.
///
/// #### Related examples
/// - <doc:BlockingGesturesExample>: learn how to use the
/// ``MLNMapViewDelegate/mapView:shouldChangeFromCamera:toCamera:`` method of ``MLNMapViewDelegate`` to
/// restrict panning.
/// - *TODO:* Camera animation, learn how to create a camera that rotates
/// around a central point.
class MLNMapCamera extends objc.NSObject
    implements objc.NSSecureCoding, objc.NSCopying {
  MLNMapCamera._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMapCamera] that points to the same underlying object as [other].
  MLNMapCamera.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMapCamera] that wraps the given raw object pointer.
  MLNMapCamera.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMapCamera].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapCamera);
  }

  /// Coordinate at the center of the map view.
  CLLocationCoordinate2D get centerCoordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(
            _ptr, this.ref.pointer, _sel_centerCoordinate)
        : _ptr.ref =
            _objc_msgSend_18o5nok(this.ref.pointer, _sel_centerCoordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// Coordinate at the center of the map view.
  set centerCoordinate(CLLocationCoordinate2D value) {
    _objc_msgSend_1zv0am(this.ref.pointer, _sel_setCenterCoordinate_, value);
  }

  /// Heading measured in degrees clockwise from true north.
  double get heading {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_heading)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_heading);
  }

  /// Heading measured in degrees clockwise from true north.
  set heading(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setHeading_, value);
  }

  /// Pitch toward the horizon measured in degrees, with 0 degrees resulting in a
  /// two-dimensional map.
  double get pitch {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_pitch)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_pitch);
  }

  /// Pitch toward the horizon measured in degrees, with 0 degrees resulting in a
  /// two-dimensional map.
  set pitch(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setPitch_, value);
  }

  /// The altitude (measured in meters) above the map at which the camera is
  /// situated.
  ///
  /// The altitude is the distance from the viewpoint to the map, perpendicular to
  /// the map plane. This property does not account for physical elevation.
  ///
  /// This property’s value may be less than that of the ``viewingDistance`` property.
  /// Setting this property automatically updates the ``viewingDistance`` property
  /// based on the ``pitch`` property’s current value.
  double get altitude {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_altitude)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_altitude);
  }

  /// The altitude (measured in meters) above the map at which the camera is
  /// situated.
  ///
  /// The altitude is the distance from the viewpoint to the map, perpendicular to
  /// the map plane. This property does not account for physical elevation.
  ///
  /// This property’s value may be less than that of the ``viewingDistance`` property.
  /// Setting this property automatically updates the ``viewingDistance`` property
  /// based on the ``pitch`` property’s current value.
  set altitude(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setAltitude_, value);
  }

  /// The straight-line distance from the viewpoint to the ``centerCoordinate``.
  ///
  /// Setting this property automatically updates the ``altitude`` property based on
  /// the ``pitch`` property’s current value.
  double get viewingDistance {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_viewingDistance)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_viewingDistance);
  }

  /// The straight-line distance from the viewpoint to the ``centerCoordinate``.
  ///
  /// Setting this property automatically updates the ``altitude`` property based on
  /// the ``pitch`` property’s current value.
  set viewingDistance(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setViewingDistance_, value);
  }

  /// Returns a new camera with all properties set to 0.
  static MLNMapCamera camera() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapCamera, _sel_camera);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new camera based on information about the camera’s viewpoint
  /// and focus point.
  ///
  /// @param centerCoordinate The geographic coordinate on which the map should be
  /// centered.
  /// @param eyeCoordinate The geometric coordinate at which the camera should be
  /// situated.
  /// @param eyeAltitude The altitude (measured in meters) above the map at which the
  /// camera should be situated. The altitude may be less than the distance from
  /// the camera’s viewpoint to the camera’s focus point.
  static MLNMapCamera cameraLookingAtCenterCoordinate(
      CLLocationCoordinate2D centerCoordinate$1,
      {required CLLocationCoordinate2D fromEyeCoordinate,
      required double eyeAltitude}) {
    final _ret = _objc_msgSend_2d68z4(
        _class_MLNMapCamera,
        _sel_cameraLookingAtCenterCoordinate_fromEyeCoordinate_eyeAltitude_,
        centerCoordinate$1,
        fromEyeCoordinate,
        eyeAltitude);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new camera with the given distance, pitch, and heading.
  ///
  /// This method interprets the distance as a straight-line distance from the
  /// viewpoint to the center coordinate. To specify the altitude of the viewpoint,
  /// use the ``cameraLookingAtCenterCoordinate:altitude:pitch:heading:`` method.
  ///
  /// @param centerCoordinate The geographic coordinate on which the map should be
  /// centered.
  /// @param distance The straight-line distance from the viewpoint to the
  /// ``centerCoordinate``.
  /// @param pitch The viewing angle of the camera, measured in degrees. A value of
  /// `0` results in a camera pointed straight down at the map. Angles greater
  /// than `0` result in a camera angled toward the horizon.
  /// @param heading The camera’s heading, measured in degrees clockwise from true
  /// north. A value of `0` means that the top edge of the map view corresponds to
  /// true north. The value `90` means the top of the map is pointing due east.
  /// The value `180` means the top of the map points due south, and so on.
  static MLNMapCamera cameraLookingAtCenterCoordinate$1(
      CLLocationCoordinate2D centerCoordinate$1,
      {required double acrossDistance,
      required double pitch$1,
      required double heading$1}) {
    final _ret = _objc_msgSend_x3m0f9(
        _class_MLNMapCamera,
        _sel_cameraLookingAtCenterCoordinate_acrossDistance_pitch_heading_,
        centerCoordinate$1,
        acrossDistance,
        pitch$1,
        heading$1);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new camera with the given altitude, pitch, and heading.
  ///
  /// @param centerCoordinate The geographic coordinate on which the map should be
  /// centered.
  /// @param altitude The altitude (measured in meters) above the map at which the
  /// camera should be situated. The altitude may be less than the distance from
  /// the camera’s viewpoint to the camera’s focus point.
  /// @param pitch The viewing angle of the camera, measured in degrees. A value of
  /// `0` results in a camera pointed straight down at the map. Angles greater
  /// than `0` result in a camera angled toward the horizon.
  /// @param heading The camera’s heading, measured in degrees clockwise from true
  /// north. A value of `0` means that the top edge of the map view corresponds to
  /// true north. The value `90` means the top of the map is pointing due east.
  /// The value `180` means the top of the map points due south, and so on.
  static MLNMapCamera cameraLookingAtCenterCoordinate$2(
      CLLocationCoordinate2D centerCoordinate$1,
      {required double altitude$1,
      required double pitch$1,
      required double heading$1}) {
    final _ret = _objc_msgSend_x3m0f9(
        _class_MLNMapCamera,
        _sel_cameraLookingAtCenterCoordinate_altitude_pitch_heading_,
        centerCoordinate$1,
        altitude$1,
        pitch$1,
        heading$1);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// > This initializer incorrectly interprets the `distance` parameter. To
  /// specify the straight-line distance from the viewpoint to ``centerCoordinate``,
  /// use the ``cameraLookingAtCenterCoordinate:acrossDistance:pitch:heading:``
  /// method. To specify the altitude of the viewpoint, use the
  /// ``cameraLookingAtCenterCoordinate:altitude:pitch:heading:`` method, which has
  /// the same behavior as this initializer.
  static MLNMapCamera cameraLookingAtCenterCoordinate$3(
      CLLocationCoordinate2D centerCoordinate$1,
      {required double fromDistance,
      required double pitch$1,
      required double heading$1}) {
    final _ret = _objc_msgSend_x3m0f9(
        _class_MLNMapCamera,
        _sel_cameraLookingAtCenterCoordinate_fromDistance_pitch_heading_,
        centerCoordinate$1,
        fromDistance,
        pitch$1,
        heading$1);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a Boolean value indicating whether the given camera is functionally
  /// equivalent to the receiver.
  ///
  /// Unlike `isEqual:`, this method returns `YES` if the difference between the
  /// coordinates, altitudes, pitches, or headings of the two camera objects is
  /// negligible.
  ///
  /// @param otherCamera The camera with which to compare the receiver.
  /// @return A Boolean value indicating whether the two cameras are functionally
  /// equivalent.
  bool isEqualToMapCamera(MLNMapCamera otherCamera) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqualToMapCamera_, otherCamera.ref.pointer);
  }

  /// init
  MLNMapCamera init() {
    objc.checkOsVersionInternal('MLNMapCamera.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMapCamera new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapCamera, _sel_new);
    return MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMapCamera allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNMapCamera, _sel_allocWithZone_, zone);
    return MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMapCamera alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapCamera, _sel_alloc);
    return MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNMapCamera self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNMapCamera retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNMapCamera autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNMapCamera, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  MLNMapCamera? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNMapCamera.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of MLNMapCamera constructed with the default `new` method.
  factory MLNMapCamera() => new$();
}

late final _class_MLNActionJournalOptions =
    objc.getClass("MLNActionJournalOptions");
late final _sel_enabled = objc.registerName("enabled");
late final _sel_path = objc.registerName("path");
late final _sel_setPath_ = objc.registerName("setPath:");
late final _sel_logFileSize = objc.registerName("logFileSize");
late final _sel_setLogFileSize_ = objc.registerName("setLogFileSize:");
late final _sel_logFileCount = objc.registerName("logFileCount");
late final _sel_setLogFileCount_ = objc.registerName("setLogFileCount:");
late final _sel_renderingStatsReportInterval =
    objc.registerName("renderingStatsReportInterval");
late final _sel_setRenderingStatsReportInterval_ =
    objc.registerName("setRenderingStatsReportInterval:");

/// The ``MLNActionJournalOptions`` defines action journal properties such as path, log size, etc...
class MLNActionJournalOptions extends objc.NSObject {
  MLNActionJournalOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNActionJournalOptions] that points to the same underlying object as [other].
  MLNActionJournalOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNActionJournalOptions] that wraps the given raw object pointer.
  MLNActionJournalOptions.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNActionJournalOptions].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNActionJournalOptions);
  }

  /// Enable/disable journal logging
  bool get enabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_enabled);
  }

  /// Enable/disable journal logging
  set enabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// Local file path.
  objc.NSString get path {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_path);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Local file path.
  set path(objc.NSString value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPath_, value.ref.pointer);
  }

  /// Log file size (total journal size is equal to `logFileSize * logFileCount`)
  int get logFileSize {
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_logFileSize);
  }

  /// Log file size (total journal size is equal to `logFileSize * logFileCount`)
  set logFileSize(int value) {
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setLogFileSize_, value);
  }

  /// Maximum number of log files
  int get logFileCount {
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_logFileCount);
  }

  /// Maximum number of log files
  set logFileCount(int value) {
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setLogFileCount_, value);
  }

  /// The wait time (seconds) between rendering reports
  int get renderingStatsReportInterval {
    return _objc_msgSend_1hz7y9r(
        this.ref.pointer, _sel_renderingStatsReportInterval);
  }

  /// The wait time (seconds) between rendering reports
  set renderingStatsReportInterval(int value) {
    _objc_msgSend_4sp4xj(
        this.ref.pointer, _sel_setRenderingStatsReportInterval_, value);
  }

  /// init
  MLNActionJournalOptions init() {
    objc.checkOsVersionInternal('MLNActionJournalOptions.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNActionJournalOptions.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNActionJournalOptions new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNActionJournalOptions, _sel_new);
    return MLNActionJournalOptions.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNActionJournalOptions allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNActionJournalOptions, _sel_allocWithZone_, zone);
    return MLNActionJournalOptions.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNActionJournalOptions alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNActionJournalOptions, _sel_alloc);
    return MLNActionJournalOptions.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNActionJournalOptions self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNActionJournalOptions.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNActionJournalOptions retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNActionJournalOptions.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNActionJournalOptions autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNActionJournalOptions.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNActionJournalOptions constructed with the default `new` method.
  factory MLNActionJournalOptions() => new$();
}

late final _class_MLNMapOptions = objc.getClass("MLNMapOptions");
late final _sel_styleURL = objc.registerName("styleURL");
late final _sel_setStyleURL_ = objc.registerName("setStyleURL:");
late final _sel_styleJSON = objc.registerName("styleJSON");
late final _sel_setStyleJSON_ = objc.registerName("setStyleJSON:");
late final _sel_actionJournalOptions =
    objc.registerName("actionJournalOptions");
late final _sel_setActionJournalOptions_ =
    objc.registerName("setActionJournalOptions:");
late final _sel_pluginLayers = objc.registerName("pluginLayers");
late final _sel_setPluginLayers_ = objc.registerName("setPluginLayers:");

/// The ``MLNMapOptions`` object provides a way to set map properties for each instance
class MLNMapOptions extends objc.NSObject {
  MLNMapOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMapOptions] that points to the same underlying object as [other].
  MLNMapOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMapOptions] that wraps the given raw object pointer.
  MLNMapOptions.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMapOptions].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapOptions);
  }

  /// URL of the map style to display. The URL may be a full HTTP
  /// or HTTPS URL, a canonical URL or a path to a local file relative
  /// to the application’s resource path. Specify `nil` for the default style.
  objc.NSURL? get styleURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_styleURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL of the map style to display. The URL may be a full HTTP
  /// or HTTPS URL, a canonical URL or a path to a local file relative
  /// to the application’s resource path. Specify `nil` for the default style.
  set styleURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setStyleURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// JSON string of the map style to display. The JSON must conform to the
  /// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
  /// Specify `nil` for the default style.
  /// Ignored if `styleURL` is set to a non-nil value.
  objc.NSString? get styleJSON {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_styleJSON);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// JSON string of the map style to display. The JSON must conform to the
  /// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
  /// Specify `nil` for the default style.
  /// Ignored if `styleURL` is set to a non-nil value.
  set styleJSON(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setStyleJSON_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// Action journal  options
  MLNActionJournalOptions get actionJournalOptions {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_actionJournalOptions);
    return MLNActionJournalOptions.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Action journal  options
  set actionJournalOptions(MLNActionJournalOptions value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setActionJournalOptions_, value.ref.pointer);
  }

  /// List of plugin classes
  objc.NSArray get pluginLayers {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pluginLayers);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// List of plugin classes
  set pluginLayers(objc.NSArray value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setPluginLayers_, value.ref.pointer);
  }

  /// init
  MLNMapOptions init() {
    objc.checkOsVersionInternal('MLNMapOptions.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapOptions.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMapOptions new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapOptions, _sel_new);
    return MLNMapOptions.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMapOptions allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNMapOptions, _sel_allocWithZone_, zone);
    return MLNMapOptions.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMapOptions alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapOptions, _sel_alloc);
    return MLNMapOptions.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNMapOptions self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNMapOptions.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNMapOptions retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNMapOptions.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNMapOptions autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNMapOptions.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNMapOptions constructed with the default `new` method.
  factory MLNMapOptions() => new$();
}

late final _class_MLNStyleLayer = objc.getClass("MLNStyleLayer");
late final _sel_isVisible = objc.registerName("isVisible");
late final _sel_setVisible_ = objc.registerName("setVisible:");
late final _sel_maximumZoomLevel = objc.registerName("maximumZoomLevel");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setMaximumZoomLevel_ =
    objc.registerName("setMaximumZoomLevel:");
late final _sel_minimumZoomLevel = objc.registerName("minimumZoomLevel");
late final _sel_setMinimumZoomLevel_ =
    objc.registerName("setMinimumZoomLevel:");

/// ``MLNStyleLayer`` is an abstract base class for style layers. A style layer
/// manages the layout and appearance of content at a specific z-index in a style.
/// An ``MLNStyle`` object consists of one or more ``MLNStyle`` objects.
///
/// Each style layer defined by the style JSON file is represented at runtime by an
/// ``MLNStyleLayer`` object, which you can use to refine the map’s appearance. You
/// can also add and remove style layers dynamically.
///
/// Create instances of ``MLNBackgroundStyleLayer`` and the concrete subclasses of
/// ``MLNForegroundStyleLayer`` in order to use ``MLNForegroundStyleLayer``'s properties and methods.
/// You do not create instances of ``MLNStyleLayer`` directly, and do not
/// create your own subclasses of this class.
///
/// Do not add ``MLNStyleLayer`` objects to the `style` property of a ``MLNStyleLayer`` before
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` is called.
class MLNStyleLayer extends objc.NSObject {
  MLNStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNStyleLayer] that points to the same underlying object as [other].
  MLNStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNStyleLayer] that wraps the given raw object pointer.
  MLNStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNStyleLayer);
  }

  /// init
  MLNStyleLayer init() {
    objc.checkOsVersionInternal('MLNStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNStyleLayer.castFromPointer(_ret, retain: false, release: true);
  }

  /// A string that uniquely identifies the style layer in the style to which it is
  /// added.
  objc.NSString get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Whether this layer is displayed. A value of `NO` hides the layer.
  ///
  /// #### Related examples
  /// TODO: Show and hide a layer, learn how to toggle an ``MLNStyleLayer``
  /// object's visibility.
  bool get visible {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isVisible);
  }

  /// Whether this layer is displayed. A value of `NO` hides the layer.
  ///
  /// #### Related examples
  /// TODO: Show and hide a layer, learn how to toggle an ``MLNStyleLayer``
  /// object's visibility.
  set visible(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setVisible_, value);
  }

  /// The maximum zoom level at which the layer gets parsed and appears. This value is a floating-point
  /// number.
  double get maximumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(this.ref.pointer, _sel_maximumZoomLevel)
        : _objc_msgSend_2cgrxl(this.ref.pointer, _sel_maximumZoomLevel);
  }

  /// The maximum zoom level at which the layer gets parsed and appears. This value is a floating-point
  /// number.
  set maximumZoomLevel(double value) {
    _objc_msgSend_v5hmet(this.ref.pointer, _sel_setMaximumZoomLevel_, value);
  }

  /// The minimum zoom level at which the layer gets parsed and appears. This value is a floating-point
  /// number.
  double get minimumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(this.ref.pointer, _sel_minimumZoomLevel)
        : _objc_msgSend_2cgrxl(this.ref.pointer, _sel_minimumZoomLevel);
  }

  /// The minimum zoom level at which the layer gets parsed and appears. This value is a floating-point
  /// number.
  set minimumZoomLevel(double value) {
    _objc_msgSend_v5hmet(this.ref.pointer, _sel_setMinimumZoomLevel_, value);
  }

  /// new
  static MLNStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNStyleLayer, _sel_new);
    return MLNStyleLayer.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNStyleLayer, _sel_allocWithZone_, zone);
    return MLNStyleLayer.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNStyleLayer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNStyleLayer, _sel_alloc);
    return MLNStyleLayer.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNStyleLayer constructed with the default `new` method.
  factory MLNStyleLayer() => new$();
}

late final _class_MLNDefaultStyle = objc.getClass("MLNDefaultStyle");
late final _sel_url = objc.registerName("url");
late final _sel_setUrl_ = objc.registerName("setUrl:");
late final _sel_name = objc.registerName("name");
late final _sel_setName_ = objc.registerName("setName:");
late final _sel_version = objc.registerName("version");
final _objc_msgSend_13yqbb6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setVersion_ = objc.registerName("setVersion:");
final _objc_msgSend_9o8504 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// The ``MLNDefaultStyle`` defines the predefined vendor style
class MLNDefaultStyle extends objc.NSObject {
  MLNDefaultStyle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNDefaultStyle] that points to the same underlying object as [other].
  MLNDefaultStyle.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNDefaultStyle] that wraps the given raw object pointer.
  MLNDefaultStyle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNDefaultStyle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNDefaultStyle);
  }

  /// The style URL
  objc.NSURL get url {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_url);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// The style URL
  set url(objc.NSURL value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setUrl_, value.ref.pointer);
  }

  /// The style name
  objc.NSString get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The style name
  set name(objc.NSString value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setName_, value.ref.pointer);
  }

  /// The style version
  int get version {
    return _objc_msgSend_13yqbb6(this.ref.pointer, _sel_version);
  }

  /// The style version
  set version(int value) {
    _objc_msgSend_9o8504(this.ref.pointer, _sel_setVersion_, value);
  }

  /// init
  MLNDefaultStyle init() {
    objc.checkOsVersionInternal('MLNDefaultStyle.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNDefaultStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNDefaultStyle new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNDefaultStyle, _sel_new);
    return MLNDefaultStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNDefaultStyle allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNDefaultStyle, _sel_allocWithZone_, zone);
    return MLNDefaultStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNDefaultStyle alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNDefaultStyle, _sel_alloc);
    return MLNDefaultStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNDefaultStyle self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNDefaultStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNDefaultStyle retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNDefaultStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNDefaultStyle autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNDefaultStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNDefaultStyle constructed with the default `new` method.
  factory MLNDefaultStyle() => new$();
}

late final _class_MLNTileServerOptions = objc.getClass("MLNTileServerOptions");
late final _sel_baseURL = objc.registerName("baseURL");
late final _sel_setBaseURL_ = objc.registerName("setBaseURL:");
late final _sel_uriSchemeAlias = objc.registerName("uriSchemeAlias");
late final _sel_setUriSchemeAlias_ = objc.registerName("setUriSchemeAlias:");
late final _sel_sourceTemplate = objc.registerName("sourceTemplate");
late final _sel_setSourceTemplate_ = objc.registerName("setSourceTemplate:");
late final _sel_sourceDomainName = objc.registerName("sourceDomainName");
late final _sel_setSourceDomainName_ =
    objc.registerName("setSourceDomainName:");
late final _sel_sourceVersionPrefix = objc.registerName("sourceVersionPrefix");
late final _sel_setSourceVersionPrefix_ =
    objc.registerName("setSourceVersionPrefix:");
late final _sel_styleTemplate = objc.registerName("styleTemplate");
late final _sel_setStyleTemplate_ = objc.registerName("setStyleTemplate:");
late final _sel_styleDomainName = objc.registerName("styleDomainName");
late final _sel_setStyleDomainName_ = objc.registerName("setStyleDomainName:");
late final _sel_styleVersionPrefix = objc.registerName("styleVersionPrefix");
late final _sel_setStyleVersionPrefix_ =
    objc.registerName("setStyleVersionPrefix:");
late final _sel_spritesTemplate = objc.registerName("spritesTemplate");
late final _sel_setSpritesTemplate_ = objc.registerName("setSpritesTemplate:");
late final _sel_spritesDomainName = objc.registerName("spritesDomainName");
late final _sel_setSpritesDomainName_ =
    objc.registerName("setSpritesDomainName:");
late final _sel_spritesVersionPrefix =
    objc.registerName("spritesVersionPrefix");
late final _sel_setSpritesVersionPrefix_ =
    objc.registerName("setSpritesVersionPrefix:");
late final _sel_glyphsTemplate = objc.registerName("glyphsTemplate");
late final _sel_setGlyphsTemplate_ = objc.registerName("setGlyphsTemplate:");
late final _sel_glyphsDomainName = objc.registerName("glyphsDomainName");
late final _sel_setGlyphsDomainName_ =
    objc.registerName("setGlyphsDomainName:");
late final _sel_glyphsVersionPrefix = objc.registerName("glyphsVersionPrefix");
late final _sel_setGlyphsVersionPrefix_ =
    objc.registerName("setGlyphsVersionPrefix:");
late final _sel_tileTemplate = objc.registerName("tileTemplate");
late final _sel_setTileTemplate_ = objc.registerName("setTileTemplate:");
late final _sel_tileDomainName = objc.registerName("tileDomainName");
late final _sel_setTileDomainName_ = objc.registerName("setTileDomainName:");
late final _sel_tileVersionPrefix = objc.registerName("tileVersionPrefix");
late final _sel_setTileVersionPrefix_ =
    objc.registerName("setTileVersionPrefix:");
late final _sel_apiKeyParameterName = objc.registerName("apiKeyParameterName");
late final _sel_setApiKeyParameterName_ =
    objc.registerName("setApiKeyParameterName:");
late final _sel_defaultStyles = objc.registerName("defaultStyles");
late final _sel_setDefaultStyles_ = objc.registerName("setDefaultStyles:");
late final _sel_defaultStyle = objc.registerName("defaultStyle");
late final _sel_setDefaultStyle_ = objc.registerName("setDefaultStyle:");

/// The ``MLNTileServerOptions`` defines server properties such as URL etc...
class MLNTileServerOptions extends objc.NSObject {
  MLNTileServerOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNTileServerOptions] that points to the same underlying object as [other].
  MLNTileServerOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNTileServerOptions] that wraps the given raw object pointer.
  MLNTileServerOptions.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNTileServerOptions].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNTileServerOptions);
  }

  /// API base URL.
  objc.NSString get baseURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_baseURL);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// API base URL.
  set baseURL(objc.NSString value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBaseURL_, value.ref.pointer);
  }

  /// Tile server URI alias.
  objc.NSString get uriSchemeAlias {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_uriSchemeAlias);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Tile server URI alias.
  set uriSchemeAlias(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setUriSchemeAlias_, value.ref.pointer);
  }

  /// URL template for sources.
  objc.NSString get sourceTemplate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sourceTemplate);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL template for sources.
  set sourceTemplate(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSourceTemplate_, value.ref.pointer);
  }

  /// source domain name.
  objc.NSString get sourceDomainName {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sourceDomainName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// source domain name.
  set sourceDomainName(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSourceDomainName_, value.ref.pointer);
  }

  /// source version prefix
  objc.NSString? get sourceVersionPrefix {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_sourceVersionPrefix);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// source version prefix
  set sourceVersionPrefix(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSourceVersionPrefix_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// URL template for style.
  objc.NSString get styleTemplate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_styleTemplate);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL template for style.
  set styleTemplate(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setStyleTemplate_, value.ref.pointer);
  }

  /// style domain name.
  objc.NSString get styleDomainName {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_styleDomainName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// style domain name.
  set styleDomainName(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setStyleDomainName_, value.ref.pointer);
  }

  /// style version prefix
  objc.NSString? get styleVersionPrefix {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_styleVersionPrefix);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// style version prefix
  set styleVersionPrefix(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setStyleVersionPrefix_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// URL template for sprites.
  objc.NSString get spritesTemplate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_spritesTemplate);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL template for sprites.
  set spritesTemplate(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSpritesTemplate_, value.ref.pointer);
  }

  /// sprites domain name.
  objc.NSString get spritesDomainName {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_spritesDomainName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// sprites domain name.
  set spritesDomainName(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSpritesDomainName_, value.ref.pointer);
  }

  /// version prefix
  objc.NSString? get spritesVersionPrefix {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_spritesVersionPrefix);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// version prefix
  set spritesVersionPrefix(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSpritesVersionPrefix_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// URL template for glyphs.
  objc.NSString get glyphsTemplate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_glyphsTemplate);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL template for glyphs.
  set glyphsTemplate(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setGlyphsTemplate_, value.ref.pointer);
  }

  /// glyphs domain name.
  objc.NSString get glyphsDomainName {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_glyphsDomainName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// glyphs domain name.
  set glyphsDomainName(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setGlyphsDomainName_, value.ref.pointer);
  }

  /// Glyphs version prefix
  objc.NSString? get glyphsVersionPrefix {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_glyphsVersionPrefix);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Glyphs version prefix
  set glyphsVersionPrefix(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setGlyphsVersionPrefix_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// URL template for tiles.
  objc.NSString get tileTemplate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tileTemplate);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL template for tiles.
  set tileTemplate(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTileTemplate_, value.ref.pointer);
  }

  /// tile domain name.
  objc.NSString get tileDomainName {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tileDomainName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// tile domain name.
  set tileDomainName(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTileDomainName_, value.ref.pointer);
  }

  /// tile version prefix
  objc.NSString? get tileVersionPrefix {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_tileVersionPrefix);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// tile version prefix
  set tileVersionPrefix(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTileVersionPrefix_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// API key parameter name.
  objc.NSString get apiKeyParameterName {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_apiKeyParameterName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// API key parameter name.
  set apiKeyParameterName(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setApiKeyParameterName_, value.ref.pointer);
  }

  /// Default styles.
  objc.NSArray get defaultStyles {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_defaultStyles);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Default styles.
  set defaultStyles(objc.NSArray value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDefaultStyles_, value.ref.pointer);
  }

  /// Default style
  MLNDefaultStyle get defaultStyle {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_defaultStyle);
    return MLNDefaultStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// Default style
  set defaultStyle(MLNDefaultStyle value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDefaultStyle_, value.ref.pointer);
  }

  /// init
  MLNTileServerOptions init() {
    objc.checkOsVersionInternal('MLNTileServerOptions.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNTileServerOptions.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNTileServerOptions new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNTileServerOptions, _sel_new);
    return MLNTileServerOptions.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNTileServerOptions allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNTileServerOptions, _sel_allocWithZone_, zone);
    return MLNTileServerOptions.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNTileServerOptions alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNTileServerOptions, _sel_alloc);
    return MLNTileServerOptions.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNTileServerOptions self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNTileServerOptions.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNTileServerOptions retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNTileServerOptions.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNTileServerOptions autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNTileServerOptions.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNTileServerOptions constructed with the default `new` method.
  factory MLNTileServerOptions() => new$();
}

/// Well-known tile servers
enum MLNWellKnownTileServer {
  /// Maptiler
  MLNMapTiler(0),

  /// MapLibre
  MLNMapLibre(1),

  /// Mapbox
  MLNMapbox(2);

  final int value;
  const MLNWellKnownTileServer(this.value);

  static MLNWellKnownTileServer fromValue(int value) => switch (value) {
        0 => MLNMapTiler,
        1 => MLNMapLibre,
        2 => MLNMapbox,
        _ => throw ArgumentError(
            'Unknown value for MLNWellKnownTileServer: $value'),
      };
}

late final _class_MLNSettings = objc.getClass("MLNSettings");
late final _sel_tileServerOptions = objc.registerName("tileServerOptions");
late final _sel_setTileServerOptions_ =
    objc.registerName("setTileServerOptions:");
late final _sel_apiKey = objc.registerName("apiKey");
late final _sel_setApiKey_ = objc.registerName("setApiKey:");
late final _sel_useWellKnownTileServer_ =
    objc.registerName("useWellKnownTileServer:");
final _objc_msgSend_1vrforg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// The ``MLNSettings`` object provides a global way to set SDK properties such
/// as apiKey, backend URL, etc.
class MLNSettings extends objc.NSObject {
  MLNSettings._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNSettings] that points to the same underlying object as [other].
  MLNSettings.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNSettings] that wraps the given raw object pointer.
  MLNSettings.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNSettings].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNSettings);
  }

  /// Tile server options
  static MLNTileServerOptions? getTileServerOptions() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNSettings, _sel_tileServerOptions);
    return _ret.address == 0
        ? null
        : MLNTileServerOptions.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// Tile server options
  static void setTileServerOptions(MLNTileServerOptions? value) {
    _objc_msgSend_xtuoz7(_class_MLNSettings, _sel_setTileServerOptions_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// The API Key used by all instances of ``MLNMapView`` in the current application.
  /// Setting this property to a value of `nil` has no effect.
  ///
  /// > Note: You must set the API key before attempting to load any style which
  /// requires the token. Therefore, you should generally set it before creating an instance of
  /// ``MLNMapView``. The recommended way to set an api key is to add an entry
  /// to your application’s Info.plist file with the key `MLNApiKey``
  /// and the type `String`. Alternatively, you may call this method from your
  /// application delegate’s `-applicationDidFinishLaunching:` method.
  static objc.NSString? getApiKey() {
    final _ret = _objc_msgSend_151sglz(_class_MLNSettings, _sel_apiKey);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The API Key used by all instances of ``MLNMapView`` in the current application.
  /// Setting this property to a value of `nil` has no effect.
  ///
  /// > Note: You must set the API key before attempting to load any style which
  /// requires the token. Therefore, you should generally set it before creating an instance of
  /// ``MLNMapView``. The recommended way to set an api key is to add an entry
  /// to your application’s Info.plist file with the key `MLNApiKey``
  /// and the type `String`. Alternatively, you may call this method from your
  /// application delegate’s `-applicationDidFinishLaunching:` method.
  static void setApiKey(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        _class_MLNSettings, _sel_setApiKey_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Instructs the SDk to use the give tile server
  static void useWellKnownTileServer(MLNWellKnownTileServer tileServer) {
    _objc_msgSend_1vrforg(
        _class_MLNSettings, _sel_useWellKnownTileServer_, tileServer.value);
  }

  /// init
  MLNSettings init() {
    objc.checkOsVersionInternal('MLNSettings.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNSettings.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNSettings new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNSettings, _sel_new);
    return MLNSettings.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNSettings allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNSettings, _sel_allocWithZone_, zone);
    return MLNSettings.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNSettings alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNSettings, _sel_alloc);
    return MLNSettings.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNSettings self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNSettings.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNSettings retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNSettings.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNSettings autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNSettings.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNSettings constructed with the default `new` method.
  factory MLNSettings() => new$();
}

late final _class_MLNStyle = objc.getClass("MLNStyle");
late final _sel_predefinedStyles = objc.registerName("predefinedStyles");
late final _sel_defaultStyleURL = objc.registerName("defaultStyleURL");
late final _sel_predefinedStyle_ = objc.registerName("predefinedStyle:");
late final _sel_sources = objc.registerName("sources");
late final _sel_setSources_ = objc.registerName("setSources:");
late final _sel_transition = objc.registerName("transition");
final _objc_msgSend_1i0p3hy = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNTransition Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        MLNTransition Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1i0p3hyStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNTransition>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<MLNTransition>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTransition_ = objc.registerName("setTransition:");
final _objc_msgSend_z7lywk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNTransition)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNTransition)>();
late final _sel_performsPlacementTransitions =
    objc.registerName("performsPlacementTransitions");
late final _sel_setPerformsPlacementTransitions_ =
    objc.registerName("setPerformsPlacementTransitions:");
late final _class_MLNSource = objc.getClass("MLNSource");
late final _sel_initWithIdentifier_ = objc.registerName("initWithIdentifier:");
late final _sel_setIdentifier_ = objc.registerName("setIdentifier:");

/// ``MLNSource`` is an abstract base class for map content sources. A map content
/// source supplies content to be shown on the map. A source is added to an
/// ``MLNStyle`` object along with an ``MLNStyle`` object. The
/// foreground style layer defines the appearance of any content supplied by the
/// source.
///
/// Each source defined by the style JSON file is represented at runtime by an
/// ``MLNSource`` object that you can use to refine the map’s content. You can also
/// add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// Create instances of ``MLNShapeSource``, ``MLNShapeSource``,
/// ``MLNImageSource``, and the concrete subclasses of ``MLNImageSource``
/// (``MLNVectorTileSource`` and ``MLNRasterTileSource``) in order to use ``MLNRasterTileSource``’s
/// properties and methods. Do not create instances of ``MLNSource`` directly, and do
/// not create your own subclasses of this class.
class MLNSource extends objc.NSObject {
  MLNSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNSource] that points to the same underlying object as [other].
  MLNSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNSource] that wraps the given raw object pointer.
  MLNSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNSource);
  }

  /// init
  MLNSource init() {
    objc.checkOsVersionInternal('MLNSource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// A string that uniquely identifies the source in the style to which it is added.
  objc.NSString get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// A string that uniquely identifies the source in the style to which it is added.
  set identifier(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIdentifier_, value.ref.pointer);
  }

  /// new
  static MLNSource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNSource, _sel_new);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNSource, _sel_allocWithZone_, zone);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNSource alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNSource, _sel_alloc);
    return MLNSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNSource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNSource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNSource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNSource constructed with the default `new` method.
  factory MLNSource() => new$();
}

late final _sel_sourceWithIdentifier_ =
    objc.registerName("sourceWithIdentifier:");
late final _sel_addSource_ = objc.registerName("addSource:");
late final _sel_removeSource_ = objc.registerName("removeSource:");
late final _sel_removeSource_error_ = objc.registerName("removeSource:error:");
final _objc_msgSend_l9p60w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_layers = objc.registerName("layers");
late final _sel_setLayers_ = objc.registerName("setLayers:");
late final _sel_layerWithIdentifier_ =
    objc.registerName("layerWithIdentifier:");
late final _sel_addLayer_ = objc.registerName("addLayer:");
late final _sel_insertLayer_atIndex_ =
    objc.registerName("insertLayer:atIndex:");
final _objc_msgSend_djsa9o = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_insertLayer_belowLayer_ =
    objc.registerName("insertLayer:belowLayer:");
late final _sel_insertLayer_aboveLayer_ =
    objc.registerName("insertLayer:aboveLayer:");
late final _sel_removeLayer_ = objc.registerName("removeLayer:");
late final _sel_imageForName_ = objc.registerName("imageForName:");
late final _sel_setImage_forName_ = objc.registerName("setImage:forName:");
late final _sel_removeImageForName_ = objc.registerName("removeImageForName:");
late final _class_MLNLight = objc.getClass("MLNLight");

/// MLNLight
class MLNLight extends objc.ObjCObjectBase {
  MLNLight._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNLight] that points to the same underlying object as [other].
  MLNLight.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNLight] that wraps the given raw object pointer.
  MLNLight.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNLight].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNLight);
  }
}

late final _sel_light = objc.registerName("light");
late final _sel_setLight_ = objc.registerName("setLight:");
late final _sel_localizeLabelsIntoLocale_ =
    objc.registerName("localizeLabelsIntoLocale:");

/// The proxy object for the current map style.
///
/// MLNStyle provides a set of convenience methods for changing default styles included
/// with MapLibre.
///
/// It is also possible to directly manipulate the current map style
/// via ``MLNMapView/style`` by updating the style's data sources or layers.
///
/// > Note: Wait until the map style has finished loading before modifying a map's
/// style via any of the ``MLNStyle`` instance methods below. You can use the
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
/// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` methods as indicators
/// that it's safe to modify the map's style.
class MLNStyle extends objc.NSObject {
  MLNStyle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNStyle] that points to the same underlying object as [other].
  MLNStyle.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNStyle] that wraps the given raw object pointer.
  MLNStyle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNStyle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNStyle);
  }

  /// Returns list of predefined styles
  static objc.NSArray predefinedStyles() {
    final _ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_predefinedStyles);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns default style
  static MLNDefaultStyle defaultStyle() {
    final _ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_defaultStyle);
    return MLNDefaultStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns default style as NSURL
  static objc.NSURL? defaultStyleURL() {
    final _ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_defaultStyleURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// Get predefined style by name
  ///
  /// @param withStyleName style name.
  static MLNDefaultStyle? predefinedStyle(objc.NSString withStyleName) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_MLNStyle, _sel_predefinedStyle_, withStyleName.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNDefaultStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// The name of the style.
  ///
  /// You can customize the style’s name in Mapbox Studio.
  objc.NSString? get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The style JSON representation of the map.
  ///
  /// Setting this property results in an asynchronous style change. If you wish to know when the style
  /// change is complete, observe the ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` method
  /// on ``MLNMapViewDelegate``.
  ///
  /// The JSON must conform to the
  /// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
  ///
  /// @throws NSInvalidArgumentException if styleJSON is nil or invalid JSON
  objc.NSString get styleJSON {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_styleJSON);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The style JSON representation of the map.
  ///
  /// Setting this property results in an asynchronous style change. If you wish to know when the style
  /// change is complete, observe the ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` method
  /// on ``MLNMapViewDelegate``.
  ///
  /// The JSON must conform to the
  /// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
  ///
  /// @throws NSInvalidArgumentException if styleJSON is nil or invalid JSON
  set styleJSON(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setStyleJSON_, value.ref.pointer);
  }

  /// A set containing the style’s sources.
  objc.NSSet get sources {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sources);
    return objc.NSSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// A set containing the style’s sources.
  set sources(objc.NSSet value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSources_, value.ref.pointer);
  }

  /// Values describing animated transitions to changes on a style's individual
  /// paint properties.
  MLNTransition get transition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(_ptr, this.ref.pointer, _sel_transition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_transition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// Values describing animated transitions to changes on a style's individual
  /// paint properties.
  set transition(MLNTransition value) {
    _objc_msgSend_z7lywk(this.ref.pointer, _sel_setTransition_, value);
  }

  /// A boolean value indicating whether label placement transitions are enabled.
  ///
  /// The default value of this property is `YES`.
  bool get performsPlacementTransitions {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_performsPlacementTransitions);
  }

  /// A boolean value indicating whether label placement transitions are enabled.
  ///
  /// The default value of this property is `YES`.
  set performsPlacementTransitions(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPerformsPlacementTransitions_, value);
  }

  /// Returns a source with the given identifier in the current style.
  ///
  /// @return An instance of a concrete subclass of ``MLNSource`` associated with the
  /// given identifier, or `nil` if the current style contains no such source.
  MLNSource? sourceWithIdentifier(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_sourceWithIdentifier_, identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds a new source to the current style.
  ///
  /// > Note: Adding the same source instance more than once will result in a
  /// ``MLNRedundantSourceException``. Reusing the same source identifier, even with
  /// different source instances, will result in a
  /// ``MLNRedundantSourceIdentifierException``.
  ///
  /// > Note: Sources should be added in
  /// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
  /// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
  /// has loaded the style and is ready to accept a new source.
  ///
  /// @param source The source to add to the current style.
  void addSource(MLNSource source) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addSource_, source.ref.pointer);
  }

  /// Removes a source from the current style.
  ///
  /// @param source The source to remove from the current style.
  void removeSource(MLNSource source) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeSource_, source.ref.pointer);
  }

  /// Removes a source from the current style.
  ///
  /// @param source The source to remove from the current style.
  /// @param outError Upon return, if an error has occurred, a pointer to an `NSError`
  /// object describing the error. Pass in `NULL` to ignore any error.
  ///
  /// @return `YES` if `source` was removed successfully. If `NO`, `outError` contains
  /// an `NSError` object describing the problem.
  bool removeSource$1(MLNSource source,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    return _objc_msgSend_l9p60w(
        this.ref.pointer, _sel_removeSource_error_, source.ref.pointer, error);
  }

  /// The layers included in the style, arranged according to their back-to-front
  /// ordering on the screen.
  objc.NSArray get layers {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layers);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The layers included in the style, arranged according to their back-to-front
  /// ordering on the screen.
  set layers(objc.NSArray value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLayers_, value.ref.pointer);
  }

  /// Returns a style layer with the given identifier in the current style.
  ///
  /// @return An instance of a concrete subclass of ``MLNStyleLayer`` associated with
  /// the given identifier, or `nil` if the current style contains no such style
  /// layer.
  MLNStyleLayer? layerWithIdentifier(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_layerWithIdentifier_, identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds a new layer on top of existing layers.
  ///
  /// > Note: Adding the same layer instance more than once will result in a
  /// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
  /// different layer instances, will also result in an exception.
  ///
  /// > Note: Layers should be added in
  /// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
  /// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
  /// has loaded the style and is ready to accept a new layer.
  ///
  /// @param layer The layer object to add to the map view. This object must be an
  /// instance of a concrete subclass of ``MLNStyleLayer``.
  void addLayer(MLNStyleLayer layer) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addLayer_, layer.ref.pointer);
  }

  /// Inserts a new layer into the style at the given index.
  ///
  /// > Note: Adding the same layer instance more than once will result in a
  /// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
  /// different layer instances, will also result in an exception.
  ///
  /// > Note: Layers should be added in
  /// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
  /// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
  /// has loaded the style and is ready to accept a new layer.
  ///
  /// @param layer The layer to insert.
  /// @param index The index at which to insert the layer. An index of 0 would send
  /// the layer to the back; an index equal to the number of objects in the
  /// `layers` property would bring the layer to the front.
  void insertLayer(MLNStyleLayer layer, {required int atIndex}) {
    _objc_msgSend_djsa9o(this.ref.pointer, _sel_insertLayer_atIndex_,
        layer.ref.pointer, atIndex);
  }

  /// Inserts a new layer below another layer.
  ///
  /// > Note: Inserting the same layer instance more than once will result in a
  /// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
  /// different layer instances, will also result in an exception.
  ///
  /// @param layer The layer to insert.
  /// @param sibling An existing layer in the style.
  ///
  /// #### Related examples
  /// TODO: Add multiple shapes from a single shape source, learn how to
  /// add a layer to your map below an existing layer.
  void insertLayer$1(MLNStyleLayer layer, {required MLNStyleLayer belowLayer}) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_insertLayer_belowLayer_,
        layer.ref.pointer, belowLayer.ref.pointer);
  }

  /// Inserts a new layer above another layer.
  ///
  /// > Note: Inserting the same layer instance more than once will result in a
  /// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
  /// different layer instances, will also result in an exception.
  ///
  /// @param layer The layer to insert.
  /// @param sibling An existing layer in the style.
  ///
  /// #### Related examples
  /// TODO: Add an image, learn how to add a layer to your map above an
  /// existing layer.
  void insertLayer$2(MLNStyleLayer layer, {required MLNStyleLayer aboveLayer}) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_insertLayer_aboveLayer_,
        layer.ref.pointer, aboveLayer.ref.pointer);
  }

  /// Removes a layer from the map view.
  ///
  /// @param layer The layer object to remove from the map view. This object
  /// must conform to the ``MLNStyleLayer`` protocol.
  void removeLayer(MLNStyleLayer layer) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeLayer_, layer.ref.pointer);
  }

  /// Returns the image associated with the given name in the style.
  ///
  /// @param name The name associated with the image you want to obtain.
  /// @return The image associated with the given name, or `nil` if no image is
  /// associated with that name.
  UIImage? imageForName(objc.NSString name$1) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_imageForName_, name$1.ref.pointer);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds or overrides an image used by the style’s layers.
  ///
  /// To use an image in a style layer, give it a unique name using this method, then
  /// set the `iconImageName` property of an ``MLNSymbolStyleLayer`` object to that
  /// name.
  ///
  /// @param image The image for the name.
  /// @param name The name of the image to set to the style.
  ///
  /// #### Related examples
  /// TODO: Use images to cluster point data
  /// TODO: Cluster point data
  /// Learn how to add images to your map using an ``MLNStyle`` object.
  void setImage(UIImage image, {required objc.NSString forName}) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setImage_forName_,
        image.ref.pointer, forName.ref.pointer);
  }

  /// Removes a name and its associated image from the style.
  ///
  /// @param name The name of the image to remove.
  void removeImageForName(objc.NSString name$1) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeImageForName_, name$1.ref.pointer);
  }

  /// Provides global light source for the style.
  MLNLight get light {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_light);
    return MLNLight.castFromPointer(_ret, retain: true, release: true);
  }

  /// Provides global light source for the style.
  set light(MLNLight value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLight_, value.ref.pointer);
  }

  /// Attempts to localize labels in the style into the given locale.
  ///
  /// This method automatically modifies the text property of any symbol style layer
  /// in the style whose source is the
  /// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets-v8/#overview">Mapbox Streets
  /// source</a>. On iOS, the user can set the system’s preferred language in Settings, General Settings,
  /// Language & Region. On macOS, the user can set the system’s preferred language in the Language &
  /// Region pane of System Preferences.
  ///
  /// @param locale The locale into which labels should be localized. To use the
  /// system’s preferred language, if supported, specify `nil`. To use the local
  /// language, specify a locale with the identifier `mul`.
  void localizeLabelsIntoLocale(objc.NSLocale? locale) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_localizeLabelsIntoLocale_,
        locale?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  MLNStyle init() {
    objc.checkOsVersionInternal('MLNStyle.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNStyle new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_new);
    return MLNStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNStyle allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNStyle, _sel_allocWithZone_, zone);
    return MLNStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNStyle alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_alloc);
    return MLNStyle.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNStyle self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNStyle retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNStyle autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNStyle constructed with the default `new` method.
  factory MLNStyle() => new$();
}

late final _protocol_MLNStylable = objc.getProtocol("MLNStylable");
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCProtocol>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCProtocol>)>();
late final _sel_style = objc.registerName("style");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_MLNStyle_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_MLNStyle_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_MLNStyle_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_MLNStyle_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_MLNStyle_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_MLNStyle_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_MLNStyle_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_MLNStyle_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> fromFunction(
          MLNStyle? Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_MLNStyle_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) =>
                  fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_MLNStyle_ffiVoid_CallExtension
    on objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> {
  MLNStyle? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : MLNStyle.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

/// An object whose contents are represented by an ``MLNStyle`` object that you
/// configure.
interface class MLNStylable extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  MLNStylable._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNStylable] that points to the same underlying object as [other].
  MLNStylable.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNStylable] that wraps the given raw object pointer.
  MLNStylable.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNStylable].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNStylable);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNStylable.cast());

  /// Builds an object that implements the MLNStylable protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNStylable implement(
      {required MLNStyle? Function() style, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNStylable');
    MLNStylable.style.implement(builder, style);
    builder.addProtocol($protocol);
    return MLNStylable.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNStylable protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required MLNStyle? Function() style, bool $keepIsolateAlive = true}) {
    MLNStylable.style.implement(builder, style);
    builder.addProtocol($protocol);
  }

  /// The style currently displayed in the receiver.
  static final style = objc.ObjCProtocolMethod<MLNStyle? Function()>(
    _protocol_MLNStylable,
    _sel_style,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNStylable,
      _sel_style,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (MLNStyle? Function() func) => ObjCBlock_MLNStyle_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );
}

/// The vertical alignment of an annotation within a map view. Used with
/// ``MLNMapView/userLocationVerticalAlignment``.
enum MLNAnnotationVerticalAlignment {
  /// Aligns the annotation vertically in the center of the map view.
  MLNAnnotationVerticalAlignmentCenter(0),

  /// Aligns the annotation vertically at the top of the map view.
  MLNAnnotationVerticalAlignmentTop(1),

  /// Aligns the annotation vertically at the bottom of the map view.
  MLNAnnotationVerticalAlignmentBottom(2);

  final int value;
  const MLNAnnotationVerticalAlignment(this.value);

  static MLNAnnotationVerticalAlignment fromValue(int value) => switch (value) {
        0 => MLNAnnotationVerticalAlignmentCenter,
        1 => MLNAnnotationVerticalAlignmentTop,
        2 => MLNAnnotationVerticalAlignmentBottom,
        _ => throw ArgumentError(
            'Unknown value for MLNAnnotationVerticalAlignment: $value'),
      };
}

/// The position of scale bar, compass, logo and attribution in a map view. Used with
/// ``MLNMapView/scaleBarPosition``,
/// ``MLNMapView/compassViewPosition``,
/// ``MLNMapView/logoViewPosition``,
/// ``MLNMapView/attributionButtonPosition``.
enum MLNOrnamentPosition {
  /// Place the ornament in the top left of the map view.
  MLNOrnamentPositionTopLeft(0),

  /// Place the ornament in the top right of the map view.
  MLNOrnamentPositionTopRight(1),

  /// Place the ornament in the bottom left of the map view.
  MLNOrnamentPositionBottomLeft(2),

  /// Place the ornament in the bottom right of the map view.
  MLNOrnamentPositionBottomRight(3);

  final int value;
  const MLNOrnamentPosition(this.value);

  static MLNOrnamentPosition fromValue(int value) => switch (value) {
        0 => MLNOrnamentPositionTopLeft,
        1 => MLNOrnamentPositionTopRight,
        2 => MLNOrnamentPositionBottomLeft,
        3 => MLNOrnamentPositionBottomRight,
        _ =>
          throw ArgumentError('Unknown value for MLNOrnamentPosition: $value'),
      };
}

/// The mode used to track the user location on the map. Used with
/// ``MLNMapView/userTrackingMode``.
///
/// #### Related examples
/// - TODO: Switch between user tracking modes</a> example to learn how to toggle modes and
/// how each mode behaves.
enum MLNUserTrackingMode {
  /// The map does not follow the user location.
  MLNUserTrackingModeNone(0),

  /// The map follows the user location. This tracking mode falls back
  /// to ``MLNUserTrackingMode/MLNUserTrackingModeNone`` if the user pans the map view.
  MLNUserTrackingModeFollow(1),

  /// The map follows the user location and rotates when the heading changes.
  /// The default user location annotation displays a fan-shaped indicator with
  /// the current heading. The heading indicator represents the direction the
  /// device is facing, which is sized according to the reported accuracy.
  ///
  /// This tracking mode is disabled if the user pans the map view, but
  /// remains enabled if the user zooms in. If the user rotates the map
  /// view, this tracking mode will fall back to ``MLNUserTrackingModeFollow``.
  MLNUserTrackingModeFollowWithHeading(2),

  /// The map follows the user location and rotates when the course changes.
  /// Course represents the direction in which the device is traveling.
  /// The default user location annotation shows a puck-shaped indicator
  /// that rotates as the course changes.
  ///
  /// This tracking mode is disabled if the user pans the map view, but
  /// remains enabled if the user zooms in. If the user rotates the map view,
  /// this tracking mode will fall back to ``MLNUserTrackingModeFollow``.
  MLNUserTrackingModeFollowWithCourse(3);

  final int value;
  const MLNUserTrackingMode(this.value);

  static MLNUserTrackingMode fromValue(int value) => switch (value) {
        0 => MLNUserTrackingModeNone,
        1 => MLNUserTrackingModeFollow,
        2 => MLNUserTrackingModeFollowWithHeading,
        3 => MLNUserTrackingModeFollowWithCourse,
        _ =>
          throw ArgumentError('Unknown value for MLNUserTrackingMode: $value'),
      };
}

enum MLNPanScrollingMode {
  /// The map allows the user to only scroll horizontally.
  MLNPanScrollingModeHorizontal(0),

  /// The map allows the user to only scroll vertically.
  MLNPanScrollingModeVertical(1),

  /// The map allows the user to scroll both horizontally and vertically.
  MLNPanScrollingModeDefault(2);

  final int value;
  const MLNPanScrollingMode(this.value);

  static MLNPanScrollingMode fromValue(int value) => switch (value) {
        0 => MLNPanScrollingModeHorizontal,
        1 => MLNPanScrollingModeVertical,
        2 => MLNPanScrollingModeDefault,
        _ =>
          throw ArgumentError('Unknown value for MLNPanScrollingMode: $value'),
      };
}

late final _class_MLNMapView = objc.getClass("MapLibre.MLNMapView");
late final _sel_initWithFrame_styleURL_ =
    objc.registerName("initWithFrame:styleURL:");
late final _sel_initWithFrame_styleJSON_ =
    objc.registerName("initWithFrame:styleJSON:");
late final _sel_initWithFrame_options_ =
    objc.registerName("initWithFrame:options:");
late final _protocol_MLNMapViewDelegate =
    objc.getProtocol("MLNMapViewDelegate");

/// MLNMapViewDelegate
interface class MLNMapViewDelegate extends objc.ObjCProtocolBase {
  MLNMapViewDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNMapViewDelegate] that points to the same underlying object as [other].
  MLNMapViewDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMapViewDelegate] that wraps the given raw object pointer.
  MLNMapViewDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMapViewDelegate].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_MLNMapViewDelegate);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNMapViewDelegate.cast());

  /// Builds an object that implements the MLNMapViewDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNMapViewDelegate implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNMapViewDelegate');

    builder.addProtocol($protocol);
    return MLNMapViewDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNMapViewDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {bool $keepIsolateAlive = true}) {
    builder.addProtocol($protocol);
  }
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
late final _sel_reloadStyle_ = objc.registerName("reloadStyle:");
late final _sel_automaticallyAdjustsContentInset =
    objc.registerName("automaticallyAdjustsContentInset");
late final _sel_setAutomaticallyAdjustsContentInset_ =
    objc.registerName("setAutomaticallyAdjustsContentInset:");
late final _sel_showsScale = objc.registerName("showsScale");
late final _sel_setShowsScale_ = objc.registerName("setShowsScale:");
late final _class_MLNScaleBar = objc.getClass("MLNScaleBar");

/// MLNScaleBar
class MLNScaleBar extends objc.ObjCObjectBase {
  MLNScaleBar._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNScaleBar] that points to the same underlying object as [other].
  MLNScaleBar.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNScaleBar] that wraps the given raw object pointer.
  MLNScaleBar.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNScaleBar].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNScaleBar);
  }
}

late final _sel_scaleBar = objc.registerName("scaleBar");
late final _sel_scaleBarShouldShowDarkStyles =
    objc.registerName("scaleBarShouldShowDarkStyles");
late final _sel_setScaleBarShouldShowDarkStyles_ =
    objc.registerName("setScaleBarShouldShowDarkStyles:");
late final _sel_scaleBarUsesMetricSystem =
    objc.registerName("scaleBarUsesMetricSystem");
late final _sel_setScaleBarUsesMetricSystem_ =
    objc.registerName("setScaleBarUsesMetricSystem:");
late final _sel_scaleBarPosition = objc.registerName("scaleBarPosition");
final _objc_msgSend_1c31cvt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setScaleBarPosition_ =
    objc.registerName("setScaleBarPosition:");
final _objc_msgSend_8fd115 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_scaleBarMargins = objc.registerName("scaleBarMargins");
late final _sel_setScaleBarMargins_ = objc.registerName("setScaleBarMargins:");
late final _sel_compassView = objc.registerName("compassView");
late final _sel_compassViewPosition = objc.registerName("compassViewPosition");
late final _sel_setCompassViewPosition_ =
    objc.registerName("setCompassViewPosition:");
late final _sel_compassViewMargins = objc.registerName("compassViewMargins");
late final _sel_setCompassViewMargins_ =
    objc.registerName("setCompassViewMargins:");
late final _sel_logoView = objc.registerName("logoView");
late final _sel_logoViewPosition = objc.registerName("logoViewPosition");
late final _sel_setLogoViewPosition_ =
    objc.registerName("setLogoViewPosition:");
late final _sel_logoViewMargins = objc.registerName("logoViewMargins");
late final _sel_setLogoViewMargins_ = objc.registerName("setLogoViewMargins:");
late final _sel_attributionButton = objc.registerName("attributionButton");
late final _sel_attributionButtonPosition =
    objc.registerName("attributionButtonPosition");
late final _sel_setAttributionButtonPosition_ =
    objc.registerName("setAttributionButtonPosition:");
late final _sel_attributionButtonMargins =
    objc.registerName("attributionButtonMargins");
late final _sel_setAttributionButtonMargins_ =
    objc.registerName("setAttributionButtonMargins:");
late final _sel_showAttribution_ = objc.registerName("showAttribution:");
late final _sel_preferredFramesPerSecond =
    objc.registerName("preferredFramesPerSecond");
late final _sel_setPreferredFramesPerSecond_ =
    objc.registerName("setPreferredFramesPerSecond:");
late final _sel_prefetchesTiles = objc.registerName("prefetchesTiles");
late final _sel_setPrefetchesTiles_ = objc.registerName("setPrefetchesTiles:");
late final _sel_tileCacheEnabled = objc.registerName("tileCacheEnabled");
late final _sel_setTileCacheEnabled_ =
    objc.registerName("setTileCacheEnabled:");
late final _sel_tileLodMinRadius = objc.registerName("tileLodMinRadius");
late final _sel_setTileLodMinRadius_ =
    objc.registerName("setTileLodMinRadius:");
late final _sel_tileLodScale = objc.registerName("tileLodScale");
late final _sel_setTileLodScale_ = objc.registerName("setTileLodScale:");
late final _sel_tileLodPitchThreshold =
    objc.registerName("tileLodPitchThreshold");
late final _sel_setTileLodPitchThreshold_ =
    objc.registerName("setTileLodPitchThreshold:");
late final _sel_tileLodZoomShift = objc.registerName("tileLodZoomShift");
late final _sel_setTileLodZoomShift_ =
    objc.registerName("setTileLodZoomShift:");
late final _protocol_MLNLocationManager =
    objc.getProtocol("MLNLocationManager");

/// MLNLocationManager
interface class MLNLocationManager extends objc.ObjCProtocolBase {
  MLNLocationManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNLocationManager] that points to the same underlying object as [other].
  MLNLocationManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNLocationManager] that wraps the given raw object pointer.
  MLNLocationManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNLocationManager].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_MLNLocationManager);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNLocationManager.cast());

  /// Builds an object that implements the MLNLocationManager protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNLocationManager implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNLocationManager');

    builder.addProtocol($protocol);
    return MLNLocationManager.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNLocationManager protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {bool $keepIsolateAlive = true}) {
    builder.addProtocol($protocol);
  }
}

late final _sel_locationManager = objc.registerName("locationManager");
late final _sel_setLocationManager_ = objc.registerName("setLocationManager:");
late final _sel_showsUserLocation = objc.registerName("showsUserLocation");
late final _sel_setShowsUserLocation_ =
    objc.registerName("setShowsUserLocation:");
late final _sel_dynamicNavigationCameraAnimationDuration =
    objc.registerName("dynamicNavigationCameraAnimationDuration");
late final _sel_setDynamicNavigationCameraAnimationDuration_ =
    objc.registerName("setDynamicNavigationCameraAnimationDuration:");
late final _sel_shouldRequestAuthorizationToUseLocationServices =
    objc.registerName("shouldRequestAuthorizationToUseLocationServices");
late final _sel_setShouldRequestAuthorizationToUseLocationServices_ =
    objc.registerName("setShouldRequestAuthorizationToUseLocationServices:");
late final _sel_isUserLocationVisible =
    objc.registerName("isUserLocationVisible");
late final _class_MLNUserLocation = objc.getClass("MLNUserLocation");

/// MLNUserLocation
class MLNUserLocation extends objc.ObjCObjectBase {
  MLNUserLocation._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNUserLocation] that points to the same underlying object as [other].
  MLNUserLocation.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNUserLocation] that wraps the given raw object pointer.
  MLNUserLocation.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNUserLocation].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNUserLocation);
  }
}

late final _sel_userLocation = objc.registerName("userLocation");
late final _sel_userTrackingMode = objc.registerName("userTrackingMode");
final _objc_msgSend_1swtepj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setUserTrackingMode_ =
    objc.registerName("setUserTrackingMode:");
final _objc_msgSend_xoapar = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setUserTrackingMode_animated_ =
    objc.registerName("setUserTrackingMode:animated:");
final _objc_msgSend_7oa3sf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_setUserTrackingMode_animated_completionHandler_ =
    objc.registerName("setUserTrackingMode:animated:completionHandler:");
final _objc_msgSend_1iu40ms = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_userLocationVerticalAlignment =
    objc.registerName("userLocationVerticalAlignment");
final _objc_msgSend_1m9zum6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setUserLocationVerticalAlignment_ =
    objc.registerName("setUserLocationVerticalAlignment:");
final _objc_msgSend_47doj4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setUserLocationVerticalAlignment_animated_ =
    objc.registerName("setUserLocationVerticalAlignment:animated:");
final _objc_msgSend_1qddrus = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_updateUserLocationAnnotationView =
    objc.registerName("updateUserLocationAnnotationView");
late final _sel_updateUserLocationAnnotationViewAnimatedWithDuration_ =
    objc.registerName("updateUserLocationAnnotationViewAnimatedWithDuration:");
late final _sel_showsUserHeadingIndicator =
    objc.registerName("showsUserHeadingIndicator");
late final _sel_setShowsUserHeadingIndicator_ =
    objc.registerName("setShowsUserHeadingIndicator:");
late final _sel_displayHeadingCalibration =
    objc.registerName("displayHeadingCalibration");
late final _sel_setDisplayHeadingCalibration_ =
    objc.registerName("setDisplayHeadingCalibration:");
late final _sel_targetCoordinate = objc.registerName("targetCoordinate");
late final _sel_setTargetCoordinate_ =
    objc.registerName("setTargetCoordinate:");
late final _sel_setTargetCoordinate_animated_ =
    objc.registerName("setTargetCoordinate:animated:");
final _objc_msgSend_o7hjv2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D, bool)>();
late final _sel_setTargetCoordinate_animated_completionHandler_ =
    objc.registerName("setTargetCoordinate:animated:completionHandler:");
final _objc_msgSend_1pbhom5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_isZoomEnabled = objc.registerName("isZoomEnabled");
late final _sel_setZoomEnabled_ = objc.registerName("setZoomEnabled:");
late final _sel_isQuickZoomReversed = objc.registerName("isQuickZoomReversed");
late final _sel_setQuickZoomReversed_ =
    objc.registerName("setQuickZoomReversed:");
late final _sel_isScrollEnabled = objc.registerName("isScrollEnabled");
late final _sel_setScrollEnabled_ = objc.registerName("setScrollEnabled:");
late final _sel_panScrollingMode = objc.registerName("panScrollingMode");
final _objc_msgSend_1vb5jwj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPanScrollingMode_ =
    objc.registerName("setPanScrollingMode:");
final _objc_msgSend_k7jknj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isRotateEnabled = objc.registerName("isRotateEnabled");
late final _sel_setRotateEnabled_ = objc.registerName("setRotateEnabled:");
late final _sel_isPitchEnabled = objc.registerName("isPitchEnabled");
late final _sel_setPitchEnabled_ = objc.registerName("setPitchEnabled:");
late final _sel_anchorRotateOrZoomGesturesToCenterCoordinate =
    objc.registerName("anchorRotateOrZoomGesturesToCenterCoordinate");
late final _sel_setAnchorRotateOrZoomGesturesToCenterCoordinate_ =
    objc.registerName("setAnchorRotateOrZoomGesturesToCenterCoordinate:");
late final _sel_isHapticFeedbackEnabled =
    objc.registerName("isHapticFeedbackEnabled");
late final _sel_setHapticFeedbackEnabled_ =
    objc.registerName("setHapticFeedbackEnabled:");
late final _sel_decelerationRate = objc.registerName("decelerationRate");
late final _sel_setDecelerationRate_ =
    objc.registerName("setDecelerationRate:");
late final _sel_setCenterCoordinate_animated_ =
    objc.registerName("setCenterCoordinate:animated:");
late final _sel_setCenterCoordinate_zoomLevel_animated_ =
    objc.registerName("setCenterCoordinate:zoomLevel:animated:");
final _objc_msgSend_sbs4d5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Double,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            double,
            bool)>();
late final _sel_setCenterCoordinate_zoomLevel_direction_animated_ =
    objc.registerName("setCenterCoordinate:zoomLevel:direction:animated:");
final _objc_msgSend_3zczym = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Double,
                ffi.Double,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            double,
            double,
            bool)>();
late final _sel_setCenterCoordinate_zoomLevel_direction_animated_completionHandler_ =
    objc.registerName(
        "setCenterCoordinate:zoomLevel:direction:animated:completionHandler:");
final _objc_msgSend_d9pvdp = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Double,
                ffi.Double,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            double,
            double,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_zoomLevel = objc.registerName("zoomLevel");
late final _sel_setZoomLevel_ = objc.registerName("setZoomLevel:");
late final _sel_setZoomLevel_animated_ =
    objc.registerName("setZoomLevel:animated:");
final _objc_msgSend_ghxo7e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double, bool)>();
late final _sel_maximumScreenBounds = objc.registerName("maximumScreenBounds");
final _objc_msgSend_ygoa6a = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNCoordinateBounds Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        MLNCoordinateBounds Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_ygoa6aStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNCoordinateBounds>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<MLNCoordinateBounds>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setMaximumScreenBounds_ =
    objc.registerName("setMaximumScreenBounds:");
final _objc_msgSend_9ay59k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>();
late final _sel_direction = objc.registerName("direction");
late final _sel_setDirection_ = objc.registerName("setDirection:");
late final _sel_setDirection_animated_ =
    objc.registerName("setDirection:animated:");
late final _sel_minimumPitch = objc.registerName("minimumPitch");
late final _sel_setMinimumPitch_ = objc.registerName("setMinimumPitch:");
late final _sel_maximumPitch = objc.registerName("maximumPitch");
late final _sel_setMaximumPitch_ = objc.registerName("setMaximumPitch:");
late final _sel_resetNorth = objc.registerName("resetNorth");
late final _sel_resetPosition = objc.registerName("resetPosition");
late final _sel_visibleCoordinateBounds =
    objc.registerName("visibleCoordinateBounds");
late final _sel_setVisibleCoordinateBounds_ =
    objc.registerName("setVisibleCoordinateBounds:");
late final _sel_setVisibleCoordinateBounds_animated_ =
    objc.registerName("setVisibleCoordinateBounds:animated:");
final _objc_msgSend_148tmbg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds, bool)>();
late final _sel_setVisibleCoordinateBounds_edgePadding_animated_ =
    objc.registerName("setVisibleCoordinateBounds:edgePadding:animated:");
final _objc_msgSend_18wcmvu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                UIEdgeInsets,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            UIEdgeInsets,
            bool)>();
late final _sel_setVisibleCoordinateBounds_edgePadding_animated_completionHandler_ =
    objc.registerName(
        "setVisibleCoordinateBounds:edgePadding:animated:completionHandler:");
final _objc_msgSend_1v6m6tt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                UIEdgeInsets,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            UIEdgeInsets,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_setVisibleCoordinates_count_edgePadding_animated_ =
    objc.registerName("setVisibleCoordinates:count:edgePadding:animated:");
final _objc_msgSend_1evryr5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong,
                UIEdgeInsets,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            int,
            UIEdgeInsets,
            bool)>();
late final _sel_setVisibleCoordinates_count_edgePadding_direction_duration_animationTimingFunction_completionHandler_ =
    objc.registerName(
        "setVisibleCoordinates:count:edgePadding:direction:duration:animationTimingFunction:completionHandler:");
final _objc_msgSend_v2jdd0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong,
                UIEdgeInsets,
                ffi.Double,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            int,
            UIEdgeInsets,
            double,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_showAnnotations_animated_ =
    objc.registerName("showAnnotations:animated:");
late final _sel_showAnnotations_edgePadding_animated_ =
    objc.registerName("showAnnotations:edgePadding:animated:");
final _objc_msgSend_1f4zv7b = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                UIEdgeInsets,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            UIEdgeInsets,
            bool)>();
late final _sel_showAnnotations_edgePadding_animated_completionHandler_ = objc
    .registerName("showAnnotations:edgePadding:animated:completionHandler:");
final _objc_msgSend_16lja1o = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                UIEdgeInsets,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            UIEdgeInsets,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_setCamera_ = objc.registerName("setCamera:");
late final _sel_setCamera_animated_ = objc.registerName("setCamera:animated:");
late final _sel_setCamera_withDuration_animationTimingFunction_ =
    objc.registerName("setCamera:withDuration:animationTimingFunction:");
final _objc_msgSend_r1s65y = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setCamera_withDuration_animationTimingFunction_completionHandler_ =
    objc.registerName(
        "setCamera:withDuration:animationTimingFunction:completionHandler:");
final _objc_msgSend_1s40ged = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_setCamera_withDuration_animationTimingFunction_edgePadding_completionHandler_ =
    objc.registerName(
        "setCamera:withDuration:animationTimingFunction:edgePadding:completionHandler:");
final _objc_msgSend_tm3gbn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>,
                UIEdgeInsets,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCObject>,
            UIEdgeInsets,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_flyToCamera_completionHandler_ =
    objc.registerName("flyToCamera:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_flyToCamera_withDuration_completionHandler_ =
    objc.registerName("flyToCamera:withDuration:completionHandler:");
final _objc_msgSend_a85mgj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_flyToCamera_withDuration_peakAltitude_completionHandler_ = objc
    .registerName("flyToCamera:withDuration:peakAltitude:completionHandler:");
final _objc_msgSend_b0p9a0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_flyToCamera_edgePadding_withDuration_completionHandler_ = objc
    .registerName("flyToCamera:edgePadding:withDuration:completionHandler:");
final _objc_msgSend_s17tgr = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                UIEdgeInsets,
                ffi.Double,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            UIEdgeInsets,
            double,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_cameraThatFitsCoordinateBounds_ =
    objc.registerName("cameraThatFitsCoordinateBounds:");
final _objc_msgSend_5pnf8k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>();
late final _sel_cameraThatFitsCoordinateBounds_edgePadding_ =
    objc.registerName("cameraThatFitsCoordinateBounds:edgePadding:");
final _objc_msgSend_1a5ayri = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                UIEdgeInsets)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            UIEdgeInsets)>();
late final _sel_camera_fittingCoordinateBounds_edgePadding_ =
    objc.registerName("camera:fittingCoordinateBounds:edgePadding:");
final _objc_msgSend_1v2rrrs = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                MLNCoordinateBounds,
                UIEdgeInsets)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            MLNCoordinateBounds,
            UIEdgeInsets)>();
late final _class_MLNShape = objc.getClass("MLNShape");
late final _protocol_MLNAnnotation = objc.getProtocol("MLNAnnotation");
late final _sel_coordinate = objc.registerName("coordinate");
CLLocationCoordinate2D
    _ObjCBlock_CLLocationCoordinate2D_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    CLLocationCoordinate2D Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CLLocationCoordinate2D_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                CLLocationCoordinate2D Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CLLocationCoordinate2D_ffiVoid_fnPtrTrampoline)
        .cast();
CLLocationCoordinate2D
    _ObjCBlock_CLLocationCoordinate2D_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as CLLocationCoordinate2D Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_CLLocationCoordinate2D_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                CLLocationCoordinate2D Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CLLocationCoordinate2D_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CLLocationCoordinate2D_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      CLLocationCoordinate2D Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_CLLocationCoordinate2D_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>
      fromFunction(CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_CLLocationCoordinate2D_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CLLocationCoordinate2D_ffiVoid_CallExtension
    on objc.ObjCBlock<CLLocationCoordinate2D Function(ffi.Pointer<ffi.Void>)> {
  CLLocationCoordinate2D call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  CLLocationCoordinate2D Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

/// The ``MLNAnnotation`` protocol is used to provide annotation-related information
/// to a map view. To use this protocol, you adopt it in any custom objects that
/// store or represent annotation data. Each object then serves as the source of
/// information about a single map annotation and provides critical information,
/// such as the annotation’s location on the map. Annotation objects do not provide
/// the visual representation of the annotation but typically coordinate (in
/// conjunction with the map view’s delegate) the creation of an appropriate
/// objects to handle the display.
///
/// An object that adopts this protocol must implement the `coordinate` property.
/// The other methods of this protocol are optional.
///
/// #### Related examples
/// TODO: Annotation models
/// TODO: Annotation views, learn how to add objects that follow the
/// ``MLNAnnotation`` protocol
interface class MLNAnnotation extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  MLNAnnotation._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNAnnotation] that points to the same underlying object as [other].
  MLNAnnotation.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNAnnotation] that wraps the given raw object pointer.
  MLNAnnotation.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNAnnotation].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNAnnotation);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNAnnotation.cast());

  /// Builds an object that implements the MLNAnnotation protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNAnnotation implement(
      {required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNAnnotation');
    MLNAnnotation.coordinate.implement(builder, coordinate);
    MLNAnnotation.title.implement(builder, title);
    MLNAnnotation.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
    return MLNAnnotation.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNAnnotation protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    MLNAnnotation.coordinate.implement(builder, coordinate);
    MLNAnnotation.title.implement(builder, title);
    MLNAnnotation.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  static final coordinate =
      objc.ObjCProtocolMethod<CLLocationCoordinate2D Function()>(
    _protocol_MLNAnnotation,
    _sel_coordinate,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    CLLocationCoordinate2D Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_neuenc)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNAnnotation,
      _sel_coordinate,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CLLocationCoordinate2D Function() func) =>
        ObjCBlock_CLLocationCoordinate2D_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  static final title = objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_MLNAnnotation,
    _sel_title,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNAnnotation,
      _sel_title,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  static final subtitle = objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_MLNAnnotation,
    _sel_subtitle,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNAnnotation,
      _sel_subtitle,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );
}

late final _sel_shapeWithData_encoding_error_ =
    objc.registerName("shapeWithData:encoding:error:");
final _objc_msgSend_1nomli1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_geoJSONDataUsingEncoding_ =
    objc.registerName("geoJSONDataUsingEncoding:");

/// ``MLNShape`` is an abstract class that represents a shape or annotation. Shapes
/// constitute the content of a map — not only the overlays atop the map, but also
/// the content that forms the base map.
///
/// Create instances of ``MLNPointAnnotation``, ``MLNPointAnnotation``, ``MLNPointAnnotation``,
/// ``MLNMultiPolyline``, ``MLNMultiPolyline``, ``MLNMultiPolyline``, or ``MLNMultiPolyline`` in
/// order to use ``MLNShape``'s methods. Do not create instances of ``MLNShape``
/// directly, and do not create your own subclasses of this class. The shape
/// classes correspond to the
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1">Geometry</a> object
/// types in the GeoJSON standard, but some have nonstandard names for backwards
/// compatibility.
///
/// Although you do not create instances of this class directly, you can use its
/// ``MLNShape/shapeWithData:encoding:error:`` factory method to create one of the
/// concrete subclasses of ``MLNShape`` noted above from GeoJSON data. To access a
/// shape’s attributes, use the corresponding ``MLNFeature`` class instead.
///
/// You can add shapes to the map by adding them to an ``MLNShapeSource`` object.
/// Configure the appearance of an ``MLNShapeSource``’s or ``MLNShapeSource``’s
/// shapes collectively using a concrete instance of ``MLNVectorStyleLayer``.
/// Alternatively, you can add some kinds of shapes directly to a map view as
/// annotations or overlays.
///
/// You can filter the features in a ``MLNVectorStyleLayer`` or vary their layout or
/// paint attributes based on the features’ geographies. Pass an ``MLNShape`` into an
/// `NSPredicate` with the format `SELF IN %@` or `%@ CONTAINS SELF` and set the
/// ``MLNVectorStyleLayer/predicate`` property to that predicate, or set a layout or
/// paint attribute to a similarly formatted `NSExpression`.
class MLNShape extends objc.NSObject
    implements MLNAnnotation, objc.NSSecureCoding {
  MLNShape._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNShape] that points to the same underlying object as [other].
  MLNShape.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNShape] that wraps the given raw object pointer.
  MLNShape.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNShape].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShape);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNShape,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// The title of the shape annotation.
  ///
  /// The default value of this property is `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``. To name
  /// a shape used in a shape source, create an ``MLNFeature`` and add an attribute to
  /// the ``MLNFeature/attributes`` property.
  objc.NSString? get title {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The title of the shape annotation.
  ///
  /// The default value of this property is `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``. To name
  /// a shape used in a shape source, create an ``MLNFeature`` and add an attribute to
  /// the ``MLNFeature/attributes`` property.
  set title(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The subtitle of the shape annotation. The default value of this property is
  /// `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``. To
  /// provide additional information about a shape used in a shape source, create an
  /// ``MLNFeature`` and add an attribute to the ``MLNFeature/attributes`` property.
  objc.NSString? get subtitle {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The subtitle of the shape annotation. The default value of this property is
  /// `nil`.
  ///
  /// This property is ignored when the shape is used in an ``MLNShapeSource``. To
  /// provide additional information about a shape used in a shape source, create an
  /// ``MLNFeature`` and add an attribute to the ``MLNFeature/attributes`` property.
  set subtitle(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSubtitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns the GeoJSON string representation of the shape encapsulated in a data
  /// object.
  ///
  /// @param encoding The string encoding to use.
  /// @return A data object containing the shape’s GeoJSON string representation.
  objc.NSData geoJSONDataUsingEncoding(int encoding) {
    final _ret = _objc_msgSend_14hpxwa(
        this.ref.pointer, _sel_geoJSONDataUsingEncoding_, encoding);
    return objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNShape init() {
    objc.checkOsVersionInternal('MLNShape.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNShape new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNShape, _sel_new);
    return MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNShape allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNShape, _sel_allocWithZone_, zone);
    return MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNShape alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNShape, _sel_alloc);
    return MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNShape self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNShape retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNShape autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNShape, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  MLNShape? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of MLNShape constructed with the default `new` method.
  factory MLNShape() => new$();
}

late final _sel_camera_fittingShape_edgePadding_ =
    objc.registerName("camera:fittingShape:edgePadding:");
final _objc_msgSend_53bjzp = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                UIEdgeInsets)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            UIEdgeInsets)>();
late final _sel_cameraThatFitsShape_direction_edgePadding_ =
    objc.registerName("cameraThatFitsShape:direction:edgePadding:");
final _objc_msgSend_ebhzse = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double,
                UIEdgeInsets)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double,
            UIEdgeInsets)>();
late final _sel_anchorPointForGesture_ =
    objc.registerName("anchorPointForGesture:");
final _objc_msgSend_1mpyy6y = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGPoint Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_1mpyy6yStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_contentInset = objc.registerName("contentInset");
late final _sel_setContentInset_ = objc.registerName("setContentInset:");
late final _sel_cameraEdgeInsets = objc.registerName("cameraEdgeInsets");
late final _sel_setContentInset_animated_ =
    objc.registerName("setContentInset:animated:");
final _objc_msgSend_6ueq99 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, UIEdgeInsets, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, UIEdgeInsets, bool)>();
late final _sel_setContentInset_animated_completionHandler_ =
    objc.registerName("setContentInset:animated:completionHandler:");
final _objc_msgSend_1vx0lfy = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                UIEdgeInsets,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            UIEdgeInsets,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_convertPoint_toCoordinateFromView_ =
    objc.registerName("convertPoint:toCoordinateFromView:");
final _objc_msgSend_4xp05x = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CLLocationCoordinate2D Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        CLLocationCoordinate2D Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_4xp05xStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CLLocationCoordinate2D>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertCoordinate_toPointToView_ =
    objc.registerName("convertCoordinate:toPointToView:");
final _objc_msgSend_mus1wv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGPoint Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGPoint Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_mus1wvStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGPoint>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CLLocationCoordinate2D,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertRect_toCoordinateBoundsFromView_ =
    objc.registerName("convertRect:toCoordinateBoundsFromView:");
final _objc_msgSend_1f65wix = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNCoordinateBounds Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        MLNCoordinateBounds Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_1f65wixStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNCoordinateBounds>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<MLNCoordinateBounds>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_convertCoordinateBounds_toRectToView_ =
    objc.registerName("convertCoordinateBounds:toRectToView:");
final _objc_msgSend_18hv5gj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.CGRect Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_18hv5gjStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_metersPerPointAtLatitude_ =
    objc.registerName("metersPerPointAtLatitude:");
final _objc_msgSend_1tczmpv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
final _objc_msgSend_1tczmpvFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _class_MLNMapProjection = objc.getClass("MLNMapProjection");
late final _sel_initWithMapView_ = objc.registerName("initWithMapView:");
late final _sel_setCamera_withEdgeInsets_ =
    objc.registerName("setCamera:withEdgeInsets:");
final _objc_msgSend_1c0ferf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                UIEdgeInsets)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            UIEdgeInsets)>();
late final _sel_setVisibleCoordinateBounds_edgePadding_ =
    objc.registerName("setVisibleCoordinateBounds:edgePadding:");
final _objc_msgSend_vmuxgq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                MLNCoordinateBounds,
                UIEdgeInsets)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            MLNCoordinateBounds,
            UIEdgeInsets)>();
late final _sel_convertPoint_ = objc.registerName("convertPoint:");
final _objc_msgSend_zdqa7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>>()
    .asFunction<
        CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>();
final _objc_msgSend_zdqa7Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CLLocationCoordinate2D>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint)>();
late final _sel_convertCoordinate_ = objc.registerName("convertCoordinate:");
final _objc_msgSend_p1qkdl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>>()
    .asFunction<
        objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>();
final _objc_msgSend_p1qkdlStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.CGPoint>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CLLocationCoordinate2D)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.CGPoint>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CLLocationCoordinate2D)>();
late final _sel_metersPerPoint = objc.registerName("metersPerPoint");

/// The aim of this class is to provide the functionality of changing the camera state and
/// converting between map view screen coordinates and geographical coordinates without
/// changing the actual map view camera state.
class MLNMapProjection extends objc.NSObject {
  MLNMapProjection._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMapProjection] that points to the same underlying object as [other].
  MLNMapProjection.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMapProjection] that wraps the given raw object pointer.
  MLNMapProjection.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMapProjection].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapProjection);
  }

  /// Initializes and returns the new projection object with the current
  /// camera state from the provided map view.
  ///
  /// @param mapView The map view the camera state to use for the initialization.
  /// @return An initialized map projection.
  MLNMapProjection initWithMapView(MLNMapView mapView) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithMapView_, mapView.ref.pointer);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// A camera representing the current projection state
  MLNMapCamera get camera {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_camera);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Change the projection state with camera and padding values.
  ///
  /// @param camera The new camera to be used in the projection calculation.
  /// @param insets The insets applied on top of the camera be used in the projection calculation.
  ///
  /// > Note: ``MLNMapView`` instance frame must not be changed since this projection is initialized,
  /// otherwise the calculation may be wrong.
  void setCamera(MLNMapCamera camera$1,
      {required UIEdgeInsets withEdgeInsets}) {
    _objc_msgSend_1c0ferf(this.ref.pointer, _sel_setCamera_withEdgeInsets_,
        camera$1.ref.pointer, withEdgeInsets);
  }

  /// Change the projection state to make the provided bounds visible with the specified inset.
  ///
  /// @param bounds The bounds that the viewport should fit.
  /// @param insets The insets applied on top of the viewport to be used in the projection calculation.
  ///
  /// > Note: ``MLNMapView`` instance frame must not be changed since this projection is initialized,
  /// otherwise the calculation may be wrong.
  void setVisibleCoordinateBounds(MLNCoordinateBounds bounds,
      {required UIEdgeInsets edgePadding}) {
    _objc_msgSend_vmuxgq(this.ref.pointer,
        _sel_setVisibleCoordinateBounds_edgePadding_, bounds, edgePadding);
  }

  /// Converts a point in the coordinate system of the map view the projection
  /// was initialized with to the geographical coordinate.
  ///
  /// @param point The point to convert.
  /// @return The geographic coordinate at the given point.
  CLLocationCoordinate2D convertPoint(objc.CGPoint point) {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_zdqa7Stret(
            _ptr, this.ref.pointer, _sel_convertPoint_, point)
        : _ptr.ref =
            _objc_msgSend_zdqa7(this.ref.pointer, _sel_convertPoint_, point);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// Converts a geographic coordinate to a point in the map view's the projection
  /// was initialized with coordinate system.
  ///
  /// @param coordinate The geographic coordinate to convert.
  /// @return The point corresponding to the given geographic coordinate.
  objc.CGPoint convertCoordinate(CLLocationCoordinate2D coordinate) {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_p1qkdlStret(
            _ptr, this.ref.pointer, _sel_convertCoordinate_, coordinate)
        : _ptr.ref = _objc_msgSend_p1qkdl(
            this.ref.pointer, _sel_convertCoordinate_, coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// The distance in meters spanned by a single point for the current camera.
  double get metersPerPoint {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_metersPerPoint)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_metersPerPoint);
  }

  /// init
  MLNMapProjection init() {
    objc.checkOsVersionInternal('MLNMapProjection.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMapProjection new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapProjection, _sel_new);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMapProjection allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNMapProjection, _sel_allocWithZone_, zone);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMapProjection alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapProjection, _sel_alloc);
    return MLNMapProjection.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNMapProjection self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNMapProjection.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNMapProjection retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNMapProjection.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNMapProjection autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNMapProjection.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNMapProjection constructed with the default `new` method.
  factory MLNMapProjection() => new$();
}

late final _sel_mapProjection = objc.registerName("mapProjection");
late final _sel_annotations = objc.registerName("annotations");
late final _sel_addAnnotation_ = objc.registerName("addAnnotation:");
late final _sel_addAnnotations_ = objc.registerName("addAnnotations:");
late final _sel_removeAnnotation_ = objc.registerName("removeAnnotation:");
late final _sel_removeAnnotations_ = objc.registerName("removeAnnotations:");
late final _class_MLNAnnotationView = objc.getClass("MLNAnnotationView");

/// MLNAnnotationView
class MLNAnnotationView extends objc.ObjCObjectBase {
  MLNAnnotationView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNAnnotationView] that points to the same underlying object as [other].
  MLNAnnotationView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNAnnotationView] that wraps the given raw object pointer.
  MLNAnnotationView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNAnnotationView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNAnnotationView);
  }
}

late final _sel_viewForAnnotation_ = objc.registerName("viewForAnnotation:");
late final _class_MLNAnnotationImage = objc.getClass("MLNAnnotationImage");

/// MLNAnnotationImage
class MLNAnnotationImage extends objc.ObjCObjectBase {
  MLNAnnotationImage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNAnnotationImage] that points to the same underlying object as [other].
  MLNAnnotationImage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNAnnotationImage] that wraps the given raw object pointer.
  MLNAnnotationImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNAnnotationImage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNAnnotationImage);
  }
}

late final _sel_dequeueReusableAnnotationImageWithIdentifier_ =
    objc.registerName("dequeueReusableAnnotationImageWithIdentifier:");
late final _sel_dequeueReusableAnnotationViewWithIdentifier_ =
    objc.registerName("dequeueReusableAnnotationViewWithIdentifier:");
late final _sel_visibleAnnotations = objc.registerName("visibleAnnotations");
late final _sel_visibleAnnotationsInRect_ =
    objc.registerName("visibleAnnotationsInRect:");
late final _sel_selectedAnnotations = objc.registerName("selectedAnnotations");
late final _sel_setSelectedAnnotations_ =
    objc.registerName("setSelectedAnnotations:");
late final _sel_selectAnnotation_animated_ =
    objc.registerName("selectAnnotation:animated:");
late final _sel_selectAnnotation_animated_completionHandler_ =
    objc.registerName("selectAnnotation:animated:completionHandler:");
final _objc_msgSend_na2nx0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_selectAnnotation_moveIntoView_animateSelection_completionHandler_ =
    objc.registerName(
        "selectAnnotation:moveIntoView:animateSelection:completionHandler:");
final _objc_msgSend_2nhnqw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_deselectAnnotation_animated_ =
    objc.registerName("deselectAnnotation:animated:");
late final _sel_overlays = objc.registerName("overlays");
late final _protocol_MLNOverlay = objc.getProtocol("MLNOverlay");
late final _sel_overlayBounds = objc.registerName("overlayBounds");
MLNCoordinateBounds _ObjCBlock_MLNCoordinateBounds_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    MLNCoordinateBounds Function(ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)>()(
        arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_MLNCoordinateBounds_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                MLNCoordinateBounds Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_MLNCoordinateBounds_ffiVoid_fnPtrTrampoline)
        .cast();
MLNCoordinateBounds _ObjCBlock_MLNCoordinateBounds_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as MLNCoordinateBounds Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_MLNCoordinateBounds_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                MLNCoordinateBounds Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_MLNCoordinateBounds_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_MLNCoordinateBounds_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      MLNCoordinateBounds Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_MLNCoordinateBounds_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)>
      fromFunction(MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_MLNCoordinateBounds_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_MLNCoordinateBounds_ffiVoid_CallExtension
    on objc.ObjCBlock<MLNCoordinateBounds Function(ffi.Pointer<ffi.Void>)> {
  MLNCoordinateBounds call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              MLNCoordinateBounds Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          MLNCoordinateBounds Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_intersectsOverlayBounds_ =
    objc.registerName("intersectsOverlayBounds:");
final _objc_msgSend_10h1dgu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateBounds)>();
bool _ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        MLNCoordinateBounds arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<ffi.Void> arg0, MLNCoordinateBounds arg1)>>()
        .asFunction<
            bool Function(
                ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>(
            _ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        MLNCoordinateBounds arg1) =>
    (objc.getBlockClosure(block) as bool Function(
        ffi.Pointer<ffi.Void>, MLNCoordinateBounds))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>(
            _ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>`.
abstract final class ObjCBlock_bool_ffiVoid_MLNCoordinateBounds {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, MLNCoordinateBounds arg1)>>
                  ptr) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>(
              objc.newPointerBlock(
                  _ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, MLNCoordinateBounds arg1) =>
                  fn(arg0, arg1),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>`.
extension ObjCBlock_bool_ffiVoid_MLNCoordinateBounds_CallExtension on objc
    .ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds)> {
  bool call(ffi.Pointer<ffi.Void> arg0, MLNCoordinateBounds arg1) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0, MLNCoordinateBounds arg1)>>()
          .asFunction<
              bool Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  MLNCoordinateBounds)>()(ref.pointer, arg0, arg1);
}

/// The ``MLNOverlay`` protocol defines a specific type of annotation that represents
/// both a point and an area on a map. Overlay objects are essentially data objects
/// that contain the geographic data needed to represent the map area. Overlays can
/// take the form of a polyline or polygon.
///
/// You use overlays to layer more sophisticated content on top of a map view. For
/// example, you could use an overlay to show the boundaries of a national park or
/// trace a bus route along city streets. This SDK defines several concrete classes
/// that conform to this protocol and define standard shapes.
interface class MLNOverlay extends objc.ObjCProtocolBase
    implements MLNAnnotation {
  MLNOverlay._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNOverlay] that points to the same underlying object as [other].
  MLNOverlay.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNOverlay] that wraps the given raw object pointer.
  MLNOverlay.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNOverlay].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNOverlay);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNOverlay.cast());

  /// Builds an object that implements the MLNOverlay protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNOverlay implement(
      {required CLLocationCoordinate2D Function() coordinate,
      required MLNCoordinateBounds Function() overlayBounds,
      required bool Function(MLNCoordinateBounds) intersectsOverlayBounds_,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNOverlay');
    MLNOverlay.coordinate.implement(builder, coordinate);
    MLNOverlay.overlayBounds.implement(builder, overlayBounds);
    MLNOverlay.intersectsOverlayBounds_
        .implement(builder, intersectsOverlayBounds_);
    MLNOverlay.title.implement(builder, title);
    MLNOverlay.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
    return MLNOverlay.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNOverlay protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required CLLocationCoordinate2D Function() coordinate,
      required MLNCoordinateBounds Function() overlayBounds,
      required bool Function(MLNCoordinateBounds) intersectsOverlayBounds_,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    MLNOverlay.coordinate.implement(builder, coordinate);
    MLNOverlay.overlayBounds.implement(builder, overlayBounds);
    MLNOverlay.intersectsOverlayBounds_
        .implement(builder, intersectsOverlayBounds_);
    MLNOverlay.title.implement(builder, title);
    MLNOverlay.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  static final coordinate =
      objc.ObjCProtocolMethod<CLLocationCoordinate2D Function()>(
    _protocol_MLNOverlay,
    _sel_coordinate,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    CLLocationCoordinate2D Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_neuenc)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOverlay,
      _sel_coordinate,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CLLocationCoordinate2D Function() func) =>
        ObjCBlock_CLLocationCoordinate2D_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The cooordinate rectangle that encompasses the overlay. (required) (read-only)
  ///
  /// This property contains the smallest rectangle that completely encompasses the
  /// overlay. Implementers of this protocol must set this area when implementing
  /// their overlay class, and after setting it, you must not change it.
  ///
  /// If this overlay spans the antimeridian, its bounds may extend west of −180 degrees
  /// longitude or east of 180 degrees longitude. For example, an overlay covering the
  /// Pacific Ocean from Tokyo to San Francisco might have a bounds extending
  /// from (35.68476, −220.24257) to (37.78428, −122.41310).
  static final overlayBounds =
      objc.ObjCProtocolMethod<MLNCoordinateBounds Function()>(
    _protocol_MLNOverlay,
    _sel_overlayBounds,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    MLNCoordinateBounds Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1fkc0ji)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOverlay,
      _sel_overlayBounds,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (MLNCoordinateBounds Function() func) =>
        ObjCBlock_MLNCoordinateBounds_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// Returns a Boolean indicating whether the specified rectangle intersects the
  /// receiver’s shape.
  ///
  /// You can implement this method to provide more specific bounds checking for an
  /// overlay. If you do not implement it, the bounding rectangle is used to detect
  /// intersections.
  ///
  /// @param overlayBounds The rectangle to intersect with the receiver’s area.
  /// @return `YES` if any part of the map rectangle intersects the receiver’s shape
  /// or `NO` if it does not.
  static final intersectsOverlayBounds_ =
      objc.ObjCProtocolMethod<bool Function(MLNCoordinateBounds)>(
    _protocol_MLNOverlay,
    _sel_intersectsOverlayBounds_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, MLNCoordinateBounds)>>(
            _MapLibreFFi_protocolTrampoline_krbldm)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOverlay,
      _sel_intersectsOverlayBounds_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function(MLNCoordinateBounds) func) =>
        ObjCBlock_bool_ffiVoid_MLNCoordinateBounds.fromFunction(
            (ffi.Pointer<ffi.Void> _, MLNCoordinateBounds arg1) => func(arg1)),
  );

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  static final title = objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_MLNOverlay,
    _sel_title,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOverlay,
      _sel_title,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  static final subtitle = objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_MLNOverlay,
    _sel_subtitle,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOverlay,
      _sel_subtitle,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );
}

late final _sel_addOverlay_ = objc.registerName("addOverlay:");
late final _sel_addOverlays_ = objc.registerName("addOverlays:");
late final _sel_removeOverlay_ = objc.registerName("removeOverlay:");
late final _sel_removeOverlays_ = objc.registerName("removeOverlays:");
late final _sel_visibleFeaturesAtPoint_ =
    objc.registerName("visibleFeaturesAtPoint:");
final _objc_msgSend_wgkxx2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>();
late final _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_ =
    objc.registerName("visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:");
late final _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_predicate_ =
    objc.registerName(
        "visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:");
final _objc_msgSend_19l1l5m = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGPoint,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_visibleFeaturesInRect_ =
    objc.registerName("visibleFeaturesInRect:");
late final _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_ =
    objc.registerName("visibleFeaturesInRect:inStyleLayersWithIdentifiers:");
late final _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_predicate_ =
    objc.registerName(
        "visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:");
final _objc_msgSend_1o8sa9u = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.CGRect,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_debugMask = objc.registerName("debugMask");
final _objc_msgSend_1kwkjor = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setDebugMask_ = objc.registerName("setDebugMask:");
final _objc_msgSend_pisvbv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isRenderingStatsViewEnabled =
    objc.registerName("isRenderingStatsViewEnabled");
late final _sel_enableRenderingStatsView_ =
    objc.registerName("enableRenderingStatsView:");
late final _sel_getActionJournalLogFiles =
    objc.registerName("getActionJournalLogFiles");
late final _sel_getActionJournalLog = objc.registerName("getActionJournalLog");
late final _sel_clearActionJournalLog =
    objc.registerName("clearActionJournalLog");
late final _sel_backendResource = objc.registerName("backendResource");
late final _sel_triggerRepaint = objc.registerName("triggerRepaint");
late final _sel_addPluginLayerType_ = objc.registerName("addPluginLayerType:");

/// An interactive, customizable map view with an interface similar to the one
/// provided by Apple’s MapKit.
///
/// Using ``MLNMapView``, you can embed the map inside a view, allow users to
/// manipulate it with standard gestures, animate the map between different
/// viewpoints, and present information in the form of annotations and overlays.
///
/// The map view loads scalable vector tiles that conform to the
/// <a href="https://github.com/mapbox/vector-tile-spec">Mapbox Vector Tile Specification</a>.
/// It styles them with a style that conforms to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Spec</a>.
/// Such styles can be designed with
/// <a href="https://maplibre.org/maputnik/">Maputnik</a>.
///
///
/// Because ``MLNMapView`` loads asynchronously, several delegate methods are available
/// for receiving map-related updates. These methods can be used to ensure that certain operations
/// have completed before taking any additional actions. Information on these methods is located
/// in the ``MLNMapViewDelegate`` protocol documentation.
///
/// Adding your own gesture recognizer to ``MLNMapView`` will block the corresponding
/// gesture recognizer built into ``MLNMapView``. To avoid conflicts, define which
/// gesture takes precedence. For example, you can create your own
/// `UITapGestureRecognizer` that will be invoked only if the default ``MLNMapView``
/// tap gesture fails:
///
/// ```swift
/// let mapTapGestureRecognizer = UITapGestureRecognizer(target: self, action:
/// #selector(myCustomFunction)) for recognizer in mapView.gestureRecognizers! where recognizer is
/// UITapGestureRecognizer { mapTapGestureRecognizer.require(toFail: recognizer)
/// }
/// mapView.addGestureRecognizer(mapTapGestureRecognizer)
/// ```
///
/// > Note: You are responsible for getting permission to use the map data and for
/// ensuring that your use adheres to the relevant terms of use.
class MLNMapView extends UIView implements MLNStylable {
  MLNMapView._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMapView] that points to the same underlying object as [other].
  MLNMapView.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMapView] that wraps the given raw object pointer.
  MLNMapView.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMapView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapView);
  }

  /// initWithFrame:
  MLNMapView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('MLNMapView.initWithFrame:',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// Initializes and returns a newly allocated map view with the specified frame
  /// and style URL.
  ///
  /// @param frame The frame for the view, measured in points.
  /// @param styleURL URL of the map style to display. The URL may be a full HTTP
  /// or HTTPS URL, a canonical URL or a path to a local file relative
  /// to the application’s resource path. Specify `nil` for the default style.
  /// @return An initialized map view.
  ///
  /// #### Related examples
  ///
  /// - TODO: initialize an ``MLNMapView`` with a custom style
  /// - TODO: how to initialize an ``MLNMapView`` with a third-party tile source
  MLNMapView initWithFrame2(objc.CGRect frame, {objc.NSURL? styleURL}) {
    final _ret = _objc_msgSend_gxusyk(
        this.ref.retainAndReturnPointer(),
        _sel_initWithFrame_styleURL_,
        frame,
        styleURL?.ref.pointer ?? ffi.nullptr);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// Initializes and returns a newly allocated map view with the specified frame
  /// and style JSON.
  ///
  /// @param frame The frame for the view, measured in points.
  /// @param styleJSON JSON string of the map style to display. The JSON must conform to the
  /// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
  /// Specify `nil` for the default style.
  /// @return An initialized map view.
  MLNMapView initWithFrame$1(objc.CGRect frame,
      {required objc.NSString styleJSON}) {
    final _ret = _objc_msgSend_gxusyk(this.ref.retainAndReturnPointer(),
        _sel_initWithFrame_styleJSON_, frame, styleJSON.ref.pointer);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// Initializes and returns a newly allocated map view with the specified frame
  /// and the default style.
  ///
  /// @param frame The frame for the view, measured in points.
  /// @param options The map instance options
  /// @return An initialized map view.
  MLNMapView initWithFrame$2(objc.CGRect frame,
      {required MLNMapOptions options}) {
    final _ret = _objc_msgSend_gxusyk(this.ref.retainAndReturnPointer(),
        _sel_initWithFrame_options_, frame, options.ref.pointer);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// The receiver’s delegate.
  ///
  /// A map view sends messages to its delegate to notify it of changes to its
  /// contents or the viewpoint. The delegate also provides information about
  /// annotations displayed on the map, such as the styles to apply to individual
  /// annotations.
  MLNMapViewDelegate? get delegate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : MLNMapViewDelegate.castFromPointer(_ret, retain: true, release: true);
  }

  /// The receiver’s delegate.
  ///
  /// A map view sends messages to its delegate to notify it of changes to its
  /// contents or the viewpoint. The delegate also provides information about
  /// annotations displayed on the map, such as the styles to apply to individual
  /// annotations.
  set delegate(MLNMapViewDelegate? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The style currently displayed in the receiver.
  MLNStyle? get style {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_style);
    return _ret.address == 0
        ? null
        : MLNStyle.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL of the style currently displayed in the receiver.
  ///
  /// The URL may be a full HTTP or HTTPS URL, canonical URL, or
  /// a path to a local file relative to the application’s resource path.
  ///
  /// If you set this property to `nil`, the receiver will use the default style
  /// and this property will automatically be set to that style’s URL.
  ///
  /// If you want to modify the current style without replacing it outright, or if
  /// you want to introspect individual style attributes, use the `style` property.
  ///
  /// #### Related examples
  /// - TODO: change the style of a map at runtime.
  objc.NSURL get styleURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_styleURL);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URL of the style currently displayed in the receiver.
  ///
  /// The URL may be a full HTTP or HTTPS URL, canonical URL, or
  /// a path to a local file relative to the application’s resource path.
  ///
  /// If you set this property to `nil`, the receiver will use the default style
  /// and this property will automatically be set to that style’s URL.
  ///
  /// If you want to modify the current style without replacing it outright, or if
  /// you want to introspect individual style attributes, use the `style` property.
  ///
  /// #### Related examples
  /// - TODO: change the style of a map at runtime.
  set styleURL(objc.NSURL value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setStyleURL_, value.ref.pointer);
  }

  /// The style JSON representation of the map.
  ///
  /// Setting this property results in an asynchronous style change. If you wish to know when the style
  /// change is complete, observe the ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` method
  /// on ``MLNMapViewDelegate``.
  ///
  /// The JSON must conform to the
  /// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
  ///
  /// @throws NSInvalidArgumentException if styleJSON is nil or invalid JSON
  objc.NSString get styleJSON {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_styleJSON);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The style JSON representation of the map.
  ///
  /// Setting this property results in an asynchronous style change. If you wish to know when the style
  /// change is complete, observe the ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` method
  /// on ``MLNMapViewDelegate``.
  ///
  /// The JSON must conform to the
  /// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
  ///
  /// @throws NSInvalidArgumentException if styleJSON is nil or invalid JSON
  set styleJSON(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setStyleJSON_, value.ref.pointer);
  }

  /// Reloads the style.
  ///
  /// You do not normally need to call this method. The map view automatically
  /// responds to changes in network connectivity by reloading the style.
  ///
  /// This method does not bust the cache. Even if the style has recently changed on
  /// the server, calling this method does not necessarily ensure that the map view
  /// reflects those changes.
  void reloadStyle(objc.ObjCObjectBase? sender) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_reloadStyle_,
        sender?.ref.pointer ?? ffi.nullptr);
  }

  /// A boolean value that indicates if whether the map view should automatically
  /// adjust its content insets.
  ///
  /// When this property is set to `YES` the map automatically updates its
  /// `contentInset` property to account for any area not covered by navigation bars,
  /// tab bars, toolbars, and other ancestors that obscure the map view.
  bool get automaticallyAdjustsContentInset {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_automaticallyAdjustsContentInset);
  }

  /// A boolean value that indicates if whether the map view should automatically
  /// adjust its content insets.
  ///
  /// When this property is set to `YES` the map automatically updates its
  /// `contentInset` property to account for any area not covered by navigation bars,
  /// tab bars, toolbars, and other ancestors that obscure the map view.
  set automaticallyAdjustsContentInset(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAutomaticallyAdjustsContentInset_, value);
  }

  /// A Boolean value indicating whether the map may display scale information.
  ///
  /// The scale bar may not be shown at all zoom levels. The scale bar becomes visible
  /// when the maximum distance visible on the map view is less than 400 miles (800
  /// kilometers). The zoom level where this occurs depends on the latitude at the map
  /// view’s center coordinate, as well as the device screen width. At latitudes
  /// farther from the equator, the scale bar becomes visible at lower zoom levels.
  ///
  /// The unit of measurement is determined by the user's device locale.
  ///
  /// The view controlled by this property is available at `scaleBar`. The default value
  /// of this property is `NO`.
  bool get showsScale {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsScale);
  }

  /// A Boolean value indicating whether the map may display scale information.
  ///
  /// The scale bar may not be shown at all zoom levels. The scale bar becomes visible
  /// when the maximum distance visible on the map view is less than 400 miles (800
  /// kilometers). The zoom level where this occurs depends on the latitude at the map
  /// view’s center coordinate, as well as the device screen width. At latitudes
  /// farther from the equator, the scale bar becomes visible at lower zoom levels.
  ///
  /// The unit of measurement is determined by the user's device locale.
  ///
  /// The view controlled by this property is available at `scaleBar`. The default value
  /// of this property is `NO`.
  set showsScale(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsScale_, value);
  }

  /// A control indicating the scale of the map. The scale bar is positioned in the
  /// upper-left corner. Enable the scale bar via `showsScale`.
  MLNScaleBar get scaleBar {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_scaleBar);
    return MLNScaleBar.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sets whether the scale uses styles that make it easier to read on a dark styled map
  bool get scaleBarShouldShowDarkStyles {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_scaleBarShouldShowDarkStyles);
  }

  /// Sets whether the scale uses styles that make it easier to read on a dark styled map
  set scaleBarShouldShowDarkStyles(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setScaleBarShouldShowDarkStyles_, value);
  }

  /// Sets whether the scale uses metric
  bool get scaleBarUsesMetricSystem {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_scaleBarUsesMetricSystem);
  }

  /// Sets whether the scale uses metric
  set scaleBarUsesMetricSystem(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setScaleBarUsesMetricSystem_, value);
  }

  /// The position of the scale bar. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionTopLeft``.
  MLNOrnamentPosition get scaleBarPosition {
    final _ret = _objc_msgSend_1c31cvt(this.ref.pointer, _sel_scaleBarPosition);
    return MLNOrnamentPosition.fromValue(_ret);
  }

  /// The position of the scale bar. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionTopLeft``.
  set scaleBarPosition(MLNOrnamentPosition value) {
    _objc_msgSend_8fd115(
        this.ref.pointer, _sel_setScaleBarPosition_, value.value);
  }

  /// A `CGPoint` indicating the position offset of the scale bar.
  objc.CGPoint get scaleBarMargins {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_scaleBarMargins)
        : _ptr.ref =
            _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_scaleBarMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// A `CGPoint` indicating the position offset of the scale bar.
  set scaleBarMargins(objc.CGPoint value) {
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setScaleBarMargins_, value);
  }

  /// A control indicating the map’s direction and allowing the user to manipulate
  /// the direction, positioned in the upper-right corner.
  MLNCompassButton get compassView {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_compassView);
    return MLNCompassButton.castFromPointer(_ret, retain: true, release: true);
  }

  /// The position of the compass view. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionTopRight``.
  MLNOrnamentPosition get compassViewPosition {
    final _ret =
        _objc_msgSend_1c31cvt(this.ref.pointer, _sel_compassViewPosition);
    return MLNOrnamentPosition.fromValue(_ret);
  }

  /// The position of the compass view. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionTopRight``.
  set compassViewPosition(MLNOrnamentPosition value) {
    _objc_msgSend_8fd115(
        this.ref.pointer, _sel_setCompassViewPosition_, value.value);
  }

  /// A `CGPoint` indicating the position offset of the compass.
  objc.CGPoint get compassViewMargins {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_compassViewMargins)
        : _ptr.ref =
            _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_compassViewMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// A `CGPoint` indicating the position offset of the compass.
  set compassViewMargins(objc.CGPoint value) {
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setCompassViewMargins_, value);
  }

  /// A logo, the MapLibre logo by default, positioned in the lower-left corner.
  /// You are not required to display this, but some vector-sources may require attribution.
  UIImageView get logoView {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_logoView);
    return UIImageView.castFromPointer(_ret, retain: true, release: true);
  }

  /// The position of the logo view. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionBottomLeft``.
  MLNOrnamentPosition get logoViewPosition {
    final _ret = _objc_msgSend_1c31cvt(this.ref.pointer, _sel_logoViewPosition);
    return MLNOrnamentPosition.fromValue(_ret);
  }

  /// The position of the logo view. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionBottomLeft``.
  set logoViewPosition(MLNOrnamentPosition value) {
    _objc_msgSend_8fd115(
        this.ref.pointer, _sel_setLogoViewPosition_, value.value);
  }

  /// A `CGPoint` indicating the position offset of the logo.
  objc.CGPoint get logoViewMargins {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_logoViewMargins)
        : _ptr.ref =
            _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_logoViewMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// A `CGPoint` indicating the position offset of the logo.
  set logoViewMargins(objc.CGPoint value) {
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setLogoViewMargins_, value);
  }

  /// A view showing legally required copyright notices,
  /// positioned at the bottom-right of the map view.
  ///
  /// If you choose to reimplement this view, assign the `-showAttribution:` method
  /// as the action for your view to present the default notices and settings.
  ///
  /// > Note: Attribution is often required for many vector sources,
  /// OpenStreetMap data, or other data such as satellite or terrain
  /// data. If that applies to this map view, do not hide this view or remove
  /// any notices from it.
  UIButton get attributionButton {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_attributionButton);
    return UIButton.castFromPointer(_ret, retain: true, release: true);
  }

  /// The position of the attribution button. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionBottomRight``.
  MLNOrnamentPosition get attributionButtonPosition {
    final _ret =
        _objc_msgSend_1c31cvt(this.ref.pointer, _sel_attributionButtonPosition);
    return MLNOrnamentPosition.fromValue(_ret);
  }

  /// The position of the attribution button. The default value is
  /// ``MLNOrnamentPosition/MLNOrnamentPositionBottomRight``.
  set attributionButtonPosition(MLNOrnamentPosition value) {
    _objc_msgSend_8fd115(
        this.ref.pointer, _sel_setAttributionButtonPosition_, value.value);
  }

  /// A `CGPoint` indicating the position offset of the attribution.
  objc.CGPoint get attributionButtonMargins {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            _ptr, this.ref.pointer, _sel_attributionButtonMargins)
        : _ptr.ref = _objc_msgSend_1uwdhlk(
            this.ref.pointer, _sel_attributionButtonMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// A `CGPoint` indicating the position offset of the attribution.
  set attributionButtonMargins(objc.CGPoint value) {
    _objc_msgSend_iy8iz6(
        this.ref.pointer, _sel_setAttributionButtonMargins_, value);
  }

  /// Show the attribution action sheet.
  ///
  /// This action is performed when the user taps on the attribution button provided
  /// by default via the `attributionButton` property. If you implement a custom
  /// attribution button, you should add this action to the button.
  void showAttribution(objc.ObjCObjectBase sender) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_showAttribution_, sender.ref.pointer);
  }

  /// The preferred frame rate at which the map view is rendered.
  ///
  /// The default value for this property is
  /// ``MLNMapViewPreferredFramesPerSecondDefault``, which will adaptively set the
  /// preferred frame rate based on the capability of the user’s device to maintain
  /// a smooth experience.
  ///
  /// In addition to the provided ``MLNMapViewPreferredFramesPerSecond`` options, this
  /// property can be set to arbitrary integer values.
  ///
  /// @see `CADisplayLink.preferredFramesPerSecond`
  int get preferredFramesPerSecond {
    return _objc_msgSend_1hz7y9r(
        this.ref.pointer, _sel_preferredFramesPerSecond);
  }

  /// The preferred frame rate at which the map view is rendered.
  ///
  /// The default value for this property is
  /// ``MLNMapViewPreferredFramesPerSecondDefault``, which will adaptively set the
  /// preferred frame rate based on the capability of the user’s device to maintain
  /// a smooth experience.
  ///
  /// In addition to the provided ``MLNMapViewPreferredFramesPerSecond`` options, this
  /// property can be set to arbitrary integer values.
  ///
  /// @see `CADisplayLink.preferredFramesPerSecond`
  set preferredFramesPerSecond(int value) {
    _objc_msgSend_4sp4xj(
        this.ref.pointer, _sel_setPreferredFramesPerSecond_, value);
  }

  /// A Boolean value indicating whether the map should prefetch tiles.
  ///
  /// When this property is set to `YES`, the map view prefetches tiles designed for
  /// a low zoom level and displays them until receiving more detailed tiles for the
  /// current zoom level. The prefetched tiles typically contain simplified versions
  /// of each shape, improving the map view’s perceived performance.
  ///
  /// The default value of this property is `YES`.
  bool get prefetchesTiles {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefetchesTiles);
  }

  /// A Boolean value indicating whether the map should prefetch tiles.
  ///
  /// When this property is set to `YES`, the map view prefetches tiles designed for
  /// a low zoom level and displays them until receiving more detailed tiles for the
  /// current zoom level. The prefetched tiles typically contain simplified versions
  /// of each shape, improving the map view’s perceived performance.
  ///
  /// The default value of this property is `YES`.
  set prefetchesTiles(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setPrefetchesTiles_, value);
  }

  /// A Boolean value indicating whether the map may cache tiles for different zoom levels or not.
  ///
  /// When this property is set to `YES`,  the map view consumes more memory and
  /// provide a smoother user experience when zoom in/out.
  ///
  /// The default value of this property is `YES`.
  bool get tileCacheEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_tileCacheEnabled);
  }

  /// A Boolean value indicating whether the map may cache tiles for different zoom levels or not.
  ///
  /// When this property is set to `YES`,  the map view consumes more memory and
  /// provide a smoother user experience when zoom in/out.
  ///
  /// The default value of this property is `YES`.
  set tileCacheEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setTileCacheEnabled_, value);
  }

  /// Camera based tile level of detail controls
  ///
  /// Minimum radius around the view point in unit of tiles in which the fine
  /// grained zoom level tiles are always used when performing LOD
  /// radius must be greater than 1 (At least 1 fine detailed tile is present)
  /// A smaller radius value may improve performance at the cost of quality (tiles away from
  /// camera use lower Zoom levels)
  double get tileLodMinRadius {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_tileLodMinRadius)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_tileLodMinRadius);
  }

  /// Camera based tile level of detail controls
  ///
  /// Minimum radius around the view point in unit of tiles in which the fine
  /// grained zoom level tiles are always used when performing LOD
  /// radius must be greater than 1 (At least 1 fine detailed tile is present)
  /// A smaller radius value may improve performance at the cost of quality (tiles away from
  /// camera use lower Zoom levels)
  set tileLodMinRadius(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setTileLodMinRadius_, value);
  }

  /// Camera based tile level of detail controls
  ///
  /// Factor for the distance to the camera view point
  /// A value larger than 1 increases the distance to the camera view point reducing LOD
  /// Larger values may improve performance at the cost of quality (tiles away from camera
  /// use lower Zoom levels)
  double get tileLodScale {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_tileLodScale)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_tileLodScale);
  }

  /// Camera based tile level of detail controls
  ///
  /// Factor for the distance to the camera view point
  /// A value larger than 1 increases the distance to the camera view point reducing LOD
  /// Larger values may improve performance at the cost of quality (tiles away from camera
  /// use lower Zoom levels)
  set tileLodScale(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setTileLodScale_, value);
  }

  /// Camera based tile level of detail controls
  ///
  /// Pitch angle in radians above which LOD calculation is performed
  /// A smaller radius value may improve performance at the cost of quality
  double get tileLodPitchThreshold {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            this.ref.pointer, _sel_tileLodPitchThreshold)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_tileLodPitchThreshold);
  }

  /// Camera based tile level of detail controls
  ///
  /// Pitch angle in radians above which LOD calculation is performed
  /// A smaller radius value may improve performance at the cost of quality
  set tileLodPitchThreshold(double value) {
    _objc_msgSend_hwm8nu(
        this.ref.pointer, _sel_setTileLodPitchThreshold_, value);
  }

  /// Camera based tile level of detail controls
  ///
  /// Shift applied to the Zoom level during LOD calculation
  /// A negative value shifts the Zoom level to a coarser level reducing quality but improving
  /// performance A positive value shifts the Zoom level to a finer level increasing details but
  /// negatively affecting performance A value of zero (default) does not apply any shift to the Zoom
  /// level It is not recommended to change the default value unless performance is critical and the loss
  /// of quality is acceptable. A value of -1 reduces the number of displayed tiles by a factor of 4 on
  /// average It is recommended to first configure the pixelRatio before adjusting TileLodZoomShift.
  double get tileLodZoomShift {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_tileLodZoomShift)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_tileLodZoomShift);
  }

  /// Camera based tile level of detail controls
  ///
  /// Shift applied to the Zoom level during LOD calculation
  /// A negative value shifts the Zoom level to a coarser level reducing quality but improving
  /// performance A positive value shifts the Zoom level to a finer level increasing details but
  /// negatively affecting performance A value of zero (default) does not apply any shift to the Zoom
  /// level It is not recommended to change the default value unless performance is critical and the loss
  /// of quality is acceptable. A value of -1 reduces the number of displayed tiles by a factor of 4 on
  /// average It is recommended to first configure the pixelRatio before adjusting TileLodZoomShift.
  set tileLodZoomShift(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setTileLodZoomShift_, value);
  }

  /// The object that this map view uses to start and stop the delivery of
  /// location-related updates.
  ///
  /// To receive the current user location, implement the
  /// ``MLNMapViewDelegate/mapView:didUpdateUserLocation:`` and
  /// ``MLNMapViewDelegate/mapView:didFailToLocateUserWithError:`` methods.
  ///
  /// If setting this property to `nil` or if no custom manager is provided this
  /// property is set to the default location manager.
  ///
  /// ``MLNMapView`` uses a default location manager. If you want to substitute your
  /// own location manager, you should do so by setting this property before setting
  /// `showsUserLocation` to `YES`. To restore the default location manager,
  /// set this property to `nil`.
  MLNLocationManager get locationManager {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_locationManager);
    return MLNLocationManager.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// The object that this map view uses to start and stop the delivery of
  /// location-related updates.
  ///
  /// To receive the current user location, implement the
  /// ``MLNMapViewDelegate/mapView:didUpdateUserLocation:`` and
  /// ``MLNMapViewDelegate/mapView:didFailToLocateUserWithError:`` methods.
  ///
  /// If setting this property to `nil` or if no custom manager is provided this
  /// property is set to the default location manager.
  ///
  /// ``MLNMapView`` uses a default location manager. If you want to substitute your
  /// own location manager, you should do so by setting this property before setting
  /// `showsUserLocation` to `YES`. To restore the default location manager,
  /// set this property to `nil`.
  set locationManager(MLNLocationManager value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLocationManager_, value.ref.pointer);
  }

  /// A Boolean value indicating whether the map may display the user location.
  ///
  /// Setting this property to `YES` causes the map view to use the Core Location
  /// framework to find the current location. As long as this property is `YES`, the
  /// map view continues to track the user’s location and update it periodically.
  ///
  /// This property does not indicate whether the user’s position is actually visible
  /// on the map, only whether the map view is allowed to display it. To determine
  /// whether the user’s position is visible, use the `userLocationVisible` property.
  /// The default value of this property is `NO`.
  ///
  /// Your app must specify a value for `NSLocationWhenInUseUsageDescription` or
  /// `NSLocationAlwaysUsageDescription` in its `Info.plist` to satisfy the
  /// requirements of the underlying Core Location framework when enabling this
  /// property.
  ///
  /// If you implement a custom location manager, set the `locationManager` before
  /// calling `showsUserLocation`.
  bool get showsUserLocation {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsUserLocation);
  }

  /// A Boolean value indicating whether the map may display the user location.
  ///
  /// Setting this property to `YES` causes the map view to use the Core Location
  /// framework to find the current location. As long as this property is `YES`, the
  /// map view continues to track the user’s location and update it periodically.
  ///
  /// This property does not indicate whether the user’s position is actually visible
  /// on the map, only whether the map view is allowed to display it. To determine
  /// whether the user’s position is visible, use the `userLocationVisible` property.
  /// The default value of this property is `NO`.
  ///
  /// Your app must specify a value for `NSLocationWhenInUseUsageDescription` or
  /// `NSLocationAlwaysUsageDescription` in its `Info.plist` to satisfy the
  /// requirements of the underlying Core Location framework when enabling this
  /// property.
  ///
  /// If you implement a custom location manager, set the `locationManager` before
  /// calling `showsUserLocation`.
  set showsUserLocation(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsUserLocation_, value);
  }

  /// A boolean value indicating whether camera animation duration is set based
  /// on the time difference between the last location update and the current one
  /// or the default animation duration of 1 second.
  ///
  /// The default value of this property is `NO`
  bool get dynamicNavigationCameraAnimationDuration {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_dynamicNavigationCameraAnimationDuration);
  }

  /// A boolean value indicating whether camera animation duration is set based
  /// on the time difference between the last location update and the current one
  /// or the default animation duration of 1 second.
  ///
  /// The default value of this property is `NO`
  set dynamicNavigationCameraAnimationDuration(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setDynamicNavigationCameraAnimationDuration_, value);
  }

  /// A Boolean value indicating whether the map may request authorization to use location services.
  ///
  /// Setting this property to `YES` causes the map view to use the Core Location
  /// framework to request authorization when authorizationStatus == kCLAuthorizationStatusNotDetermined.
  ///
  /// The default value of this property is `YES`.
  bool get shouldRequestAuthorizationToUseLocationServices {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_shouldRequestAuthorizationToUseLocationServices);
  }

  /// A Boolean value indicating whether the map may request authorization to use location services.
  ///
  /// Setting this property to `YES` causes the map view to use the Core Location
  /// framework to request authorization when authorizationStatus == kCLAuthorizationStatusNotDetermined.
  ///
  /// The default value of this property is `YES`.
  set shouldRequestAuthorizationToUseLocationServices(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setShouldRequestAuthorizationToUseLocationServices_, value);
  }

  /// A Boolean value indicating whether the device’s current location is visible in
  /// the map view.
  ///
  /// Use `showsUserLocation` to control the visibility of the on-screen user
  /// location annotation.
  bool get userLocationVisible {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isUserLocationVisible);
  }

  /// Returns the annotation object indicating the user’s current location.
  MLNUserLocation? get userLocation {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_userLocation);
    return _ret.address == 0
        ? null
        : MLNUserLocation.castFromPointer(_ret, retain: true, release: true);
  }

  /// The mode used to track the user location. The default value is
  /// ``MLNUserTrackingMode/MLNUserTrackingModeNone``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setUserTrackingMode:animated:` method instead.
  ///
  /// #### Related examples
  /// - TODO: Customize the user location annotation and learn how to customize the
  /// default user location annotation shown by ``MLNUserTrackingMode``.
  MLNUserTrackingMode get userTrackingMode {
    final _ret = _objc_msgSend_1swtepj(this.ref.pointer, _sel_userTrackingMode);
    return MLNUserTrackingMode.fromValue(_ret);
  }

  /// The mode used to track the user location. The default value is
  /// ``MLNUserTrackingMode/MLNUserTrackingModeNone``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setUserTrackingMode:animated:` method instead.
  ///
  /// #### Related examples
  /// - TODO: Customize the user location annotation and learn how to customize the
  /// default user location annotation shown by ``MLNUserTrackingMode``.
  set userTrackingMode(MLNUserTrackingMode value) {
    _objc_msgSend_xoapar(
        this.ref.pointer, _sel_setUserTrackingMode_, value.value);
  }

  /// Deprecated. Sets the mode used to track the user location, with an optional transition.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-setUserTrackingMode:animated:completionHandler:` method.
  ///
  /// @param mode The mode used to track the user location.
  /// @param animated If `YES`, there is an animated transition from the current
  /// viewport to a viewport that results from the change to `mode`. If `NO`, the
  /// map view instantaneously changes to the new viewport. This parameter only
  /// affects the initial transition; subsequent changes to the user location or
  /// heading are always animated.
  void setUserTrackingMode(MLNUserTrackingMode mode, {required bool animated}) {
    _objc_msgSend_7oa3sf(this.ref.pointer, _sel_setUserTrackingMode_animated_,
        mode.value, animated);
  }

  /// Sets the mode used to track the user location, with an optional transition and
  /// completion handler.
  ///
  /// @param mode The mode used to track the user location.
  /// @param animated If `YES`, there is an animated transition from the current
  /// viewport to a viewport that results from the change to `mode`. If `NO`, the
  /// map view instantaneously changes to the new viewport. This parameter only
  /// affects the initial transition; subsequent changes to the user location or
  /// heading are always animated.
  /// @param completion The block executed after the animation finishes.
  void setUserTrackingMode$1(MLNUserTrackingMode mode,
      {required bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_1iu40ms(
        this.ref.pointer,
        _sel_setUserTrackingMode_animated_completionHandler_,
        mode.value,
        animated,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// The vertical alignment of the user location annotation within the receiver. The
  /// default value is ``MLNAnnotationVerticalAlignment/MLNAnnotationVerticalAlignmentCenter``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setUserLocationVerticalAlignment:animated:` method instead.
  MLNAnnotationVerticalAlignment get userLocationVerticalAlignment {
    final _ret = _objc_msgSend_1m9zum6(
        this.ref.pointer, _sel_userLocationVerticalAlignment);
    return MLNAnnotationVerticalAlignment.fromValue(_ret);
  }

  /// The vertical alignment of the user location annotation within the receiver. The
  /// default value is ``MLNAnnotationVerticalAlignment/MLNAnnotationVerticalAlignmentCenter``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setUserLocationVerticalAlignment:animated:` method instead.
  set userLocationVerticalAlignment(MLNAnnotationVerticalAlignment value) {
    _objc_msgSend_47doj4(
        this.ref.pointer, _sel_setUserLocationVerticalAlignment_, value.value);
  }

  /// Sets the vertical alignment of the user location annotation within the
  /// receiver, with an optional transition.
  ///
  /// @param alignment The vertical alignment of the user location annotation.
  /// @param animated If `YES`, the user location annotation animates to its new
  /// position within the map view. If `NO`, the user location annotation
  /// instantaneously moves to its new position.
  void setUserLocationVerticalAlignment(
      MLNAnnotationVerticalAlignment alignment,
      {required bool animated}) {
    _objc_msgSend_1qddrus(
        this.ref.pointer,
        _sel_setUserLocationVerticalAlignment_animated_,
        alignment.value,
        animated);
  }

  /// Updates the position of the user location annotation view by retreiving the user's last
  /// known location.
  void updateUserLocationAnnotationView() {
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_updateUserLocationAnnotationView);
  }

  /// Updates the position of the user location annotation view by retreiving the user's last
  /// known location with a specified duration.
  /// @param duration The duration to animate the change in seconds.
  void updateUserLocationAnnotationViewAnimatedWithDuration(double duration) {
    _objc_msgSend_hwm8nu(this.ref.pointer,
        _sel_updateUserLocationAnnotationViewAnimatedWithDuration_, duration);
  }

  /// A Boolean value indicating whether the user location annotation may display a
  /// permanent heading indicator.
  ///
  /// Setting this property to `YES` causes the default user location annotation to
  /// appear and always show an arrow-shaped heading indicator, if heading is
  /// available. This property does not rotate the map; for that, see
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading``.
  ///
  /// This property has no effect when ``userTrackingMode`` is
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading`` or
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// The default value of this property is `NO`.
  bool get showsUserHeadingIndicator {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_showsUserHeadingIndicator);
  }

  /// A Boolean value indicating whether the user location annotation may display a
  /// permanent heading indicator.
  ///
  /// Setting this property to `YES` causes the default user location annotation to
  /// appear and always show an arrow-shaped heading indicator, if heading is
  /// available. This property does not rotate the map; for that, see
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading``.
  ///
  /// This property has no effect when ``userTrackingMode`` is
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading`` or
  /// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// The default value of this property is `NO`.
  set showsUserHeadingIndicator(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setShowsUserHeadingIndicator_, value);
  }

  /// Whether the map view should display a heading calibration alert when necessary.
  /// The default value is `YES`.
  bool get displayHeadingCalibration {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_displayHeadingCalibration);
  }

  /// Whether the map view should display a heading calibration alert when necessary.
  /// The default value is `YES`.
  set displayHeadingCalibration(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setDisplayHeadingCalibration_, value);
  }

  /// The geographic coordinate that is the subject of observation as the user
  /// location is being tracked.
  ///
  /// By default, this property is set to an invalid coordinate, indicating that
  /// there is no target. In course tracking mode, the target forms one of two foci
  /// in the viewport, the other being the user location annotation. Typically, this
  /// property is set to a destination or waypoint in a real-time navigation scene.
  /// As the user annotation moves toward the target, the map automatically zooms in
  /// to fit both foci optimally within the viewport.
  ///
  /// This property has no effect if the `userTrackingMode` property is set to a
  /// value other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setTargetCoordinate:animated:` method instead.
  CLLocationCoordinate2D get targetCoordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(
            _ptr, this.ref.pointer, _sel_targetCoordinate)
        : _ptr.ref =
            _objc_msgSend_18o5nok(this.ref.pointer, _sel_targetCoordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The geographic coordinate that is the subject of observation as the user
  /// location is being tracked.
  ///
  /// By default, this property is set to an invalid coordinate, indicating that
  /// there is no target. In course tracking mode, the target forms one of two foci
  /// in the viewport, the other being the user location annotation. Typically, this
  /// property is set to a destination or waypoint in a real-time navigation scene.
  /// As the user annotation moves toward the target, the map automatically zooms in
  /// to fit both foci optimally within the viewport.
  ///
  /// This property has no effect if the `userTrackingMode` property is set to a
  /// value other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// Changing the value of this property updates the map view with an animated
  /// transition. If you don’t want to animate the change, use the
  /// `-setTargetCoordinate:animated:` method instead.
  set targetCoordinate(CLLocationCoordinate2D value) {
    _objc_msgSend_1zv0am(this.ref.pointer, _sel_setTargetCoordinate_, value);
  }

  /// Deprecated. Sets the geographic coordinate that is the subject of observation as
  /// the user location is being tracked, with an optional transition animation.
  ///
  /// By default, the target coordinate is set to an invalid coordinate, indicating
  /// that there is no target. In course tracking mode, the target forms one of two
  /// foci in the viewport, the other being the user location annotation. Typically,
  /// the target is set to a destination or waypoint in a real-time navigation scene.
  /// As the user annotation moves toward the target, the map automatically zooms in
  /// to fit both foci optimally within the viewport.
  ///
  /// This method has no effect if the `userTrackingMode` property is set to a value
  /// other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-setTargetCoordinate:animated:completionHandler:` method.
  ///
  /// @param targetCoordinate The target coordinate to fit within the viewport.
  /// @param animated If `YES`, the map animates to fit the target within the map
  /// view. If `NO`, the map fits the target instantaneously.
  void setTargetCoordinate(CLLocationCoordinate2D targetCoordinate$1,
      {required bool animated}) {
    _objc_msgSend_o7hjv2(this.ref.pointer, _sel_setTargetCoordinate_animated_,
        targetCoordinate$1, animated);
  }

  /// Sets the geographic coordinate that is the subject of observation as the user
  /// location is being tracked, with an optional transition animation and completion
  /// handler.
  ///
  /// By default, the target coordinate is set to an invalid coordinate, indicating
  /// that there is no target. In course tracking mode, the target forms one of two
  /// foci in the viewport, the other being the user location annotation. Typically,
  /// the target is set to a destination or waypoint in a real-time navigation scene.
  /// As the user annotation moves toward the target, the map automatically zooms in
  /// to fit both foci optimally within the viewport.
  ///
  /// This method has no effect if the `userTrackingMode` property is set to a value
  /// other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
  ///
  /// @param targetCoordinate The target coordinate to fit within the viewport.
  /// @param animated If `YES`, the map animates to fit the target within the map
  /// view. If `NO`, the map fits the target instantaneously.
  /// @param completion The block executed after the animation finishes.
  void setTargetCoordinate$1(CLLocationCoordinate2D targetCoordinate$1,
      {required bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_1pbhom5(
        this.ref.pointer,
        _sel_setTargetCoordinate_animated_completionHandler_,
        targetCoordinate$1,
        animated,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// A Boolean value that determines whether the user may zoom the map in and
  /// out, changing the zoom level.
  ///
  /// When this property is set to `YES`, the default, the user may zoom the map
  /// in and out by pinching two fingers or by double tapping, holding, and moving
  /// the finger up and down.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the map zoom
  /// programmatically.
  bool get zoomEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isZoomEnabled);
  }

  /// A Boolean value that determines whether the user may zoom the map in and
  /// out, changing the zoom level.
  ///
  /// When this property is set to `YES`, the default, the user may zoom the map
  /// in and out by pinching two fingers or by double tapping, holding, and moving
  /// the finger up and down.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the map zoom
  /// programmatically.
  set zoomEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setZoomEnabled_, value);
  }

  /// A boolean value that reverses the direction of the quick zoom gesture.
  ///
  /// When this property is set, the zoom-in and zoom-out behavior during the quick
  /// zoom gesture (also called one-finger zoom) is reversed, aligning with the
  /// behavior in Apple Maps. The default value is `NO`.
  bool get quickZoomReversed {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isQuickZoomReversed);
  }

  /// A boolean value that reverses the direction of the quick zoom gesture.
  ///
  /// When this property is set, the zoom-in and zoom-out behavior during the quick
  /// zoom gesture (also called one-finger zoom) is reversed, aligning with the
  /// behavior in Apple Maps. The default value is `NO`.
  set quickZoomReversed(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setQuickZoomReversed_, value);
  }

  /// A Boolean value that determines whether the user may scroll around the map,
  /// changing the center coordinate.
  ///
  /// When this property is set to `YES`, the default, the user may scroll the map
  /// by dragging or swiping with one finger.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the map location
  /// programmatically.
  bool get scrollEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isScrollEnabled);
  }

  /// A Boolean value that determines whether the user may scroll around the map,
  /// changing the center coordinate.
  ///
  /// When this property is set to `YES`, the default, the user may scroll the map
  /// by dragging or swiping with one finger.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the map location
  /// programmatically.
  set scrollEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setScrollEnabled_, value);
  }

  /// The scrolling mode the user is allowed to use to interact with the map.
  ///
  /// `MLNPanScrollingModeHorizontal` only allows the user to scroll horizontally on the map,
  /// restricting a user's ability to scroll vertically.
  /// `MLNPanScrollingModeVertical` only allows the user to scroll vertically on the map,
  /// restricting a user's ability to scroll horizontally.
  /// ``MLNPanScrollingMode/MLNPanScrollingModeDefault`` allows the user to scroll both horizontally and
  /// vertically on the map.
  ///
  /// By default, this property is set to ``MLNPanScrollingMode/MLNPanScrollingModeDefault``.
  MLNPanScrollingMode get panScrollingMode {
    final _ret = _objc_msgSend_1vb5jwj(this.ref.pointer, _sel_panScrollingMode);
    return MLNPanScrollingMode.fromValue(_ret);
  }

  /// The scrolling mode the user is allowed to use to interact with the map.
  ///
  /// `MLNPanScrollingModeHorizontal` only allows the user to scroll horizontally on the map,
  /// restricting a user's ability to scroll vertically.
  /// `MLNPanScrollingModeVertical` only allows the user to scroll vertically on the map,
  /// restricting a user's ability to scroll horizontally.
  /// ``MLNPanScrollingMode/MLNPanScrollingModeDefault`` allows the user to scroll both horizontally and
  /// vertically on the map.
  ///
  /// By default, this property is set to ``MLNPanScrollingMode/MLNPanScrollingModeDefault``.
  set panScrollingMode(MLNPanScrollingMode value) {
    _objc_msgSend_k7jknj(
        this.ref.pointer, _sel_setPanScrollingMode_, value.value);
  }

  /// A Boolean value that determines whether the user may rotate the map,
  /// changing the direction.
  ///
  /// When this property is set to `YES`, the default, the user may rotate the map
  /// by moving two fingers in a circular motion.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still rotate the map
  /// programmatically.
  bool get rotateEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isRotateEnabled);
  }

  /// A Boolean value that determines whether the user may rotate the map,
  /// changing the direction.
  ///
  /// When this property is set to `YES`, the default, the user may rotate the map
  /// by moving two fingers in a circular motion.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still rotate the map
  /// programmatically.
  set rotateEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setRotateEnabled_, value);
  }

  /// A Boolean value that determines whether the user may change the pitch (tilt) of
  /// the map.
  ///
  /// When this property is set to `YES`, the default, the user may tilt the map by
  /// vertically dragging two fingers.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the pitch of the map
  /// programmatically.
  ///
  /// The default value of this property is `YES`.
  bool get pitchEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isPitchEnabled);
  }

  /// A Boolean value that determines whether the user may change the pitch (tilt) of
  /// the map.
  ///
  /// When this property is set to `YES`, the default, the user may tilt the map by
  /// vertically dragging two fingers.
  ///
  /// This property controls only user interactions with the map. If you set the
  /// value of this property to `NO`, you may still change the pitch of the map
  /// programmatically.
  ///
  /// The default value of this property is `YES`.
  set pitchEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setPitchEnabled_, value);
  }

  /// A Boolean value that determines whether gestures are anchored to the center coordinate of the map
  /// while rotating or zooming. Default value is set to NO.
  bool get anchorRotateOrZoomGesturesToCenterCoordinate {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_anchorRotateOrZoomGesturesToCenterCoordinate);
  }

  /// A Boolean value that determines whether gestures are anchored to the center coordinate of the map
  /// while rotating or zooming. Default value is set to NO.
  set anchorRotateOrZoomGesturesToCenterCoordinate(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer,
        _sel_setAnchorRotateOrZoomGesturesToCenterCoordinate_, value);
  }

  /// A Boolean value that determines whether the user will receive haptic feedback
  /// for certain interactions with the map.
  ///
  /// When this property is set to `YES`, the default, a `UIImpactFeedbackStyleLight`
  /// haptic feedback event be played when the user rotates the map to due north
  /// (0°).
  ///
  /// This feature requires a device that supports haptic feedback, running iOS 10 or
  /// newer.
  bool get hapticFeedbackEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHapticFeedbackEnabled);
  }

  /// A Boolean value that determines whether the user will receive haptic feedback
  /// for certain interactions with the map.
  ///
  /// When this property is set to `YES`, the default, a `UIImpactFeedbackStyleLight`
  /// haptic feedback event be played when the user rotates the map to due north
  /// (0°).
  ///
  /// This feature requires a device that supports haptic feedback, running iOS 10 or
  /// newer.
  set hapticFeedbackEnabled(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setHapticFeedbackEnabled_, value);
  }

  /// A floating-point value that determines the rate of deceleration after the user
  /// lifts their finger.
  ///
  /// Your application can use the ``MLNMapViewDecelerationRateNormal`` and
  /// ``MLNMapViewDecelerationRateFast`` constants as reference points for reasonable
  /// deceleration rates. ``MLNMapViewDecelerationRateImmediate`` can be used to
  /// disable deceleration entirely.
  double get decelerationRate {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_decelerationRate)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_decelerationRate);
  }

  /// A floating-point value that determines the rate of deceleration after the user
  /// lifts their finger.
  ///
  /// Your application can use the ``MLNMapViewDecelerationRateNormal`` and
  /// ``MLNMapViewDecelerationRateFast`` constants as reference points for reasonable
  /// deceleration rates. ``MLNMapViewDecelerationRateImmediate`` can be used to
  /// disable deceleration entirely.
  set decelerationRate(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setDecelerationRate_, value);
  }

  /// The geographic coordinate at the center of the map view.
  ///
  /// Changing the value of this property centers the map on the new coordinate
  /// without changing the current zoom level.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setCenterCoordinate:animated:` method
  /// instead.
  CLLocationCoordinate2D get centerCoordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(
            _ptr, this.ref.pointer, _sel_centerCoordinate)
        : _ptr.ref =
            _objc_msgSend_18o5nok(this.ref.pointer, _sel_centerCoordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The geographic coordinate at the center of the map view.
  ///
  /// Changing the value of this property centers the map on the new coordinate
  /// without changing the current zoom level.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setCenterCoordinate:animated:` method
  /// instead.
  set centerCoordinate(CLLocationCoordinate2D value) {
    _objc_msgSend_1zv0am(this.ref.pointer, _sel_setCenterCoordinate_, value);
  }

  /// Changes the center coordinate of the map and optionally animates the change.
  ///
  /// Changing the center coordinate centers the map on the new coordinate without
  /// changing the current zoom level. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param coordinate The new center coordinate for the map.
  /// @param animated Specify `YES` if you want the map view to scroll to the new
  /// location or `NO` if you want the map to display the new location
  /// immediately.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate(CLLocationCoordinate2D coordinate,
      {required bool animated}) {
    _objc_msgSend_o7hjv2(this.ref.pointer, _sel_setCenterCoordinate_animated_,
        coordinate, animated);
  }

  /// Changes the center coordinate and zoom level of the map and optionally animates
  /// the change. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param centerCoordinate The new center coordinate for the map.
  /// @param zoomLevel The new zoom level for the map.
  /// @param animated Specify `YES` if you want the map view to animate scrolling and
  /// zooming to the new location or `NO` if you want the map to display the new
  /// location immediately.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate$1(CLLocationCoordinate2D centerCoordinate$1,
      {required double zoomLevel, required bool animated}) {
    _objc_msgSend_sbs4d5(
        this.ref.pointer,
        _sel_setCenterCoordinate_zoomLevel_animated_,
        centerCoordinate$1,
        zoomLevel,
        animated);
  }

  /// Changes the center coordinate, zoom level, and direction of the map and
  /// optionally animates the change. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param centerCoordinate The new center coordinate for the map.
  /// @param zoomLevel The new zoom level for the map.
  /// @param direction The new direction for the map, measured in degrees relative to
  /// true north. A negative value leaves the map’s direction unchanged.
  /// @param animated Specify `YES` if you want the map view to animate scrolling,
  /// zooming, and rotating to the new location or `NO` if you want the map to
  /// display the new location immediately.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate$2(CLLocationCoordinate2D centerCoordinate$1,
      {required double zoomLevel,
      required double direction,
      required bool animated}) {
    _objc_msgSend_3zczym(
        this.ref.pointer,
        _sel_setCenterCoordinate_zoomLevel_direction_animated_,
        centerCoordinate$1,
        zoomLevel,
        direction,
        animated);
  }

  /// Changes the center coordinate, zoom level, and direction of the map, calling a
  /// completion handler at the end of an optional animation. For animated changes,
  /// wait until the map view has finished loading before calling this method.
  ///
  /// @param centerCoordinate The new center coordinate for the map.
  /// @param zoomLevel The new zoom level for the map.
  /// @param direction The new direction for the map, measured in degrees relative to
  /// true north. A negative value leaves the map’s direction unchanged.
  /// @param animated Specify `YES` if you want the map view to animate scrolling,
  /// zooming, and rotating to the new location or `NO` if you want the map to
  /// display the new location immediately.
  /// @param completion The block executed after the animation finishes.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate$3(CLLocationCoordinate2D centerCoordinate$1,
      {required double zoomLevel,
      required double direction,
      required bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_d9pvdp(
        this.ref.pointer,
        _sel_setCenterCoordinate_zoomLevel_direction_animated_completionHandler_,
        centerCoordinate$1,
        zoomLevel,
        direction,
        animated,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// The zoom level of the receiver.
  ///
  /// In addition to affecting the visual size and detail of features on the map,
  /// the zoom level affects the size of the vector tiles that are loaded. At zoom
  /// level 0, each tile covers the entire world map; at zoom level 1, it covers ¼
  /// of the world; at zoom level 2, <sup>1</sup>⁄<sub>16</sub> of the world, and
  /// so on.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setZoomLevel:animated:` method instead.
  double get zoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_zoomLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_zoomLevel);
  }

  /// The zoom level of the receiver.
  ///
  /// In addition to affecting the visual size and detail of features on the map,
  /// the zoom level affects the size of the vector tiles that are loaded. At zoom
  /// level 0, each tile covers the entire world map; at zoom level 1, it covers ¼
  /// of the world; at zoom level 2, <sup>1</sup>⁄<sub>16</sub> of the world, and
  /// so on.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setZoomLevel:animated:` method instead.
  set zoomLevel(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setZoomLevel_, value);
  }

  /// Changes the zoom level of the map and optionally animates the change.
  ///
  /// Changing the zoom level scales the map without changing the current center
  /// coordinate.
  ///
  /// @param zoomLevel The new zoom level for the map.
  /// @param animated Specify `YES` if you want the map view to animate the change
  /// to the new zoom level or `NO` if you want the map to display the new
  /// zoom level immediately.
  void setZoomLevel(double zoomLevel$1, {required bool animated}) {
    _objc_msgSend_ghxo7e(
        this.ref.pointer, _sel_setZoomLevel_animated_, zoomLevel$1, animated);
  }

  /// The minimum zoom level at which the map can be shown.
  ///
  /// Depending on the map view’s aspect ratio, the map view may be prevented
  /// from reaching the minimum zoom level, in order to keep the map from
  /// repeating within the current viewport.
  ///
  /// If the value of this property is greater than that of the
  /// maximumZoomLevel property, the behavior is undefined.
  ///
  /// The default minimumZoomLevel is 0.
  double get minimumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumZoomLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumZoomLevel);
  }

  /// The minimum zoom level at which the map can be shown.
  ///
  /// Depending on the map view’s aspect ratio, the map view may be prevented
  /// from reaching the minimum zoom level, in order to keep the map from
  /// repeating within the current viewport.
  ///
  /// If the value of this property is greater than that of the
  /// maximumZoomLevel property, the behavior is undefined.
  ///
  /// The default minimumZoomLevel is 0.
  set minimumZoomLevel(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumZoomLevel_, value);
  }

  /// The maximum zoom level the map can be shown at.
  ///
  /// If the value of this property is smaller than that of the
  /// minimumZoomLevel property, the behavior is undefined.
  ///
  /// The default maximumZoomLevel is 22. The upper bound for this property
  /// is 25.5.
  double get maximumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_maximumZoomLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_maximumZoomLevel);
  }

  /// The maximum zoom level the map can be shown at.
  ///
  /// If the value of this property is smaller than that of the
  /// minimumZoomLevel property, the behavior is undefined.
  ///
  /// The default maximumZoomLevel is 22. The upper bound for this property
  /// is 25.5.
  set maximumZoomLevel(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMaximumZoomLevel_, value);
  }

  /// The maximum bounds of the map that can be shown on screen.
  ///
  /// @param MLNCoordinateBounds the bounds to constrain the screen to.
  MLNCoordinateBounds get maximumScreenBounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(
            _ptr, this.ref.pointer, _sel_maximumScreenBounds)
        : _ptr.ref =
            _objc_msgSend_ygoa6a(this.ref.pointer, _sel_maximumScreenBounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// The maximum bounds of the map that can be shown on screen.
  ///
  /// @param MLNCoordinateBounds the bounds to constrain the screen to.
  set maximumScreenBounds(MLNCoordinateBounds value) {
    _objc_msgSend_9ay59k(this.ref.pointer, _sel_setMaximumScreenBounds_, value);
  }

  /// The heading of the map, measured in degrees clockwise from true north.
  ///
  /// The value `0` means that the top edge of the map view corresponds to true
  /// north. The value `90` means the top of the map is pointing due east. The
  /// value `180` means the top of the map points due south, and so on.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setDirection:animated:` method instead.
  double get direction {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_direction)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_direction);
  }

  /// The heading of the map, measured in degrees clockwise from true north.
  ///
  /// The value `0` means that the top edge of the map view corresponds to true
  /// north. The value `90` means the top of the map is pointing due east. The
  /// value `180` means the top of the map points due south, and so on.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setDirection:animated:` method instead.
  set direction(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setDirection_, value);
  }

  /// Changes the heading of the map and optionally animates the change.
  ///
  /// @param direction The heading of the map, measured in degrees clockwise from
  /// true north.
  /// @param animated Specify `YES` if you want the map view to animate the change
  /// to the new heading or `NO` if you want the map to display the new
  /// heading immediately.
  ///
  /// Changing the heading rotates the map without changing the current center
  /// coordinate or zoom level.
  void setDirection(double direction$1, {required bool animated}) {
    _objc_msgSend_ghxo7e(
        this.ref.pointer, _sel_setDirection_animated_, direction$1, animated);
  }

  /// The minimum pitch of the map’s camera toward the horizon measured in degrees.
  ///
  /// If the value of this property is greater than that of the `maximumPitch`
  /// property, the behavior is undefined. The pitch may not be less than 0
  /// regardless of this property.
  ///
  /// The default value of this property is 0 degrees, allowing the map to appear
  /// two-dimensional.
  double get minimumPitch {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumPitch)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumPitch);
  }

  /// The minimum pitch of the map’s camera toward the horizon measured in degrees.
  ///
  /// If the value of this property is greater than that of the `maximumPitch`
  /// property, the behavior is undefined. The pitch may not be less than 0
  /// regardless of this property.
  ///
  /// The default value of this property is 0 degrees, allowing the map to appear
  /// two-dimensional.
  set minimumPitch(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumPitch_, value);
  }

  /// The maximum pitch of the map’s camera toward the horizon measured in degrees.
  ///
  /// If the value of this property is smaller than that of the `minimumPitch`
  /// property, the behavior is undefined. The pitch may not exceed 60 degrees
  /// regardless of this property.
  ///
  /// The default value of this property is 60 degrees.
  double get maximumPitch {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_maximumPitch)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_maximumPitch);
  }

  /// The maximum pitch of the map’s camera toward the horizon measured in degrees.
  ///
  /// If the value of this property is smaller than that of the `minimumPitch`
  /// property, the behavior is undefined. The pitch may not exceed 60 degrees
  /// regardless of this property.
  ///
  /// The default value of this property is 60 degrees.
  set maximumPitch(double value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMaximumPitch_, value);
  }

  /// Resets the map rotation to a northern heading — a `direction` of `0` degrees.
  void resetNorth() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resetNorth);
  }

  /// Resets the map to the current style’s default viewport.
  ///
  /// If the style doesn’t specify a default viewport, the map resets to a minimum
  /// zoom level, a center coordinate of (0, 0), and a northern heading.
  void resetPosition() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resetPosition);
  }

  /// The coordinate bounds visible in the receiver’s viewport.
  ///
  /// Changing the value of this property updates the receiver immediately. If you
  /// want to animate the change, call `-setVisibleCoordinateBounds:animated:`
  /// instead.
  ///
  /// If a longitude is less than −180 degrees or greater than 180 degrees, the
  /// visible bounds straddles the antimeridian or international date line. For
  /// example, if both Tokyo and San Francisco are visible, the visible bounds might
  /// extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  MLNCoordinateBounds get visibleCoordinateBounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(
            _ptr, this.ref.pointer, _sel_visibleCoordinateBounds)
        : _ptr.ref = _objc_msgSend_ygoa6a(
            this.ref.pointer, _sel_visibleCoordinateBounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// The coordinate bounds visible in the receiver’s viewport.
  ///
  /// Changing the value of this property updates the receiver immediately. If you
  /// want to animate the change, call `-setVisibleCoordinateBounds:animated:`
  /// instead.
  ///
  /// If a longitude is less than −180 degrees or greater than 180 degrees, the
  /// visible bounds straddles the antimeridian or international date line. For
  /// example, if both Tokyo and San Francisco are visible, the visible bounds might
  /// extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  set visibleCoordinateBounds(MLNCoordinateBounds value) {
    _objc_msgSend_9ay59k(
        this.ref.pointer, _sel_setVisibleCoordinateBounds_, value);
  }

  /// Changes the receiver’s viewport to fit the given coordinate bounds,
  /// optionally animating the change.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible bounds to extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  ///
  /// @param bounds The bounds that the viewport will show in its entirety.
  /// @param animated Specify `YES` to animate the change by smoothly scrolling
  /// and zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinateBounds(MLNCoordinateBounds bounds,
      {required bool animated}) {
    _objc_msgSend_148tmbg(this.ref.pointer,
        _sel_setVisibleCoordinateBounds_animated_, bounds, animated);
  }

  /// Deprecated. Changes the receiver’s viewport to fit the given coordinate bounds with
  /// some additional padding on each side.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible bounds to extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-setVisibleCoordinateBounds:edgePadding:animated:completionHandler:` method.
  ///
  /// @param bounds The bounds that the viewport will show in its entirety.
  /// @param insets The minimum padding (in screen points) that will be visible
  /// around the given coordinate bounds.
  /// @param animated Specify `YES` to animate the change by smoothly scrolling and
  /// zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinateBounds$1(MLNCoordinateBounds bounds,
      {required UIEdgeInsets edgePadding, required bool animated}) {
    _objc_msgSend_18wcmvu(
        this.ref.pointer,
        _sel_setVisibleCoordinateBounds_edgePadding_animated_,
        bounds,
        edgePadding,
        animated);
  }

  /// Changes the receiver’s viewport to fit the given coordinate bounds with some
  /// additional padding on each side, optionally calling a completion handler.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible bounds to extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  ///
  /// @param bounds The bounds that the viewport will show in its entirety.
  /// @param insets The minimum padding (in screen points) that will be visible
  /// around the given coordinate bounds.
  /// @param animated Specify `YES` to animate the change by smoothly scrolling and
  /// zooming or `NO` to immediately display the given bounds.
  /// @param completion The block executed after the animation finishes.
  void setVisibleCoordinateBounds$2(MLNCoordinateBounds bounds,
      {required UIEdgeInsets edgePadding,
      required bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_1v6m6tt(
        this.ref.pointer,
        _sel_setVisibleCoordinateBounds_edgePadding_animated_completionHandler_,
        bounds,
        edgePadding,
        animated,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Changes the receiver’s viewport to fit all of the given coordinates with some
  /// additional padding on each side.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible coordinates to (35.68476, −220.24257) and (37.78428, −122.41310).
  ///
  /// @param coordinates The coordinates that the viewport will show.
  /// @param count The number of coordinates. This number must not be greater than
  /// the number of elements in `coordinates`.
  /// @param insets The minimum padding (in screen points) that will be visible
  /// around the given coordinate bounds.
  /// @param animated Specify `YES` to animate the change by smoothly scrolling and
  /// zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinates(ffi.Pointer<CLLocationCoordinate2D> coordinates,
      {required int count,
      required UIEdgeInsets edgePadding,
      required bool animated}) {
    _objc_msgSend_1evryr5(
        this.ref.pointer,
        _sel_setVisibleCoordinates_count_edgePadding_animated_,
        coordinates,
        count,
        edgePadding,
        animated);
  }

  /// Changes the receiver’s viewport to fit all of the given coordinates with some
  /// additional padding on each side, optionally calling a completion handler.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible coordinates to (35.68476, −220.24257) and (37.78428, −122.41310).
  ///
  /// @param coordinates The coordinates that the viewport will show.
  /// @param count The number of coordinates. This number must not be greater than
  /// the number of elements in `coordinates`.
  /// @param insets The minimum padding (in screen points) that will be visible
  /// around the given coordinate bounds.
  /// @param direction The direction to rotate the map to, measured in degrees
  /// relative to true north. A negative value leaves the map’s direction
  /// unchanged.
  /// @param duration The duration to animate the change in seconds.
  /// @param function The timing function to animate the change.
  /// @param completion The block executed after the animation finishes.
  void setVisibleCoordinates$1(ffi.Pointer<CLLocationCoordinate2D> coordinates,
      {required int count,
      required UIEdgeInsets edgePadding,
      required double direction$1,
      required double duration,
      CAMediaTimingFunction? animationTimingFunction,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_v2jdd0(
        this.ref.pointer,
        _sel_setVisibleCoordinates_count_edgePadding_direction_duration_animationTimingFunction_completionHandler_,
        coordinates,
        count,
        edgePadding,
        direction$1,
        duration,
        animationTimingFunction?.ref.pointer ?? ffi.nullptr,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Sets the visible region so that the map displays the specified annotations.
  ///
  /// Calling this method updates the value in the `visibleCoordinateBounds` property
  /// and potentially other properties to reflect the new map region. A small amount
  /// of padding is reserved around the edges of the map view. To specify a different
  /// amount of padding, use the `-showAnnotations:edgePadding:animated:` method.
  ///
  /// @param annotations The annotations that you want to be visible in the map.
  /// @param animated `YES` if you want the map region change to be animated, or `NO`
  /// if you want the map to display the new region immediately without animations.
  void showAnnotations(objc.NSArray annotations, {required bool animated}) {
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_showAnnotations_animated_,
        annotations.ref.pointer, animated);
  }

  /// Deprecated. Sets the visible region so that the map displays the specified
  /// annotations with the specified amount of padding on each side.
  ///
  /// Calling this method updates the value in the `visibleCoordinateBounds` property
  /// and potentially other properties to reflect the new map region.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-showAnnotations:edgePadding:animated:completionHandler:` method.
  ///
  /// @param annotations The annotations that you want to be visible in the map.
  /// @param insets The minimum padding (in screen points) around the edges of the
  /// map view to keep clear of annotations.
  /// @param animated `YES` if you want the map region change to be animated, or `NO`
  /// if you want the map to display the new region immediately without animations.
  void showAnnotations$1(objc.NSArray annotations,
      {required UIEdgeInsets edgePadding, required bool animated}) {
    _objc_msgSend_1f4zv7b(
        this.ref.pointer,
        _sel_showAnnotations_edgePadding_animated_,
        annotations.ref.pointer,
        edgePadding,
        animated);
  }

  /// Sets the visible region so that the map displays the specified annotations with
  /// the specified amount of padding on each side and an optional completion
  /// handler.
  ///
  /// Calling this method updates the value in the `visibleCoordinateBounds` property
  /// and potentially other properties to reflect the new map region.
  ///
  /// @param annotations The annotations that you want to be visible in the map.
  /// @param insets The minimum padding (in screen points) around the edges of the
  /// map view to keep clear of annotations.
  /// @param animated `YES` if you want the map region change to be animated, or `NO`
  /// if you want the map to display the new region immediately without animations.
  /// @param completion The block executed after the animation finishes.
  void showAnnotations$2(objc.NSArray annotations,
      {required UIEdgeInsets edgePadding,
      required bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_16lja1o(
        this.ref.pointer,
        _sel_showAnnotations_edgePadding_animated_completionHandler_,
        annotations.ref.pointer,
        edgePadding,
        animated,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// A camera representing the current viewpoint of the map.
  MLNMapCamera get camera {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_camera);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// A camera representing the current viewpoint of the map.
  set camera(MLNMapCamera value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCamera_, value.ref.pointer);
  }

  /// Moves the viewpoint to a different location with respect to the map with an
  /// optional transition animation. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param camera The new viewpoint.
  /// @param animated Specify `YES` if you want the map view to animate the change to
  /// the new viewpoint or `NO` if you want the map to display the new viewpoint
  /// immediately.
  ///
  /// #### Related examples
  /// - TODO: Camera animation: learn how to trigger an animation that rotates around a central point.
  void setCamera(MLNMapCamera camera$1, {required bool animated}) {
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_setCamera_animated_,
        camera$1.ref.pointer, animated);
  }

  /// Moves the viewpoint to a different location with respect to the map with an
  /// optional transition duration and timing function. For animated changes, wait
  /// until the map view has finished loading before calling this method.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously.
  /// @param function A timing function used for the animation. Set this parameter to
  /// `nil` for a transition that matches most system animations. If the duration
  /// is `0`, this parameter is ignored.
  ///
  /// #### Related examples
  /// - TODO: Camera animation: learn how to create a timed animation that
  /// rotates around a central point for a specific duration.
  void setCamera$1(MLNMapCamera camera$1,
      {required double withDuration,
      CAMediaTimingFunction? animationTimingFunction}) {
    _objc_msgSend_r1s65y(
        this.ref.pointer,
        _sel_setCamera_withDuration_animationTimingFunction_,
        camera$1.ref.pointer,
        withDuration,
        animationTimingFunction?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location with respect to the map with an
  /// optional transition duration and timing function. For animated changes, wait
  /// until the map view has finished loading before calling this method.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously.
  /// @param function A timing function used for the animation. Set this parameter to
  /// `nil` for a transition that matches most system animations. If the duration
  /// is `0`, this parameter is ignored.
  /// @param completion The block to execute after the animation finishes.
  void setCamera$2(MLNMapCamera camera$1,
      {required double withDuration,
      CAMediaTimingFunction? animationTimingFunction,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_1s40ged(
        this.ref.pointer,
        _sel_setCamera_withDuration_animationTimingFunction_completionHandler_,
        camera$1.ref.pointer,
        withDuration,
        animationTimingFunction?.ref.pointer ?? ffi.nullptr,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location with respect to the map with an
  /// optional transition duration and timing function, and optionally some additional
  /// padding on each side. For animated changes, wait until the map view has
  /// finished loading before calling this method.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously.
  /// @param function A timing function used for the animation. Set this parameter to
  /// `nil` for a transition that matches most system animations. If the duration
  /// is `0`, this parameter is ignored.
  /// @param edgePadding The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @param completion The block to execute after the animation finishes.
  void setCamera$3(MLNMapCamera camera$1,
      {required double withDuration,
      CAMediaTimingFunction? animationTimingFunction,
      required UIEdgeInsets edgePadding,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_tm3gbn(
        this.ref.pointer,
        _sel_setCamera_withDuration_animationTimingFunction_edgePadding_completionHandler_,
        camera$1.ref.pointer,
        withDuration,
        animationTimingFunction?.ref.pointer ?? ffi.nullptr,
        edgePadding,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location using a transition animation that
  /// evokes powered flight and a default duration based on the length of the flight
  /// path.
  ///
  /// The transition animation seamlessly incorporates zooming and panning to help
  /// the user find his or her bearings even after traversing a great distance.
  ///
  /// @param camera The new viewpoint.
  /// @param completion The block to execute after the animation finishes.
  void flyToCamera(MLNMapCamera camera$1,
      {objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_o762yo(this.ref.pointer, _sel_flyToCamera_completionHandler_,
        camera$1.ref.pointer, completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location using a transition animation that
  /// evokes powered flight and an optional transition duration.
  ///
  /// The transition animation seamlessly incorporates zooming and panning to help
  /// the user find his or her bearings even after traversing a great distance.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously. Specify a negative value to use the default duration, which
  /// is based on the length of the flight path.
  /// @param completion The block to execute after the animation finishes.
  void flyToCamera$1(MLNMapCamera camera$1,
      {required double withDuration,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_a85mgj(
        this.ref.pointer,
        _sel_flyToCamera_withDuration_completionHandler_,
        camera$1.ref.pointer,
        withDuration,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location using a transition animation that
  /// evokes powered flight and an optional transition duration and peak altitude.
  ///
  /// The transition animation seamlessly incorporates zooming and panning to help
  /// the user find his or her bearings even after traversing a great distance.
  ///
  /// @param camera The new viewpoint.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously. Specify a negative value to use the default duration, which
  /// is based on the length of the flight path.
  /// @param peakAltitude The altitude, measured in meters, at the midpoint of the
  /// animation. The value of this parameter is ignored if it is negative or if
  /// the animation transition resulting from a similar call to
  /// `-setCamera:animated:` would have a midpoint at a higher altitude.
  /// @param completion The block to execute after the animation finishes.
  void flyToCamera$2(MLNMapCamera camera$1,
      {required double withDuration,
      required double peakAltitude,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_b0p9a0(
        this.ref.pointer,
        _sel_flyToCamera_withDuration_peakAltitude_completionHandler_,
        camera$1.ref.pointer,
        withDuration,
        peakAltitude,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Moves the viewpoint to a different location using a transition animation that
  /// evokes powered flight.
  ///
  /// The transition animation seamlessly incorporates zooming and panning to help
  /// the user find his or her bearings even after traversing a great distance.
  ///
  /// @param camera The new viewpoint.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver's camera.
  /// @param duration The amount of time, measured in seconds, that the transition
  /// animation should take. Specify `0` to jump to the new viewpoint
  /// instantaneously. Specify a negative value to use the default duration, which
  /// is based on the length of the flight path.
  /// @param completion The block to execute after the animation finishes.
  void flyToCamera$3(MLNMapCamera camera$1,
      {required UIEdgeInsets edgePadding,
      required double withDuration,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_s17tgr(
        this.ref.pointer,
        _sel_flyToCamera_edgePadding_withDuration_completionHandler_,
        camera$1.ref.pointer,
        edgePadding,
        withDuration,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns the camera that best fits the given coordinate bounds.
  ///
  /// @param bounds The coordinate bounds to fit to the receiver’s viewport.
  /// @return A camera object centered on the same location as the coordinate
  /// bounds with zoom level as high (close to the ground) as possible while still
  /// including the entire coordinate bounds. The camera object uses the current
  /// direction and pitch.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsCoordinateBounds(MLNCoordinateBounds bounds) {
    final _ret = _objc_msgSend_5pnf8k(
        this.ref.pointer, _sel_cameraThatFitsCoordinateBounds_, bounds);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the camera that best fits the given coordinate bounds with some
  /// additional padding on each side.
  ///
  /// @param bounds The coordinate bounds to fit to the receiver’s viewport.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @return A camera object centered on the same location as the coordinate bounds
  /// with zoom level as high (close to the ground) as possible while still
  /// including the entire coordinate bounds. The camera object uses the current
  /// direction and pitch.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsCoordinateBounds$1(MLNCoordinateBounds bounds,
      {required UIEdgeInsets edgePadding}) {
    final _ret = _objc_msgSend_1a5ayri(this.ref.pointer,
        _sel_cameraThatFitsCoordinateBounds_edgePadding_, bounds, edgePadding);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the camera that best fits the given coordinate bounds with some
  /// additional padding on each side, matching an existing camera as much as
  /// possible.
  ///
  /// @param camera The camera that the return camera should adhere to. All values
  /// on this camera will be manipulated except for pitch and direction.
  /// @param bounds The coordinate bounds to fit to the receiver’s viewport.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @return A camera object centered on the same location as the coordinate bounds
  /// with zoom level as high (close to the ground) as possible while still
  /// including the entire coordinate bounds. The initial camera's pitch and
  /// direction will be honored.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera camera$1(MLNMapCamera camera$2,
      {required MLNCoordinateBounds fittingCoordinateBounds,
      required UIEdgeInsets edgePadding}) {
    final _ret = _objc_msgSend_1v2rrrs(
        this.ref.pointer,
        _sel_camera_fittingCoordinateBounds_edgePadding_,
        camera$2.ref.pointer,
        fittingCoordinateBounds,
        edgePadding);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the camera that best fits the given shape with some additional padding
  /// on each side, matching an existing camera as much as possible.
  ///
  /// @param camera The camera that the return camera should adhere to. All values
  /// on this camera will be manipulated except for pitch and direction.
  /// @param shape The shape to fit to the receiver’s viewport.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @return A camera object centered on the shape's center with zoom level as high
  /// (close to the ground) as possible while still including the entire shape.
  /// The initial camera's pitch and direction will be honored.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera camera$2(MLNMapCamera camera$3,
      {required MLNShape fittingShape, required UIEdgeInsets edgePadding}) {
    final _ret = _objc_msgSend_53bjzp(
        this.ref.pointer,
        _sel_camera_fittingShape_edgePadding_,
        camera$3.ref.pointer,
        fittingShape.ref.pointer,
        edgePadding);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the camera that best fits the given shape with some additional padding
  /// on each side while looking in the specified direction.
  ///
  /// @param shape The shape to fit to the receiver’s viewport.
  /// @param direction The direction of the viewport, measured in degrees clockwise
  /// from true north.
  /// @param insets The minimum padding (in screen points) that would be visible
  /// around the returned camera object if it were set as the receiver’s camera.
  /// @return A camera object centered on the shape's center with zoom level as high
  /// (close to the ground) as possible while still including the entire shape.
  /// The camera object uses the current pitch.
  ///
  /// > Note: The behavior of this method is undefined if called in response to
  /// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
  /// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsShape(MLNShape shape,
      {required double direction$1, required UIEdgeInsets edgePadding}) {
    final _ret = _objc_msgSend_ebhzse(
        this.ref.pointer,
        _sel_cameraThatFitsShape_direction_edgePadding_,
        shape.ref.pointer,
        direction$1,
        edgePadding);
    return MLNMapCamera.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the point in this view’s coordinate system on which to “anchor” in
  /// response to a user-initiated gesture.
  ///
  /// For example, a pinch-to-zoom gesture would anchor the map at the midpoint of
  /// the pinch.
  ///
  /// If the ``userTrackingMode`` property is not ``MLNUserTrackingMode/MLNUserTrackingModeNone``, the
  /// user annotation is used as the anchor point.
  ///
  /// Subclasses may override this method to provide specialized behavior - for
  /// example, anchoring on the map’s center point to provide a "locked" zooming
  /// mode.
  ///
  /// @param gesture An anchorable user gesture.
  /// @return The point on which to anchor in response to the gesture.
  objc.CGPoint anchorPointForGesture(UIGestureRecognizer gesture) {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1mpyy6yStret(_ptr, this.ref.pointer,
            _sel_anchorPointForGesture_, gesture.ref.pointer)
        : _ptr.ref = _objc_msgSend_1mpyy6y(
            this.ref.pointer, _sel_anchorPointForGesture_, gesture.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// The distance from the edges of the map view’s frame to the edges of the map
  /// view’s logical viewport.
  ///
  /// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
  /// properties such as `centerCoordinate` assume a viewport that matches the map
  /// view’s frame. Otherwise, those properties are inset, excluding part of the
  /// frame from the viewport. For instance, if the only the top edge is inset, the
  /// map center is effectively shifted downward.
  ///
  /// When the map view’s superview is an instance of `UIViewController` whose
  /// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
  /// property may be overridden at any time.
  ///
  /// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
  /// use the map view’s property ``MLNMapView/automaticallyAdjustsContentInset``instead.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setContentInset:animated:completionHandler:`
  /// method instead.
  UIEdgeInsets get contentInset {
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_contentInset)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_contentInset);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// The distance from the edges of the map view’s frame to the edges of the map
  /// view’s logical viewport.
  ///
  /// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
  /// properties such as `centerCoordinate` assume a viewport that matches the map
  /// view’s frame. Otherwise, those properties are inset, excluding part of the
  /// frame from the viewport. For instance, if the only the top edge is inset, the
  /// map center is effectively shifted downward.
  ///
  /// When the map view’s superview is an instance of `UIViewController` whose
  /// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
  /// property may be overridden at any time.
  ///
  /// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
  /// use the map view’s property ``MLNMapView/automaticallyAdjustsContentInset``instead.
  ///
  /// Changing the value of this property updates the map view immediately. If you
  /// want to animate the change, use the `-setContentInset:animated:completionHandler:`
  /// method instead.
  set contentInset(UIEdgeInsets value) {
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setContentInset_, value);
  }

  /// The current edge insets of the current map view’s camera.
  ///
  /// Camera edge insets are formed as accumulation of map view's content insets
  /// and the edge padding passed to the method like `seCamera:...edgePadding:`,
  /// `setVisibleCoordinates:...edgePadding:`, `showAnnotations:...edgePadding:` etc.
  ///
  /// The camera edge insets influences the `centerCoordinate` of the viewport.
  /// This value is read-only, in order to apply paddings,  use either persistent
  /// `contentInset`, either transient `edgePadding` parameter of the `set...` methods.
  UIEdgeInsets get cameraEdgeInsets {
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            _ptr, this.ref.pointer, _sel_cameraEdgeInsets)
        : _ptr.ref =
            _objc_msgSend_ct4cu5(this.ref.pointer, _sel_cameraEdgeInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// Deprecated. Sets the distance from the edges of the map view’s frame to the edges
  /// of the map view’s logical viewport with an optional transition animation.
  ///
  /// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
  /// properties such as `centerCoordinate` assume a viewport that matches the map
  /// view’s frame. Otherwise, those properties are inset, excluding part of the
  /// frame from the viewport. For instance, if the only the top edge is inset, the
  /// map center is effectively shifted downward.
  ///
  /// When the map view’s superview is an instance of `UIViewController` whose
  /// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
  /// property may be overridden at any time.
  ///
  /// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
  /// use the map view’s property ``MLNMapView/automaticallyAdjustsContentInset``instead.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-setContentInset:animated:completionHandler:` method.
  ///
  /// @param contentInset The new values to inset the content by.
  /// @param animated Specify `YES` if you want the map view to animate the change to
  /// the content inset or `NO` if you want the map to inset the content
  /// immediately.
  void setContentInset(UIEdgeInsets contentInset$1, {required bool animated}) {
    _objc_msgSend_6ueq99(this.ref.pointer, _sel_setContentInset_animated_,
        contentInset$1, animated);
  }

  /// Sets the distance from the edges of the map view’s frame to the edges of the
  /// map view’s logical viewport with an optional transition animation and
  /// completion handler.
  ///
  /// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
  /// properties such as `centerCoordinate` assume a viewport that matches the map
  /// view’s frame. Otherwise, those properties are inset, excluding part of the
  /// frame from the viewport. For instance, if the only the top edge is inset, the
  /// map center is effectively shifted downward.
  ///
  /// When the map view’s superview is an instance of `UIViewController` whose
  /// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
  /// property may be overridden at any time.
  ///
  /// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
  /// use the map view’s property ``MLNMapView/automaticallyAdjustsContentInset``instead.
  ///
  /// @param contentInset The new values to inset the content by.
  /// @param animated Specify `YES` if you want the map view to animate the change to
  /// the content inset or `NO` if you want the map to inset the content
  /// immediately.
  /// @param completion The block executed after the animation finishes.
  void setContentInset$1(UIEdgeInsets contentInset$1,
      {required bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_1vx0lfy(
        this.ref.pointer,
        _sel_setContentInset_animated_completionHandler_,
        contentInset$1,
        animated,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Converts a point in the given view’s coordinate system to a geographic
  /// coordinate.
  ///
  /// @param point The point to convert.
  /// @param view The view in whose coordinate system the point is expressed.
  /// @return The geographic coordinate at the given point.
  ///
  /// #### Related examples
  /// - TODO: Point conversion example to learn how to convert a `CGPoint` to a map coordinate.
  CLLocationCoordinate2D convertPoint2(objc.CGPoint point,
      {UIView? toCoordinateFromView}) {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_4xp05xStret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_toCoordinateFromView_,
            point,
            toCoordinateFromView?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_4xp05x(
            this.ref.pointer,
            _sel_convertPoint_toCoordinateFromView_,
            point,
            toCoordinateFromView?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// Converts a geographic coordinate to a point in the given view’s coordinate
  /// system.
  ///
  /// @param coordinate The geographic coordinate to convert.
  /// @param view The view in whose coordinate system the returned point should be
  /// expressed. If this parameter is `nil`, the returned point is expressed
  /// in the window’s coordinate system. If `view` is not `nil`, it must
  /// belong to the same window as the map view.
  /// @return The point (in the appropriate view or window coordinate system)
  /// corresponding to the given geographic coordinate.
  ///
  /// #### Related examples
  /// - TODO: Point conversion: learn how to convert a map coordinate to a `CGPoint` object.
  objc.CGPoint convertCoordinate(CLLocationCoordinate2D coordinate,
      {UIView? toPointToView}) {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_mus1wvStret(
            _ptr,
            this.ref.pointer,
            _sel_convertCoordinate_toPointToView_,
            coordinate,
            toPointToView?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_mus1wv(
            this.ref.pointer,
            _sel_convertCoordinate_toPointToView_,
            coordinate,
            toPointToView?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// Converts a rectangle in the given view’s coordinate system to a geographic
  /// bounding box.
  ///
  /// If the returned coordinate bounds contains a longitude is less than −180 degrees
  /// or greater than 180 degrees, the bounding box straddles the antimeridian or
  /// international date line.
  ///
  /// @param rect The rectangle to convert.
  /// @param view The view in whose coordinate system the rectangle is expressed.
  /// @return The geographic bounding box coextensive with the given rectangle.
  MLNCoordinateBounds convertRect2(objc.CGRect rect,
      {UIView? toCoordinateBoundsFromView}) {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1f65wixStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_toCoordinateBoundsFromView_,
            rect,
            toCoordinateBoundsFromView?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_1f65wix(
            this.ref.pointer,
            _sel_convertRect_toCoordinateBoundsFromView_,
            rect,
            toCoordinateBoundsFromView?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// Converts a geographic bounding box to a rectangle in the given view’s
  /// coordinate system.
  ///
  /// To bring both sides of the antimeridian or international date line into view,
  /// specify some longitudes less than −180 degrees or greater than 180 degrees. For
  /// example, to show both Tokyo and San Francisco simultaneously, you could set the
  /// visible bounds to extend from (35.68476, −220.24257) to (37.78428, −122.41310).
  ///
  /// @param bounds The geographic bounding box to convert.
  /// @param view The view in whose coordinate system the returned rectangle should
  /// be expressed. If this parameter is `nil`, the returned rectangle is
  /// expressed in the window’s coordinate system. If `view` is not `nil`, it must
  /// belong to the same window as the map view.
  objc.CGRect convertCoordinateBounds(MLNCoordinateBounds bounds,
      {UIView? toRectToView}) {
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18hv5gjStret(
            _ptr,
            this.ref.pointer,
            _sel_convertCoordinateBounds_toRectToView_,
            bounds,
            toRectToView?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_18hv5gj(
            this.ref.pointer,
            _sel_convertCoordinateBounds_toRectToView_,
            bounds,
            toRectToView?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// Returns the distance spanned by one point in the map view’s coordinate system
  /// at the given latitude and current zoom level.
  ///
  /// The distance between points decreases as the latitude approaches the poles.
  /// This relationship parallels the relationship between longitudinal coordinates
  /// at different latitudes.
  ///
  /// @param latitude The latitude of the geographic coordinate represented by the
  /// point.
  /// @return The distance in meters spanned by a single point.
  double metersPerPointAtLatitude(double latitude) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1tczmpvFpret(
            this.ref.pointer, _sel_metersPerPointAtLatitude_, latitude)
        : _objc_msgSend_1tczmpv(
            this.ref.pointer, _sel_metersPerPointAtLatitude_, latitude);
  }

  /// Returns the new map projection instance initialized with the map view,
  /// i.e. with the current camera state.
  MLNMapProjection mapProjection() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_mapProjection);
    return MLNMapProjection.castFromPointer(_ret, retain: true, release: true);
  }

  /// The complete list of annotations associated with the receiver. (read-only)
  ///
  /// The objects in this array must adopt the ``MLNAnnotation`` protocol. If no
  /// annotations are associated with the map view, the value of this property is
  /// `nil`.
  objc.NSArray? get annotations {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_annotations);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds an annotation to the map view.
  ///
  /// > Note: ``MLNMultiPolyline``, ``MLNMultiPolyline``, ``MLNMultiPolyline``, and
  /// ``MLNPointCollection`` objects cannot be added to the map view at this time.
  /// Any multipoint, multipolyline, multipolygon, shape or point collection
  /// object that is specified is silently ignored.
  ///
  /// @param annotation The annotation object to add to the receiver. This object
  /// must conform to the ``MLNAnnotation`` protocol. The map view retains the
  /// annotation object.
  ///
  /// #### Related examples
  /// - TODO: add a line annotation from GeoJSON.
  /// - TODO: add an annotation to an ``MLNMapView`` object.
  void addAnnotation(MLNAnnotation annotation) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addAnnotation_, annotation.ref.pointer);
  }

  /// Adds an array of annotations to the map view.
  ///
  /// > Note: ``MLNMultiPolyline``, ``MLNMultiPolyline``, and ``MLNMultiPolyline`` objects
  /// cannot be added to the map view at this time. Nor can ``MLNMultiPoint``
  /// objects that are not instances of ``MLNPolyline`` or ``MLNPolyline``. Any
  /// multipoint, multipolyline, multipolygon, or shape collection objects that
  /// are specified are silently ignored.
  ///
  /// @param annotations An array of annotation objects. Each object in the array
  /// must conform to the ``MLNAnnotation`` protocol. The map view retains each
  /// individual annotation object.
  void addAnnotations(objc.NSArray annotations$1) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addAnnotations_, annotations$1.ref.pointer);
  }

  /// Removes an annotation from the map view, deselecting it if it is selected.
  ///
  /// Removing an annotation object dissociates it from the map view entirely,
  /// preventing it from being displayed on the map. Thus you would typically call
  /// this method only when you want to hide or delete a given annotation.
  ///
  /// @param annotation The annotation object to remove. This object must conform
  /// to the ``MLNAnnotation`` protocol
  void removeAnnotation(MLNAnnotation annotation) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeAnnotation_, annotation.ref.pointer);
  }

  /// Removes an array of annotations from the map view, deselecting any selected
  /// annotations in the array.
  ///
  /// Removing annotation objects dissociates them from the map view entirely,
  /// preventing them from being displayed on the map. Thus you would typically
  /// call this method only when you want to hide or delete the given annotations.
  ///
  /// @param annotations The array of annotation objects to remove. Objects in the
  /// array must conform to the ``MLNAnnotation`` protocol.
  void removeAnnotations(objc.NSArray annotations$1) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeAnnotations_, annotations$1.ref.pointer);
  }

  /// Returns an ``MLNAnnotationView`` if the given annotation is currently associated
  /// with a view, otherwise nil.
  ///
  /// @param annotation The annotation associated with the view.
  /// Annotation must conform to the ``MLNAnnotation`` protocol.
  MLNAnnotationView? viewForAnnotation(MLNAnnotation annotation) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_viewForAnnotation_, annotation.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNAnnotationView.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a reusable annotation image object associated with its identifier.
  ///
  /// For performance reasons, you should generally reuse ``MLNAnnotationImage``
  /// objects for identical-looking annotations in your map views. Dequeueing
  /// saves time and memory during performance-critical operations such as
  /// scrolling.
  ///
  /// @param identifier A string identifying the annotation image to be reused.
  /// This string is the same one you specify when initially returning the
  /// annotation image object using the `-mapView:imageForAnnotation:` method.
  /// @return An annotation image object with the given identifier, or `nil` if no
  /// such object exists in the reuse queue.
  ///
  /// #### Related examples
  /// - TODO: Add annotation views and images: learn how to most efficiently
  /// reuse an ``MLNAnnotationImage``.
  MLNAnnotationImage? dequeueReusableAnnotationImageWithIdentifier(
      objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_dequeueReusableAnnotationImageWithIdentifier_,
        identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNAnnotationImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a reusable annotation view object associated with its identifier.
  ///
  /// For performance reasons, you should generally reuse ``MLNAnnotationView``
  /// objects for identical-looking annotations in your map views. Dequeueing
  /// saves time and memory during performance-critical operations such as
  /// scrolling.
  ///
  /// @param identifier A string identifying the annotation view to be reused.
  /// This string is the same one you specify when initially returning the
  /// annotation view object using the `-mapView:viewForAnnotation:` method.
  /// @return An annotation view object with the given identifier, or `nil` if no
  /// such object exists in the reuse queue.
  MLNAnnotationView? dequeueReusableAnnotationViewWithIdentifier(
      objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_dequeueReusableAnnotationViewWithIdentifier_,
        identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNAnnotationView.castFromPointer(_ret, retain: true, release: true);
  }

  /// The complete list of annotations associated with the receiver that are
  /// currently visible.
  ///
  /// The objects in this array must adopt the ``MLNAnnotation`` protocol. If no
  /// annotations are associated with the map view or if no annotations associated
  /// with the map view are currently visible, the value of this property is `nil`.
  objc.NSArray? get visibleAnnotations {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_visibleAnnotations);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the list of annotations associated with the receiver that intersect with
  /// the given rectangle.
  ///
  /// @param rect A rectangle expressed in the map view’s coordinate system.
  /// @return An array of objects that adopt the ``MLNAnnotation`` protocol or `nil` if
  /// no annotations associated with the map view are currently visible in the
  /// rectangle.
  objc.NSArray? visibleAnnotationsInRect(objc.CGRect rect) {
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.pointer, _sel_visibleAnnotationsInRect_, rect);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The currently selected annotations.
  ///
  /// Assigning a new array to this property selects only the first annotation in
  /// the array.
  ///
  /// If the annotation is of type ``MLNPointAnnotation`` and is offscreen, the camera
  /// will animate to bring the annotation and its callout just on screen. If you
  /// need finer control, consider using `-selectAnnotation:animated:`.
  ///
  /// > Note: In versions prior to `4.0.0` if the annotation was offscreen it was not
  /// selected.
  objc.NSArray get selectedAnnotations {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedAnnotations);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The currently selected annotations.
  ///
  /// Assigning a new array to this property selects only the first annotation in
  /// the array.
  ///
  /// If the annotation is of type ``MLNPointAnnotation`` and is offscreen, the camera
  /// will animate to bring the annotation and its callout just on screen. If you
  /// need finer control, consider using `-selectAnnotation:animated:`.
  ///
  /// > Note: In versions prior to `4.0.0` if the annotation was offscreen it was not
  /// selected.
  set selectedAnnotations(objc.NSArray value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSelectedAnnotations_, value.ref.pointer);
  }

  /// Deprecated. Selects an annotation and displays its callout view.
  ///
  /// The `animated` parameter determines whether the selection is animated including whether the map is
  /// panned to bring the annotation into view, specifically:
  ///
  /// | `animated` parameter | Effect |
  /// |------------------|--------|
  /// | `NO`             | The annotation is selected, and the callout is presented. However the map is
  /// not panned to bring the annotation or callout into view. The presentation of the callout is NOT
  /// animated. | | `YES`            | The annotation is selected, and the callout is presented. If the
  /// annotation is not visible (or is partially visible) *and* is of type ``MLNPointAnnotation``, the
  /// map is panned so that the annotation and its callout are brought into view. The annotation is *not*
  /// centered within the viewport. |
  ///
  /// Note that a selection initiated by a single tap gesture is always animated.
  ///
  /// To specify a completion handler to execute after the animation finishes, use
  /// the `-selectAnnotation:animated:completionHandler:` method.
  ///
  /// @param annotation The annotation object to select.
  /// @param animated If `YES`, the annotation and callout view are animated on-screen.
  ///
  /// > Note: In versions prior to `4.0.0` selecting an offscreen annotation did not
  /// change the camera.
  void selectAnnotation(MLNAnnotation annotation, {required bool animated}) {
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_selectAnnotation_animated_,
        annotation.ref.pointer, animated);
  }

  /// Selects an annotation and displays its callout view with an optional completion
  /// handler.
  ///
  /// The `animated` parameter determines whether the selection is animated including whether the map is
  /// panned to bring the annotation into view, specifically:
  ///
  /// | `animated` parameter | Effect |
  /// |------------------|--------|
  /// | `NO`             | The annotation is selected, and the callout is presented. However the map is
  /// not panned to bring the annotation or callout into view. The presentation of the callout is NOT
  /// animated. | | `YES`            | The annotation is selected, and the callout is presented. If the
  /// annotation is not visible (or is partially visible) *and* is of type ``MLNPointAnnotation``, the
  /// map is panned so that the annotation and its callout are brought into view. The annotation is *not*
  /// centered within the viewport. |
  ///
  /// Note that a selection initiated by a single tap gesture is always animated.
  ///
  /// @param annotation The annotation object to select.
  /// @param animated If `YES`, the annotation and callout view are animated on-screen.
  /// @param completion The block executed after the animation finishes.
  ///
  /// > Note: In versions prior to `4.0.0` selecting an offscreen annotation did not
  /// change the camera.
  void selectAnnotation$1(MLNAnnotation annotation,
      {required bool animated,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_na2nx0(
        this.ref.pointer,
        _sel_selectAnnotation_animated_completionHandler_,
        annotation.ref.pointer,
        animated,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// :nodoc:
  /// Selects an annotation and displays its callout view with an optional completion
  /// handler. This method should be considered "alpha" and as such is subject to
  /// change.
  ///
  /// @param annotation The annotation object to select.
  /// @param moveIntoView If the annotation is not visible (or is partially visible) *and* is of type
  /// ``MLNPointAnnotation``, the map is panned so that the annotation and its callout are brought into
  /// view. The annotation is *not* centered within the viewport.
  /// @param animateSelection If `YES`, the annotation's selection state and callout view's presentation
  /// are animated.
  /// @param completion The block executed after the animation finishes.
  void selectAnnotation$2(MLNAnnotation annotation,
      {required bool moveIntoView,
      required bool animateSelection,
      objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
    _objc_msgSend_2nhnqw(
        this.ref.pointer,
        _sel_selectAnnotation_moveIntoView_animateSelection_completionHandler_,
        annotation.ref.pointer,
        moveIntoView,
        animateSelection,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Deselects an annotation and hides its callout view.
  ///
  /// @param annotation The annotation object to deselect.
  /// @param animated If `YES`, the callout view is animated offscreen.
  void deselectAnnotation(MLNAnnotation? annotation, {required bool animated}) {
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_deselectAnnotation_animated_,
        annotation?.ref.pointer ?? ffi.nullptr, animated);
  }

  /// The complete list of overlays associated with the receiver. (read-only)
  ///
  /// The objects in this array must adopt the ``MLNOverlay`` protocol. If no
  /// overlays are associated with the map view, the value of this property is
  /// empty array.
  objc.NSArray get overlays {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_overlays);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds a single overlay object to the map.
  ///
  /// To remove an overlay from a map, use the `-removeOverlay:` method.
  ///
  /// @param overlay The overlay object to add. This object must conform to the
  /// ``MLNOverlay`` protocol.
  void addOverlay(MLNOverlay overlay) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addOverlay_, overlay.ref.pointer);
  }

  /// Adds an array of overlay objects to the map.
  ///
  /// To remove multiple overlays from a map, use the `-removeOverlays:` method.
  ///
  /// @param overlays An array of objects, each of which must conform to the
  /// ``MLNOverlay`` protocol.
  void addOverlays(objc.NSArray overlays$1) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addOverlays_, overlays$1.ref.pointer);
  }

  /// Removes a single overlay object from the map.
  ///
  /// If the specified overlay is not currently associated with the map view, this
  /// method does nothing.
  ///
  /// @param overlay The overlay object to remove.
  void removeOverlay(MLNOverlay overlay) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeOverlay_, overlay.ref.pointer);
  }

  /// Removes one or more overlay objects from the map.
  ///
  /// If a given overlay object is not associated with the map view, it is ignored.
  ///
  /// @param overlays An array of objects, each of which conforms to the ``MLNOverlay``
  /// protocol.
  void removeOverlays(objc.NSArray overlays$1) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeOverlays_, overlays$1.ref.pointer);
  }

  /// Returns an array of rendered map features that intersect with a given point.
  ///
  /// This method may return features from any of the map’s style layers. To restrict
  /// the search to a particular layer or layers, use the
  /// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:` method. For more
  /// information about searching for map features, see that method’s documentation.
  ///
  /// @param point A point expressed in the map view’s coordinate system.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  ///
  /// #### Related examples
  /// - TODO: Select a feature within a layer: to learn how to query an
  /// ``MLNMapView`` object for visible ``MLNMapView`` objects.
  objc.NSArray visibleFeaturesAtPoint(objc.CGPoint point) {
    final _ret = _objc_msgSend_wgkxx2(
        this.ref.pointer, _sel_visibleFeaturesAtPoint_, point);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with a given point,
  /// restricted to the given style layers.
  ///
  /// This method returns all the intersecting features from the specified layers. To
  /// filter the returned features, use the
  /// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:` method. For
  /// more information about searching for map features, see that method’s
  /// documentation.
  ///
  /// @param point A point expressed in the map view’s coordinate system.
  /// @param styleLayerIdentifiers A set of strings that correspond to the names
  /// of layers defined in the current style. Only the features contained in
  /// these layers are included in the returned array.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesAtPoint$1(objc.CGPoint point,
      {objc.NSSet? inStyleLayersWithIdentifiers}) {
    final _ret = _objc_msgSend_u7nfz8(
        this.ref.pointer,
        _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_,
        point,
        inStyleLayersWithIdentifiers?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with a given point,
  /// restricted to the given style layers and filtered by the given predicate.
  ///
  /// Each object in the returned array represents a feature rendered by the
  /// current style and provides access to attributes specified by the relevant map
  /// content sources. The returned array includes features loaded by
  /// ``MLNShapeSource`` and ``MLNShapeSource`` objects but does not include
  /// anything from ``MLNRasterTileSource`` objects, or from video or canvas sources,
  /// which are unsupported by this SDK.
  ///
  /// The returned features are drawn by a style layer in the current style. For
  /// example, suppose the current style uses the
  /// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets/">Mapbox Streets source</a>,
  /// but none of the specified style layers includes features that have the `maki`
  /// property set to `bus`. If you pass a point corresponding to the location of a
  /// bus stop into this method, the bus stop feature does not appear in the
  /// resulting array. On the other hand, if the style does include bus stops, an
  /// ``MLNFeature`` object representing that bus stop is returned and its
  /// `featureAttributes` dictionary has the `maki` key set to `bus` (along with
  /// other attributes). The dictionary contains only the attributes provided by the
  /// tile source; it does not include computed attribute values or rules about how
  /// the feature is rendered by the current style.
  ///
  /// The returned array is sorted by z-order, starting with the topmost rendered
  /// feature and ending with the bottommost rendered feature. A feature that is
  /// rendered multiple times due to wrapping across the antimeridian at low zoom
  /// levels is included only once, subject to the caveat that follows.
  ///
  /// Features come from tiled vector data or GeoJSON data that is converted to tiles
  /// internally, so feature geometries are clipped at tile boundaries and features
  /// may appear duplicated across tiles. For example, suppose the specified point
  /// lies along a road that spans the screen. The resulting array includes those
  /// parts of the road that lie within the map tile that contain the specified
  /// point, even if the road extends into other tiles.
  ///
  /// To find out the layer names in a particular style, view the style in
  /// <a href="https://maplibre.org/maputnik">Maputnik</a>.
  ///
  /// Only visible features are returned. To obtain features regardless of
  /// visibility, use the
  /// ``MLNVectorTileSource/featuresInSourceLayersWithIdentifiers:predicate:`` and
  /// ``MLNShapeSource/featuresMatchingPredicate:`` methods on the relevant sources.
  ///
  /// The returned features may also include features corresponding to annotations.
  /// These features are not object-equal to the ``MLNAnnotation`` objects that were
  /// originally added to the map. To query the map for annotations, use
  /// `visibleAnnotations` or ``MLNMapView/visibleAnnotationsInRect:``.
  ///
  ///
  /// @param point A point expressed in the map view’s coordinate system.
  /// @param styleLayerIdentifiers A set of strings that correspond to the names of
  /// layers defined in the current style. Only the features contained in these
  /// layers are included in the returned array.
  /// @param predicate A predicate to filter the returned features.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesAtPoint$2(objc.CGPoint point,
      {objc.NSSet? inStyleLayersWithIdentifiers, NSPredicate? predicate}) {
    final _ret = _objc_msgSend_19l1l5m(
        this.ref.pointer,
        _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_predicate_,
        point,
        inStyleLayersWithIdentifiers?.ref.pointer ?? ffi.nullptr,
        predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with the given
  /// rectangle.
  ///
  /// This method may return features from any of the map’s style layers. To restrict
  /// the search to a particular layer or layers, use the
  /// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:` method. For more
  /// information about searching for map features, see that method’s documentation.
  ///
  /// @param rect A rectangle expressed in the map view’s coordinate system.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect(objc.CGRect rect) {
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.pointer, _sel_visibleFeaturesInRect_, rect);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with the given
  /// rectangle, restricted to the given style layers.
  ///
  /// This method returns all the intersecting features from the specified layers. To
  /// filter the returned features, use the
  /// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:` method. For
  /// more information about searching for map features, see that method’s
  /// documentation.
  ///
  /// @param rect A rectangle expressed in the map view’s coordinate system.
  /// @param styleLayerIdentifiers A set of strings that correspond to the names of
  /// layers defined in the current style. Only the features contained in these
  /// layers are included in the returned array.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect$1(objc.CGRect rect,
      {objc.NSSet? inStyleLayersWithIdentifiers}) {
    final _ret = _objc_msgSend_gxusyk(
        this.ref.pointer,
        _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_,
        rect,
        inStyleLayersWithIdentifiers?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of rendered map features that intersect with the given
  /// rectangle, restricted to the given style layers and filtered by the given
  /// predicate.
  ///
  /// Each object in the returned array represents a feature rendered by the
  /// current style and provides access to attributes specified by the relevant map
  /// content sources. The returned array includes features loaded by
  /// ``MLNShapeSource`` and ``MLNShapeSource`` objects but does not include
  /// anything from ``MLNRasterTileSource`` objects, or from video or canvas sources,
  /// which are unsupported by this SDK.
  ///
  /// The returned features are drawn by a style layer in the current style. For
  /// example, suppose the current style uses a particular source,
  /// but none of the specified style layers includes features that have the `maki`
  /// property set to `bus`. If you pass a rectangle containing the location of a bus
  /// stop into this method, the bus stop feature does not appear in the resulting
  /// array. On the other hand, if the style does include bus stops, an ``MLNFeature``
  /// object representing that bus stop is returned and its `featureAttributes`
  /// dictionary has the `maki` key set to `bus` (along with other attributes). The
  /// dictionary contains only the attributes provided by the tile source; it does
  /// not include computed attribute values or rules about how the feature is
  /// rendered by the current style.
  ///
  /// The returned array is sorted by z-order, starting with the topmost rendered
  /// feature and ending with the bottommost rendered feature. A feature that is
  /// rendered multiple times due to wrapping across the antimeridian at low zoom
  /// levels is included only once, subject to the caveat that follows.
  ///
  /// Features come from tiled vector data or GeoJSON data that is converted to tiles
  /// internally, so feature geometries are clipped at tile boundaries and features
  /// may appear duplicated across tiles. For example, suppose the specified
  /// rectangle intersects with a road that spans the screen. The resulting array
  /// includes those parts of the road that lie within the map tiles covering the
  /// specified rectangle, even if the road extends into other tiles. The portion of
  /// the road within each map tile is included individually.
  ///
  /// To find out the layer names in a particular style, view the style in
  /// <a href="https://maplibre.org/maputnik">Maputnik</a>.
  ///
  /// Only visible features are returned. To obtain features regardless of
  /// visibility, use the
  /// ``MLNVectorTileSource/featuresInSourceLayersWithIdentifiers:predicate:`` and
  /// ``MLNShapeSource/featuresMatchingPredicate:`` methods on the relevant sources.
  ///
  /// @param rect A rectangle expressed in the map view’s coordinate system.
  /// @param styleLayerIdentifiers A set of strings that correspond to the names of
  /// layers defined in the current style. Only the features contained in these
  /// layers are included in the returned array.
  /// @param predicate A predicate to filter the returned features.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect$2(objc.CGRect rect,
      {objc.NSSet? inStyleLayersWithIdentifiers, NSPredicate? predicate}) {
    final _ret = _objc_msgSend_1o8sa9u(
        this.ref.pointer,
        _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_predicate_,
        rect,
        inStyleLayersWithIdentifiers?.ref.pointer ?? ffi.nullptr,
        predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The options that determine which debugging aids are shown on the map.
  ///
  /// These options are all disabled by default and should remain disabled in
  /// released software for performance and aesthetic reasons.
  MLNMapDebugMaskOptions get debugMask {
    final _ret = _objc_msgSend_1kwkjor(this.ref.pointer, _sel_debugMask);
    return MLNMapDebugMaskOptions.fromValue(_ret);
  }

  /// The options that determine which debugging aids are shown on the map.
  ///
  /// These options are all disabled by default and should remain disabled in
  /// released software for performance and aesthetic reasons.
  set debugMask(MLNMapDebugMaskOptions value) {
    _objc_msgSend_pisvbv(this.ref.pointer, _sel_setDebugMask_, value.value);
  }

  /// Returns the status of the rendering statistics overlay.
  bool isRenderingStatsViewEnabled() {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_isRenderingStatsViewEnabled);
  }

  /// Enable a rendering statistics overlay with ``MLNRenderingStats`` values.
  void enableRenderingStatsView(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_enableRenderingStatsView_, value);
  }

  /// Get the list of action journal log files from oldest to newest.
  ///
  /// @return An array of log file paths.
  objc.NSArray getActionJournalLogFiles() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_getActionJournalLogFiles);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Get the action journal events from oldest to newest.
  ///
  /// Each element contains a serialized json object with the event data.
  /// Example
  /// `{
  /// "name" : "onTileAction",
  /// "time" : "2025-04-17T13:13:13.974Z",
  /// "styleName" : "Streets",
  /// "styleURL" : "maptiler://maps/streets",
  /// "event" : {
  /// "action" : "RequestedFromNetwork",
  /// "tileX" : 0,
  /// "tileY" : 0,
  /// "tileZ" : 0,
  /// "overscaledZ" : 0,
  /// "sourceID" : "openmaptiles"
  /// }
  /// }`
  objc.NSArray getActionJournalLog() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_getActionJournalLog);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Clear stored action journal events.
  void clearActionJournalLog() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_clearActionJournalLog);
  }

  /// backendResource
  MLNBackendResource backendResource() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backendResource);
    return MLNBackendResource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Triggers a repaint of the map.
  void triggerRepaint() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_triggerRepaint);
  }

  /// Adds a plug-in layer that is external to this library
  void addPluginLayerType(objc.ObjCObjectBase pluginLayerClass) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addPluginLayerType_,
        pluginLayerClass.ref.pointer);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('MLNMapView.layerClass',
        iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_MLNMapView, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  MLNMapView? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute(
          UISemanticContentAttribute attribute) {
    objc.checkOsVersionInternal(
        'MLNMapView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_racczx(
        _class_MLNMapView,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
        attribute.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
      userInterfaceLayoutDirectionForSemanticContentAttribute$1(
          UISemanticContentAttribute semanticContentAttribute$1,
          {required UIUserInterfaceLayoutDirection relativeToLayoutDirection}) {
    objc.checkOsVersionInternal(
        'MLNMapView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
        iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_tz4p54(
        _class_MLNMapView,
        _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
        semanticContentAttribute$1.value,
        relativeToLayoutDirection.value);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// init
  MLNMapView init() {
    objc.checkOsVersionInternal('MLNMapView.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMapView new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapView, _sel_new);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMapView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNMapView, _sel_allocWithZone_, zone);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMapView alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapView, _sel_alloc);
    return MLNMapView.castFromPointer(_ret, retain: false, release: true);
  }

  /// appearance
  static MLNMapView appearance() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMapView, _sel_appearance);
    return MLNMapView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static MLNMapView appearanceWhenContainedIn(
      UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('MLNMapView.appearanceWhenContainedIn:',
        iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_MLNMapView,
        _sel_appearanceWhenContainedIn_,
        ContainerClass?.ref.pointer ?? ffi.nullptr);
    return MLNMapView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static MLNMapView appearanceWhenContainedInInstancesOfClasses(
      objc.NSArray containerTypes) {
    objc.checkOsVersionInternal(
        'MLNMapView.appearanceWhenContainedInInstancesOfClasses:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_MLNMapView,
        _sel_appearanceWhenContainedInInstancesOfClasses_,
        containerTypes.ref.pointer);
    return MLNMapView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static MLNMapView appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('MLNMapView.appearanceForTraitCollection:',
        iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_MLNMapView,
        _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return MLNMapView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static MLNMapView appearanceForTraitCollection$1(UITraitCollection trait,
      {UIAppearanceContainer? whenContainedIn}) {
    objc.checkOsVersionInternal(
        'MLNMapView.appearanceForTraitCollection:whenContainedIn:',
        iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_MLNMapView,
        _sel_appearanceForTraitCollection_whenContainedIn_,
        trait.ref.pointer,
        whenContainedIn?.ref.pointer ?? ffi.nullptr);
    return MLNMapView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static MLNMapView appearanceForTraitCollection$2(UITraitCollection trait,
      {required objc.NSArray whenContainedInInstancesOfClasses}) {
    objc.checkOsVersionInternal(
        'MLNMapView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
        iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_MLNMapView,
        _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
        trait.ref.pointer,
        whenContainedInInstancesOfClasses.ref.pointer);
    return MLNMapView.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNMapView constructed with the default `new` method.
  factory MLNMapView() => new$();
}

late final _protocol_MLNCluster = objc.getProtocol("MLNCluster");
late final _protocol_MLNFeature = objc.getProtocol("MLNFeature");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSDictionary_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSDictionary_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSDictionary_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSDictionary_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSDictionary_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSDictionary_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSDictionary Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSDictionary_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSDictionary_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)> {
  objc.NSDictionary call(ffi.Pointer<ffi.Void> arg0) =>
      objc.NSDictionary.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

void _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSDictionary_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSDictionary.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSDictionary.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            objc.NSDictionary)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSDictionary.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSDictionary_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSDictionary.castFromPointer(arg1,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>,
            objc.NSDictionary)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSDictionary_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSDictionary arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_attributeForKey_ = objc.registerName("attributeForKey:");
late final _sel_geoJSONDictionary = objc.registerName("geoJSONDictionary");

/// The ``MLNFeature``  protocol is used to provide details about geographic features
/// contained in an ``MLNShapeSource`` or ``MLNVectorTileSource`` object. Each concrete
/// subclass of ``MLNShape`` in turn has a subclass that conforms to this protocol. A
/// feature object associates a shape with an optional identifier and attributes.
///
/// You can add custom data to display on the map by creating feature objects and
/// adding them to an ``MLNShapeSource`` using the
/// ``MLNShapeSource/initWithIdentifier:shape:options:`` method or
/// ``MLNShapeSource/shape`` property.
///
/// In addition to adding data to the map, you can also extract data from the map:
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods return feature
/// objects that correspond to features in the source. This enables you to inspect
/// the properties of features in vector tiles loaded by ``MLNVectorTileSource``
/// objects. You also reuse these feature objects as overlay annotations.
///
/// While it is possible to add ``MLNFeature``-conforming objects to the map as
/// annotations using ``MLNMapView/addAnnotations:`` and related methods, doing so
/// has trade-offs:
///
/// - Features added as annotations will not have ``identifier`` or ``attributes``
/// properties when used with feature querying.
///
/// - Features added as annotations become interactive. Taps and selection can be
/// handled in ``MLNMapViewDelegate/mapView:didSelectAnnotation:``.
interface class MLNFeature extends objc.ObjCProtocolBase
    implements MLNAnnotation {
  MLNFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNFeature] that points to the same underlying object as [other].
  MLNFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNFeature] that wraps the given raw object pointer.
  MLNFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNFeature].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNFeature);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNFeature.cast());

  /// Builds an object that implements the MLNFeature protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNFeature implement(
      {required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNFeature');
    MLNFeature.identifier.implement(builder, identifier);
    MLNFeature.setIdentifier_.implement(builder, setIdentifier_);
    MLNFeature.attributes.implement(builder, attributes);
    MLNFeature.setAttributes_.implement(builder, setAttributes_);
    MLNFeature.attributeForKey_.implement(builder, attributeForKey_);
    MLNFeature.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNFeature.coordinate.implement(builder, coordinate);
    MLNFeature.title.implement(builder, title);
    MLNFeature.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
    return MLNFeature.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNFeature protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    MLNFeature.identifier.implement(builder, identifier);
    MLNFeature.setIdentifier_.implement(builder, setIdentifier_);
    MLNFeature.attributes.implement(builder, attributes);
    MLNFeature.setAttributes_.implement(builder, setAttributes_);
    MLNFeature.attributeForKey_.implement(builder, attributeForKey_);
    MLNFeature.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNFeature.coordinate.implement(builder, coordinate);
    MLNFeature.title.implement(builder, title);
    MLNFeature.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the MLNFeature protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNFeature implementAsListener(
      {required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNFeature');
    MLNFeature.identifier.implement(builder, identifier);
    MLNFeature.setIdentifier_.implementAsListener(builder, setIdentifier_);
    MLNFeature.attributes.implement(builder, attributes);
    MLNFeature.setAttributes_.implementAsListener(builder, setAttributes_);
    MLNFeature.attributeForKey_.implement(builder, attributeForKey_);
    MLNFeature.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNFeature.coordinate.implement(builder, coordinate);
    MLNFeature.title.implement(builder, title);
    MLNFeature.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
    return MLNFeature.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNFeature protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    MLNFeature.identifier.implement(builder, identifier);
    MLNFeature.setIdentifier_.implementAsListener(builder, setIdentifier_);
    MLNFeature.attributes.implement(builder, attributes);
    MLNFeature.setAttributes_.implementAsListener(builder, setAttributes_);
    MLNFeature.attributeForKey_.implement(builder, attributeForKey_);
    MLNFeature.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNFeature.coordinate.implement(builder, coordinate);
    MLNFeature.title.implement(builder, title);
    MLNFeature.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the MLNFeature protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNFeature implementAsBlocking(
      {required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNFeature');
    MLNFeature.identifier.implement(builder, identifier);
    MLNFeature.setIdentifier_.implementAsBlocking(builder, setIdentifier_);
    MLNFeature.attributes.implement(builder, attributes);
    MLNFeature.setAttributes_.implementAsBlocking(builder, setAttributes_);
    MLNFeature.attributeForKey_.implement(builder, attributeForKey_);
    MLNFeature.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNFeature.coordinate.implement(builder, coordinate);
    MLNFeature.title.implement(builder, title);
    MLNFeature.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
    return MLNFeature.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNFeature protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    MLNFeature.identifier.implement(builder, identifier);
    MLNFeature.setIdentifier_.implementAsBlocking(builder, setIdentifier_);
    MLNFeature.attributes.implement(builder, attributes);
    MLNFeature.setAttributes_.implementAsBlocking(builder, setAttributes_);
    MLNFeature.attributeForKey_.implement(builder, attributeForKey_);
    MLNFeature.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNFeature.coordinate.implement(builder, coordinate);
    MLNFeature.title.implement(builder, title);
    MLNFeature.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  static final identifier =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase? Function()>(
    _protocol_MLNFeature,
    _sel_identifier,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_identifier,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase? Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  static final setIdentifier_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.ObjCObjectBase?)>(
    _protocol_MLNFeature,
    _sel_setIdentifier_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _MapLibreFFi_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_setIdentifier_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function(objc.ObjCObjectBase?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_objcObjCObject.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase? arg1) => func(arg1)),
    (void Function(objc.ObjCObjectBase?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_objcObjCObject.listener(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase? arg1) => func(arg1)),
    (void Function(objc.ObjCObjectBase?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_objcObjCObject.blocking(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase? arg1) => func(arg1)),
  );

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  static final attributes =
      objc.ObjCProtocolMethod<objc.NSDictionary Function()>(
    _protocol_MLNFeature,
    _sel_attributes,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_attributes,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.NSDictionary Function() func) =>
        ObjCBlock_NSDictionary_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  static final setAttributes_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSDictionary)>(
    _protocol_MLNFeature,
    _sel_setAttributes_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _MapLibreFFi_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_setAttributes_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSDictionary.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
    (void Function(objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSDictionary.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
    (void Function(objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSDictionary.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
  );

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  static final attributeForKey_ =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase? Function(objc.NSString)>(
    _protocol_MLNFeature,
    _sel_attributeForKey_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    instancetype Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _MapLibreFFi_protocolTrampoline_xr62hr)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_attributeForKey_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase? Function(objc.NSString) func) =>
        ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey
            .fromFunction(
                (ffi.Pointer<ffi.Void> _, objc.NSString arg1) => func(arg1)),
  );

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  static final geoJSONDictionary =
      objc.ObjCProtocolMethod<objc.NSDictionary Function()>(
    _protocol_MLNFeature,
    _sel_geoJSONDictionary,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_geoJSONDictionary,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.NSDictionary Function() func) =>
        ObjCBlock_NSDictionary_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  static final coordinate =
      objc.ObjCProtocolMethod<CLLocationCoordinate2D Function()>(
    _protocol_MLNFeature,
    _sel_coordinate,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    CLLocationCoordinate2D Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_neuenc)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_coordinate,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CLLocationCoordinate2D Function() func) =>
        ObjCBlock_CLLocationCoordinate2D_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  static final title = objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_MLNFeature,
    _sel_title,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_title,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  static final subtitle = objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_MLNFeature,
    _sel_subtitle,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNFeature,
      _sel_subtitle,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );
}

late final _sel_clusterIdentifier = objc.registerName("clusterIdentifier");
int _ObjCBlock_NSUInteger_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSUInteger_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSUInteger_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_NSUInteger_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSUInteger_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSUInteger_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSUInteger_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.UnsignedLong Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSUInteger_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      fromFunction(int Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSUInteger_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSUInteger_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          int Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_clusterPointCount = objc.registerName("clusterPointCount");

/// A protocol that feature subclasses (i.e. those already conforming to
/// the ``MLNFeature`` protocol) conform to if they represent clusters.
///
/// Currently the only class that conforms to ``MLNCluster`` is
/// ``MLNPointFeatureCluster`` (a subclass of ``MLNPointFeatureCluster``).
///
/// To check if a feature is a cluster, check conformity to ``MLNCluster``, for
/// example:
///
/// ```swift
/// let shape = try! MLNShape(data: clusterShapeData, encoding: String.Encoding.utf8.rawValue)
///
/// guard let pointFeature = shape as? MLNPointFeature else {
/// throw ExampleError.unexpectedFeatureType
/// }
///
/// // Check for cluster conformance
/// guard let cluster = pointFeature as? MLNCluster else {
/// throw ExampleError.featureIsNotACluster
/// }
///
/// // Currently the only supported class that conforms to ``MLNCluster`` is
/// // ``MLNPointFeatureCluster``
/// guard cluster is MLNPointFeatureCluster else {
/// throw ExampleError.unexpectedFeatureType
/// }
/// ```
interface class MLNCluster extends objc.ObjCProtocolBase implements MLNFeature {
  MLNCluster._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNCluster] that points to the same underlying object as [other].
  MLNCluster.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNCluster] that wraps the given raw object pointer.
  MLNCluster.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNCluster].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNCluster);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNCluster.cast());

  /// Builds an object that implements the MLNCluster protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNCluster implement(
      {required int Function() clusterIdentifier,
      required int Function() clusterPointCount,
      required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNCluster');
    MLNCluster.clusterIdentifier.implement(builder, clusterIdentifier);
    MLNCluster.clusterPointCount.implement(builder, clusterPointCount);
    MLNCluster.identifier.implement(builder, identifier);
    MLNCluster.setIdentifier_.implement(builder, setIdentifier_);
    MLNCluster.attributes.implement(builder, attributes);
    MLNCluster.setAttributes_.implement(builder, setAttributes_);
    MLNCluster.attributeForKey_.implement(builder, attributeForKey_);
    MLNCluster.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNCluster.coordinate.implement(builder, coordinate);
    MLNCluster.title.implement(builder, title);
    MLNCluster.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
    return MLNCluster.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNCluster protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required int Function() clusterIdentifier,
      required int Function() clusterPointCount,
      required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    MLNCluster.clusterIdentifier.implement(builder, clusterIdentifier);
    MLNCluster.clusterPointCount.implement(builder, clusterPointCount);
    MLNCluster.identifier.implement(builder, identifier);
    MLNCluster.setIdentifier_.implement(builder, setIdentifier_);
    MLNCluster.attributes.implement(builder, attributes);
    MLNCluster.setAttributes_.implement(builder, setAttributes_);
    MLNCluster.attributeForKey_.implement(builder, attributeForKey_);
    MLNCluster.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNCluster.coordinate.implement(builder, coordinate);
    MLNCluster.title.implement(builder, title);
    MLNCluster.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the MLNCluster protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNCluster implementAsListener(
      {required int Function() clusterIdentifier,
      required int Function() clusterPointCount,
      required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNCluster');
    MLNCluster.clusterIdentifier.implement(builder, clusterIdentifier);
    MLNCluster.clusterPointCount.implement(builder, clusterPointCount);
    MLNCluster.identifier.implement(builder, identifier);
    MLNCluster.setIdentifier_.implementAsListener(builder, setIdentifier_);
    MLNCluster.attributes.implement(builder, attributes);
    MLNCluster.setAttributes_.implementAsListener(builder, setAttributes_);
    MLNCluster.attributeForKey_.implement(builder, attributeForKey_);
    MLNCluster.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNCluster.coordinate.implement(builder, coordinate);
    MLNCluster.title.implement(builder, title);
    MLNCluster.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
    return MLNCluster.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNCluster protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {required int Function() clusterIdentifier,
      required int Function() clusterPointCount,
      required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    MLNCluster.clusterIdentifier.implement(builder, clusterIdentifier);
    MLNCluster.clusterPointCount.implement(builder, clusterPointCount);
    MLNCluster.identifier.implement(builder, identifier);
    MLNCluster.setIdentifier_.implementAsListener(builder, setIdentifier_);
    MLNCluster.attributes.implement(builder, attributes);
    MLNCluster.setAttributes_.implementAsListener(builder, setAttributes_);
    MLNCluster.attributeForKey_.implement(builder, attributeForKey_);
    MLNCluster.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNCluster.coordinate.implement(builder, coordinate);
    MLNCluster.title.implement(builder, title);
    MLNCluster.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the MLNCluster protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNCluster implementAsBlocking(
      {required int Function() clusterIdentifier,
      required int Function() clusterPointCount,
      required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNCluster');
    MLNCluster.clusterIdentifier.implement(builder, clusterIdentifier);
    MLNCluster.clusterPointCount.implement(builder, clusterPointCount);
    MLNCluster.identifier.implement(builder, identifier);
    MLNCluster.setIdentifier_.implementAsBlocking(builder, setIdentifier_);
    MLNCluster.attributes.implement(builder, attributes);
    MLNCluster.setAttributes_.implementAsBlocking(builder, setAttributes_);
    MLNCluster.attributeForKey_.implement(builder, attributeForKey_);
    MLNCluster.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNCluster.coordinate.implement(builder, coordinate);
    MLNCluster.title.implement(builder, title);
    MLNCluster.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
    return MLNCluster.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNCluster protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {required int Function() clusterIdentifier,
      required int Function() clusterPointCount,
      required objc.ObjCObjectBase? Function() identifier,
      required void Function(objc.ObjCObjectBase?) setIdentifier_,
      required objc.NSDictionary Function() attributes,
      required void Function(objc.NSDictionary) setAttributes_,
      required objc.ObjCObjectBase? Function(objc.NSString) attributeForKey_,
      required objc.NSDictionary Function() geoJSONDictionary,
      required CLLocationCoordinate2D Function() coordinate,
      objc.NSString? Function()? title,
      objc.NSString? Function()? subtitle,
      bool $keepIsolateAlive = true}) {
    MLNCluster.clusterIdentifier.implement(builder, clusterIdentifier);
    MLNCluster.clusterPointCount.implement(builder, clusterPointCount);
    MLNCluster.identifier.implement(builder, identifier);
    MLNCluster.setIdentifier_.implementAsBlocking(builder, setIdentifier_);
    MLNCluster.attributes.implement(builder, attributes);
    MLNCluster.setAttributes_.implementAsBlocking(builder, setAttributes_);
    MLNCluster.attributeForKey_.implement(builder, attributeForKey_);
    MLNCluster.geoJSONDictionary.implement(builder, geoJSONDictionary);
    MLNCluster.coordinate.implement(builder, coordinate);
    MLNCluster.title.implement(builder, title);
    MLNCluster.subtitle.implement(builder, subtitle);
    builder.addProtocol($protocol);
  }

  /// The identifier for the cluster.
  static final clusterIdentifier = objc.ObjCProtocolMethod<int Function()>(
    _protocol_MLNCluster,
    _sel_clusterIdentifier,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.UnsignedLong Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1ckyi24)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_clusterIdentifier,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_NSUInteger_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// The number of points within this cluster
  static final clusterPointCount = objc.ObjCProtocolMethod<int Function()>(
    _protocol_MLNCluster,
    _sel_clusterPointCount,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.UnsignedLong Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1ckyi24)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_clusterPointCount,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_NSUInteger_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  static final identifier =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase? Function()>(
    _protocol_MLNCluster,
    _sel_identifier,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_identifier,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase? Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  static final setIdentifier_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.ObjCObjectBase?)>(
    _protocol_MLNCluster,
    _sel_setIdentifier_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _MapLibreFFi_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_setIdentifier_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function(objc.ObjCObjectBase?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_objcObjCObject.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase? arg1) => func(arg1)),
    (void Function(objc.ObjCObjectBase?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_objcObjCObject.listener(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase? arg1) => func(arg1)),
    (void Function(objc.ObjCObjectBase?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_objcObjCObject.blocking(
            (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase? arg1) => func(arg1)),
  );

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  static final attributes =
      objc.ObjCProtocolMethod<objc.NSDictionary Function()>(
    _protocol_MLNCluster,
    _sel_attributes,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_attributes,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.NSDictionary Function() func) =>
        ObjCBlock_NSDictionary_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  static final setAttributes_ =
      objc.ObjCProtocolListenableMethod<void Function(objc.NSDictionary)>(
    _protocol_MLNCluster,
    _sel_setAttributes_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _MapLibreFFi_protocolTrampoline_18v1jvf)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_setAttributes_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function(objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSDictionary.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
    (void Function(objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSDictionary.listener(
            (ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
    (void Function(objc.NSDictionary) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSDictionary.blocking(
            (ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
  );

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  static final attributeForKey_ =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase? Function(objc.NSString)>(
    _protocol_MLNCluster,
    _sel_attributeForKey_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    instancetype Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _MapLibreFFi_protocolTrampoline_xr62hr)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_attributeForKey_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase? Function(objc.NSString) func) =>
        ObjCBlock_objcObjCObject_ffiVoid_UIActivityItemsConfigurationMetadataKey
            .fromFunction(
                (ffi.Pointer<ffi.Void> _, objc.NSString arg1) => func(arg1)),
  );

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  static final geoJSONDictionary =
      objc.ObjCProtocolMethod<objc.NSDictionary Function()>(
    _protocol_MLNCluster,
    _sel_geoJSONDictionary,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_geoJSONDictionary,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.NSDictionary Function() func) =>
        ObjCBlock_NSDictionary_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  static final coordinate =
      objc.ObjCProtocolMethod<CLLocationCoordinate2D Function()>(
    _protocol_MLNCluster,
    _sel_coordinate,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    CLLocationCoordinate2D Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_neuenc)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_coordinate,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CLLocationCoordinate2D Function() func) =>
        ObjCBlock_CLLocationCoordinate2D_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  static final title = objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_MLNCluster,
    _sel_title,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_title,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  static final subtitle = objc.ObjCProtocolMethod<objc.NSString? Function()>(
    _protocol_MLNCluster,
    _sel_subtitle,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNCluster,
      _sel_subtitle,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSString? Function() func) =>
        ObjCBlock_NSString_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );
}

late final _class_MLNPointAnnotation = objc.getClass("MLNPointAnnotation");
late final _sel_setCoordinate_ = objc.registerName("setCoordinate:");

/// An ``MLNPointAnnotation`` object represents a one-dimensional shape located at a
/// single geographical coordinate. Depending on how it is used, an
/// ``MLNPointAnnotation`` object is known as a point annotation or point shape. For
/// example, you could use a point shape to represent a city at low zoom levels, an
/// address at high zoom levels, or the location of a long press gesture.
///
/// You can add point shapes to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``’s or
/// ``MLNVectorTileSource``’s point shapes collectively using an ``MLNVectorTileSource`` or
/// ``MLNSymbolStyleLayer`` object.
///
/// For more interactivity, add a selectable point annotation to a map view using
/// the ``MLNMapView/addAnnotation:`` method. Alternatively, define your own model
/// class that conforms to the ``MLNAnnotation`` protocol. Configure a point
/// annotation’s appearance using
/// ``MLNMapViewDelegate/mapView:imageForAnnotation:`` or
/// ``MLNMapViewDelegate/mapView:viewForAnnotation:`` (iOS only). A point
/// annotation’s ``MLNShape/title`` and ``MLNShape/title`` properties define the
/// default content of the annotation’s callout (on iOS) or popover (on macOS).
///
/// To group multiple related points together in one shape, use an
/// ``MLNPointCollection`` or ``MLNPointCollection`` object. To access
/// a point’s attributes, use an ``MLNPointFeature`` object.
///
/// A point shape is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.2">Point</a> geometry
/// in GeoJSON.
///
/// #### Related examples
/// TODO: Mark a place on the map with an annotation
/// TODO: Mark a place on the map with an image
/// TODO: Default callout usage
/// Learn how to add ``MLNPointAnnotation`` objects to your map.
class MLNPointAnnotation extends MLNShape {
  MLNPointAnnotation._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPointAnnotation] that points to the same underlying object as [other].
  MLNPointAnnotation.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPointAnnotation] that wraps the given raw object pointer.
  MLNPointAnnotation.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPointAnnotation].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointAnnotation);
  }

  /// The coordinate point of the shape, specified as a latitude and longitude.
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The coordinate point of the shape, specified as a latitude and longitude.
  set coordinate(CLLocationCoordinate2D value) {
    _objc_msgSend_1zv0am(this.ref.pointer, _sel_setCoordinate_, value);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPointAnnotation,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPointAnnotation init() {
    objc.checkOsVersionInternal('MLNPointAnnotation.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointAnnotation.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNPointAnnotation new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPointAnnotation, _sel_new);
    return MLNPointAnnotation.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPointAnnotation allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNPointAnnotation, _sel_allocWithZone_, zone);
    return MLNPointAnnotation.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNPointAnnotation alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPointAnnotation, _sel_alloc);
    return MLNPointAnnotation.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNPointAnnotation self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPointAnnotation.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNPointAnnotation retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPointAnnotation.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNPointAnnotation autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPointAnnotation.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNPointAnnotation, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPointAnnotation? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPointAnnotation.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// Returns a new instance of MLNPointAnnotation constructed with the default `new` method.
  factory MLNPointAnnotation() => new$();
}

late final _class_MLNPointCollection = objc.getClass("MLNPointCollection");
late final _sel_pointCollectionWithCoordinates_count_ =
    objc.registerName("pointCollectionWithCoordinates:count:");
final _objc_msgSend_i90tul = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            int)>();
late final _sel_coordinates = objc.registerName("coordinates");
final _objc_msgSend_k56nhe = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<CLLocationCoordinate2D> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<CLLocationCoordinate2D> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_pointCount = objc.registerName("pointCount");
late final _sel_getCoordinates_range_ =
    objc.registerName("getCoordinates:range:");
final _objc_msgSend_peohs4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                objc.NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            objc.NSRange)>();

/// An ``MLNPointCollection`` object represents a shape consisting of one or more
/// disconnected vertices, specified as `CLLocationCoordinate2D` instances. The
/// points in the collection may be related but are not connected spatially. For
/// example, you could use a point collection to represent all the trees in an
/// orchard.
///
/// You can add point collections to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``’s or
/// ``MLNVectorTileSource``’s point collections collectively using an
/// ``MLNCircleStyleLayer`` or ``MLNCircleStyleLayer`` object. To access a point
/// collection’s attributes, use an ``MLNPointCollectionFeature`` object.
///
/// You cannot add an ``MLNPointCollection`` object directly to a map view as an
/// annotation. However, you can create individual ``MLNPointAnnotation`` objects
/// from the `coordinates` array and add those annotation objects to the map view
/// using the ``MLNMapView/addAnnotations:`` method.
///
/// A point collection is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.3">MultiPoint</a>
/// geometry in GeoJSON. Do not confuse ``MLNPointCollection`` with ``MLNPointCollection``,
/// the abstract superclass of ``MLNPolyline`` and ``MLNPolyline``.
class MLNPointCollection extends MLNShape implements MLNOverlay {
  MLNPointCollection._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPointCollection] that points to the same underlying object as [other].
  MLNPointCollection.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPointCollection] that wraps the given raw object pointer.
  MLNPointCollection.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPointCollection].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointCollection);
  }

  /// Creates and returns a ``MLNPointCollection`` object from the specified set of
  /// coordinates.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the new object.
  /// @param count The number of items in the `coords` array.
  /// @return A new point collection object.
  static MLNPointCollection pointCollectionWithCoordinates(
      ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count}) {
    final _ret = _objc_msgSend_i90tul(_class_MLNPointCollection,
        _sel_pointCollectionWithCoordinates_count_, coords, count);
    return MLNPointCollection.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// The array of coordinates associated with the shape.
  ffi.Pointer<CLLocationCoordinate2D> get coordinates {
    return _objc_msgSend_k56nhe(this.ref.pointer, _sel_coordinates);
  }

  /// The number of coordinates associated with the shape.
  int get pointCount {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_pointCount);
  }

  /// Retrieves one or more coordinates associated with the shape.
  ///
  /// @param coords On input, you must provide a C array of structures large enough
  /// to hold the desired number of coordinates. On output, this structure
  /// contains the requested coordinate data.
  /// @param range The range of points you want. The `location` field indicates the
  /// first point you are requesting, with `0` being the first point, `1` being
  /// the second point, and so on. The `length` field indicates the number of
  /// points you want. The array in _`coords`_ must be large enough to accommodate
  /// the number of requested coordinates.
  void getCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords,
      {required objc.NSRange range}) {
    _objc_msgSend_peohs4(
        this.ref.pointer, _sel_getCoordinates_range_, coords, range);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPointCollection,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPointCollection init() {
    objc.checkOsVersionInternal('MLNPointCollection.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointCollection.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNPointCollection new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPointCollection, _sel_new);
    return MLNPointCollection.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPointCollection allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNPointCollection, _sel_allocWithZone_, zone);
    return MLNPointCollection.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNPointCollection alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPointCollection, _sel_alloc);
    return MLNPointCollection.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNPointCollection self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPointCollection.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNPointCollection retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPointCollection.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNPointCollection autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPointCollection.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNPointCollection, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPointCollection? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPointCollection.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The cooordinate rectangle that encompasses the overlay. (required) (read-only)
  ///
  /// This property contains the smallest rectangle that completely encompasses the
  /// overlay. Implementers of this protocol must set this area when implementing
  /// their overlay class, and after setting it, you must not change it.
  ///
  /// If this overlay spans the antimeridian, its bounds may extend west of −180 degrees
  /// longitude or east of 180 degrees longitude. For example, an overlay covering the
  /// Pacific Ocean from Tokyo to San Francisco might have a bounds extending
  /// from (35.68476, −220.24257) to (37.78428, −122.41310).
  MLNCoordinateBounds get overlayBounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(_ptr, this.ref.pointer, _sel_overlayBounds)
        : _ptr.ref = _objc_msgSend_ygoa6a(this.ref.pointer, _sel_overlayBounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// Returns a Boolean indicating whether the specified rectangle intersects the
  /// receiver’s shape.
  ///
  /// You can implement this method to provide more specific bounds checking for an
  /// overlay. If you do not implement it, the bounding rectangle is used to detect
  /// intersections.
  ///
  /// @param overlayBounds The rectangle to intersect with the receiver’s area.
  /// @return `YES` if any part of the map rectangle intersects the receiver’s shape
  /// or `NO` if it does not.
  bool intersectsOverlayBounds(MLNCoordinateBounds overlayBounds$1) {
    return _objc_msgSend_10h1dgu(
        this.ref.pointer, _sel_intersectsOverlayBounds_, overlayBounds$1);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPointCollection', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPointCollection', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNPointCollection constructed with the default `new` method.
  factory MLNPointCollection() => new$();
}

late final _class_MLNMultiPoint = objc.getClass("MLNMultiPoint");
late final _sel_setCoordinates_count_ =
    objc.registerName("setCoordinates:count:");
final _objc_msgSend_xee6m1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            int)>();
late final _sel_insertCoordinates_count_atIndex_ =
    objc.registerName("insertCoordinates:count:atIndex:");
final _objc_msgSend_1vf050y = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            int,
            int)>();
late final _sel_appendCoordinates_count_ =
    objc.registerName("appendCoordinates:count:");
late final _sel_replaceCoordinatesInRange_withCoordinates_ =
    objc.registerName("replaceCoordinatesInRange:withCoordinates:");
final _objc_msgSend_1krtrwi = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.Pointer<CLLocationCoordinate2D>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            ffi.Pointer<CLLocationCoordinate2D>)>();
late final _sel_replaceCoordinatesInRange_withCoordinates_count_ =
    objc.registerName("replaceCoordinatesInRange:withCoordinates:count:");
final _objc_msgSend_61jbin = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            ffi.Pointer<CLLocationCoordinate2D>,
            int)>();
late final _sel_removeCoordinatesInRange_ =
    objc.registerName("removeCoordinatesInRange:");
final _objc_msgSend_1e3pm0z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>();

/// The ``MLNMultiPoint`` class is an abstract superclass used to define shapes
/// composed of multiple vertices.
///
/// Create instances of ``MLNPolyline`` or ``MLNPolyline`` in order to use
/// properties of ``MLNMultiPoint``. Do not create instances of ``MLNMultiPoint``
/// directly and do not create your own subclasses of this class. You can use
/// the method and properties of this class to access information about the
/// vertices of the line or polygon.
///
/// Do not confuse ``MLNMultiPoint`` with ``MLNMultiPoint``, which represents a
/// collection of related but disconnected points.
class MLNMultiPoint extends MLNShape {
  MLNMultiPoint._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMultiPoint] that points to the same underlying object as [other].
  MLNMultiPoint.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMultiPoint] that wraps the given raw object pointer.
  MLNMultiPoint.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMultiPoint].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPoint);
  }

  /// The array of vertices associated with the shape.
  ///
  /// This C array is a pointer to a structure inside the multipoint object, which
  /// may have a lifetime shorter than the multipoint object and will certainly not
  /// have a longer lifetime. Therefore, you should copy the C array if it needs to
  /// be stored outside of the memory context in which you use this property.
  ffi.Pointer<CLLocationCoordinate2D> get coordinates {
    return _objc_msgSend_k56nhe(this.ref.pointer, _sel_coordinates);
  }

  /// The number of vertices in the shape.
  int get pointCount {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_pointCount);
  }

  /// Retrieves the vertices of part of the shape.
  ///
  /// @param coords On input, you must provide a C array of `CLLocationCoordinate2D`
  /// structures large enough to hold the desired number of coordinates. On
  /// output, this structure contains the requested coordinate data.
  /// @param range The range of vertices you want. The `location` field indicates
  /// the first vertex you are requesting, with `0` being the first vertex, `1`
  /// being the second vertex, and so on. The `length` field indicates the number
  /// of vertices you want. The array in `coords` must be large enough to
  /// accommodate the number of requested coordinates.
  void getCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords,
      {required objc.NSRange range}) {
    _objc_msgSend_peohs4(
        this.ref.pointer, _sel_getCoordinates_range_, coords, range);
  }

  /// Sets the shape’s vertices to the given C array of vertices.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the shape’s `coordinates` property.
  /// @param count The number of coordinates from the `coords` array.
  void setCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count}) {
    _objc_msgSend_xee6m1(
        this.ref.pointer, _sel_setCoordinates_count_, coords, count);
  }

  /// Inserts the given vertices into the shape.
  ///
  /// If the shape is currently visible on the map as an annotation, it is redrawn
  /// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
  /// explicitly set the ``MLNShapeSource/shape`` property in order for any style
  /// layers that use the source to be redrawn.
  ///
  /// @param coords The array of coordinates to insert into the shape. The data in
  /// this array is copied to the shape’s `coordinates` property.
  /// @param count The number of items in the `coords` array.
  /// @param index The zero-based index at which the first coordinate in `coords`
  /// will appear in the `coordinates` property.
  void insertCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count, required int atIndex}) {
    _objc_msgSend_1vf050y(this.ref.pointer,
        _sel_insertCoordinates_count_atIndex_, coords, count, atIndex);
  }

  /// Appends the given vertices to the shape.
  ///
  /// If the shape is currently visible on the map as an annotation, it is redrawn
  /// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
  /// explicitly set the ``MLNShapeSource/shape`` property in order for any style
  /// layers that use the source to be redrawn.
  ///
  /// @param coords The array of coordinates to add to the shape. The data in this
  /// array is copied to the shape’s `coordinates` property.
  /// @param count The number of items in the `coords` array.
  void appendCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count}) {
    _objc_msgSend_xee6m1(
        this.ref.pointer, _sel_appendCoordinates_count_, coords, count);
  }

  /// Replaces the vertices at the given range in the shape with the same number of
  /// vertices from a given C array.
  ///
  /// If the shape is currently visible on the map as an annotation, it is redrawn
  /// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
  /// explicitly set the ``MLNShapeSource/shape`` property in order for any style
  /// layers that use the source to be redrawn.
  ///
  /// The number of coordinates in `coords` must be equal to the length of `range`.
  /// If you want to insert or delete one or more vertices, use the
  /// `-replaceCoordinatesInRange:withCoordinates:count:` method.
  ///
  /// If `range` extends beyond the shape’s `coordinates` property, an
  /// `NSRangeException` is raised. If you want to append new vertices to the shape,
  /// use the `-appendCoordinates:count:` method.
  ///
  /// @param range The range of vertices to replace. The `location` field indicates
  /// the first vertex you are replacing, with `0` being the first vertex, `1`
  /// being the second vertex, and so on. The `length` field indicates the number
  /// of vertices to replace.
  /// @param coords The array of coordinates defining part of the shape. The data in
  /// this array is copied to the shape’s `coordinates` property.
  void replaceCoordinatesInRange(objc.NSRange range,
      {required ffi.Pointer<CLLocationCoordinate2D> withCoordinates}) {
    _objc_msgSend_1krtrwi(
        this.ref.pointer,
        _sel_replaceCoordinatesInRange_withCoordinates_,
        range,
        withCoordinates);
  }

  /// Replaces the vertices at the given range in the shape with the specified number
  /// of vertices from a given C array.
  ///
  /// If the shape is currently visible on the map as an annotation, it is redrawn
  /// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
  /// explicitly set the ``MLNShapeSource/shape`` property in order for any style
  /// layers that use the source to be redrawn.
  ///
  /// If `count` is greater than the `length` field of `range`, some vertices will
  /// effectively be inserted into the shape. On the other hand, if `count` is less
  /// than the `length` field of `range`, some vertices will effectively be removed.
  ///
  /// If `range` extends beyond the shape’s `coordinates` property, an
  /// `NSRangeException` is raised. If you want to append new vertices to the shape,
  /// use the `-appendCoordinates:count:` method.
  ///
  /// @param range The range of vertices to replace. The `location` field indicates
  /// the first vertex you are replacing, with `0` being the first vertex, `1`
  /// being the second vertex, and so on. The `length` field indicates the number
  /// of vertices to replace.
  /// @param coords The array of coordinates defining part of the shape. The data in
  /// this array is copied to the shape’s `coordinates` property.
  /// @param count The number of coordinates from the `coords` array to insert in
  /// place of the coordinates in `range`. The sum of `range`’s length and this
  /// count must not exceed the number of items currently in the `coordinates`
  /// property.
  void replaceCoordinatesInRange$1(objc.NSRange range,
      {required ffi.Pointer<CLLocationCoordinate2D> withCoordinates,
      required int count}) {
    _objc_msgSend_61jbin(
        this.ref.pointer,
        _sel_replaceCoordinatesInRange_withCoordinates_count_,
        range,
        withCoordinates,
        count);
  }

  /// Removes the vertices at the given range from the shape.
  ///
  /// If the shape is currently visible on the map as an annotation, it is redrawn
  /// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
  /// explicitly set the ``MLNShapeSource/shape`` property in order for any style
  /// layers that use the source to be redrawn.
  ///
  /// If `range` extends beyond the shape’s `coordinates` property, an
  /// `NSRangeException` is raised.
  ///
  /// @param range The range of vertices to remove. The `location` field indicates
  /// the first vertex you are removing, with `0` being the first vertex, `1`
  /// being the second vertex, and so on. The `length` field indicates the number
  /// of vertices to remove.
  void removeCoordinatesInRange(objc.NSRange range) {
    _objc_msgSend_1e3pm0z(
        this.ref.pointer, _sel_removeCoordinatesInRange_, range);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNMultiPoint,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNMultiPoint init() {
    objc.checkOsVersionInternal('MLNMultiPoint.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPoint.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMultiPoint new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMultiPoint, _sel_new);
    return MLNMultiPoint.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMultiPoint allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNMultiPoint, _sel_allocWithZone_, zone);
    return MLNMultiPoint.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMultiPoint alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMultiPoint, _sel_alloc);
    return MLNMultiPoint.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNMultiPoint self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNMultiPoint.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNMultiPoint retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNMultiPoint.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNMultiPoint autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNMultiPoint.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNMultiPoint, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNMultiPoint? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNMultiPoint.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of MLNMultiPoint constructed with the default `new` method.
  factory MLNMultiPoint() => new$();
}

late final _class_MLNPolygon = objc.getClass("MLNPolygon");
late final _sel_interiorPolygons = objc.registerName("interiorPolygons");
late final _sel_polygonWithCoordinates_count_ =
    objc.registerName("polygonWithCoordinates:count:");
late final _sel_polygonWithCoordinates_count_interiorPolygons_ =
    objc.registerName("polygonWithCoordinates:count:interiorPolygons:");
final _objc_msgSend_inmhr7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CLLocationCoordinate2D>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CLLocationCoordinate2D>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();

/// An ``MLNPolygon`` object represents a closed shape consisting of four or more
/// vertices, specified as `CLLocationCoordinate2D` instances, and the edges that
/// connect them. For example, you could use a polygon shape to represent a
/// building, a lake, or an area you want to highlight.
///
/// You can add polygon shapes to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``’s or
/// ``MLNVectorTileSource``’s polygons collectively using an ``MLNVectorTileSource`` or
/// ``MLNSymbolStyleLayer`` object. To access a polygon’s attributes, use an
/// ``MLNPolygonFeature`` object.
///
/// Alternatively, you can add a polygon overlay directly to a map view using the
/// ``MLNMapView/addAnnotation:`` or ``MLNMapView/addOverlay:`` method. Configure
/// a polygon overlay’s appearance using
/// ``MLNMapViewDelegate/mapView:strokeColorForShapeAnnotation:`` and
/// ``MLNMapViewDelegate/mapView:fillColorForPolygonAnnotation:``.
///
/// The vertices are automatically connected in the order in which you provide
/// them. You should close the polygon by specifying the same
/// `CLLocationCoordinate2D` as the first and last vertices; otherwise, the
/// polygon’s fill may not cover the area you expect it to. To avoid filling the
/// space within the shape, give the polygon a transparent fill or use an
/// ``MLNPolyline`` object.
///
/// A polygon may have one or more interior polygons, or holes, that you specify as
/// ``MLNPolygon`` objects with the `+polygonWithCoordinates:count:interiorPolygons:`
/// method. For example, if a polygon represents a lake, it could exclude an island
/// within the lake using an interior polygon. Interior polygons may not themselves
/// have interior polygons. To represent a shape that includes a polygon within a
/// hole or, more generally, to group multiple polygons together in one shape, use
/// an ``MLNMultiPolygon`` or ``MLNMultiPolygon`` object.
///
/// To make the polygon straddle the antimeridian, specify some longitudes less
/// than −180 degrees or greater than 180 degrees.
///
/// #### Related examples
/// TODO: Add a polygon annotation, learn how to initialize an
/// ``MLNPolygon`` object from an array of coordinates.
class MLNPolygon extends MLNMultiPoint implements MLNOverlay {
  MLNPolygon._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPolygon] that points to the same underlying object as [other].
  MLNPolygon.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPolygon] that wraps the given raw object pointer.
  MLNPolygon.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPolygon].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPolygon);
  }

  /// The array of polygons nested inside the receiver.
  ///
  /// The area occupied by any interior polygons is excluded from the overall shape.
  /// Interior polygons should not overlap. An interior polygon should not have
  /// interior polygons of its own.
  ///
  /// If there are no interior polygons, the value of this property is `nil`.
  objc.NSArray? get interiorPolygons {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_interiorPolygons);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates and returns an ``MLNPolygon`` object from the specified set of
  /// coordinates.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the new object.
  /// @param count The number of items in the `coords` array.
  /// @return A new polygon object.
  static MLNPolygon polygonWithCoordinates(
      ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count}) {
    final _ret = _objc_msgSend_i90tul(
        _class_MLNPolygon, _sel_polygonWithCoordinates_count_, coords, count);
    return MLNPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates and returns an ``MLNPolygon`` object from the specified set of
  /// coordinates and interior polygons.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the new object.
  /// @param count The number of items in the `coords` array.
  /// @param interiorPolygons An array of ``MLNPolygon`` objects that define regions
  /// excluded from the overall shape. If this array is `nil` or empty, the shape
  /// is considered to have no interior polygons.
  /// @return A new polygon object.
  static MLNPolygon polygonWithCoordinates$1(
      ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count,
      objc.NSArray? interiorPolygons$1}) {
    final _ret = _objc_msgSend_inmhr7(
        _class_MLNPolygon,
        _sel_polygonWithCoordinates_count_interiorPolygons_,
        coords,
        count,
        interiorPolygons$1?.ref.pointer ?? ffi.nullptr);
    return MLNPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPolygon,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPolygon init() {
    objc.checkOsVersionInternal('MLNPolygon.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNPolygon new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPolygon, _sel_new);
    return MLNPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPolygon allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNPolygon, _sel_allocWithZone_, zone);
    return MLNPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNPolygon alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPolygon, _sel_alloc);
    return MLNPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNPolygon self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNPolygon retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNPolygon autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPolygon, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPolygon? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The cooordinate rectangle that encompasses the overlay. (required) (read-only)
  ///
  /// This property contains the smallest rectangle that completely encompasses the
  /// overlay. Implementers of this protocol must set this area when implementing
  /// their overlay class, and after setting it, you must not change it.
  ///
  /// If this overlay spans the antimeridian, its bounds may extend west of −180 degrees
  /// longitude or east of 180 degrees longitude. For example, an overlay covering the
  /// Pacific Ocean from Tokyo to San Francisco might have a bounds extending
  /// from (35.68476, −220.24257) to (37.78428, −122.41310).
  MLNCoordinateBounds get overlayBounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(_ptr, this.ref.pointer, _sel_overlayBounds)
        : _ptr.ref = _objc_msgSend_ygoa6a(this.ref.pointer, _sel_overlayBounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// Returns a Boolean indicating whether the specified rectangle intersects the
  /// receiver’s shape.
  ///
  /// You can implement this method to provide more specific bounds checking for an
  /// overlay. If you do not implement it, the bounding rectangle is used to detect
  /// intersections.
  ///
  /// @param overlayBounds The rectangle to intersect with the receiver’s area.
  /// @return `YES` if any part of the map rectangle intersects the receiver’s shape
  /// or `NO` if it does not.
  bool intersectsOverlayBounds(MLNCoordinateBounds overlayBounds$1) {
    return _objc_msgSend_10h1dgu(
        this.ref.pointer, _sel_intersectsOverlayBounds_, overlayBounds$1);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException('MLNPolygon', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException('MLNPolygon', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNPolygon constructed with the default `new` method.
  factory MLNPolygon() => new$();
}

late final _class_MLNMultiPolygon = objc.getClass("MLNMultiPolygon");
late final _sel_polygons = objc.registerName("polygons");
late final _sel_multiPolygonWithPolygons_ =
    objc.registerName("multiPolygonWithPolygons:");

/// An ``MLNMultiPolygon`` object represents a shape consisting of one or more
/// polygons that do not overlap. For example, you could use a multipolygon shape
/// to represent the body of land that consists of an island surrounded by an
/// atoll: the inner island would be one ``MLNPolygon`` object, while the surrounding
/// atoll would be another. You could also use a multipolygon shape to represent a
/// group of disconnected but related buildings.
///
/// You can add multipolygon shapes to the map by adding them to an
/// ``MLNShapeSource`` object. Configure the appearance of an ``MLNShapeSource``’s or
/// ``MLNVectorTileSource``’s multipolygons collectively using an ``MLNVectorTileSource``
/// or ``MLNSymbolStyleLayer`` object.
///
/// You cannot add an ``MLNMultiPolygon`` object directly to a map view using
/// ``MLNMapView/addAnnotation:`` or ``MLNMapView/addOverlay:``. However, you can
/// add the `polygons` array’s items as overlays individually.
class MLNMultiPolygon extends MLNShape implements MLNOverlay {
  MLNMultiPolygon._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMultiPolygon] that points to the same underlying object as [other].
  MLNMultiPolygon.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMultiPolygon] that wraps the given raw object pointer.
  MLNMultiPolygon.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMultiPolygon].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPolygon);
  }

  /// An array of polygons forming the multipolygon.
  objc.NSArray get polygons {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_polygons);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates and returns a multipolygon object consisting of the given polygons.
  ///
  /// @param polygons The array of polygons defining the shape.
  /// @return A new multipolygon object.
  static MLNMultiPolygon multiPolygonWithPolygons(objc.NSArray polygons$1) {
    final _ret = _objc_msgSend_1sotr3r(_class_MLNMultiPolygon,
        _sel_multiPolygonWithPolygons_, polygons$1.ref.pointer);
    return MLNMultiPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNMultiPolygon,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNMultiPolygon init() {
    objc.checkOsVersionInternal('MLNMultiPolygon.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMultiPolygon new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMultiPolygon, _sel_new);
    return MLNMultiPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMultiPolygon allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNMultiPolygon, _sel_allocWithZone_, zone);
    return MLNMultiPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMultiPolygon alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMultiPolygon, _sel_alloc);
    return MLNMultiPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNMultiPolygon self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNMultiPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNMultiPolygon retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNMultiPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNMultiPolygon autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNMultiPolygon.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNMultiPolygon, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNMultiPolygon? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNMultiPolygon.castFromPointer(_ret, retain: false, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The cooordinate rectangle that encompasses the overlay. (required) (read-only)
  ///
  /// This property contains the smallest rectangle that completely encompasses the
  /// overlay. Implementers of this protocol must set this area when implementing
  /// their overlay class, and after setting it, you must not change it.
  ///
  /// If this overlay spans the antimeridian, its bounds may extend west of −180 degrees
  /// longitude or east of 180 degrees longitude. For example, an overlay covering the
  /// Pacific Ocean from Tokyo to San Francisco might have a bounds extending
  /// from (35.68476, −220.24257) to (37.78428, −122.41310).
  MLNCoordinateBounds get overlayBounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(_ptr, this.ref.pointer, _sel_overlayBounds)
        : _ptr.ref = _objc_msgSend_ygoa6a(this.ref.pointer, _sel_overlayBounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// Returns a Boolean indicating whether the specified rectangle intersects the
  /// receiver’s shape.
  ///
  /// You can implement this method to provide more specific bounds checking for an
  /// overlay. If you do not implement it, the bounding rectangle is used to detect
  /// intersections.
  ///
  /// @param overlayBounds The rectangle to intersect with the receiver’s area.
  /// @return `YES` if any part of the map rectangle intersects the receiver’s shape
  /// or `NO` if it does not.
  bool intersectsOverlayBounds(MLNCoordinateBounds overlayBounds$1) {
    return _objc_msgSend_10h1dgu(
        this.ref.pointer, _sel_intersectsOverlayBounds_, overlayBounds$1);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNMultiPolygon', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNMultiPolygon', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNMultiPolygon constructed with the default `new` method.
  factory MLNMultiPolygon() => new$();
}

late final _class_MLNPolyline = objc.getClass("MLNPolyline");
late final _sel_polylineWithCoordinates_count_ =
    objc.registerName("polylineWithCoordinates:count:");

/// An ``MLNPolyline`` object represents a shape consisting of two or more vertices,
/// specified as `CLLocationCoordinate2D` instances, and the line segments that
/// connect them. For example, you could use an polyline to represent a road or the
/// path along which something moves.
///
/// You can add polyline shapes to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``’s or
/// ``MLNVectorTileSource``’s polylines collectively using an ``MLNLineStyleLayer`` or
/// ``MLNSymbolStyleLayer`` object. To access a polyline’s attributes, use an
/// ``MLNPolylineFeature`` object.
///
/// Alternatively, you can add a polyline overlay directly to a map view using the
/// ``MLNMapView/addAnnotation:`` or ``MLNMapView/addOverlay:`` methods. Configure
/// a polyline overlay’s appearance using
/// ``MLNMapViewDelegate/mapView:strokeColorForShapeAnnotation:`` and
/// ``MLNMapViewDelegate/mapView:lineWidthForPolylineAnnotation:``.
///
/// The vertices are automatically connected in the order in which you provide
/// them. The first and last vertices are not connected to each other, but you can
/// specify the same `CLLocationCoordinate2D` as the first and last vertices in
/// order to close the polyline. To fill the space within the shape, use an
/// ``MLNPolygon`` object. To group multiple polylines together in one shape, use an
/// ``MLNMultiPolyline`` or ``MLNShapeCollection`` object.
///
/// To make the polyline go across the antimeridian or international date line,
/// specify some longitudes less than −180 degrees or greater than 180 degrees.
/// For example, a polyline that stretches from Tokyo to San Francisco would have
/// coordinates of (35.68476, -220.24257) and (37.78428, -122.41310).
///
/// ```swift
/// let coordinates = [
/// CLLocationCoordinate2D(latitude: 35.68476, longitude: -220.24257),
/// CLLocationCoordinate2D(latitude: 37.78428, longitude: -122.41310)
/// ]
/// let polyline = MLNPolyline(coordinates: coordinates, count: UInt(coordinates.count))
/// ```
///
/// A polyline is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.4">LineString</a>
/// geometry in GeoJSON.
///
/// #### Related examples
///
/// - <doc:LineOnUserTap>
/// - <doc:AnimatedLineExample>
class MLNPolyline extends MLNMultiPoint implements MLNOverlay {
  MLNPolyline._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPolyline] that points to the same underlying object as [other].
  MLNPolyline.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPolyline] that wraps the given raw object pointer.
  MLNPolyline.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPolyline].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPolyline);
  }

  /// Creates and returns an ``MLNPolyline`` object from the specified set of
  /// coordinates.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the new object.
  /// @param count The number of items in the `coords` array.
  /// @return A new polyline object.
  static MLNPolyline polylineWithCoordinates(
      ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count}) {
    final _ret = _objc_msgSend_i90tul(
        _class_MLNPolyline, _sel_polylineWithCoordinates_count_, coords, count);
    return MLNPolyline.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPolyline,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPolyline init() {
    objc.checkOsVersionInternal('MLNPolyline.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNPolyline new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPolyline, _sel_new);
    return MLNPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPolyline allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNPolyline, _sel_allocWithZone_, zone);
    return MLNPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNPolyline alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPolyline, _sel_alloc);
    return MLNPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNPolyline self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPolyline.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNPolyline retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPolyline.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNPolyline autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPolyline.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPolyline, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPolyline? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The cooordinate rectangle that encompasses the overlay. (required) (read-only)
  ///
  /// This property contains the smallest rectangle that completely encompasses the
  /// overlay. Implementers of this protocol must set this area when implementing
  /// their overlay class, and after setting it, you must not change it.
  ///
  /// If this overlay spans the antimeridian, its bounds may extend west of −180 degrees
  /// longitude or east of 180 degrees longitude. For example, an overlay covering the
  /// Pacific Ocean from Tokyo to San Francisco might have a bounds extending
  /// from (35.68476, −220.24257) to (37.78428, −122.41310).
  MLNCoordinateBounds get overlayBounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(_ptr, this.ref.pointer, _sel_overlayBounds)
        : _ptr.ref = _objc_msgSend_ygoa6a(this.ref.pointer, _sel_overlayBounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// Returns a Boolean indicating whether the specified rectangle intersects the
  /// receiver’s shape.
  ///
  /// You can implement this method to provide more specific bounds checking for an
  /// overlay. If you do not implement it, the bounding rectangle is used to detect
  /// intersections.
  ///
  /// @param overlayBounds The rectangle to intersect with the receiver’s area.
  /// @return `YES` if any part of the map rectangle intersects the receiver’s shape
  /// or `NO` if it does not.
  bool intersectsOverlayBounds(MLNCoordinateBounds overlayBounds$1) {
    return _objc_msgSend_10h1dgu(
        this.ref.pointer, _sel_intersectsOverlayBounds_, overlayBounds$1);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException('MLNPolyline', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPolyline', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNPolyline constructed with the default `new` method.
  factory MLNPolyline() => new$();
}

late final _class_MLNMultiPolyline = objc.getClass("MLNMultiPolyline");
late final _sel_polylines = objc.registerName("polylines");
late final _sel_multiPolylineWithPolylines_ =
    objc.registerName("multiPolylineWithPolylines:");

/// An ``MLNMultiPolyline`` object represents a shape consisting of one or more
/// polylines. For example, you could use a multipolyline shape to represent both
/// sides of a divided highway (dual carriageway), excluding the median (central
/// reservation): each carriageway would be a distinct ``MLNPolyline`` object.
///
/// You can add multipolyline shapes to the map by adding them to an
/// ``MLNShapeSource`` object. Configure the appearance of an ``MLNShapeSource``’s or
/// ``MLNVectorTileSource``’s multipolylines collectively using an
/// ``MLNLineStyleLayer`` or ``MLNSymbolStyleLayer`` object.
///
/// You cannot add an ``MLNMultiPolyline`` object directly to a map view using
/// ``MLNMapView/addAnnotation:`` or ``MLNMapView/addOverlay:``. However, you can
/// add the `polylines` array’s items as overlays individually.
///
/// A multipolyline is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.5">MultiLineString</a>
/// geometry in GeoJSON.
class MLNMultiPolyline extends MLNShape implements MLNOverlay {
  MLNMultiPolyline._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMultiPolyline] that points to the same underlying object as [other].
  MLNMultiPolyline.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMultiPolyline] that wraps the given raw object pointer.
  MLNMultiPolyline.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMultiPolyline].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPolyline);
  }

  /// An array of polygons forming the multipolyline.
  objc.NSArray get polylines {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_polylines);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates and returns a multipolyline object consisting of the given polylines.
  ///
  /// @param polylines The array of polylines defining the shape.
  /// @return A new multipolyline object.
  static MLNMultiPolyline multiPolylineWithPolylines(objc.NSArray polylines$1) {
    final _ret = _objc_msgSend_1sotr3r(_class_MLNMultiPolyline,
        _sel_multiPolylineWithPolylines_, polylines$1.ref.pointer);
    return MLNMultiPolyline.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNMultiPolyline,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNMultiPolyline init() {
    objc.checkOsVersionInternal('MLNMultiPolyline.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNMultiPolyline new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMultiPolyline, _sel_new);
    return MLNMultiPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMultiPolyline allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNMultiPolyline, _sel_allocWithZone_, zone);
    return MLNMultiPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNMultiPolyline alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMultiPolyline, _sel_alloc);
    return MLNMultiPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNMultiPolyline self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNMultiPolyline.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNMultiPolyline retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNMultiPolyline.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNMultiPolyline autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNMultiPolyline.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNMultiPolyline, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNMultiPolyline? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNMultiPolyline.castFromPointer(_ret, retain: false, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The cooordinate rectangle that encompasses the overlay. (required) (read-only)
  ///
  /// This property contains the smallest rectangle that completely encompasses the
  /// overlay. Implementers of this protocol must set this area when implementing
  /// their overlay class, and after setting it, you must not change it.
  ///
  /// If this overlay spans the antimeridian, its bounds may extend west of −180 degrees
  /// longitude or east of 180 degrees longitude. For example, an overlay covering the
  /// Pacific Ocean from Tokyo to San Francisco might have a bounds extending
  /// from (35.68476, −220.24257) to (37.78428, −122.41310).
  MLNCoordinateBounds get overlayBounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(_ptr, this.ref.pointer, _sel_overlayBounds)
        : _ptr.ref = _objc_msgSend_ygoa6a(this.ref.pointer, _sel_overlayBounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// Returns a Boolean indicating whether the specified rectangle intersects the
  /// receiver’s shape.
  ///
  /// You can implement this method to provide more specific bounds checking for an
  /// overlay. If you do not implement it, the bounding rectangle is used to detect
  /// intersections.
  ///
  /// @param overlayBounds The rectangle to intersect with the receiver’s area.
  /// @return `YES` if any part of the map rectangle intersects the receiver’s shape
  /// or `NO` if it does not.
  bool intersectsOverlayBounds(MLNCoordinateBounds overlayBounds$1) {
    return _objc_msgSend_10h1dgu(
        this.ref.pointer, _sel_intersectsOverlayBounds_, overlayBounds$1);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNMultiPolyline', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNMultiPolyline', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNMultiPolyline constructed with the default `new` method.
  factory MLNMultiPolyline() => new$();
}

late final _class_MLNShapeCollection = objc.getClass("MLNShapeCollection");
late final _sel_shapes = objc.registerName("shapes");
late final _sel_shapeCollectionWithShapes_ =
    objc.registerName("shapeCollectionWithShapes:");

/// An ``MLNShapeCollection`` object represents a shape consisting of zero or more
/// distinct but related shapes that are instances of ``MLNShape``. The constituent
/// shapes can be a mixture of different kinds of shapes.
///
/// ``MLNShapeCollection`` is most commonly used to add multiple shapes to a single
/// ``MLNShapeSource``. Configure the appearance of an ``MLNShapeSource``’s or
/// ``MLNVectorTileSource``’s shape collection collectively using an
/// ``MLNSymbolStyleLayer`` object, or use multiple instances of
/// ``MLNCircleStyleLayer``, ``MLNCircleStyleLayer``, and ``MLNCircleStyleLayer`` to
/// configure the appearance of each kind of shape inside the collection.
///
/// You cannot add an ``MLNShapeCollection`` object directly to a map view as an
/// annotation. However, you can create individual ``MLNPointAnnotation``,
/// ``MLNPolyline``, and ``MLNPolyline`` objects from the `shapes` array and add those
/// annotation objects to the map view using the ``MLNMapView/addAnnotations:``
/// method.
///
/// To represent a collection of point, polyline, or polygon shapes, it may be more
/// convenient to use an ``MLNPointCollection``, ``MLNPointCollection``, or
/// ``MLNMultiPolygon`` object, respectively. To access a shape collection’s
/// attributes, use the corresponding ``MLNFeature`` object.
///
/// A shape collection is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.8">GeometryCollection</a>
/// geometry in GeoJSON.
class MLNShapeCollection extends MLNShape {
  MLNShapeCollection._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNShapeCollection] that points to the same underlying object as [other].
  MLNShapeCollection.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNShapeCollection] that wraps the given raw object pointer.
  MLNShapeCollection.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNShapeCollection].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShapeCollection);
  }

  /// An array of shapes forming the shape collection.
  objc.NSArray get shapes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shapes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates and returns a shape collection consisting of the given shapes.
  ///
  /// @param shapes The array of shapes defining the shape collection. The data in
  /// this array is copied to the new object.
  /// @return A new shape collection object.
  static MLNShapeCollection shapeCollectionWithShapes(objc.NSArray shapes$1) {
    final _ret = _objc_msgSend_1sotr3r(_class_MLNShapeCollection,
        _sel_shapeCollectionWithShapes_, shapes$1.ref.pointer);
    return MLNShapeCollection.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNShapeCollection,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNShapeCollection init() {
    objc.checkOsVersionInternal('MLNShapeCollection.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNShapeCollection.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNShapeCollection new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNShapeCollection, _sel_new);
    return MLNShapeCollection.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNShapeCollection allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNShapeCollection, _sel_allocWithZone_, zone);
    return MLNShapeCollection.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNShapeCollection alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNShapeCollection, _sel_alloc);
    return MLNShapeCollection.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNShapeCollection self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNShapeCollection.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNShapeCollection retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNShapeCollection.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNShapeCollection autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNShapeCollection.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNShapeCollection, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNShapeCollection? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNShapeCollection.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// Returns a new instance of MLNShapeCollection constructed with the default `new` method.
  factory MLNShapeCollection() => new$();
}

late final _class_MLNEmptyFeature = objc.getClass("MLNEmptyFeature");

/// An ``MLNEmptyFeature`` object associates an empty shape with an optional
/// identifier and attributes.
class MLNEmptyFeature extends MLNShape implements MLNFeature {
  MLNEmptyFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNEmptyFeature] that points to the same underlying object as [other].
  MLNEmptyFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNEmptyFeature] that wraps the given raw object pointer.
  MLNEmptyFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNEmptyFeature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNEmptyFeature);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNEmptyFeature,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNEmptyFeature init() {
    objc.checkOsVersionInternal('MLNEmptyFeature.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNEmptyFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNEmptyFeature new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNEmptyFeature, _sel_new);
    return MLNEmptyFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNEmptyFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNEmptyFeature, _sel_allocWithZone_, zone);
    return MLNEmptyFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNEmptyFeature alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNEmptyFeature, _sel_alloc);
    return MLNEmptyFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNEmptyFeature self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNEmptyFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNEmptyFeature retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNEmptyFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNEmptyFeature autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNEmptyFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNEmptyFeature, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNEmptyFeature? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNEmptyFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNEmptyFeature', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNEmptyFeature', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNEmptyFeature constructed with the default `new` method.
  factory MLNEmptyFeature() => new$();
}

late final _class_MLNPointFeature = objc.getClass("MLNPointFeature");

/// An ``MLNPointFeature`` object associates a point shape with an optional
/// identifier and attributes.
///
/// #### Related examples
/// - <doc:WebAPIDataExample>
class MLNPointFeature extends MLNPointAnnotation implements MLNFeature {
  MLNPointFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPointFeature] that points to the same underlying object as [other].
  MLNPointFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPointFeature] that wraps the given raw object pointer.
  MLNPointFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPointFeature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointFeature);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPointFeature,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPointFeature init() {
    objc.checkOsVersionInternal('MLNPointFeature.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNPointFeature new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPointFeature, _sel_new);
    return MLNPointFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPointFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNPointFeature, _sel_allocWithZone_, zone);
    return MLNPointFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNPointFeature alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPointFeature, _sel_alloc);
    return MLNPointFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNPointFeature self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPointFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNPointFeature retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPointFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNPointFeature autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPointFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNPointFeature, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPointFeature? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPointFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPointFeature', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPointFeature', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNPointFeature constructed with the default `new` method.
  factory MLNPointFeature() => new$();
}

late final _class_MLNPointFeatureCluster =
    objc.getClass("MLNPointFeatureCluster");

/// An ``MLNPointFeatureCluster`` object associates a point shape (with an optional
/// identifier and attributes) and represents a point cluster.
///
/// @see ``MLNCluster``
///
/// #### Related examples
/// TODO: Clustering point data, learn how to initialize
/// clusters and add them to your map.
class MLNPointFeatureCluster extends MLNPointFeature implements MLNCluster {
  MLNPointFeatureCluster._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPointFeatureCluster] that points to the same underlying object as [other].
  MLNPointFeatureCluster.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPointFeatureCluster] that wraps the given raw object pointer.
  MLNPointFeatureCluster.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPointFeatureCluster].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointFeatureCluster);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPointFeatureCluster,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPointFeatureCluster init() {
    objc.checkOsVersionInternal('MLNPointFeatureCluster.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointFeatureCluster.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNPointFeatureCluster new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPointFeatureCluster, _sel_new);
    return MLNPointFeatureCluster.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPointFeatureCluster allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNPointFeatureCluster, _sel_allocWithZone_, zone);
    return MLNPointFeatureCluster.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNPointFeatureCluster alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNPointFeatureCluster, _sel_alloc);
    return MLNPointFeatureCluster.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNPointFeatureCluster self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPointFeatureCluster.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNPointFeatureCluster retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPointFeatureCluster.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNPointFeatureCluster autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPointFeatureCluster.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNPointFeatureCluster, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPointFeatureCluster? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPointFeatureCluster.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// The identifier for the cluster.
  int get clusterIdentifier {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_clusterIdentifier);
  }

  /// The number of points within this cluster
  int get clusterPointCount {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_clusterPointCount);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPointFeatureCluster', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPointFeatureCluster', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNPointFeatureCluster constructed with the default `new` method.
  factory MLNPointFeatureCluster() => new$();
}

late final _class_MLNPolylineFeature = objc.getClass("MLNPolylineFeature");

/// An ``MLNPolylineFeature`` object associates a polyline shape with an optional
/// identifier and attributes.
///
/// A polyline feature is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.4">LineString</a>
/// feature in GeoJSON.
///
/// #### Related examples
/// - <doc:AnimatedLineExample>
class MLNPolylineFeature extends MLNPolyline implements MLNFeature {
  MLNPolylineFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPolylineFeature] that points to the same underlying object as [other].
  MLNPolylineFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPolylineFeature] that wraps the given raw object pointer.
  MLNPolylineFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPolylineFeature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPolylineFeature);
  }

  /// Creates and returns an ``MLNPolyline`` object from the specified set of
  /// coordinates.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the new object.
  /// @param count The number of items in the `coords` array.
  /// @return A new polyline object.
  static MLNPolylineFeature polylineWithCoordinates(
      ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count}) {
    final _ret = _objc_msgSend_i90tul(_class_MLNPolylineFeature,
        _sel_polylineWithCoordinates_count_, coords, count);
    return MLNPolylineFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPolylineFeature,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPolylineFeature init() {
    objc.checkOsVersionInternal('MLNPolylineFeature.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPolylineFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNPolylineFeature new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPolylineFeature, _sel_new);
    return MLNPolylineFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPolylineFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNPolylineFeature, _sel_allocWithZone_, zone);
    return MLNPolylineFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNPolylineFeature alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPolylineFeature, _sel_alloc);
    return MLNPolylineFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNPolylineFeature self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPolylineFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNPolylineFeature retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPolylineFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNPolylineFeature autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPolylineFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNPolylineFeature, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPolylineFeature? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPolylineFeature.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPolylineFeature', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPolylineFeature', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNPolylineFeature constructed with the default `new` method.
  factory MLNPolylineFeature() => new$();
}

late final _class_MLNPolygonFeature = objc.getClass("MLNPolygonFeature");

/// An ``MLNPolygonFeature`` object associates a polygon shape with an optional
/// identifier and attributes.
class MLNPolygonFeature extends MLNPolygon implements MLNFeature {
  MLNPolygonFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPolygonFeature] that points to the same underlying object as [other].
  MLNPolygonFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPolygonFeature] that wraps the given raw object pointer.
  MLNPolygonFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPolygonFeature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPolygonFeature);
  }

  /// Creates and returns an ``MLNPolygon`` object from the specified set of
  /// coordinates.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the new object.
  /// @param count The number of items in the `coords` array.
  /// @return A new polygon object.
  static MLNPolygonFeature polygonWithCoordinates(
      ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count}) {
    final _ret = _objc_msgSend_i90tul(_class_MLNPolygonFeature,
        _sel_polygonWithCoordinates_count_, coords, count);
    return MLNPolygonFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates and returns an ``MLNPolygon`` object from the specified set of
  /// coordinates and interior polygons.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the new object.
  /// @param count The number of items in the `coords` array.
  /// @param interiorPolygons An array of ``MLNPolygon`` objects that define regions
  /// excluded from the overall shape. If this array is `nil` or empty, the shape
  /// is considered to have no interior polygons.
  /// @return A new polygon object.
  static MLNPolygonFeature polygonWithCoordinates$1(
      ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count,
      objc.NSArray? interiorPolygons$1}) {
    final _ret = _objc_msgSend_inmhr7(
        _class_MLNPolygonFeature,
        _sel_polygonWithCoordinates_count_interiorPolygons_,
        coords,
        count,
        interiorPolygons$1?.ref.pointer ?? ffi.nullptr);
    return MLNPolygonFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPolygonFeature,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPolygonFeature init() {
    objc.checkOsVersionInternal('MLNPolygonFeature.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPolygonFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNPolygonFeature new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPolygonFeature, _sel_new);
    return MLNPolygonFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPolygonFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNPolygonFeature, _sel_allocWithZone_, zone);
    return MLNPolygonFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNPolygonFeature alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNPolygonFeature, _sel_alloc);
    return MLNPolygonFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNPolygonFeature self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPolygonFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNPolygonFeature retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPolygonFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNPolygonFeature autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPolygonFeature.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNPolygonFeature, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPolygonFeature? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPolygonFeature.castFromPointer(_ret, retain: false, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPolygonFeature', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPolygonFeature', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNPolygonFeature constructed with the default `new` method.
  factory MLNPolygonFeature() => new$();
}

late final _class_MLNPointCollectionFeature =
    objc.getClass("MLNPointCollectionFeature");

/// An ``MLNPointCollectionFeature`` object associates a point collection with an
/// optional identifier and attributes.
///
/// A point collection feature is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.3">MultiPoint</a>
/// feature in GeoJSON.
class MLNPointCollectionFeature extends MLNPointCollection
    implements MLNFeature {
  MLNPointCollectionFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNPointCollectionFeature] that points to the same underlying object as [other].
  MLNPointCollectionFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNPointCollectionFeature] that wraps the given raw object pointer.
  MLNPointCollectionFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNPointCollectionFeature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointCollectionFeature);
  }

  /// Creates and returns a ``MLNPointCollection`` object from the specified set of
  /// coordinates.
  ///
  /// @param coords The array of coordinates defining the shape. The data in this
  /// array is copied to the new object.
  /// @param count The number of items in the `coords` array.
  /// @return A new point collection object.
  static MLNPointCollectionFeature pointCollectionWithCoordinates(
      ffi.Pointer<CLLocationCoordinate2D> coords,
      {required int count}) {
    final _ret = _objc_msgSend_i90tul(_class_MLNPointCollectionFeature,
        _sel_pointCollectionWithCoordinates_count_, coords, count);
    return MLNPointCollectionFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNPointCollectionFeature,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNPointCollectionFeature init() {
    objc.checkOsVersionInternal('MLNPointCollectionFeature.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointCollectionFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNPointCollectionFeature new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNPointCollectionFeature, _sel_new);
    return MLNPointCollectionFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNPointCollectionFeature allocWithZone(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNPointCollectionFeature, _sel_allocWithZone_, zone);
    return MLNPointCollectionFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNPointCollectionFeature alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNPointCollectionFeature, _sel_alloc);
    return MLNPointCollectionFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNPointCollectionFeature self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNPointCollectionFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNPointCollectionFeature retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNPointCollectionFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNPointCollectionFeature autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNPointCollectionFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNPointCollectionFeature, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNPointCollectionFeature? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNPointCollectionFeature.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPointCollectionFeature', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNPointCollectionFeature', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNPointCollectionFeature constructed with the default `new` method.
  factory MLNPointCollectionFeature() => new$();
}

late final _class_MLNMultiPolylineFeature =
    objc.getClass("MLNMultiPolylineFeature");

/// An ``MLNMultiPolylineFeature`` object associates a multipolyline shape with an
/// optional identifier and attributes.
///
/// A multipolyline feature is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.5">MultiLineString</a>
/// feature in GeoJSON.
class MLNMultiPolylineFeature extends MLNMultiPolyline implements MLNFeature {
  MLNMultiPolylineFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMultiPolylineFeature] that points to the same underlying object as [other].
  MLNMultiPolylineFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMultiPolylineFeature] that wraps the given raw object pointer.
  MLNMultiPolylineFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMultiPolylineFeature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPolylineFeature);
  }

  /// Creates and returns a multipolyline object consisting of the given polylines.
  ///
  /// @param polylines The array of polylines defining the shape.
  /// @return A new multipolyline object.
  static MLNMultiPolylineFeature multiPolylineWithPolylines(
      objc.NSArray polylines$1) {
    final _ret = _objc_msgSend_1sotr3r(_class_MLNMultiPolylineFeature,
        _sel_multiPolylineWithPolylines_, polylines$1.ref.pointer);
    return MLNMultiPolylineFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNMultiPolylineFeature,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNMultiPolylineFeature init() {
    objc.checkOsVersionInternal('MLNMultiPolylineFeature.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPolylineFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNMultiPolylineFeature new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNMultiPolylineFeature, _sel_new);
    return MLNMultiPolylineFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMultiPolylineFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNMultiPolylineFeature, _sel_allocWithZone_, zone);
    return MLNMultiPolylineFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNMultiPolylineFeature alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNMultiPolylineFeature, _sel_alloc);
    return MLNMultiPolylineFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNMultiPolylineFeature self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNMultiPolylineFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNMultiPolylineFeature retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNMultiPolylineFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNMultiPolylineFeature autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNMultiPolylineFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNMultiPolylineFeature, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNMultiPolylineFeature? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNMultiPolylineFeature.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNMultiPolylineFeature', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNMultiPolylineFeature', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNMultiPolylineFeature constructed with the default `new` method.
  factory MLNMultiPolylineFeature() => new$();
}

late final _class_MLNMultiPolygonFeature =
    objc.getClass("MLNMultiPolygonFeature");

/// An ``MLNMultiPolygonFeature`` object associates a multipolygon shape with an
/// optional identifier and attributes.
class MLNMultiPolygonFeature extends MLNMultiPolygon implements MLNFeature {
  MLNMultiPolygonFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNMultiPolygonFeature] that points to the same underlying object as [other].
  MLNMultiPolygonFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNMultiPolygonFeature] that wraps the given raw object pointer.
  MLNMultiPolygonFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNMultiPolygonFeature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPolygonFeature);
  }

  /// Creates and returns a multipolygon object consisting of the given polygons.
  ///
  /// @param polygons The array of polygons defining the shape.
  /// @return A new multipolygon object.
  static MLNMultiPolygonFeature multiPolygonWithPolygons(
      objc.NSArray polygons$1) {
    final _ret = _objc_msgSend_1sotr3r(_class_MLNMultiPolygonFeature,
        _sel_multiPolygonWithPolygons_, polygons$1.ref.pointer);
    return MLNMultiPolygonFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNMultiPolygonFeature,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNMultiPolygonFeature init() {
    objc.checkOsVersionInternal('MLNMultiPolygonFeature.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPolygonFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNMultiPolygonFeature new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNMultiPolygonFeature, _sel_new);
    return MLNMultiPolygonFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNMultiPolygonFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNMultiPolygonFeature, _sel_allocWithZone_, zone);
    return MLNMultiPolygonFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNMultiPolygonFeature alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNMultiPolygonFeature, _sel_alloc);
    return MLNMultiPolygonFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNMultiPolygonFeature self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNMultiPolygonFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNMultiPolygonFeature retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNMultiPolygonFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNMultiPolygonFeature autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNMultiPolygonFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNMultiPolygonFeature, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNMultiPolygonFeature? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNMultiPolygonFeature.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNMultiPolygonFeature', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNMultiPolygonFeature', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNMultiPolygonFeature constructed with the default `new` method.
  factory MLNMultiPolygonFeature() => new$();
}

late final _class_MLNShapeCollectionFeature =
    objc.getClass("MLNShapeCollectionFeature");

/// An ``MLNShapeCollectionFeature`` object associates a shape collection with an
/// optional identifier and attributes.
///
/// ``MLNShapeCollectionFeature`` is most commonly used to add multiple shapes to a
/// single ``MLNShapeSource``. Configure the appearance of an ``MLNSource``’s shape
/// collection collectively using an ``MLNSymbolStyleLayer`` object, or use multiple
/// instances of ``MLNCircleStyleLayer``, ``MLNFillStyleLayer``, and
/// ``MLNLineStyleLayer`` to configure the appearance of each kind of shape inside
/// the collection.
///
/// A shape collection feature is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.3">feature collection</a>
/// in GeoJSON.
///
/// #### Related examples
/// TODO: Add multiple shapes from a single shape source, learn how to
/// add shape data to your map using an ``MLNShapeCollectionFeature`` object.
class MLNShapeCollectionFeature extends MLNShapeCollection
    implements MLNFeature {
  MLNShapeCollectionFeature._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNShapeCollectionFeature] that points to the same underlying object as [other].
  MLNShapeCollectionFeature.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNShapeCollectionFeature] that wraps the given raw object pointer.
  MLNShapeCollectionFeature.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNShapeCollectionFeature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShapeCollectionFeature);
  }

  /// shapes
  objc.NSArray get shapes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shapes);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates and returns a shape collection consisting of the given shapes.
  ///
  /// @param shapes The array of shapes defining the shape collection. The data in
  /// this array is copied to the new object.
  /// @return A new shape collection object.
  static MLNShapeCollectionFeature shapeCollectionWithShapes(
      objc.NSArray shapes$1) {
    final _ret = _objc_msgSend_1sotr3r(_class_MLNShapeCollectionFeature,
        _sel_shapeCollectionWithShapes_, shapes$1.ref.pointer);
    return MLNShapeCollectionFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
  /// string containing a GeoJSON object.
  ///
  /// If the GeoJSON object is a geometry, the returned value is a kind of
  /// ``MLNShape``. If it is a feature object, the returned value is a kind of
  /// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
  /// collection object, the returned value is an instance of
  /// ``MLNShapeCollectionFeature``.
  ///
  /// ### Example
  ///
  /// ```swift
  /// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
  /// let data = try! Data(contentsOf: url)
  /// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
  /// MLNShapeCollectionFeature
  /// ```
  ///
  /// @param data String data containing GeoJSON source code.
  /// @param encoding The encoding used by `data`.
  /// @param outError Upon return, if an error has occurred, a pointer to an
  /// `NSError` object describing the error. Pass in `NULL` to ignore any error.
  /// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
  /// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
  /// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data,
      {required int encoding,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    final _ret = _objc_msgSend_1nomli1(_class_MLNShapeCollectionFeature,
        _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, error);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNShapeCollectionFeature init() {
    objc.checkOsVersionInternal('MLNShapeCollectionFeature.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNShapeCollectionFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNShapeCollectionFeature new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNShapeCollectionFeature, _sel_new);
    return MLNShapeCollectionFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNShapeCollectionFeature allocWithZone(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNShapeCollectionFeature, _sel_allocWithZone_, zone);
    return MLNShapeCollectionFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNShapeCollectionFeature alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNShapeCollectionFeature, _sel_alloc);
    return MLNShapeCollectionFeature.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNShapeCollectionFeature self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNShapeCollectionFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNShapeCollectionFeature retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNShapeCollectionFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNShapeCollectionFeature autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNShapeCollectionFeature.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNShapeCollectionFeature, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  MLNShapeCollectionFeature? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNShapeCollectionFeature.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNShapeCollectionFeature', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNShapeCollectionFeature', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNShapeCollectionFeature constructed with the default `new` method.
  factory MLNShapeCollectionFeature() => new$();
}

late final _class_MLNTileSource = objc.getClass("MLNTileSource");
late final _sel_configurationURL = objc.registerName("configurationURL");
late final _sel_attributionInfos = objc.registerName("attributionInfos");
late final _sel_attributionHTMLString =
    objc.registerName("attributionHTMLString");

/// ``MLNTileSource`` is a map content source that supplies map tiles to be shown on
/// the map. The location of and metadata about the tiles are defined either by an
/// option dictionary or by an external file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` or ``MLNRasterStyleLayer`` objects. Use a style layer to
/// control the appearance of content supplied by the tile source.
///
/// A tile source is also known as a tile set. To learn about the structure of a
/// Mapbox-hosted tile set, view it in
/// <a href="https://www.mapbox.com/studio/tilesets/">Mapbox Studio’s Tilesets editor</a>.
///
/// Create instances of ``MLNRasterTileSource`` and ``MLNRasterTileSource`` in order
/// to use ``MLNTileSource``'s properties and methods. Do not create instances of
/// ``MLNTileSource`` directly, and do not create your own subclasses of this class.
class MLNTileSource extends MLNSource {
  MLNTileSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNTileSource] that points to the same underlying object as [other].
  MLNTileSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNTileSource] that wraps the given raw object pointer.
  MLNTileSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNTileSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNTileSource);
  }

  /// The URL to the TileJSON configuration file that specifies the contents of the
  /// source.
  ///
  /// If the receiver was initialized using
  /// `-initWithIdentifier:tileURLTemplates:options`, this property is set to `nil`.
  objc.NSURL? get configurationURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_configurationURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// An array of ``MLNAttributionInfo`` objects that define the attribution
  /// statements to be displayed when the map is shown to the user.
  ///
  /// By default, this array is empty. If the source is initialized with a
  /// configuration URL, this array is also empty until the configuration JSON file
  /// is loaded.
  objc.NSArray get attributionInfos {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributionInfos);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The attribution HTML string associated with this source.
  ///
  /// By default, this is nil. If the source is initialized with a
  /// configuration URL, this is nil until the configuration JSON file
  /// is loaded.
  objc.NSString? get attributionHTMLString {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_attributionHTMLString);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNTileSource init() {
    objc.checkOsVersionInternal('MLNTileSource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNTileSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNTileSource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNTileSource, _sel_new);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNTileSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNTileSource, _sel_allocWithZone_, zone);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNTileSource alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNTileSource, _sel_alloc);
    return MLNTileSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNTileSource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNTileSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNTileSource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNTileSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNTileSource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNTileSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNTileSource constructed with the default `new` method.
  factory MLNTileSource() => new$();
}

late final _class_MLNVectorTileSource =
    objc.getClass("MapLibre.MLNVectorTileSource");
late final _sel_initWithIdentifier_configurationURL_ =
    objc.registerName("initWithIdentifier:configurationURL:");
late final _sel_initWithIdentifier_configurationURLString_ =
    objc.registerName("initWithIdentifier:configurationURLString:");
late final _sel_initWithIdentifier_tileURLTemplates_options_ =
    objc.registerName("initWithIdentifier:tileURLTemplates:options:");
late final _sel_featuresInSourceLayersWithIdentifiers_predicate_ =
    objc.registerName("featuresInSourceLayersWithIdentifiers:predicate:");

/// ``MLNVectorTileSource`` is a map content source that supplies tiled vector data
/// in <a href="https://www.mapbox.com/vector-tiles/">Mapbox Vector Tile</a> format
/// to be shown on the map. The location of and metadata about the tiles are
/// defined either by an option dictionary or by an external file that conforms to
/// the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A vector tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNVectorStyleLayer`` objects. A vector style layer defines the appearance of
/// any content supplied by the vector tile source.
///
/// ``MLNVectorTileSource`` is optimized for data sets that are too large to fit
/// completely in memory, such as vector tile sets or data sets managed in
/// <a href="https://www.mapbox.com/studio/">Mapbox Studio</a>. For
/// <a href="http://geojson.org/">GeoJSON</a> data, use the ``MLNShapeSource``
/// class. For tiled data that changes dynamically, the ``MLNComputedShapeSource``
/// class may be a suitable alternative.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/sources/#vector"><code>vector</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNVectorTileSource`` object that you can use to initialize new style layers.
/// You can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// Within each vector tile, each geometric coordinate must lie between
/// −1&nbsp;×&nbsp;<var>extent</var> and
/// (<var>extent</var>&nbsp;×&nbsp;2)&nbsp;−&nbsp;1, inclusive. Any vector style
/// layer initialized with a vector tile source must have a non-`nil` value in its
/// `sourceLayerIdentifier` property.
///
/// Commonly used vector tile sources include
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets/">Mapbox Streets</a>,
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-terrain/">Mapbox Terrain</a>,
/// and
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-traffic-v1/">Mapbox Traffic</a>.
///
/// ### Example
///
/// ```swift
/// let source = MLNVectorTileSource(identifier: "pois", tileURLTemplates:
/// ["https://example.com/vector-tiles/{z}/{x}/{y}.mvt"], options: [ .minimumZoomLevel: 9,
/// .maximumZoomLevel: 16,
/// .attributionInfos: [
/// MLNAttributionInfo(title: NSAttributedString(string: "© Mapbox"), url: URL(string:
/// "https://mapbox.com"))
/// ]
/// ])
/// mapView.style?.addSource(source)
/// ```
///
/// #### Related examples
/// TODO: Data-driven circles, learn how to add data to your map using
/// an ``MLNVectorTileSource`` object.
class MLNVectorTileSource extends MLNTileSource {
  MLNVectorTileSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNVectorTileSource] that points to the same underlying object as [other].
  MLNVectorTileSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNVectorTileSource] that wraps the given raw object pointer.
  MLNVectorTileSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNVectorTileSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNVectorTileSource);
  }

  /// Returns a vector tile source initialized with an identifier and configuration
  /// URL.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or a canonical
  /// URL. The URL should point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @return An initialized vector tile source.
  MLNVectorTileSource initWithIdentifier(objc.NSString identifier,
      {required objc.NSURL configurationURL}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_,
        identifier.ref.pointer,
        configurationURL.ref.pointer);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a vector tile source initialized with an identifier and a
  /// string-based configuration URL.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The string may be a full HTTP or HTTPS URL or a canonical URL. The string should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// This constructor can be used for URLs that cause problems with `NSURL`’s URL
  /// parsing behavior. For example, URLs starting with `pmtiles://https://` were
  /// not parsed correctly on iOS 17.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURLString A string to a TileJSON configuration file
  /// describing the source’s contents and other metadata.
  /// @return An initialized vector tile source.
  MLNVectorTileSource initWithIdentifier$1(objc.NSString identifier,
      {required objc.NSString configurationURLString}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURLString_,
        identifier.ref.pointer,
        configurationURLString.ref.pointer);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a vector tile source initialized an identifier, tile URL templates, and
  /// options.
  ///
  /// Tile URL templates are strings that specify the URLs of the vector tiles to
  /// load. See the “<a href="../tile-url-templates.html">Tile URL Templates</a>”
  /// guide for information about the format of a tile URL template.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param tileURLTemplates An array of tile URL template strings. Only the first
  /// string is used; any additional strings are ignored.
  /// @param options A dictionary containing configuration options. See
  /// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
  /// the default values.
  /// @return An initialized tile source.
  MLNVectorTileSource initWithIdentifier$2(objc.NSString identifier,
      {required objc.NSArray tileURLTemplates, objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_tileURLTemplates_options_,
        identifier.ref.pointer,
        tileURLTemplates.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns an array of map features loaded by this source, restricted to the given
  /// source layers and filtered by the given predicate.
  ///
  /// Each object in the returned array represents a feature loaded by the source and
  /// provides access to attributes specified as part of the loaded feature. The
  /// source loads a feature if the source is added to an ``MLNMapView``’s style; that
  /// style has a layer that uses the source; and the map view has recently scrolled
  /// to the region containing the feature.
  ///
  /// Features come from tiled vector data that is converted to tiles internally, so
  /// feature geometries are clipped at tile boundaries and features may appear
  /// duplicated across tiles. For example, suppose part of a lengthy polyline
  /// representing a road has recently scrolled into view. The resulting array
  /// includes those parts of the road that lie within the map tiles that the source
  /// has loaded, even if the road extends into other tiles. The portion of the road
  /// within each map tile is included individually.
  ///
  /// Returned features may not necessarily be visible to the user at the time they
  /// are loaded: the style may contain a layer that forces the source’s tiles to
  /// load but filters out the features in question, preventing them from being
  /// drawn. To obtain only _visible_ features, use the
  /// ``MLNMapView/visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:``
  /// or
  /// ``MLNMapView/visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:``
  /// method.
  ///
  /// @param sourceLayerIdentifiers The source layers to include in the query. Only
  /// the features contained in these source layers are included in the returned
  /// array. This array may not be empty.
  /// @param predicate A predicate to filter the returned features. Use `nil` to
  /// include all loaded features.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features loaded by the source that match the predicate.
  objc.NSArray featuresInSourceLayersWithIdentifiers(
      objc.NSSet sourceLayerIdentifiers,
      {NSPredicate? predicate}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_featuresInSourceLayersWithIdentifiers_predicate_,
        sourceLayerIdentifiers.ref.pointer,
        predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNVectorTileSource init() {
    objc.checkOsVersionInternal('MLNVectorTileSource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNVectorTileSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNVectorTileSource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNVectorTileSource, _sel_new);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNVectorTileSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNVectorTileSource, _sel_allocWithZone_, zone);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNVectorTileSource alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNVectorTileSource, _sel_alloc);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNVectorTileSource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNVectorTileSource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNVectorTileSource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNVectorTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNVectorTileSource constructed with the default `new` method.
  factory MLNVectorTileSource() => new$();
}

late final _class_MLNShapeSource = objc.getClass("MLNShapeSource");
late final _sel_initWithIdentifier_URL_options_ =
    objc.registerName("initWithIdentifier:URL:options:");
late final _sel_initWithIdentifier_shape_options_ =
    objc.registerName("initWithIdentifier:shape:options:");
late final _sel_initWithIdentifier_features_options_ =
    objc.registerName("initWithIdentifier:features:options:");
late final _sel_initWithIdentifier_shapes_options_ =
    objc.registerName("initWithIdentifier:shapes:options:");
late final _sel_URL = objc.registerName("URL");
late final _sel_setURL_ = objc.registerName("setURL:");
late final _sel_featuresMatchingPredicate_ =
    objc.registerName("featuresMatchingPredicate:");
late final _sel_leavesOfCluster_offset_limit_ =
    objc.registerName("leavesOfCluster:offset:limit:");
final _objc_msgSend_17wuhyd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int)>();
late final _sel_childrenOfCluster_ = objc.registerName("childrenOfCluster:");
late final _sel_zoomLevelForExpandingCluster_ =
    objc.registerName("zoomLevelForExpandingCluster:");
final _objc_msgSend_mabicu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_mabicuFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// ``MLNShapeSource`` is a map content source that supplies vector shapes to be
/// shown on the map. The shapes may be instances of ``MLNShape`` or ``MLNShape``,
/// or they may be defined by local or external
/// <a href="http://geojson.org/">GeoJSON</a> code. A shape source is added to an
/// ``MLNStyle`` object along with an ``MLNStyle`` object. The vector style
/// layer defines the appearance of any content supplied by the shape source. You
/// can update a shape source by setting its `shape` or `URL` property.
///
/// ``MLNShapeSource`` is optimized for data sets that change dynamically and fit
/// completely in memory. For large data sets that do not fit completely in memory,
/// use the ``MLNComputedShapeSource`` or ``MLNComputedShapeSource`` class.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-geojson"><code>geojson</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNShapeSource`` object that you can use to refine the map’s content and
/// initialize new style layers. You can also add and remove sources dynamically
/// using methods such as ``MLNStyle/addSource:`` and
/// ``MLNStyle/sourceWithIdentifier:``.
///
/// Any vector style layer initialized with a shape source should have a `nil`
/// value in its `sourceLayerIdentifier` property.
///
/// ### Example
///
/// ```swift
/// var coordinates: [CLLocationCoordinate2D] = [
/// CLLocationCoordinate2D(latitude: 37.77, longitude: -122.42),
/// CLLocationCoordinate2D(latitude: 38.91, longitude: -77.04),
/// ]
/// let polyline = MLNPolylineFeature(coordinates: &coordinates, count: UInt(coordinates.count))
/// let source = MLNShapeSource(identifier: "lines", features: [polyline], options: nil)
/// mapView.style?.addSource(source)
/// ```
///
/// #### Related examples
/// TODO: Cluster point data
/// TODO: Use images to cluster point data
/// TODO: Add live data
/// Learn how to add data to your map using this ``MLNSource`` object.
class MLNShapeSource extends MLNSource {
  MLNShapeSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNShapeSource] that points to the same underlying object as [other].
  MLNShapeSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNShapeSource] that wraps the given raw object pointer.
  MLNShapeSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNShapeSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShapeSource);
  }

  /// Returns a shape source with an identifier, URL, and dictionary of options for
  /// the source.
  ///
  /// This class supports the following options: ``MLNShapeSourceOptionClustered``,
  /// ``MLNShapeSourceOptionClusterRadius``,
  /// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``, and
  /// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
  /// source are not clipped or wrapped automatically.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param url An HTTP(S) URL, absolute file URL, or local file URL relative to the
  /// current application’s resource bundle.
  /// @param options An `NSDictionary` of options for this source.
  /// @return An initialized shape source.
  ///
  /// #### Related examples
  /// TODO: Add live data, learn how to add live data to your map by
  /// updating the an ``MLNShapeSource`` object's `URL` property.
  MLNShapeSource initWithIdentifier(objc.NSString identifier,
      {required objc.NSURL URL, objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_URL_options_,
        identifier.ref.pointer,
        URL.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a shape source with an identifier, a shape, and dictionary of options
  /// for the source.
  ///
  /// This class supports the following options: ``MLNShapeSourceOptionClustered``,
  /// ``MLNShapeSourceOptionClusterRadius``, ``MLNShapeSourceOptionClusterMinPoints``,
  /// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``, and
  /// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
  /// source are not clipped or wrapped automatically.
  ///
  /// To specify attributes about the shape, use an instance of an ``MLNShape``
  /// subclass that conforms to the ``MLNFeature`` protocol, such as ``MLNFeature``.
  /// To include multiple shapes in the source, use an ``MLNShapeCollection`` or
  /// ``MLNShapeCollectionFeature`` object, or use the
  /// `-initWithIdentifier:features:options:` or
  /// `-initWithIdentifier:shapes:options:` methods.
  ///
  /// To create a shape from GeoJSON source code, use the
  /// ``MLNShape/shapeWithData:encoding:error:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param shape A concrete subclass of ``MLNShape``
  /// @param options An `NSDictionary` of options for this source.
  /// @return An initialized shape source.
  ///
  /// #### Related examples
  /// TODO: Animate a line, learn how to animate line data by continously
  /// updating an ``MLNShapeSource``'s `shape` attribute.
  MLNShapeSource initWithIdentifier$1(objc.NSString identifier,
      {MLNShape? shape, objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_shape_options_,
        identifier.ref.pointer,
        shape?.ref.pointer ?? ffi.nullptr,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a shape source with an identifier, an array of features, and a dictionary
  /// of options for the source.
  ///
  /// This class supports the following options: ``MLNShapeSourceOptionClustered``,
  /// ``MLNShapeSourceOptionClusterRadius``,
  /// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``, and
  /// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
  /// source are not clipped or wrapped automatically.
  ///
  /// Unlike `-initWithIdentifier:shapes:options:`, this method accepts ``MLNFeature``
  /// instances, such as ``MLNPointFeature`` objects, whose attributes you can use when
  /// applying a predicate to ``MLNVectorStyleLayer`` or configuring a style layer’s
  /// appearance.
  ///
  /// To create a shape from GeoJSON source code, use the
  /// ``MLNShape/shapeWithData:encoding:error:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param features An array of objects that conform to the MLNFeature protocol.
  /// @param options An `NSDictionary` of options for this source.
  /// @return An initialized shape source.
  MLNShapeSource initWithIdentifier$2(objc.NSString identifier,
      {required objc.NSArray features, objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_features_options_,
        identifier.ref.pointer,
        features.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a shape source with an identifier, an array of shapes, and a dictionary of
  /// options for the source.
  ///
  /// This class supports the following options: ``MLNShapeSourceOptionClustered``,
  /// ``MLNShapeSourceOptionClusterRadius``,
  /// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``, and
  /// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
  /// source are not clipped or wrapped automatically.
  ///
  /// Any ``MLNFeature`` instance passed into this initializer is treated as an ordinary
  /// shape, causing any attributes to be inaccessible to an ``MLNVectorStyleLayer`` when
  /// evaluating a predicate or configuring certain layout or paint attributes. To
  /// preserve the attributes associated with each feature, use the
  /// `-initWithIdentifier:features:options:` method instead.
  ///
  /// To create a shape from GeoJSON source code, use the
  /// ``MLNShape/shapeWithData:encoding:error:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param shapes An array of shapes; each shape is a member of a concrete subclass of MLNShape.
  /// @param options An `NSDictionary` of options for this source.
  /// @return An initialized shape source.
  MLNShapeSource initWithIdentifier$3(objc.NSString identifier,
      {required objc.NSArray shapes, objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_shapes_options_,
        identifier.ref.pointer,
        shapes.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// The contents of the source. A shape can represent a GeoJSON geometry, a
  /// feature, or a collection of features.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:URL:options:`, this
  /// property is set to `nil`. This property is unavailable until the receiver is
  /// passed into ``MLNStyle/addSource:``.
  ///
  /// You can get/set the shapes within a collection via this property. Actions must
  /// be performed on the application's main thread.
  MLNShape? get shape {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shape);
    return _ret.address == 0
        ? null
        : MLNShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// The contents of the source. A shape can represent a GeoJSON geometry, a
  /// feature, or a collection of features.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:URL:options:`, this
  /// property is set to `nil`. This property is unavailable until the receiver is
  /// passed into ``MLNStyle/addSource:``.
  ///
  /// You can get/set the shapes within a collection via this property. Actions must
  /// be performed on the application's main thread.
  set shape(MLNShape? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setShape_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The URL to the GeoJSON document that specifies the contents of the source.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:shape:options:`,
  /// this property is set to `nil`.
  objc.NSURL? get URL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_URL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// The URL to the GeoJSON document that specifies the contents of the source.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:shape:options:`,
  /// this property is set to `nil`.
  set URL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns an array of map features for this source, filtered by the given
  /// predicate.
  ///
  /// Each object in the returned array represents a feature for the current style
  /// and provides access to attributes specified via the `shape` property.
  ///
  /// Features come from tiled GeoJSON data that is converted to tiles internally,
  /// so feature geometries are clipped at tile boundaries and features
  /// may appear duplicated across tiles. For example, suppose this source contains a
  /// long polyline representing a road. The resulting array includes those parts of
  /// the road that lie within the map tiles that the source has loaded, even if the
  /// road extends into other tiles. The portion of the road within each map tile is
  /// included individually.
  ///
  /// Returned features may not necessarily be visible to the user at the time they
  /// are loaded: the style may lack a layer that draws the features in question. To
  /// obtain only _visible_ features, use the
  /// ``MLNMapView/visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:``
  /// or
  /// ``MLNMapView/visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:``
  /// method.
  ///
  /// @param predicate A predicate to filter the returned features. Use `nil` to
  /// include all features in the source.
  /// @return An array of objects conforming to the ``MLNFeature`` protocol that
  /// represent features in the source that match the predicate.
  objc.NSArray featuresMatchingPredicate(NSPredicate? predicate) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_featuresMatchingPredicate_, predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of map features that are the leaves of the specified cluster.
  /// ("Leaves" are the original points that belong to the cluster.)
  ///
  /// This method supports pagination; you supply an offset (number of features to skip)
  /// and a maximum number of features to return.
  ///
  /// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
  /// ``MLNPointFeatureCluster`` protocol).
  /// @param offset Number of features to skip.
  /// @param limit The maximum number of features to return
  ///
  /// @return An array of objects that conform to the ``MLNFeature`` protocol.
  objc.NSArray leavesOfCluster(MLNPointFeatureCluster cluster,
      {required int offset, required int limit}) {
    final _ret = _objc_msgSend_17wuhyd(this.ref.pointer,
        _sel_leavesOfCluster_offset_limit_, cluster.ref.pointer, offset, limit);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of map features that are the immediate children of the specified
  /// cluster *on the next zoom level*. The may include features that also conform to
  /// the ``MLNCluster`` protocol (currently only objects of type ``MLNCluster``).
  ///
  /// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
  /// ``MLNPointFeatureCluster`` protocol).
  ///
  /// @return An array of objects that conform to the ``MLNFeature`` protocol.
  ///
  /// > Note: The returned array may contain the `cluster` that was passed in, if the next
  /// zoom level doesn't match the zoom level for expanding that cluster. See
  /// ``MLNShapeSource/zoomLevelForExpandingCluster:``.
  objc.NSArray childrenOfCluster(MLNPointFeatureCluster cluster) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_childrenOfCluster_, cluster.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the zoom level at which the given cluster expands.
  ///
  /// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
  /// ``MLNPointFeatureCluster`` protocol).
  ///
  /// @return Zoom level. This should be >= 0; any negative return value should be
  /// considered an error.
  double zoomLevelForExpandingCluster(MLNPointFeatureCluster cluster) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_mabicuFpret(this.ref.pointer,
            _sel_zoomLevelForExpandingCluster_, cluster.ref.pointer)
        : _objc_msgSend_mabicu(this.ref.pointer,
            _sel_zoomLevelForExpandingCluster_, cluster.ref.pointer);
  }

  /// init
  MLNShapeSource init() {
    objc.checkOsVersionInternal('MLNShapeSource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNShapeSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNShapeSource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNShapeSource, _sel_new);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNShapeSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNShapeSource, _sel_allocWithZone_, zone);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNShapeSource alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNShapeSource, _sel_alloc);
    return MLNShapeSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNShapeSource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNShapeSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNShapeSource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNShapeSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNShapeSource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNShapeSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNShapeSource constructed with the default `new` method.
  factory MLNShapeSource() => new$();
}

late final _protocol_MLNComputedShapeSourceDataSource =
    objc.getProtocol("MLNComputedShapeSourceDataSource");
late final _sel_featuresInTileAtX_y_zoomLevel_ =
    objc.registerName("featuresInTileAtX:y:zoomLevel:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            int arg1,
            int arg2,
            int arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.UnsignedLong arg1,
                        ffi.UnsignedLong arg2,
                        ffi.UnsignedLong arg3)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    int, int, int)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.UnsignedLong,
                    ffi.UnsignedLong,
                    ffi.UnsignedLong)>(
            _ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            int arg1,
            int arg2,
            int arg3) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, int, int, int))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.UnsignedLong,
                    ffi.UnsignedLong,
                    ffi.UnsignedLong)>(
            _ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong, ffi.UnsignedLong, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.NSArray Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong,
              ffi.UnsignedLong, ffi.UnsignedLong)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.NSArray Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.UnsignedLong,
                  ffi.UnsignedLong,
                  ffi.UnsignedLong)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          objc.NSArray Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong,
              ffi.UnsignedLong, ffi.UnsignedLong)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1, ffi.UnsignedLong arg2, ffi.UnsignedLong arg3)>> ptr) =>
          objc.ObjCBlock<
                  objc.NSArray Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong,
                      ffi.UnsignedLong, ffi.UnsignedLong)>(
              objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong, ffi.UnsignedLong, ffi.UnsignedLong)>
      fromFunction(
              objc.NSArray Function(ffi.Pointer<ffi.Void>, int, int, int) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong, ffi.UnsignedLong, ffi.UnsignedLong)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, int arg1, int arg2, int arg3) =>
                      fn(arg0, arg1, arg2, arg3).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong, ffi.UnsignedLong, ffi.UnsignedLong)>`.
extension ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger_CallExtension
    on objc.ObjCBlock<
        objc.NSArray Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong,
            ffi.UnsignedLong, ffi.UnsignedLong)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0, int arg1, int arg2, int arg3) =>
      objc.NSArray.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.UnsignedLong arg1,
                          ffi.UnsignedLong arg2,
                          ffi.UnsignedLong arg3)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      int,
                      int,
                      int)>()(ref.pointer, arg0, arg1, arg2, arg3),
          retain: true,
          release: true);
}

late final _sel_featuresInCoordinateBounds_zoomLevel_ =
    objc.registerName("featuresInCoordinateBounds:zoomLevel:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            MLNCoordinateBounds arg1,
            int arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        MLNCoordinateBounds arg1,
                        ffi.UnsignedLong arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    MLNCoordinateBounds, int)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    MLNCoordinateBounds,
                    ffi.UnsignedLong)>(
            _ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            MLNCoordinateBounds arg1,
            int arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, MLNCoordinateBounds, int))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    MLNCoordinateBounds,
                    ffi.UnsignedLong)>(
            _ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.NSArray Function(
              ffi.Pointer<ffi.Void>, MLNCoordinateBounds, ffi.UnsignedLong)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.NSArray Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds,
                  ffi.UnsignedLong)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds, ffi.UnsignedLong)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, MLNCoordinateBounds arg1, ffi.UnsignedLong arg2)>> ptr) =>
          objc.ObjCBlock<
                  objc.NSArray Function(ffi.Pointer<ffi.Void>,
                      MLNCoordinateBounds, ffi.UnsignedLong)>(
              objc.newPointerBlock(
                  _ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
          objc.NSArray Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds, ffi.UnsignedLong)>
      fromFunction(objc.NSArray Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds, int) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds, ffi.UnsignedLong)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, MLNCoordinateBounds arg1, int arg2) =>
                      fn(arg0, arg1, arg2).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, MLNCoordinateBounds, ffi.UnsignedLong)>`.
extension ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger_CallExtension
    on objc.ObjCBlock<
        objc.NSArray Function(
            ffi.Pointer<ffi.Void>, MLNCoordinateBounds, ffi.UnsignedLong)> {
  objc.NSArray call(
          ffi.Pointer<ffi.Void> arg0, MLNCoordinateBounds arg1, int arg2) =>
      objc.NSArray.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          MLNCoordinateBounds arg1,
                          ffi.UnsignedLong arg2)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      MLNCoordinateBounds,
                      int)>()(ref.pointer, arg0, arg1, arg2),
          retain: true,
          release: true);
}

/// Data source for ``MLNComputedShapeSource``. This protocol defines two optional methods for fetching
/// data, one based on tile coordinates, and one based on a bounding box. Classes that implement this
/// protocol must implement one, and only one of the methods. Methods on this protocol will not be
/// called on main thread, they will be called on the caller's `requestQueue`.
interface class MLNComputedShapeSourceDataSource extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  MLNComputedShapeSourceDataSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNComputedShapeSourceDataSource] that points to the same underlying object as [other].
  MLNComputedShapeSourceDataSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNComputedShapeSourceDataSource] that wraps the given raw object pointer.
  MLNComputedShapeSourceDataSource.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNComputedShapeSourceDataSource].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_MLNComputedShapeSourceDataSource);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol => objc.Protocol.castFromPointer(
      _protocol_MLNComputedShapeSourceDataSource.cast());

  /// Builds an object that implements the MLNComputedShapeSourceDataSource protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNComputedShapeSourceDataSource implement(
      {objc.NSArray Function(int, int, int)? featuresInTileAtX_y_zoomLevel_,
      objc.NSArray Function(MLNCoordinateBounds, int)?
          featuresInCoordinateBounds_zoomLevel_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'MLNComputedShapeSourceDataSource');
    MLNComputedShapeSourceDataSource.featuresInTileAtX_y_zoomLevel_
        .implement(builder, featuresInTileAtX_y_zoomLevel_);
    MLNComputedShapeSourceDataSource.featuresInCoordinateBounds_zoomLevel_
        .implement(builder, featuresInCoordinateBounds_zoomLevel_);
    builder.addProtocol($protocol);
    return MLNComputedShapeSourceDataSource.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNComputedShapeSourceDataSource protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {objc.NSArray Function(int, int, int)? featuresInTileAtX_y_zoomLevel_,
      objc.NSArray Function(MLNCoordinateBounds, int)?
          featuresInCoordinateBounds_zoomLevel_,
      bool $keepIsolateAlive = true}) {
    MLNComputedShapeSourceDataSource.featuresInTileAtX_y_zoomLevel_
        .implement(builder, featuresInTileAtX_y_zoomLevel_);
    MLNComputedShapeSourceDataSource.featuresInCoordinateBounds_zoomLevel_
        .implement(builder, featuresInCoordinateBounds_zoomLevel_);
    builder.addProtocol($protocol);
  }

  /// Fetch features for a tile. This method will not be invoked on the main queue, it
  /// will be invoked on the caller's `requestQueue`.
  /// @param x Tile X coordinate.
  /// @param y Tile Y coordinate.
  /// @param zoomLevel Tile zoom level.
  static final featuresInTileAtX_y_zoomLevel_ =
      objc.ObjCProtocolMethod<objc.NSArray Function(int, int, int)>(
    _protocol_MLNComputedShapeSourceDataSource,
    _sel_featuresInTileAtX_y_zoomLevel_,
    ffi.Native.addressOf<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Void>,
                    ffi.UnsignedLong,
                    ffi.UnsignedLong,
                    ffi.UnsignedLong)>>(_MapLibreFFi_protocolTrampoline_fclj7c)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNComputedShapeSourceDataSource,
      _sel_featuresInTileAtX_y_zoomLevel_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSArray Function(int, int, int) func) =>
        ObjCBlock_NSArray_ffiVoid_NSUInteger_NSUInteger_NSUInteger.fromFunction(
            (ffi.Pointer<ffi.Void> _, int arg1, int arg2, int arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Fetch features for a tile. This method will not be invoked on the main queue, it
  /// will be invoked on the caller's `requestQueue`.
  /// @param bounds The bounds to fetch data for.
  /// @param zoomLevel Tile zoom level.
  static final featuresInCoordinateBounds_zoomLevel_ =
      objc.ObjCProtocolMethod<objc.NSArray Function(MLNCoordinateBounds, int)>(
    _protocol_MLNComputedShapeSourceDataSource,
    _sel_featuresInCoordinateBounds_zoomLevel_,
    ffi.Native.addressOf<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Void>,
                    MLNCoordinateBounds,
                    ffi.UnsignedLong)>>(_MapLibreFFi_protocolTrampoline_129i16p)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNComputedShapeSourceDataSource,
      _sel_featuresInCoordinateBounds_zoomLevel_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (objc.NSArray Function(MLNCoordinateBounds, int) func) =>
        ObjCBlock_NSArray_ffiVoid_MLNCoordinateBounds_NSUInteger.fromFunction(
            (ffi.Pointer<ffi.Void> _, MLNCoordinateBounds arg1, int arg2) =>
                func(arg1, arg2)),
  );
}

late final _class_MLNComputedShapeSource =
    objc.getClass("MLNComputedShapeSource");
late final _sel_initWithIdentifier_options_ =
    objc.registerName("initWithIdentifier:options:");
late final _sel_initWithIdentifier_dataSource_options_ =
    objc.registerName("initWithIdentifier:dataSource:options:");
late final _sel_invalidateBounds_ = objc.registerName("invalidateBounds:");
late final _sel_invalidateTileAtX_y_zoomLevel_ =
    objc.registerName("invalidateTileAtX:y:zoomLevel:");
final _objc_msgSend_1r0ktp8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int, int)>();
late final _sel_setFeatures_inTileAtX_y_zoomLevel_ =
    objc.registerName("setFeatures:inTileAtX:y:zoomLevel:");
final _objc_msgSend_10v42t6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int,
            int)>();
late final _sel_dataSource = objc.registerName("dataSource");
late final _sel_setDataSource_ = objc.registerName("setDataSource:");
late final _sel_requestQueue = objc.registerName("requestQueue");

/// ``MLNComputedShapeSource`` is a map content source that supplies vector shapes,
/// one tile at a time, to be shown on the map on demand. You implement a class
/// conforming to the ``MLNComputedShapeSourceDataSource`` protocol that returns
/// instances of ``MLNShape`` or ``MLNShape``, then add a computed shape source to an
/// ``MLNStyle`` object along with an ``MLNStyle`` object. The vector style
/// layer defines the appearance of any content supplied by the computed shape
/// source.
///
/// ``MLNComputedShapeSource`` is similar to ``MLNComputedShapeSource`` but is optimized for
/// data sets that change dynamically or are too large to fit completely in memory.
/// It is also useful for data that is divided into tiles in a format other than
/// <a href="https://www.mapbox.com/vector-tiles/">Mapbox Vector Tiles</a>. For
/// <a href="http://geojson.org/">GeoJSON</a> data, use the ``MLNShapeSource`` class.
/// For static tiles or Mapbox Vector Tiles, use the ``MLNVectorTileSource`` class.
///
/// You can add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``. This class
/// cannot be represented in a style JSON file; you must add it ot the style at
/// runtime.
class MLNComputedShapeSource extends MLNSource {
  MLNComputedShapeSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNComputedShapeSource] that points to the same underlying object as [other].
  MLNComputedShapeSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNComputedShapeSource] that wraps the given raw object pointer.
  MLNComputedShapeSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNComputedShapeSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNComputedShapeSource);
  }

  /// Returns a custom shape data source initialized with an identifier, and a
  /// dictionary of options for the source according to the
  /// <a href="https://maplibre.org/maplibre-style-spec/#sources-geojson">style
  /// specification</a>.
  ///
  /// This class supports the following options:
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``,
  /// ``MLNShapeSourceOptionSimplificationTolerance``,
  /// ``MLNShapeSourceOptionWrapsCoordinates``, and
  /// ``MLNShapeSourceOptionClipsCoordinates``. Shapes provided by a computed
  /// shape source cannot be clustered.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param options An `NSDictionary` of options for this source.
  MLNComputedShapeSource initWithIdentifier(objc.NSString identifier,
      {objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_options_,
        identifier.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a custom shape data source initialized with an identifier, data source, and a
  /// dictionary of options for the source according to the
  /// <a href="https://maplibre.org/maplibre-style-spec/#sources-geojson">style
  /// specification</a>.
  ///
  /// This class supports the following options:
  /// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
  /// ``MLNShapeSourceOptionBuffer``,
  /// ``MLNShapeSourceOptionSimplificationTolerance``,
  /// ``MLNShapeSourceOptionWrapsCoordinates``, and
  /// ``MLNShapeSourceOptionClipsCoordinates``. Shapes provided by a computed shape
  /// source cannot be clustered.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param dataSource An object conforming to MLNComputedShapeSourceDataSource protocol that will
  /// provide the shape data.
  /// @param options An `NSDictionary` of options for this source.
  MLNComputedShapeSource initWithIdentifier$1(objc.NSString identifier,
      {required MLNComputedShapeSourceDataSource dataSource,
      objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_dataSource_options_,
        identifier.ref.pointer,
        dataSource.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Invalidates all the features and properties intersecting with or contained in
  /// the specified bounds. New fetch requests will immediately be invoked on the
  /// ``MLNComputedShapeSourceDataSource``.
  /// @param bounds  Coordinate bounds to invalidate.
  void invalidateBounds(MLNCoordinateBounds bounds) {
    _objc_msgSend_9ay59k(this.ref.pointer, _sel_invalidateBounds_, bounds);
  }

  /// Invalidates all the feautres and properties of a given tile. A new fetch request
  /// will immediately be invoked on the ``MLNComputedShapeSourceDataSource``.
  /// @param x Tile X coordinate.
  /// @param y Tile Y coordinate.
  /// @param zoomLevel Tile zoom level.
  void invalidateTileAtX(int x, {required int y, required int zoomLevel}) {
    _objc_msgSend_1r0ktp8(
        this.ref.pointer, _sel_invalidateTileAtX_y_zoomLevel_, x, y, zoomLevel);
  }

  /// Set a new set of features for a tile. This method can be invkoed from background threads.
  /// For best performance, use this method only to update tiles that have already been requested
  /// through ``MLNComputedShapeSourceDataSource/``
  /// @param features  Features for the tile.
  /// @param x         Tile X coordinate.
  /// @param y         Tile Y coordinate.
  /// @param zoomLevel Tile zoom level.
  void setFeatures(objc.NSArray features,
      {required int inTileAtX, required int y, required int zoomLevel}) {
    _objc_msgSend_10v42t6(
        this.ref.pointer,
        _sel_setFeatures_inTileAtX_y_zoomLevel_,
        features.ref.pointer,
        inTileAtX,
        y,
        zoomLevel);
  }

  /// An object that implements the ``MLNComputedShapeSourceDataSource`` protocol that will be queried
  /// for tile data.
  MLNComputedShapeSourceDataSource? get dataSource {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_dataSource);
    return _ret.address == 0
        ? null
        : MLNComputedShapeSourceDataSource.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// An object that implements the ``MLNComputedShapeSourceDataSource`` protocol that will be queried
  /// for tile data.
  set dataSource(MLNComputedShapeSourceDataSource? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDataSource_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A queue that calls to the data source will be made on.
  NSOperationQueue get requestQueue {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_requestQueue);
    return NSOperationQueue.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  MLNComputedShapeSource init() {
    objc.checkOsVersionInternal('MLNComputedShapeSource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNComputedShapeSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNComputedShapeSource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNComputedShapeSource, _sel_new);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNComputedShapeSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNComputedShapeSource, _sel_allocWithZone_, zone);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNComputedShapeSource alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNComputedShapeSource, _sel_alloc);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNComputedShapeSource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNComputedShapeSource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNComputedShapeSource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNComputedShapeSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNComputedShapeSource constructed with the default `new` method.
  factory MLNComputedShapeSource() => new$();
}

late final _class_MLNImageSource = objc.getClass("MLNImageSource");
late final _sel_initWithIdentifier_coordinateQuad_URL_ =
    objc.registerName("initWithIdentifier:coordinateQuad:URL:");
final _objc_msgSend_judg3a = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                MLNCoordinateQuad,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            MLNCoordinateQuad,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithIdentifier_coordinateQuad_image_ =
    objc.registerName("initWithIdentifier:coordinateQuad:image:");
final _objc_msgSend_1ua371c = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNCoordinateQuad Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        MLNCoordinateQuad Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1ua371cStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNCoordinateQuad>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<MLNCoordinateQuad>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCoordinates_ = objc.registerName("setCoordinates:");
final _objc_msgSend_1wvd2xm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, MLNCoordinateQuad)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, MLNCoordinateQuad)>();

/// ``MLNImageSource`` is a content source that is used for a georeferenced raster
/// image to be shown on the map. The georeferenced image scales and rotates as the
/// user zooms and rotates the map. Images may also be used as icons or patterns
/// in a style layer. To register an image for use as an icon or pattern,
/// use the ``MLNStyle/setImage:forName:`` method. To configure a point
/// annotation’s image, use the ``MLNAnnotationImage`` class.
///
/// The geographic location of the raster image content, supplied with
/// ``MLNCoordinateQuad``, can be non-axis aligned.
/// ``MLNImageSource`` supports raster content from `NSURL`, `NSImage` (macOS), or
/// `UIImage` (iOS).
/// An image source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` objects. Use a raster style layer to control the
/// appearance of content supplied by the image source.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-image"><code>image</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNImageSource`` object that you can use to initialize new style layers. You
/// can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// ### Example
///
/// ```swift
/// let coordinates = MLNCoordinateQuad(
/// topLeft: CLLocationCoordinate2D(latitude: 46.437, longitude: -80.425),
/// bottomLeft: CLLocationCoordinate2D(latitude: 37.936, longitude: -80.425),
/// bottomRight: CLLocationCoordinate2D(latitude: 37.936, longitude: -71.516),
/// topRight: CLLocationCoordinate2D(latitude: 46.437, longitude: -71.516))
/// let source = MLNImageSource(identifier: "radar", coordinateQuad: coordinates, url: URL(string:
/// "https://maplibre.org/maplibre-gl-js-docs/assets/radar.gif")!) mapView.style?.addSource(source)
/// ```
///
/// #### Related examples
/// TODO: Add an image, learn how to add an image to your map using ``MLNImageSource``.
class MLNImageSource extends MLNSource {
  MLNImageSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNImageSource] that points to the same underlying object as [other].
  MLNImageSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNImageSource] that wraps the given raw object pointer.
  MLNImageSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNImageSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNImageSource);
  }

  /// Returns a georeferenced image source with an identifier, coordinates and a URL.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param coordinateQuad the top left, top right, bottom right, and bottom left coordinates for the
  /// image.
  /// @param url An HTTP(S) URL, absolute file URL, or local file URL relative to the
  /// current application’s resource bundle.
  /// @return An initialized shape source.
  MLNImageSource initWithIdentifier(objc.NSString identifier,
      {required MLNCoordinateQuad coordinateQuad, required objc.NSURL URL}) {
    final _ret = _objc_msgSend_judg3a(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_coordinateQuad_URL_,
        identifier.ref.pointer,
        coordinateQuad,
        URL.ref.pointer);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a georeferenced image source with an identifier, coordinates and an image.
  ///
  /// @param identifier A string that uniquely identifies the source.
  /// @param coordinateQuad The top left, top right, bottom right, and bottom left coordinates for the
  /// image.
  /// @param image The image to display for the source.
  /// @return An initialized shape source.
  MLNImageSource initWithIdentifier$1(objc.NSString identifier,
      {required MLNCoordinateQuad coordinateQuad, required UIImage image}) {
    final _ret = _objc_msgSend_judg3a(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_coordinateQuad_image_,
        identifier.ref.pointer,
        coordinateQuad,
        image.ref.pointer);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// The URL to the source image.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:image:` or
  /// the `image` property is set, this property is set to `nil`.
  objc.NSURL? get URL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_URL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// The URL to the source image.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:image:` or
  /// the `image` property is set, this property is set to `nil`.
  set URL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The source image.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:URL:` or if the `URL`
  /// property is set, this property is set to `nil`.
  UIImage? get image {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return _ret.address == 0
        ? null
        : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// The source image.
  ///
  /// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:URL:` or if the `URL`
  /// property is set, this property is set to `nil`.
  set image(UIImage? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The coordinates at which the corners of the source image will be placed.
  MLNCoordinateQuad get coordinates {
    final _ptr = pkg_ffi.calloc<MLNCoordinateQuad>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1ua371cStret(_ptr, this.ref.pointer, _sel_coordinates)
        : _ptr.ref = _objc_msgSend_1ua371c(this.ref.pointer, _sel_coordinates);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateQuad>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateQuad>(_finalizable);
  }

  /// The coordinates at which the corners of the source image will be placed.
  set coordinates(MLNCoordinateQuad value) {
    _objc_msgSend_1wvd2xm(this.ref.pointer, _sel_setCoordinates_, value);
  }

  /// init
  MLNImageSource init() {
    objc.checkOsVersionInternal('MLNImageSource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNImageSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNImageSource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNImageSource, _sel_new);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNImageSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNImageSource, _sel_allocWithZone_, zone);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNImageSource alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNImageSource, _sel_alloc);
    return MLNImageSource.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNImageSource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNImageSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNImageSource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNImageSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNImageSource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNImageSource.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNImageSource constructed with the default `new` method.
  factory MLNImageSource() => new$();
}

late final _class_MLNRasterTileSource = objc.getClass("MLNRasterTileSource");
late final _sel_initWithIdentifier_configurationURL_tileSize_ =
    objc.registerName("initWithIdentifier:configurationURL:tileSize:");
final _objc_msgSend_hzzkpm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            double)>();

/// ``MLNRasterTileSource`` is a map content source that supplies raster image tiles
/// to be shown on the map. The location of and metadata about the tiles are
/// defined either by an option dictionary or by an external file that conforms to
/// the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A raster tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` objects. Use a raster style layer to control the
/// appearance of content supplied by the raster tile source.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-raster"><code>raster</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNRasterTileSource`` object that you can use to initialize new style layers. You
/// can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// ### Example
///
/// ```swift
/// let source = MLNRasterTileSource(identifier: "clouds", tileURLTemplates:
/// ["https://example.com/raster-tiles/{z}/{x}/{y}.png"], options: [ .minimumZoomLevel: 9,
/// .maximumZoomLevel: 16,
/// .tileSize: 512,
/// .attributionInfos: [
/// MLNAttributionInfo(title: NSAttributedString(string: "© Mapbox"), url: URL(string:
/// "https://mapbox.com"))
/// ]
/// ])
/// mapView.style?.addSource(source)
/// ```
///
/// #### Related examples
/// TODO: Add raster imagery, learn how to add a ``MLNRasterStyleLayer``
/// to your map using an ``MLNRasterTileSource``.
class MLNRasterTileSource extends MLNTileSource {
  MLNRasterTileSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNRasterTileSource] that points to the same underlying object as [other].
  MLNRasterTileSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNRasterTileSource] that wraps the given raw object pointer.
  MLNRasterTileSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNRasterTileSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterTileSource);
  }

  /// Returns a raster tile source initialized with an identifier and configuration
  /// URL.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or canonical URL. The URL should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// If a Mapbox URL is specified, this source uses a tile size of 256. For all
  /// other tilesets, the default value is 512. (See the
  /// ``MLNTileSourceOptionTileSize`` documentation for more information about tile
  /// sizes.) If you need to use a tile size other than the default, use the
  /// `-initWithIdentifier:configurationURL:tileSize:` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @return An initialized raster tile source.
  MLNRasterTileSource initWithIdentifier(objc.NSString identifier,
      {required objc.NSURL configurationURL}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_,
        identifier.ref.pointer,
        configurationURL.ref.pointer);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a raster tile source initialized with an identifier, configuration URL,
  /// and tile size.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or, canonical URL. The URL should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @param tileSize The width and height (measured in points) of each tiled image
  /// in the raster tile source. See the ``MLNTileSourceOptionTileSize``
  /// documentation for details.
  /// @return An initialized raster tile source.
  MLNRasterTileSource initWithIdentifier$1(objc.NSString identifier,
      {required objc.NSURL configurationURL, required double tileSize}) {
    final _ret = _objc_msgSend_hzzkpm(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_tileSize_,
        identifier.ref.pointer,
        configurationURL.ref.pointer,
        tileSize);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a raster tile source initialized an identifier, tile URL templates, and
  /// options.
  ///
  /// Tile URL templates are strings that specify the URLs of the raster tile images
  /// to load. See the “<a href="../tile-url-templates.html">Tile URL Templates</a>”
  /// guide for information about the format of a tile URL template.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param tileURLTemplates An array of tile URL template strings. Only the first
  /// string is used; any additional strings are ignored.
  /// @param options A dictionary containing configuration options. See
  /// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
  /// the default values.
  /// @return An initialized tile source.
  MLNRasterTileSource initWithIdentifier$2(objc.NSString identifier,
      {required objc.NSArray tileURLTemplates, objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_tileURLTemplates_options_,
        identifier.ref.pointer,
        tileURLTemplates.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// init
  MLNRasterTileSource init() {
    objc.checkOsVersionInternal('MLNRasterTileSource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNRasterTileSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNRasterTileSource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNRasterTileSource, _sel_new);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNRasterTileSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNRasterTileSource, _sel_allocWithZone_, zone);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNRasterTileSource alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNRasterTileSource, _sel_alloc);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNRasterTileSource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNRasterTileSource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNRasterTileSource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNRasterTileSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNRasterTileSource constructed with the default `new` method.
  factory MLNRasterTileSource() => new$();
}

late final _class_MLNRasterDEMSource = objc.getClass("MLNRasterDEMSource");

/// ``MLNRasterDEMSource`` is a map content source that supplies rasterized
/// <a href="https://en.wikipedia.org/wiki/Digital_elevation_model">digital elevation model</a>
/// (DEM) tiles to be shown on the map. The location of and metadata about the
/// tiles are defined either by an option dictionary or by an external file that
/// conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A raster DEM source is added to an ``MLNStyle`` object along with one or more
/// ``MLNHillshadeStyleLayer`` objects. Use a hillshade style layer to control the
/// appearance of content supplied by the raster DEM source.
///
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-raster-dem"><code>raster-dem</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNRasterDEMSource`` object that you can use to initialize new style layers.
/// You can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
///
/// Currently, raster DEM sources only support the format used by
/// <a
/// href="https://docs.mapbox.com/help/troubleshooting/access-elevation-data/#mapbox-terrain-rgb">Mapbox
/// Terrain-RGB</a>.
///
/// ### Example
///
/// ```swift
/// let terrainRGBURL = URL(string: "maptiler://sources/terrain-rgb")!
/// let source = MLNRasterDEMSource(identifier: "hills", configurationURL: terrainRGBURL)
/// mapView.style?.addSource(source)
/// ```
class MLNRasterDEMSource extends MLNRasterTileSource {
  MLNRasterDEMSource._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNRasterDEMSource] that points to the same underlying object as [other].
  MLNRasterDEMSource.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNRasterDEMSource] that wraps the given raw object pointer.
  MLNRasterDEMSource.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNRasterDEMSource].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterDEMSource);
  }

  /// Returns a raster tile source initialized with an identifier and configuration
  /// URL.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or canonical URL. The URL should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// If a Mapbox URL is specified, this source uses a tile size of 256. For all
  /// other tilesets, the default value is 512. (See the
  /// ``MLNTileSourceOptionTileSize`` documentation for more information about tile
  /// sizes.) If you need to use a tile size other than the default, use the
  /// `-initWithIdentifier:configurationURL:tileSize:` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @return An initialized raster tile source.
  MLNRasterDEMSource initWithIdentifier(objc.NSString identifier,
      {required objc.NSURL configurationURL}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_,
        identifier.ref.pointer,
        configurationURL.ref.pointer);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a raster tile source initialized with an identifier, configuration URL,
  /// and tile size.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// The URL may be a full HTTP or HTTPS URL or, canonical URL. The URL should
  /// point to a JSON file that conforms to the
  /// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param configurationURL A URL to a TileJSON configuration file describing the
  /// source’s contents and other metadata.
  /// @param tileSize The width and height (measured in points) of each tiled image
  /// in the raster tile source. See the ``MLNTileSourceOptionTileSize``
  /// documentation for details.
  /// @return An initialized raster tile source.
  MLNRasterDEMSource initWithIdentifier$1(objc.NSString identifier,
      {required objc.NSURL configurationURL, required double tileSize}) {
    final _ret = _objc_msgSend_hzzkpm(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_configurationURL_tileSize_,
        identifier.ref.pointer,
        configurationURL.ref.pointer,
        tileSize);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a raster tile source initialized an identifier, tile URL templates, and
  /// options.
  ///
  /// Tile URL templates are strings that specify the URLs of the raster tile images
  /// to load. See the “<a href="../tile-url-templates.html">Tile URL Templates</a>”
  /// guide for information about the format of a tile URL template.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param tileURLTemplates An array of tile URL template strings. Only the first
  /// string is used; any additional strings are ignored.
  /// @param options A dictionary containing configuration options. See
  /// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
  /// the default values.
  /// @return An initialized tile source.
  MLNRasterDEMSource initWithIdentifier$2(objc.NSString identifier,
      {required objc.NSArray tileURLTemplates, objc.NSDictionary? options}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_tileURLTemplates_options_,
        identifier.ref.pointer,
        tileURLTemplates.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// init
  MLNRasterDEMSource init() {
    objc.checkOsVersionInternal('MLNRasterDEMSource.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a source initialized with an identifier.
  ///
  /// After initializing and configuring the source, add it to a map view’s style
  /// using the ``MLNStyle/addSource:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @return An initialized source.
  MLNRasterDEMSource initWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNRasterDEMSource new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNRasterDEMSource, _sel_new);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNRasterDEMSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNRasterDEMSource, _sel_allocWithZone_, zone);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNRasterDEMSource alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNRasterDEMSource, _sel_alloc);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNRasterDEMSource self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNRasterDEMSource retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNRasterDEMSource autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNRasterDEMSource.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNRasterDEMSource constructed with the default `new` method.
  factory MLNRasterDEMSource() => new$();
}

late final _class_MLNBackgroundStyleLayer =
    objc.getClass("MLNBackgroundStyleLayer");
late final _sel_backgroundColorTransition =
    objc.registerName("backgroundColorTransition");
late final _sel_setBackgroundColorTransition_ =
    objc.registerName("setBackgroundColorTransition:");
late final _sel_backgroundOpacity = objc.registerName("backgroundOpacity");
late final _sel_setBackgroundOpacity_ =
    objc.registerName("setBackgroundOpacity:");
late final _sel_backgroundOpacityTransition =
    objc.registerName("backgroundOpacityTransition");
late final _sel_setBackgroundOpacityTransition_ =
    objc.registerName("setBackgroundOpacityTransition:");
late final _sel_backgroundPattern = objc.registerName("backgroundPattern");
late final _sel_setBackgroundPattern_ =
    objc.registerName("setBackgroundPattern:");
late final _sel_backgroundPatternTransition =
    objc.registerName("backgroundPatternTransition");
late final _sel_setBackgroundPatternTransition_ =
    objc.registerName("setBackgroundPatternTransition:");

/// An ``MLNBackgroundStyleLayer`` is a style layer that covers the entire map. Use
/// a background style layer to configure a color or pattern to show below all
/// other map content. If the style’s other layers use the Mapbox Streets source,
/// the background style layer is responsible for drawing land, whereas the oceans
/// and other bodies of water are drawn by ``MLNBackgroundStyleLayer`` objects.
///
/// A background style layer is typically the bottommost layer in a style, because
/// it covers the entire map and can occlude any layers below it. You can therefore
/// access it by getting the last item in the ``MLNStyle/layers`` array.
///
/// If the background style layer is transparent or omitted from the style, any
/// portion of the map view that does not show another style layer is transparent.
class MLNBackgroundStyleLayer extends MLNStyleLayer {
  MLNBackgroundStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNBackgroundStyleLayer] that points to the same underlying object as [other].
  MLNBackgroundStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNBackgroundStyleLayer] that wraps the given raw object pointer.
  MLNBackgroundStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNBackgroundStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNBackgroundStyleLayer);
  }

  /// Returns a background style layer initialized with an identifier.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  MLNBackgroundStyleLayer initWithIdentifier(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The color with which the background will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `backgroundPattern` is set to
  /// `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get backgroundColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color with which the background will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `backgroundPattern` is set to
  /// `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set backgroundColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setBackgroundColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `backgroundColor` property.
  ///
  /// This property corresponds to the `background-color-transition` property in the style JSON file format.
  MLNTransition get backgroundColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_backgroundColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_backgroundColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `backgroundColor` property.
  ///
  /// This property corresponds to the `background-color-transition` property in the style JSON file format.
  set backgroundColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setBackgroundColorTransition_, value);
  }

  /// The opacity at which the background will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get backgroundOpacity {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the background will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set backgroundOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setBackgroundOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `backgroundOpacity` property.
  ///
  /// This property corresponds to the `background-opacity-transition` property in the style JSON file format.
  MLNTransition get backgroundOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_backgroundOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_backgroundOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `backgroundOpacity` property.
  ///
  /// This property corresponds to the `background-opacity-transition` property in the style JSON file format.
  set backgroundOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setBackgroundOpacityTransition_, value);
  }

  /// Name of image in style images to use for drawing an image background. For
  /// seamless patterns, image width and height must be a factor of two (2, 4, 8,
  /// ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get backgroundPattern {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundPattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of image in style images to use for drawing an image background. For
  /// seamless patterns, image width and height must be a factor of two (2, 4, 8,
  /// ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set backgroundPattern(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setBackgroundPattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `backgroundPattern` property.
  ///
  /// This property corresponds to the `background-pattern-transition` property in the style JSON file format.
  MLNTransition get backgroundPatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_backgroundPatternTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_backgroundPatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `backgroundPattern` property.
  ///
  /// This property corresponds to the `background-pattern-transition` property in the style JSON file format.
  set backgroundPatternTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setBackgroundPatternTransition_, value);
  }

  /// init
  MLNBackgroundStyleLayer init() {
    objc.checkOsVersionInternal('MLNBackgroundStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNBackgroundStyleLayer new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNBackgroundStyleLayer, _sel_new);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNBackgroundStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNBackgroundStyleLayer, _sel_allocWithZone_, zone);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNBackgroundStyleLayer alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNBackgroundStyleLayer, _sel_alloc);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNBackgroundStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNBackgroundStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNBackgroundStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNBackgroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNBackgroundStyleLayer constructed with the default `new` method.
  factory MLNBackgroundStyleLayer() => new$();
}

late final _class_MLNForegroundStyleLayer =
    objc.getClass("MLNForegroundStyleLayer");
late final _sel_sourceIdentifier = objc.registerName("sourceIdentifier");

/// ``MLNForegroundStyleLayer`` is an abstract superclass for style layers whose
/// content is defined by an ``MLNSource`` object.
///
/// Create instances of ``MLNRasterStyleLayer``, ``MLNRasterStyleLayer``, and the
/// concrete subclasses of ``MLNVectorStyleLayer`` in order to use
/// ``MLNForegroundStyleLayer``'s methods. Do not create instances of
/// ``MLNForegroundStyleLayer`` directly, and do not create your own subclasses of
/// this class.
class MLNForegroundStyleLayer extends MLNStyleLayer {
  MLNForegroundStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNForegroundStyleLayer] that points to the same underlying object as [other].
  MLNForegroundStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNForegroundStyleLayer] that wraps the given raw object pointer.
  MLNForegroundStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNForegroundStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNForegroundStyleLayer);
  }

  /// init
  MLNForegroundStyleLayer init() {
    objc.checkOsVersionInternal('MLNForegroundStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Identifier of the source from which the receiver obtains the data to style.
  objc.NSString? get sourceIdentifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sourceIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static MLNForegroundStyleLayer new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNForegroundStyleLayer, _sel_new);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNForegroundStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNForegroundStyleLayer, _sel_allocWithZone_, zone);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNForegroundStyleLayer alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNForegroundStyleLayer, _sel_alloc);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNForegroundStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNForegroundStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNForegroundStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNForegroundStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNForegroundStyleLayer constructed with the default `new` method.
  factory MLNForegroundStyleLayer() => new$();
}

late final _class_MLNVectorStyleLayer = objc.getClass("MLNVectorStyleLayer");
late final _sel_sourceLayerIdentifier =
    objc.registerName("sourceLayerIdentifier");
late final _sel_setSourceLayerIdentifier_ =
    objc.registerName("setSourceLayerIdentifier:");
late final _sel_setPredicate_ = objc.registerName("setPredicate:");

/// ``MLNVectorStyleLayer`` is an abstract superclass for style layers whose content
/// is defined by an ``MLNShapeSource`` or ``MLNShapeSource`` object.
///
/// Create instances of ``MLNCircleStyleLayer``, ``MLNCircleStyleLayer``,
/// ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``, and
/// ``MLNSymbolStyleLayer`` in order to use ``MLNSymbolStyleLayer``'s properties and
/// methods. Do not create instances of ``MLNVectorStyleLayer`` directly, and do not
/// create your own subclasses of this class.
class MLNVectorStyleLayer extends MLNForegroundStyleLayer {
  MLNVectorStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNVectorStyleLayer] that points to the same underlying object as [other].
  MLNVectorStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNVectorStyleLayer] that wraps the given raw object pointer.
  MLNVectorStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNVectorStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNVectorStyleLayer);
  }

  /// Identifier of the layer within the source identified by the `sourceIdentifier`
  /// property from which the receiver obtains the data to style.
  objc.NSString? get sourceLayerIdentifier {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_sourceLayerIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Identifier of the layer within the source identified by the `sourceIdentifier`
  /// property from which the receiver obtains the data to style.
  set sourceLayerIdentifier(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSourceLayerIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// The style layer’s predicate.
  ///
  /// Use the style layer’s predicate to include only the features in the source
  /// layer that satisfy a condition that you define. If the style layer initially
  /// comes from the style, its predicate corresponds to the
  /// <a href="https://maplibre.org/maplibre-style-spec/#layer-filter">`filter`</a>
  /// property in the style JSON.
  ///
  /// See the “<a href="../predicates-and-expressions.html">Predicates and Expressions</a>”
  /// guide for details about the predicate syntax supported by this class.
  ///
  /// ### Example
  ///
  /// To filter the layer to include only the features whose `index` attribute is 5
  /// or 10 and whose `ele` attribute is at least 1,500, you could create an
  /// `NSCompoundPredicate` along these lines:
  ///
  /// ```swift
  /// let layer = MLNLineStyleLayer(identifier: "contour", source: terrain)
  /// layer.sourceLayerIdentifier = "contours"
  /// layer.predicate = NSPredicate(format: "(index == 5 || index == 10) && CAST(ele, 'NSNumber') >=
  /// 1500.0") mapView.style?.addLayer(layer)
  /// ```
  NSPredicate? get predicate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_predicate);
    return _ret.address == 0
        ? null
        : NSPredicate.castFromPointer(_ret, retain: true, release: true);
  }

  /// The style layer’s predicate.
  ///
  /// Use the style layer’s predicate to include only the features in the source
  /// layer that satisfy a condition that you define. If the style layer initially
  /// comes from the style, its predicate corresponds to the
  /// <a href="https://maplibre.org/maplibre-style-spec/#layer-filter">`filter`</a>
  /// property in the style JSON.
  ///
  /// See the “<a href="../predicates-and-expressions.html">Predicates and Expressions</a>”
  /// guide for details about the predicate syntax supported by this class.
  ///
  /// ### Example
  ///
  /// To filter the layer to include only the features whose `index` attribute is 5
  /// or 10 and whose `ele` attribute is at least 1,500, you could create an
  /// `NSCompoundPredicate` along these lines:
  ///
  /// ```swift
  /// let layer = MLNLineStyleLayer(identifier: "contour", source: terrain)
  /// layer.sourceLayerIdentifier = "contours"
  /// layer.predicate = NSPredicate(format: "(index == 5 || index == 10) && CAST(ele, 'NSNumber') >=
  /// 1500.0") mapView.style?.addLayer(layer)
  /// ```
  set predicate(NSPredicate? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPredicate_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  MLNVectorStyleLayer init() {
    objc.checkOsVersionInternal('MLNVectorStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNVectorStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNVectorStyleLayer, _sel_new);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNVectorStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNVectorStyleLayer, _sel_allocWithZone_, zone);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNVectorStyleLayer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNVectorStyleLayer, _sel_alloc);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNVectorStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNVectorStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNVectorStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNVectorStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNVectorStyleLayer constructed with the default `new` method.
  factory MLNVectorStyleLayer() => new$();
}

late final _class_MLNCircleStyleLayer = objc.getClass("MLNCircleStyleLayer");
late final _sel_initWithIdentifier_source_ =
    objc.registerName("initWithIdentifier:source:");
late final _sel_circleSortKey = objc.registerName("circleSortKey");
late final _sel_setCircleSortKey_ = objc.registerName("setCircleSortKey:");
late final _sel_circleBlur = objc.registerName("circleBlur");
late final _sel_setCircleBlur_ = objc.registerName("setCircleBlur:");
late final _sel_circleBlurTransition =
    objc.registerName("circleBlurTransition");
late final _sel_setCircleBlurTransition_ =
    objc.registerName("setCircleBlurTransition:");
late final _sel_circleColor = objc.registerName("circleColor");
late final _sel_setCircleColor_ = objc.registerName("setCircleColor:");
late final _sel_circleColorTransition =
    objc.registerName("circleColorTransition");
late final _sel_setCircleColorTransition_ =
    objc.registerName("setCircleColorTransition:");
late final _sel_circleOpacity = objc.registerName("circleOpacity");
late final _sel_setCircleOpacity_ = objc.registerName("setCircleOpacity:");
late final _sel_circleOpacityTransition =
    objc.registerName("circleOpacityTransition");
late final _sel_setCircleOpacityTransition_ =
    objc.registerName("setCircleOpacityTransition:");
late final _sel_circlePitchAlignment =
    objc.registerName("circlePitchAlignment");
late final _sel_setCirclePitchAlignment_ =
    objc.registerName("setCirclePitchAlignment:");
late final _sel_circleRadius = objc.registerName("circleRadius");
late final _sel_setCircleRadius_ = objc.registerName("setCircleRadius:");
late final _sel_circleRadiusTransition =
    objc.registerName("circleRadiusTransition");
late final _sel_setCircleRadiusTransition_ =
    objc.registerName("setCircleRadiusTransition:");
late final _sel_circleScaleAlignment =
    objc.registerName("circleScaleAlignment");
late final _sel_setCircleScaleAlignment_ =
    objc.registerName("setCircleScaleAlignment:");
late final _sel_circlePitchScale = objc.registerName("circlePitchScale");
late final _sel_setCirclePitchScale_ =
    objc.registerName("setCirclePitchScale:");
late final _sel_circleStrokeColor = objc.registerName("circleStrokeColor");
late final _sel_setCircleStrokeColor_ =
    objc.registerName("setCircleStrokeColor:");
late final _sel_circleStrokeColorTransition =
    objc.registerName("circleStrokeColorTransition");
late final _sel_setCircleStrokeColorTransition_ =
    objc.registerName("setCircleStrokeColorTransition:");
late final _sel_circleStrokeOpacity = objc.registerName("circleStrokeOpacity");
late final _sel_setCircleStrokeOpacity_ =
    objc.registerName("setCircleStrokeOpacity:");
late final _sel_circleStrokeOpacityTransition =
    objc.registerName("circleStrokeOpacityTransition");
late final _sel_setCircleStrokeOpacityTransition_ =
    objc.registerName("setCircleStrokeOpacityTransition:");
late final _sel_circleStrokeWidth = objc.registerName("circleStrokeWidth");
late final _sel_setCircleStrokeWidth_ =
    objc.registerName("setCircleStrokeWidth:");
late final _sel_circleStrokeWidthTransition =
    objc.registerName("circleStrokeWidthTransition");
late final _sel_setCircleStrokeWidthTransition_ =
    objc.registerName("setCircleStrokeWidthTransition:");
late final _sel_circleTranslation = objc.registerName("circleTranslation");
late final _sel_setCircleTranslation_ =
    objc.registerName("setCircleTranslation:");
late final _sel_circleTranslationTransition =
    objc.registerName("circleTranslationTransition");
late final _sel_setCircleTranslationTransition_ =
    objc.registerName("setCircleTranslationTransition:");
late final _sel_circleTranslate = objc.registerName("circleTranslate");
late final _sel_setCircleTranslate_ = objc.registerName("setCircleTranslate:");
late final _sel_circleTranslationAnchor =
    objc.registerName("circleTranslationAnchor");
late final _sel_setCircleTranslationAnchor_ =
    objc.registerName("setCircleTranslationAnchor:");
late final _sel_circleTranslateAnchor =
    objc.registerName("circleTranslateAnchor");
late final _sel_setCircleTranslateAnchor_ =
    objc.registerName("setCircleTranslateAnchor:");

/// An ``MLNCircleStyleLayer`` is a style layer that renders one or more filled
/// circles on the map.
///
/// Use a circle style layer to configure the visual appearance of point or point
/// collection features. These features can come from vector tiles loaded by an
/// ``MLNCircleStyleLayer`` object, or they can be ``MLNCircleStyleLayer``,
/// ``MLNCircleStyleLayer``, ``MLNCircleStyleLayer``, or ``MLNCircleStyleLayer``
/// instances in an ``MLNCircleStyleLayer`` or ``MLNCircleStyleLayer`` object.
///
/// A circle style layer renders circles whose radii are measured in screen units.
/// To display circles on the map whose radii correspond to real-world distances,
/// use many-sided regular polygons and configure their appearance using an
/// ``MLNCircleStyleLayer`` object.
///
/// You can access an existing circle style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new circle style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/dds-circle-layer/">Data-driven
/// circles</a>, <a
/// href="https://docs.mapbox.com/ios/maps/examples/shape-collection/">Add multiple
/// shapes from a single shape source</a>, and <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster point
/// data</a> examples to learn how to add circles to your map using this style
/// layer.
///
/// ### Example
///
/// ```swift
/// ```
class MLNCircleStyleLayer extends MLNVectorStyleLayer {
  MLNCircleStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNCircleStyleLayer] that points to the same underlying object as [other].
  MLNCircleStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNCircleStyleLayer] that wraps the given raw object pointer.
  MLNCircleStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNCircleStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNCircleStyleLayer);
  }

  /// Returns a circle style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNCircleStyleLayer initWithIdentifier(objc.NSString identifier,
      {required MLNSource source}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleSortKey {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_circleSortKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleSortKey(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleSortKey_, value.ref.pointer);
  }

  /// Amount to blur the circle. 1 blurs the circle such that only the centerpoint is
  /// full opacity.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleBlur {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_circleBlur);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Amount to blur the circle. 1 blurs the circle such that only the centerpoint is
  /// full opacity.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleBlur(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleBlur_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleBlur` property.
  ///
  /// This property corresponds to the `circle-blur-transition` property in the style JSON file format.
  MLNTransition get circleBlurTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleBlurTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_circleBlurTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleBlur` property.
  ///
  /// This property corresponds to the `circle-blur-transition` property in the style JSON file format.
  set circleBlurTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleBlurTransition_, value);
  }

  /// The fill color of the circle.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_circleColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The fill color of the circle.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleColor` property.
  ///
  /// This property corresponds to the `circle-color-transition` property in the style JSON file format.
  MLNTransition get circleColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_circleColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleColor` property.
  ///
  /// This property corresponds to the `circle-color-transition` property in the style JSON file format.
  set circleColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleColorTransition_, value);
  }

  /// The opacity at which the circle will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleOpacity {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_circleOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the circle will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleOpacity` property.
  ///
  /// This property corresponds to the `circle-opacity-transition` property in the style JSON file format.
  MLNTransition get circleOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleOpacity` property.
  ///
  /// This property corresponds to the `circle-opacity-transition` property in the style JSON file format.
  set circleOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleOpacityTransition_, value);
  }

  /// Orientation of circle when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `viewport`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCirclePitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The circle is aligned to the plane of the map.
  /// `viewport`: The circle is aligned to the plane of the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get circlePitchAlignment {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_circlePitchAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Orientation of circle when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `viewport`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCirclePitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The circle is aligned to the plane of the map.
  /// `viewport`: The circle is aligned to the plane of the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set circlePitchAlignment(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCirclePitchAlignment_, value.ref.pointer);
  }

  /// Circle radius.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `5`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleRadius {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_circleRadius);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Circle radius.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `5`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleRadius(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleRadius_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleRadius` property.
  ///
  /// This property corresponds to the `circle-radius-transition` property in the style JSON file format.
  MLNTransition get circleRadiusTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleRadiusTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleRadiusTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleRadius` property.
  ///
  /// This property corresponds to the `circle-radius-transition` property in the style JSON file format.
  set circleRadiusTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleRadiusTransition_, value);
  }

  /// Controls the scaling behavior of the circle when the map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-pitch-scale"><code>circle-pitch-scale</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCircleScaleAlignment` values
  /// Any of the following constant string values:
  /// `map`: Circles are scaled according to their apparent distance to the
  /// camera.
  /// `viewport`: Circles are not scaled.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get circleScaleAlignment {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_circleScaleAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the scaling behavior of the circle when the map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-pitch-scale"><code>circle-pitch-scale</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCircleScaleAlignment` values
  /// Any of the following constant string values:
  /// `map`: Circles are scaled according to their apparent distance to the
  /// camera.
  /// `viewport`: Circles are not scaled.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set circleScaleAlignment(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleScaleAlignment_, value.ref.pointer);
  }

  /// circlePitchScale
  NSExpression get circlePitchScale {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_circlePitchScale);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCirclePitchScale:
  set circlePitchScale(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCirclePitchScale_, value.ref.pointer);
  }

  /// The stroke color of the circle.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleStrokeColor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_circleStrokeColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The stroke color of the circle.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleStrokeColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleStrokeColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeColor` property.
  ///
  /// This property corresponds to the `circle-stroke-color-transition` property in the style JSON file format.
  MLNTransition get circleStrokeColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleStrokeColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleStrokeColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeColor` property.
  ///
  /// This property corresponds to the `circle-stroke-color-transition` property in the style JSON file format.
  set circleStrokeColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleStrokeColorTransition_, value);
  }

  /// The opacity of the circle's stroke.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleStrokeOpacity {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_circleStrokeOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity of the circle's stroke.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleStrokeOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleStrokeOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeOpacity` property.
  ///
  /// This property corresponds to the `circle-stroke-opacity-transition` property in the style JSON file format.
  MLNTransition get circleStrokeOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleStrokeOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleStrokeOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeOpacity` property.
  ///
  /// This property corresponds to the `circle-stroke-opacity-transition` property in the style JSON file format.
  set circleStrokeOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleStrokeOpacityTransition_, value);
  }

  /// The width of the circle's stroke. Strokes are placed outside of the
  /// `circleRadius`.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get circleStrokeWidth {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_circleStrokeWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The width of the circle's stroke. Strokes are placed outside of the
  /// `circleRadius`.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set circleStrokeWidth(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleStrokeWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeWidth` property.
  ///
  /// This property corresponds to the `circle-stroke-width-transition` property in the style JSON file format.
  MLNTransition get circleStrokeWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleStrokeWidthTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleStrokeWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleStrokeWidth` property.
  ///
  /// This property corresponds to the `circle-stroke-width-transition` property in the style JSON file format.
  set circleStrokeWidthTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleStrokeWidthTransition_, value);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate"><code>circle-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get circleTranslation {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_circleTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate"><code>circle-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set circleTranslation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `circleTranslation` property.
  ///
  /// This property corresponds to the `circle-translate-transition` property in the style JSON file format.
  MLNTransition get circleTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_circleTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_circleTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `circleTranslation` property.
  ///
  /// This property corresponds to the `circle-translate-transition` property in the style JSON file format.
  set circleTranslationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setCircleTranslationTransition_, value);
  }

  /// circleTranslate
  NSExpression get circleTranslate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_circleTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCircleTranslate:
  set circleTranslate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `circleTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `circleTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate-anchor"><code>circle-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCircleTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The circle is translated relative to the map.
  /// `viewport`: The circle is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get circleTranslationAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_circleTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `circleTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `circleTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate-anchor"><code>circle-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNCircleTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The circle is translated relative to the map.
  /// `viewport`: The circle is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set circleTranslationAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleTranslationAnchor_, value.ref.pointer);
  }

  /// circleTranslateAnchor
  NSExpression get circleTranslateAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_circleTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCircleTranslateAnchor:
  set circleTranslateAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCircleTranslateAnchor_, value.ref.pointer);
  }

  /// init
  MLNCircleStyleLayer init() {
    objc.checkOsVersionInternal('MLNCircleStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNCircleStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNCircleStyleLayer, _sel_new);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNCircleStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNCircleStyleLayer, _sel_allocWithZone_, zone);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNCircleStyleLayer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNCircleStyleLayer, _sel_alloc);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNCircleStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNCircleStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNCircleStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNCircleStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNCircleStyleLayer constructed with the default `new` method.
  factory MLNCircleStyleLayer() => new$();
}

late final _class_MLNFillExtrusionStyleLayer =
    objc.getClass("MLNFillExtrusionStyleLayer");
late final _sel_fillExtrusionBase = objc.registerName("fillExtrusionBase");
late final _sel_setFillExtrusionBase_ =
    objc.registerName("setFillExtrusionBase:");
late final _sel_fillExtrusionBaseTransition =
    objc.registerName("fillExtrusionBaseTransition");
late final _sel_setFillExtrusionBaseTransition_ =
    objc.registerName("setFillExtrusionBaseTransition:");
late final _sel_fillExtrusionColor = objc.registerName("fillExtrusionColor");
late final _sel_setFillExtrusionColor_ =
    objc.registerName("setFillExtrusionColor:");
late final _sel_fillExtrusionColorTransition =
    objc.registerName("fillExtrusionColorTransition");
late final _sel_setFillExtrusionColorTransition_ =
    objc.registerName("setFillExtrusionColorTransition:");
late final _sel_fillExtrusionHasVerticalGradient =
    objc.registerName("fillExtrusionHasVerticalGradient");
late final _sel_setFillExtrusionHasVerticalGradient_ =
    objc.registerName("setFillExtrusionHasVerticalGradient:");
late final _sel_fillExtrusionVerticalGradient =
    objc.registerName("fillExtrusionVerticalGradient");
late final _sel_setFillExtrusionVerticalGradient_ =
    objc.registerName("setFillExtrusionVerticalGradient:");
late final _sel_fillExtrusionHeight = objc.registerName("fillExtrusionHeight");
late final _sel_setFillExtrusionHeight_ =
    objc.registerName("setFillExtrusionHeight:");
late final _sel_fillExtrusionHeightTransition =
    objc.registerName("fillExtrusionHeightTransition");
late final _sel_setFillExtrusionHeightTransition_ =
    objc.registerName("setFillExtrusionHeightTransition:");
late final _sel_fillExtrusionOpacity =
    objc.registerName("fillExtrusionOpacity");
late final _sel_setFillExtrusionOpacity_ =
    objc.registerName("setFillExtrusionOpacity:");
late final _sel_fillExtrusionOpacityTransition =
    objc.registerName("fillExtrusionOpacityTransition");
late final _sel_setFillExtrusionOpacityTransition_ =
    objc.registerName("setFillExtrusionOpacityTransition:");
late final _sel_fillExtrusionPattern =
    objc.registerName("fillExtrusionPattern");
late final _sel_setFillExtrusionPattern_ =
    objc.registerName("setFillExtrusionPattern:");
late final _sel_fillExtrusionPatternTransition =
    objc.registerName("fillExtrusionPatternTransition");
late final _sel_setFillExtrusionPatternTransition_ =
    objc.registerName("setFillExtrusionPatternTransition:");
late final _sel_fillExtrusionTranslation =
    objc.registerName("fillExtrusionTranslation");
late final _sel_setFillExtrusionTranslation_ =
    objc.registerName("setFillExtrusionTranslation:");
late final _sel_fillExtrusionTranslationTransition =
    objc.registerName("fillExtrusionTranslationTransition");
late final _sel_setFillExtrusionTranslationTransition_ =
    objc.registerName("setFillExtrusionTranslationTransition:");
late final _sel_fillExtrusionTranslate =
    objc.registerName("fillExtrusionTranslate");
late final _sel_setFillExtrusionTranslate_ =
    objc.registerName("setFillExtrusionTranslate:");
late final _sel_fillExtrusionTranslationAnchor =
    objc.registerName("fillExtrusionTranslationAnchor");
late final _sel_setFillExtrusionTranslationAnchor_ =
    objc.registerName("setFillExtrusionTranslationAnchor:");
late final _sel_fillExtrusionTranslateAnchor =
    objc.registerName("fillExtrusionTranslateAnchor");
late final _sel_setFillExtrusionTranslateAnchor_ =
    objc.registerName("setFillExtrusionTranslateAnchor:");

/// An ``MLNFillExtrusionStyleLayer`` is a style layer that renders one or more 3D
/// extruded polygons on the map.
///
/// Use a fill-extrusion style layer to configure the visual appearance of polygon
/// or multipolygon features. These features can come from vector tiles loaded by
/// an ``MLNFillExtrusionStyleLayer`` object, or they can be
/// ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``,
/// ``MLNFillExtrusionStyleLayer``, or ``MLNFillExtrusionStyleLayer`` instances in
/// an ``MLNFillExtrusionStyleLayer`` or ``MLNFillExtrusionStyleLayer`` object.
///
/// You can access an existing fill-extrusion style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new fill-extrusion style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a href="https://docs.mapbox.com/ios/maps/examples/extrusions/">Display
/// 3D buildings</a> example to learn how to add and style 3D layers on a map.
///
/// ### Example
///
/// ```swift
/// ```
class MLNFillExtrusionStyleLayer extends MLNVectorStyleLayer {
  MLNFillExtrusionStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNFillExtrusionStyleLayer] that points to the same underlying object as [other].
  MLNFillExtrusionStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNFillExtrusionStyleLayer] that wraps the given raw object pointer.
  MLNFillExtrusionStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNFillExtrusionStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_MLNFillExtrusionStyleLayer);
  }

  /// Returns a fill-extrusion style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNFillExtrusionStyleLayer initWithIdentifier(objc.NSString identifier,
      {required MLNSource source}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The height with which to extrude the base of this layer. Must be less than or
  /// equal to `fillExtrusionHeight`.
  ///
  /// This property is measured in meters.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillExtrusionHeight` is
  /// non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillExtrusionBase {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillExtrusionBase);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The height with which to extrude the base of this layer. Must be less than or
  /// equal to `fillExtrusionHeight`.
  ///
  /// This property is measured in meters.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillExtrusionHeight` is
  /// non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillExtrusionBase(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillExtrusionBase_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionBase` property.
  ///
  /// This property corresponds to the `fill-extrusion-base-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionBaseTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionBaseTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionBaseTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionBase` property.
  ///
  /// This property corresponds to the `fill-extrusion-base-transition` property in the style JSON file format.
  set fillExtrusionBaseTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionBaseTransition_, value);
  }

  /// The base color of this layer. The extrusion's surfaces will be shaded
  /// differently based on this color in combination with the `light` settings. If
  /// this color is specified with an alpha component, the alpha component will be
  /// ignored; use `fillExtrusionOpacity` to set layer opacityco.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `fillExtrusionPattern` is set to
  /// `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillExtrusionColor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillExtrusionColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The base color of this layer. The extrusion's surfaces will be shaded
  /// differently based on this color in combination with the `light` settings. If
  /// this color is specified with an alpha component, the alpha component will be
  /// ignored; use `fillExtrusionOpacity` to set layer opacityco.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `fillExtrusionPattern` is set to
  /// `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillExtrusionColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillExtrusionColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionColor` property.
  ///
  /// This property corresponds to the `fill-extrusion-color-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionColor` property.
  ///
  /// This property corresponds to the `fill-extrusion-color-transition` property in the style JSON file format.
  set fillExtrusionColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionColorTransition_, value);
  }

  /// Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If
  /// true, sides will be shaded slightly darker farther down.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-vertical-gradient"><code>fill-extrusion-vertical-gradient</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get fillExtrusionHasVerticalGradient {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_fillExtrusionHasVerticalGradient);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If
  /// true, sides will be shaded slightly darker farther down.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-vertical-gradient"><code>fill-extrusion-vertical-gradient</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set fillExtrusionHasVerticalGradient(NSExpression value) {
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_setFillExtrusionHasVerticalGradient_, value.ref.pointer);
  }

  /// fillExtrusionVerticalGradient
  NSExpression get fillExtrusionVerticalGradient {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_fillExtrusionVerticalGradient);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillExtrusionVerticalGradient:
  set fillExtrusionVerticalGradient(NSExpression value) {
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_setFillExtrusionVerticalGradient_, value.ref.pointer);
  }

  /// The height with which to extrude this layer.
  ///
  /// This property is measured in meters.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillExtrusionHeight {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillExtrusionHeight);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The height with which to extrude this layer.
  ///
  /// This property is measured in meters.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillExtrusionHeight(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillExtrusionHeight_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionHeight` property.
  ///
  /// This property corresponds to the `fill-extrusion-height-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionHeightTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionHeightTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionHeightTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionHeight` property.
  ///
  /// This property corresponds to the `fill-extrusion-height-transition` property in the style JSON file format.
  set fillExtrusionHeightTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionHeightTransition_, value);
  }

  /// The opacity of the entire fill extrusion layer. This is rendered on a
  /// per-layer, not per-feature, basis, and data-driven styling is not available.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get fillExtrusionOpacity {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillExtrusionOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity of the entire fill extrusion layer. This is rendered on a
  /// per-layer, not per-feature, basis, and data-driven styling is not available.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set fillExtrusionOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillExtrusionOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionOpacity` property.
  ///
  /// This property corresponds to the `fill-extrusion-opacity-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionOpacity` property.
  ///
  /// This property corresponds to the `fill-extrusion-opacity-transition` property in the style JSON file format.
  set fillExtrusionOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionOpacityTransition_, value);
  }

  /// Name of image in style images to use for drawing image fill-extrusions. For
  /// seamless patterns, image width and height must be a factor of two (2, 4, 8,
  /// ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillExtrusionPattern {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillExtrusionPattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of image in style images to use for drawing image fill-extrusions. For
  /// seamless patterns, image width and height must be a factor of two (2, 4, 8,
  /// ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillExtrusionPattern(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillExtrusionPattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionPattern` property.
  ///
  /// This property corresponds to the `fill-extrusion-pattern-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionPatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionPatternTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionPatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionPattern` property.
  ///
  /// This property corresponds to the `fill-extrusion-pattern-transition` property in the style JSON file format.
  set fillExtrusionPatternTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionPatternTransition_, value);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate"><code>fill-extrusion-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get fillExtrusionTranslation {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillExtrusionTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate"><code>fill-extrusion-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set fillExtrusionTranslation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillExtrusionTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionTranslation` property.
  ///
  /// This property corresponds to the `fill-extrusion-translate-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillExtrusionTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillExtrusionTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillExtrusionTranslation` property.
  ///
  /// This property corresponds to the `fill-extrusion-translate-transition` property in the style JSON file format.
  set fillExtrusionTranslationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillExtrusionTranslationTransition_, value);
  }

  /// fillExtrusionTranslate
  NSExpression get fillExtrusionTranslate {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillExtrusionTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillExtrusionTranslate:
  set fillExtrusionTranslate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillExtrusionTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `fillExtrusionTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillExtrusionTranslation` is
  /// non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate-anchor"><code>fill-extrusion-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNFillExtrusionTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The fill extrusion is translated relative to the map.
  /// `viewport`: The fill extrusion is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get fillExtrusionTranslationAnchor {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_fillExtrusionTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `fillExtrusionTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillExtrusionTranslation` is
  /// non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate-anchor"><code>fill-extrusion-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNFillExtrusionTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The fill extrusion is translated relative to the map.
  /// `viewport`: The fill extrusion is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set fillExtrusionTranslationAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_setFillExtrusionTranslationAnchor_, value.ref.pointer);
  }

  /// fillExtrusionTranslateAnchor
  NSExpression get fillExtrusionTranslateAnchor {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_fillExtrusionTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillExtrusionTranslateAnchor:
  set fillExtrusionTranslateAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_setFillExtrusionTranslateAnchor_, value.ref.pointer);
  }

  /// init
  MLNFillExtrusionStyleLayer init() {
    objc.checkOsVersionInternal('MLNFillExtrusionStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNFillExtrusionStyleLayer new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNFillExtrusionStyleLayer, _sel_new);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNFillExtrusionStyleLayer allocWithZone(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNFillExtrusionStyleLayer, _sel_allocWithZone_, zone);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNFillExtrusionStyleLayer alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNFillExtrusionStyleLayer, _sel_alloc);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNFillExtrusionStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNFillExtrusionStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNFillExtrusionStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNFillExtrusionStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNFillExtrusionStyleLayer constructed with the default `new` method.
  factory MLNFillExtrusionStyleLayer() => new$();
}

late final _class_MLNFillStyleLayer = objc.getClass("MLNFillStyleLayer");
late final _sel_fillSortKey = objc.registerName("fillSortKey");
late final _sel_setFillSortKey_ = objc.registerName("setFillSortKey:");
late final _sel_isFillAntialiased = objc.registerName("isFillAntialiased");
late final _sel_setFillAntialiased_ = objc.registerName("setFillAntialiased:");
late final _sel_fillAntialias = objc.registerName("fillAntialias");
late final _sel_setFillAntialias_ = objc.registerName("setFillAntialias:");
late final _sel_fillColor = objc.registerName("fillColor");
late final _sel_setFillColor_ = objc.registerName("setFillColor:");
late final _sel_fillColorTransition = objc.registerName("fillColorTransition");
late final _sel_setFillColorTransition_ =
    objc.registerName("setFillColorTransition:");
late final _sel_fillOpacity = objc.registerName("fillOpacity");
late final _sel_setFillOpacity_ = objc.registerName("setFillOpacity:");
late final _sel_fillOpacityTransition =
    objc.registerName("fillOpacityTransition");
late final _sel_setFillOpacityTransition_ =
    objc.registerName("setFillOpacityTransition:");
late final _sel_fillOutlineColor = objc.registerName("fillOutlineColor");
late final _sel_setFillOutlineColor_ =
    objc.registerName("setFillOutlineColor:");
late final _sel_fillOutlineColorTransition =
    objc.registerName("fillOutlineColorTransition");
late final _sel_setFillOutlineColorTransition_ =
    objc.registerName("setFillOutlineColorTransition:");
late final _sel_fillPattern = objc.registerName("fillPattern");
late final _sel_setFillPattern_ = objc.registerName("setFillPattern:");
late final _sel_fillPatternTransition =
    objc.registerName("fillPatternTransition");
late final _sel_setFillPatternTransition_ =
    objc.registerName("setFillPatternTransition:");
late final _sel_fillTranslation = objc.registerName("fillTranslation");
late final _sel_setFillTranslation_ = objc.registerName("setFillTranslation:");
late final _sel_fillTranslationTransition =
    objc.registerName("fillTranslationTransition");
late final _sel_setFillTranslationTransition_ =
    objc.registerName("setFillTranslationTransition:");
late final _sel_fillTranslate = objc.registerName("fillTranslate");
late final _sel_setFillTranslate_ = objc.registerName("setFillTranslate:");
late final _sel_fillTranslationAnchor =
    objc.registerName("fillTranslationAnchor");
late final _sel_setFillTranslationAnchor_ =
    objc.registerName("setFillTranslationAnchor:");
late final _sel_fillTranslateAnchor = objc.registerName("fillTranslateAnchor");
late final _sel_setFillTranslateAnchor_ =
    objc.registerName("setFillTranslateAnchor:");

/// An ``MLNFillStyleLayer`` is a style layer that renders one or more filled (and
/// optionally stroked) polygons on the map.
///
/// Use a fill style layer to configure the visual appearance of polygon or
/// multipolygon features. These features can come from vector tiles loaded by an
/// ``MLNFillStyleLayer`` object, or they can be ``MLNFillStyleLayer``,
/// ``MLNFillStyleLayer``, ``MLNFillStyleLayer``, or ``MLNFillStyleLayer``
/// instances in an ``MLNFillStyleLayer`` or ``MLNFillStyleLayer`` object.
///
/// You can access an existing fill style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new fill style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/select-layer/">Select a feature
/// within a layer</a> example to learn how to use a `TERNARY` expression to modify
/// the `fillOpacity` of an ``MLNFillStyleLayer`` object. See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/fill-pattern/">Add a pattern to
/// a polygon</a> example to learn how to use an image to add pattern to the
/// features styled by a ``MLNFillStyleLayer``.
///
/// ### Example
///
/// ```swift
/// ```
class MLNFillStyleLayer extends MLNVectorStyleLayer {
  MLNFillStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNFillStyleLayer] that points to the same underlying object as [other].
  MLNFillStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNFillStyleLayer] that wraps the given raw object pointer.
  MLNFillStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNFillStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNFillStyleLayer);
  }

  /// Returns a fill style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNFillStyleLayer initWithIdentifier(objc.NSString identifier,
      {required MLNSource source}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillSortKey {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fillSortKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillSortKey(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillSortKey_, value.ref.pointer);
  }

  /// Whether or not the fill should be antialiased.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-antialias"><code>fill-antialias</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get fillAntialiased {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_isFillAntialiased);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Whether or not the fill should be antialiased.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-antialias"><code>fill-antialias</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set fillAntialiased(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillAntialiased_, value.ref.pointer);
  }

  /// fillAntialias
  NSExpression get fillAntialias {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fillAntialias);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillAntialias:
  set fillAntialias(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillAntialias_, value.ref.pointer);
  }

  /// The color of the filled part of this layer.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `fillPattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fillColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color of the filled part of this layer.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `fillPattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillColor` property.
  ///
  /// This property corresponds to the `fill-color-transition` property in the style JSON file format.
  MLNTransition get fillColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_fillColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillColor` property.
  ///
  /// This property corresponds to the `fill-color-transition` property in the style JSON file format.
  set fillColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(this.ref.pointer, _sel_setFillColorTransition_, value);
  }

  /// The opacity of the entire fill layer. In contrast to the `fillColor`, this
  /// value will also affect the 1pt stroke around the fill, if the stroke is used.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillOpacity {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fillOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity of the entire fill layer. In contrast to the `fillColor`, this
  /// value will also affect the 1pt stroke around the fill, if the stroke is used.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillOpacity` property.
  ///
  /// This property corresponds to the `fill-opacity-transition` property in the style JSON file format.
  MLNTransition get fillOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillOpacityTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_fillOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillOpacity` property.
  ///
  /// This property corresponds to the `fill-opacity-transition` property in the style JSON file format.
  set fillOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillOpacityTransition_, value);
  }

  /// The outline color of the fill. Matches the value of `fillColor` if unspecified.
  ///
  /// This property is only applied to the style if `fillPattern` is set to `nil`,
  /// and `fillAntialiased` is set to an expression that evaluates to `YES`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillOutlineColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fillOutlineColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The outline color of the fill. Matches the value of `fillColor` if unspecified.
  ///
  /// This property is only applied to the style if `fillPattern` is set to `nil`,
  /// and `fillAntialiased` is set to an expression that evaluates to `YES`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillOutlineColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillOutlineColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillOutlineColor` property.
  ///
  /// This property corresponds to the `fill-outline-color-transition` property in the style JSON file format.
  MLNTransition get fillOutlineColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillOutlineColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillOutlineColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillOutlineColor` property.
  ///
  /// This property corresponds to the `fill-outline-color-transition` property in the style JSON file format.
  set fillOutlineColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillOutlineColorTransition_, value);
  }

  /// Name of image in sprite to use for drawing image fills. For seamless patterns,
  /// image width and height must be a factor of two (2, 4, 8, ..., 512). Note that
  /// zoom-dependent expressions will be evaluated only at integer zoom levels.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get fillPattern {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fillPattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of image in sprite to use for drawing image fills. For seamless patterns,
  /// image width and height must be a factor of two (2, 4, 8, ..., 512). Note that
  /// zoom-dependent expressions will be evaluated only at integer zoom levels.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set fillPattern(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillPattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillPattern` property.
  ///
  /// This property corresponds to the `fill-pattern-transition` property in the style JSON file format.
  MLNTransition get fillPatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillPatternTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_fillPatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillPattern` property.
  ///
  /// This property corresponds to the `fill-pattern-transition` property in the style JSON file format.
  set fillPatternTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillPatternTransition_, value);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate"><code>fill-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get fillTranslation {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fillTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate"><code>fill-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set fillTranslation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `fillTranslation` property.
  ///
  /// This property corresponds to the `fill-translate-transition` property in the style JSON file format.
  MLNTransition get fillTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_fillTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_fillTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `fillTranslation` property.
  ///
  /// This property corresponds to the `fill-translate-transition` property in the style JSON file format.
  set fillTranslationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setFillTranslationTransition_, value);
  }

  /// fillTranslate
  NSExpression get fillTranslate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fillTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillTranslate:
  set fillTranslate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `fillTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate-anchor"><code>fill-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNFillTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The fill is translated relative to the map.
  /// `viewport`: The fill is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get fillTranslationAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `fillTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `fillTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate-anchor"><code>fill-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNFillTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The fill is translated relative to the map.
  /// `viewport`: The fill is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set fillTranslationAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillTranslationAnchor_, value.ref.pointer);
  }

  /// fillTranslateAnchor
  NSExpression get fillTranslateAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_fillTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFillTranslateAnchor:
  set fillTranslateAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFillTranslateAnchor_, value.ref.pointer);
  }

  /// init
  MLNFillStyleLayer init() {
    objc.checkOsVersionInternal('MLNFillStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNFillStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNFillStyleLayer, _sel_new);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNFillStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNFillStyleLayer, _sel_allocWithZone_, zone);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNFillStyleLayer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNFillStyleLayer, _sel_alloc);
    return MLNFillStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNFillStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNFillStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNFillStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNFillStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNFillStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNFillStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNFillStyleLayer constructed with the default `new` method.
  factory MLNFillStyleLayer() => new$();
}

late final _class_MLNHeatmapStyleLayer = objc.getClass("MLNHeatmapStyleLayer");
late final _sel_heatmapColor = objc.registerName("heatmapColor");
late final _sel_setHeatmapColor_ = objc.registerName("setHeatmapColor:");
late final _sel_heatmapIntensity = objc.registerName("heatmapIntensity");
late final _sel_setHeatmapIntensity_ =
    objc.registerName("setHeatmapIntensity:");
late final _sel_heatmapIntensityTransition =
    objc.registerName("heatmapIntensityTransition");
late final _sel_setHeatmapIntensityTransition_ =
    objc.registerName("setHeatmapIntensityTransition:");
late final _sel_heatmapOpacity = objc.registerName("heatmapOpacity");
late final _sel_setHeatmapOpacity_ = objc.registerName("setHeatmapOpacity:");
late final _sel_heatmapOpacityTransition =
    objc.registerName("heatmapOpacityTransition");
late final _sel_setHeatmapOpacityTransition_ =
    objc.registerName("setHeatmapOpacityTransition:");
late final _sel_heatmapRadius = objc.registerName("heatmapRadius");
late final _sel_setHeatmapRadius_ = objc.registerName("setHeatmapRadius:");
late final _sel_heatmapRadiusTransition =
    objc.registerName("heatmapRadiusTransition");
late final _sel_setHeatmapRadiusTransition_ =
    objc.registerName("setHeatmapRadiusTransition:");
late final _sel_heatmapWeight = objc.registerName("heatmapWeight");
late final _sel_setHeatmapWeight_ = objc.registerName("setHeatmapWeight:");

/// An ``MLNHeatmapStyleLayer`` is a style layer that renders a <a
/// href="https://en.wikipedia.org/wiki/Heat_map">heatmap</a>.
///
/// A heatmap visualizes the spatial distribution of a large, dense set of point
/// data, using color to avoid cluttering the map with individual points at low
/// zoom levels. The points are weighted by an attribute you specify. Use a heatmap
/// style layer in conjunction with point or point collection features. These
/// features can come from vector tiles loaded by an ``MLNHeatmapStyleLayer``
/// object, or they can be ``MLNHeatmapStyleLayer``, ``MLNHeatmapStyleLayer``,
/// ``MLNHeatmapStyleLayer``, or ``MLNHeatmapStyleLayer`` instances in an
/// ``MLNHeatmapStyleLayer`` or ``MLNHeatmapStyleLayer`` object.
///
/// Consider accompanying a heatmap style layer with an ``MLNHeatmapStyleLayer`` or
/// ``MLNHeatmapStyleLayer`` at high zoom levels. If you are unsure whether the
/// point data in an ``MLNHeatmapStyleLayer`` is dense enough to warrant a heatmap,
/// you can alternatively cluster the source using the ``MLNHeatmapStyleLayer``
/// option and render the data using an ``MLNHeatmapStyleLayer`` or
/// ``MLNHeatmapStyleLayer``.
///
/// You can access an existing heatmap style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new heatmap style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/heatmap-example/">Create a
/// heatmap layer</a> example to learn how to add this style layer to your map.
///
/// ### Example
///
/// ```swift
/// ```
class MLNHeatmapStyleLayer extends MLNVectorStyleLayer {
  MLNHeatmapStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNHeatmapStyleLayer] that points to the same underlying object as [other].
  MLNHeatmapStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNHeatmapStyleLayer] that wraps the given raw object pointer.
  MLNHeatmapStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNHeatmapStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNHeatmapStyleLayer);
  }

  /// Returns a heatmap style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNHeatmapStyleLayer initWithIdentifier(objc.NSString identifier,
      {required MLNSource source}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The color of each screen point based on its density value in a heatmap. This
  /// property is normally set to an interpolation or step expression with the
  /// `$heatmapDensity` value as its input.
  ///
  /// The default value of this property is an expression that evaluates to a rainbow
  /// color scale from blue to red. Set this property to `nil` to reset it to the
  /// default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$heatmapDensity` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get heatmapColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_heatmapColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color of each screen point based on its density value in a heatmap. This
  /// property is normally set to an interpolation or step expression with the
  /// `$heatmapDensity` value as its input.
  ///
  /// The default value of this property is an expression that evaluates to a rainbow
  /// color scale from blue to red. Set this property to `nil` to reset it to the
  /// default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$heatmapDensity` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set heatmapColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHeatmapColor_, value.ref.pointer);
  }

  /// Similar to `heatmapWeight` but controls the intensity of the heatmap globally.
  /// Primarily used for adjusting the heatmap based on zoom level.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get heatmapIntensity {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_heatmapIntensity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Similar to `heatmapWeight` but controls the intensity of the heatmap globally.
  /// Primarily used for adjusting the heatmap based on zoom level.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set heatmapIntensity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHeatmapIntensity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `heatmapIntensity` property.
  ///
  /// This property corresponds to the `heatmap-intensity-transition` property in the style JSON file format.
  MLNTransition get heatmapIntensityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_heatmapIntensityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_heatmapIntensityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `heatmapIntensity` property.
  ///
  /// This property corresponds to the `heatmap-intensity-transition` property in the style JSON file format.
  set heatmapIntensityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHeatmapIntensityTransition_, value);
  }

  /// The global opacity at which the heatmap layer will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get heatmapOpacity {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_heatmapOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The global opacity at which the heatmap layer will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set heatmapOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHeatmapOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `heatmapOpacity` property.
  ///
  /// This property corresponds to the `heatmap-opacity-transition` property in the style JSON file format.
  MLNTransition get heatmapOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_heatmapOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_heatmapOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `heatmapOpacity` property.
  ///
  /// This property corresponds to the `heatmap-opacity-transition` property in the style JSON file format.
  set heatmapOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHeatmapOpacityTransition_, value);
  }

  /// Radius of influence of one heatmap point in points. Increasing the value makes
  /// the heatmap smoother, but less detailed.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `30`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 1
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get heatmapRadius {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_heatmapRadius);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Radius of influence of one heatmap point in points. Increasing the value makes
  /// the heatmap smoother, but less detailed.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `30`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 1
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set heatmapRadius(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHeatmapRadius_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `heatmapRadius` property.
  ///
  /// This property corresponds to the `heatmap-radius-transition` property in the style JSON file format.
  MLNTransition get heatmapRadiusTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_heatmapRadiusTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_heatmapRadiusTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `heatmapRadius` property.
  ///
  /// This property corresponds to the `heatmap-radius-transition` property in the style JSON file format.
  set heatmapRadiusTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHeatmapRadiusTransition_, value);
  }

  /// A measure of how much an individual point contributes to the heatmap. A value
  /// of 10 would be equivalent to having 10 points of weight 1 in the same spot.
  /// Especially useful when combined with clustering.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get heatmapWeight {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_heatmapWeight);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// A measure of how much an individual point contributes to the heatmap. A value
  /// of 10 would be equivalent to having 10 points of weight 1 in the same spot.
  /// Especially useful when combined with clustering.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set heatmapWeight(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHeatmapWeight_, value.ref.pointer);
  }

  /// init
  MLNHeatmapStyleLayer init() {
    objc.checkOsVersionInternal('MLNHeatmapStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNHeatmapStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNHeatmapStyleLayer, _sel_new);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNHeatmapStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNHeatmapStyleLayer, _sel_allocWithZone_, zone);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNHeatmapStyleLayer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNHeatmapStyleLayer, _sel_alloc);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNHeatmapStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNHeatmapStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNHeatmapStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNHeatmapStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNHeatmapStyleLayer constructed with the default `new` method.
  factory MLNHeatmapStyleLayer() => new$();
}

late final _class_MLNHillshadeStyleLayer =
    objc.getClass("MLNHillshadeStyleLayer");
late final _sel_hillshadeAccentColor =
    objc.registerName("hillshadeAccentColor");
late final _sel_setHillshadeAccentColor_ =
    objc.registerName("setHillshadeAccentColor:");
late final _sel_hillshadeAccentColorTransition =
    objc.registerName("hillshadeAccentColorTransition");
late final _sel_setHillshadeAccentColorTransition_ =
    objc.registerName("setHillshadeAccentColorTransition:");
late final _sel_hillshadeExaggeration =
    objc.registerName("hillshadeExaggeration");
late final _sel_setHillshadeExaggeration_ =
    objc.registerName("setHillshadeExaggeration:");
late final _sel_hillshadeExaggerationTransition =
    objc.registerName("hillshadeExaggerationTransition");
late final _sel_setHillshadeExaggerationTransition_ =
    objc.registerName("setHillshadeExaggerationTransition:");
late final _sel_hillshadeHighlightColor =
    objc.registerName("hillshadeHighlightColor");
late final _sel_setHillshadeHighlightColor_ =
    objc.registerName("setHillshadeHighlightColor:");
late final _sel_hillshadeHighlightColorTransition =
    objc.registerName("hillshadeHighlightColorTransition");
late final _sel_setHillshadeHighlightColorTransition_ =
    objc.registerName("setHillshadeHighlightColorTransition:");
late final _sel_hillshadeIlluminationAnchor =
    objc.registerName("hillshadeIlluminationAnchor");
late final _sel_setHillshadeIlluminationAnchor_ =
    objc.registerName("setHillshadeIlluminationAnchor:");
late final _sel_hillshadeIlluminationDirection =
    objc.registerName("hillshadeIlluminationDirection");
late final _sel_setHillshadeIlluminationDirection_ =
    objc.registerName("setHillshadeIlluminationDirection:");
late final _sel_hillshadeShadowColor =
    objc.registerName("hillshadeShadowColor");
late final _sel_setHillshadeShadowColor_ =
    objc.registerName("setHillshadeShadowColor:");
late final _sel_hillshadeShadowColorTransition =
    objc.registerName("hillshadeShadowColorTransition");
late final _sel_setHillshadeShadowColorTransition_ =
    objc.registerName("setHillshadeShadowColorTransition:");

/// An ``MLNHillshadeStyleLayer`` is a style layer that renders raster <a
/// href="https://en.wikipedia.org/wiki/Digital_elevation_model">digital elevation
/// model</a> (DEM) tiles on the map.
///
/// Use a hillshade style layer to configure the color parameters of raster tiles
/// loaded by an ``MLNHillshadeStyleLayer`` object. For example, you could use a
/// hillshade style layer to render <a
/// href="https://docs.mapbox.com/help/troubleshooting/access-elevation-data/#mapbox-terrain-rgb">Mapbox
/// Terrain-RGB</a> data.
///
/// To display posterized hillshading based on vector shapes, as with the <a
/// href="https://www.mapbox.com/vector-tiles/mapbox-terrain/">Mapbox Terrain</a>
/// source, use an ``MLNHillshadeStyleLayer`` object in conjunction with several
/// ``MLNHillshadeStyleLayer`` objects.
///
/// You can access an existing hillshade style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new hillshade style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// ### Example
///
/// ```swift
/// ```
class MLNHillshadeStyleLayer extends MLNForegroundStyleLayer {
  MLNHillshadeStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNHillshadeStyleLayer] that points to the same underlying object as [other].
  MLNHillshadeStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNHillshadeStyleLayer] that wraps the given raw object pointer.
  MLNHillshadeStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNHillshadeStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNHillshadeStyleLayer);
  }

  /// Returns a hillshade style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNHillshadeStyleLayer initWithIdentifier(objc.NSString identifier,
      {required MLNSource source}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The shading color used to accentuate rugged terrain like sharp cliffs and
  /// gorges.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeAccentColor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_hillshadeAccentColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The shading color used to accentuate rugged terrain like sharp cliffs and
  /// gorges.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeAccentColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHillshadeAccentColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `hillshadeAccentColor` property.
  ///
  /// This property corresponds to the `hillshade-accent-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeAccentColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_hillshadeAccentColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_hillshadeAccentColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `hillshadeAccentColor` property.
  ///
  /// This property corresponds to the `hillshade-accent-color-transition` property in the style JSON file format.
  set hillshadeAccentColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHillshadeAccentColorTransition_, value);
  }

  /// Intensity of the hillshade
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0.5`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeExaggeration {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_hillshadeExaggeration);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Intensity of the hillshade
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0.5`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeExaggeration(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHillshadeExaggeration_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `hillshadeExaggeration` property.
  ///
  /// This property corresponds to the `hillshade-exaggeration-transition` property in the style JSON file format.
  MLNTransition get hillshadeExaggerationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_hillshadeExaggerationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_hillshadeExaggerationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `hillshadeExaggeration` property.
  ///
  /// This property corresponds to the `hillshade-exaggeration-transition` property in the style JSON file format.
  set hillshadeExaggerationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHillshadeExaggerationTransition_, value);
  }

  /// The shading color of areas that faces towards the light source.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.whiteColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeHighlightColor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_hillshadeHighlightColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The shading color of areas that faces towards the light source.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.whiteColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeHighlightColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHillshadeHighlightColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `hillshadeHighlightColor` property.
  ///
  /// This property corresponds to the `hillshade-highlight-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeHighlightColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_hillshadeHighlightColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_hillshadeHighlightColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `hillshadeHighlightColor` property.
  ///
  /// This property corresponds to the `hillshade-highlight-color-transition` property in the style JSON file format.
  set hillshadeHighlightColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHillshadeHighlightColorTransition_, value);
  }

  /// Direction of light source when map is rotated.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `viewport`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNHillshadeIlluminationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The hillshade illumination is relative to the north direction.
  /// `viewport`: The hillshade illumination is relative to the top of the
  /// viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get hillshadeIlluminationAnchor {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_hillshadeIlluminationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Direction of light source when map is rotated.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `viewport`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNHillshadeIlluminationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The hillshade illumination is relative to the north direction.
  /// `viewport`: The hillshade illumination is relative to the top of the
  /// viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set hillshadeIlluminationAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHillshadeIlluminationAnchor_,
        value.ref.pointer);
  }

  /// The direction of the light source used to generate the hillshading with 0 as
  /// the top of the viewport if `hillshadeIlluminationAnchor` is set to
  /// `MLNHillshadeIlluminationAnchorViewport` and due north if
  /// `hillshadeIlluminationAnchor` is set to `MLNHillshadeIlluminationAnchorMap`.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `335`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 359 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeIlluminationDirection {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_hillshadeIlluminationDirection);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The direction of the light source used to generate the hillshading with 0 as
  /// the top of the viewport if `hillshadeIlluminationAnchor` is set to
  /// `MLNHillshadeIlluminationAnchorViewport` and due north if
  /// `hillshadeIlluminationAnchor` is set to `MLNHillshadeIlluminationAnchorMap`.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `335`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 359 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeIlluminationDirection(NSExpression value) {
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_setHillshadeIlluminationDirection_, value.ref.pointer);
  }

  /// The shading color of areas that face away from the light source.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get hillshadeShadowColor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_hillshadeShadowColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The shading color of areas that face away from the light source.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set hillshadeShadowColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHillshadeShadowColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `hillshadeShadowColor` property.
  ///
  /// This property corresponds to the `hillshade-shadow-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeShadowColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_hillshadeShadowColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_hillshadeShadowColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `hillshadeShadowColor` property.
  ///
  /// This property corresponds to the `hillshade-shadow-color-transition` property in the style JSON file format.
  set hillshadeShadowColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setHillshadeShadowColorTransition_, value);
  }

  /// init
  MLNHillshadeStyleLayer init() {
    objc.checkOsVersionInternal('MLNHillshadeStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNHillshadeStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNHillshadeStyleLayer, _sel_new);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNHillshadeStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNHillshadeStyleLayer, _sel_allocWithZone_, zone);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNHillshadeStyleLayer alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNHillshadeStyleLayer, _sel_alloc);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNHillshadeStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNHillshadeStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNHillshadeStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNHillshadeStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNHillshadeStyleLayer constructed with the default `new` method.
  factory MLNHillshadeStyleLayer() => new$();
}

late final _class_MLNLineStyleLayer = objc.getClass("MLNLineStyleLayer");
late final _sel_lineCap = objc.registerName("lineCap");
late final _sel_setLineCap_ = objc.registerName("setLineCap:");
late final _sel_lineJoin = objc.registerName("lineJoin");
late final _sel_setLineJoin_ = objc.registerName("setLineJoin:");
late final _sel_lineMiterLimit = objc.registerName("lineMiterLimit");
late final _sel_setLineMiterLimit_ = objc.registerName("setLineMiterLimit:");
late final _sel_lineRoundLimit = objc.registerName("lineRoundLimit");
late final _sel_setLineRoundLimit_ = objc.registerName("setLineRoundLimit:");
late final _sel_lineSortKey = objc.registerName("lineSortKey");
late final _sel_setLineSortKey_ = objc.registerName("setLineSortKey:");
late final _sel_lineBlur = objc.registerName("lineBlur");
late final _sel_setLineBlur_ = objc.registerName("setLineBlur:");
late final _sel_lineBlurTransition = objc.registerName("lineBlurTransition");
late final _sel_setLineBlurTransition_ =
    objc.registerName("setLineBlurTransition:");
late final _sel_lineColor = objc.registerName("lineColor");
late final _sel_setLineColor_ = objc.registerName("setLineColor:");
late final _sel_lineColorTransition = objc.registerName("lineColorTransition");
late final _sel_setLineColorTransition_ =
    objc.registerName("setLineColorTransition:");
late final _sel_lineDashPattern = objc.registerName("lineDashPattern");
late final _sel_setLineDashPattern_ = objc.registerName("setLineDashPattern:");
late final _sel_lineDashPatternTransition =
    objc.registerName("lineDashPatternTransition");
late final _sel_setLineDashPatternTransition_ =
    objc.registerName("setLineDashPatternTransition:");
late final _sel_lineDasharray = objc.registerName("lineDasharray");
late final _sel_setLineDasharray_ = objc.registerName("setLineDasharray:");
late final _sel_lineGapWidth = objc.registerName("lineGapWidth");
late final _sel_setLineGapWidth_ = objc.registerName("setLineGapWidth:");
late final _sel_lineGapWidthTransition =
    objc.registerName("lineGapWidthTransition");
late final _sel_setLineGapWidthTransition_ =
    objc.registerName("setLineGapWidthTransition:");
late final _sel_lineGradient = objc.registerName("lineGradient");
late final _sel_setLineGradient_ = objc.registerName("setLineGradient:");
late final _sel_lineOffset = objc.registerName("lineOffset");
late final _sel_setLineOffset_ = objc.registerName("setLineOffset:");
late final _sel_lineOffsetTransition =
    objc.registerName("lineOffsetTransition");
late final _sel_setLineOffsetTransition_ =
    objc.registerName("setLineOffsetTransition:");
late final _sel_lineOpacity = objc.registerName("lineOpacity");
late final _sel_setLineOpacity_ = objc.registerName("setLineOpacity:");
late final _sel_lineOpacityTransition =
    objc.registerName("lineOpacityTransition");
late final _sel_setLineOpacityTransition_ =
    objc.registerName("setLineOpacityTransition:");
late final _sel_linePattern = objc.registerName("linePattern");
late final _sel_setLinePattern_ = objc.registerName("setLinePattern:");
late final _sel_linePatternTransition =
    objc.registerName("linePatternTransition");
late final _sel_setLinePatternTransition_ =
    objc.registerName("setLinePatternTransition:");
late final _sel_lineTranslation = objc.registerName("lineTranslation");
late final _sel_setLineTranslation_ = objc.registerName("setLineTranslation:");
late final _sel_lineTranslationTransition =
    objc.registerName("lineTranslationTransition");
late final _sel_setLineTranslationTransition_ =
    objc.registerName("setLineTranslationTransition:");
late final _sel_lineTranslate = objc.registerName("lineTranslate");
late final _sel_setLineTranslate_ = objc.registerName("setLineTranslate:");
late final _sel_lineTranslationAnchor =
    objc.registerName("lineTranslationAnchor");
late final _sel_setLineTranslationAnchor_ =
    objc.registerName("setLineTranslationAnchor:");
late final _sel_lineTranslateAnchor = objc.registerName("lineTranslateAnchor");
late final _sel_setLineTranslateAnchor_ =
    objc.registerName("setLineTranslateAnchor:");
late final _sel_lineWidth = objc.registerName("lineWidth");
late final _sel_setLineWidth_ = objc.registerName("setLineWidth:");
late final _sel_lineWidthTransition = objc.registerName("lineWidthTransition");
late final _sel_setLineWidthTransition_ =
    objc.registerName("setLineWidthTransition:");

/// An ``MLNLineStyleLayer`` is a style layer that renders one or more stroked
/// polylines on the map.
///
/// Use a line style layer to configure the visual appearance of polyline or
/// multipolyline features. These features can come from vector tiles loaded by an
/// ``MLNLineStyleLayer`` object, or they can be ``MLNLineStyleLayer``,
/// ``MLNLineStyleLayer``, ``MLNLineStyleLayer``, or ``MLNLineStyleLayer``
/// instances in an ``MLNLineStyleLayer`` or ``MLNLineStyleLayer`` object.
///
/// You can access an existing line style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new line style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/shape-collection/">Add multiple
/// shapes from a single shape source</a> example to learn how to add a line to
/// your map using this style layer. See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/runtime-add-line/">Add a line
/// style layer from GeoJSON</a> example to learn how to add and style line data to
/// an ``MLNMapView`` object at runtime.
///
/// ### Example
///
/// ```swift
/// ```
class MLNLineStyleLayer extends MLNVectorStyleLayer {
  MLNLineStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNLineStyleLayer] that points to the same underlying object as [other].
  MLNLineStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNLineStyleLayer] that wraps the given raw object pointer.
  MLNLineStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNLineStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNLineStyleLayer);
  }

  /// Returns a line style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNLineStyleLayer initWithIdentifier(objc.NSString identifier,
      {required MLNSource source}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The display of line endings.
  ///
  /// The default value of this property is an expression that evaluates to `butt`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineCap` values
  /// Any of the following constant string values:
  /// `butt`: A cap with a squared-off end which is drawn to the exact endpoint
  /// of the line.
  /// `round`: A cap with a rounded end which is drawn beyond the endpoint of the
  /// line at a radius of one-half of the line's width and centered on the endpoint
  /// of the line.
  /// `square`: A cap with a squared-off end which is drawn beyond the endpoint
  /// of the line at a distance of one-half of the line's width.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get lineCap {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineCap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The display of line endings.
  ///
  /// The default value of this property is an expression that evaluates to `butt`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineCap` values
  /// Any of the following constant string values:
  /// `butt`: A cap with a squared-off end which is drawn to the exact endpoint
  /// of the line.
  /// `round`: A cap with a rounded end which is drawn beyond the endpoint of the
  /// line at a radius of one-half of the line's width and centered on the endpoint
  /// of the line.
  /// `square`: A cap with a squared-off end which is drawn beyond the endpoint
  /// of the line at a distance of one-half of the line's width.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set lineCap(NSExpression value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLineCap_, value.ref.pointer);
  }

  /// The display of lines when joining.
  ///
  /// The default value of this property is an expression that evaluates to `miter`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineJoin` values
  /// Any of the following constant string values:
  /// `bevel`: A join with a squared-off end which is drawn beyond the endpoint
  /// of the line at a distance of one-half of the line's width.
  /// `round`: A join with a rounded end which is drawn beyond the endpoint of
  /// the line at a radius of one-half of the line's width and centered on the
  /// endpoint of the line.
  /// `miter`: A join with a sharp, angled corner which is drawn with the outer
  /// sides beyond the endpoint of the path until they meet.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineJoin {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineJoin);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The display of lines when joining.
  ///
  /// The default value of this property is an expression that evaluates to `miter`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineJoin` values
  /// Any of the following constant string values:
  /// `bevel`: A join with a squared-off end which is drawn beyond the endpoint
  /// of the line at a distance of one-half of the line's width.
  /// `round`: A join with a rounded end which is drawn beyond the endpoint of
  /// the line at a radius of one-half of the line's width and centered on the
  /// endpoint of the line.
  /// `miter`: A join with a sharp, angled corner which is drawn with the outer
  /// sides beyond the endpoint of the path until they meet.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineJoin(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineJoin_, value.ref.pointer);
  }

  /// Used to automatically convert miter joins to bevel joins for sharp angles.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineJoin` is set to an
  /// expression that evaluates to `miter`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get lineMiterLimit {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineMiterLimit);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Used to automatically convert miter joins to bevel joins for sharp angles.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineJoin` is set to an
  /// expression that evaluates to `miter`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set lineMiterLimit(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineMiterLimit_, value.ref.pointer);
  }

  /// Used to automatically convert round joins to miter joins for shallow angles.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1.05`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineJoin` is set to an
  /// expression that evaluates to `round`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get lineRoundLimit {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineRoundLimit);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Used to automatically convert round joins to miter joins for shallow angles.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1.05`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineJoin` is set to an
  /// expression that evaluates to `round`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set lineRoundLimit(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineRoundLimit_, value.ref.pointer);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineSortKey {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineSortKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with a higher
  /// sort key will appear above features with a lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineSortKey(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineSortKey_, value.ref.pointer);
  }

  /// Blur applied to the line, in points.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineBlur {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineBlur);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Blur applied to the line, in points.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineBlur(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineBlur_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineBlur` property.
  ///
  /// This property corresponds to the `line-blur-transition` property in the style JSON file format.
  MLNTransition get lineBlurTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineBlurTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineBlurTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineBlur` property.
  ///
  /// This property corresponds to the `line-blur-transition` property in the style JSON file format.
  set lineBlurTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(this.ref.pointer, _sel_setLineBlurTransition_, value);
  }

  /// The color with which the line will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `linePattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color with which the line will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `linePattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineColor` property.
  ///
  /// This property corresponds to the `line-color-transition` property in the style JSON file format.
  MLNTransition get lineColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineColor` property.
  ///
  /// This property corresponds to the `line-color-transition` property in the style JSON file format.
  set lineColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(this.ref.pointer, _sel_setLineColorTransition_, value);
  }

  /// Specifies the lengths of the alternating dashes and gaps that form the dash
  /// pattern. The lengths are later scaled by the line width. To convert a dash
  /// length to points, multiply the length by the current line width. Note that
  /// GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to
  /// the expected scale. Also note that zoom-dependent expressions will be evaluated
  /// only at integer zoom levels.
  ///
  /// This property is measured in line widths.
  ///
  /// This property is only applied to the style if `linePattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-dasharray"><code>line-dasharray</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant array values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get lineDashPattern {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineDashPattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Specifies the lengths of the alternating dashes and gaps that form the dash
  /// pattern. The lengths are later scaled by the line width. To convert a dash
  /// length to points, multiply the length by the current line width. Note that
  /// GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to
  /// the expected scale. Also note that zoom-dependent expressions will be evaluated
  /// only at integer zoom levels.
  ///
  /// This property is measured in line widths.
  ///
  /// This property is only applied to the style if `linePattern` is set to `nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-dasharray"><code>line-dasharray</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant array values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set lineDashPattern(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineDashPattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineDashPattern` property.
  ///
  /// This property corresponds to the `line-dasharray-transition` property in the style JSON file format.
  MLNTransition get lineDashPatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineDashPatternTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_lineDashPatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineDashPattern` property.
  ///
  /// This property corresponds to the `line-dasharray-transition` property in the style JSON file format.
  set lineDashPatternTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineDashPatternTransition_, value);
  }

  /// lineDasharray
  NSExpression get lineDasharray {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineDasharray);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLineDasharray:
  set lineDasharray(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineDasharray_, value.ref.pointer);
  }

  /// Draws a line casing outside of a line's actual path. Value indicates the width
  /// of the inner gap.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineGapWidth {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineGapWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Draws a line casing outside of a line's actual path. Value indicates the width
  /// of the inner gap.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineGapWidth(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineGapWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineGapWidth` property.
  ///
  /// This property corresponds to the `line-gap-width-transition` property in the style JSON file format.
  MLNTransition get lineGapWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineGapWidthTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_lineGapWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineGapWidth` property.
  ///
  /// This property corresponds to the `line-gap-width-transition` property in the style JSON file format.
  set lineGapWidthTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineGapWidthTransition_, value);
  }

  /// The color gradient with which the line will be drawn. This property only has an
  /// effect on lines defined by an ``MLNShapeSource`` whose ``MLNShapeSource``
  /// option is set to `YES`.
  ///
  /// This property is only applied to the style if `lineDasharray` is set to `nil`,
  /// and `linePattern` is set to `nil`, and the data source requirements are met.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$lineProgress` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get lineGradient {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineGradient);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color gradient with which the line will be drawn. This property only has an
  /// effect on lines defined by an ``MLNShapeSource`` whose ``MLNShapeSource``
  /// option is set to `YES`.
  ///
  /// This property is only applied to the style if `lineDasharray` is set to `nil`,
  /// and `linePattern` is set to `nil`, and the data source requirements are met.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$lineProgress` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set lineGradient(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineGradient_, value.ref.pointer);
  }

  /// The line's offset. For linear features, a positive value offsets the line to
  /// the right, relative to the direction of the line, and a negative value to the
  /// left. For polygon features, a positive value results in an inset, and a
  /// negative value results in an outset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineOffset {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The line's offset. For linear features, a positive value offsets the line to
  /// the right, relative to the direction of the line, and a negative value to the
  /// left. For polygon features, a positive value results in an inset, and a
  /// negative value results in an outset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineOffset(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineOffset_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineOffset` property.
  ///
  /// This property corresponds to the `line-offset-transition` property in the style JSON file format.
  MLNTransition get lineOffsetTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineOffsetTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineOffsetTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineOffset` property.
  ///
  /// This property corresponds to the `line-offset-transition` property in the style JSON file format.
  set lineOffsetTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineOffsetTransition_, value);
  }

  /// The opacity at which the line will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineOpacity {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the line will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineOpacity` property.
  ///
  /// This property corresponds to the `line-opacity-transition` property in the style JSON file format.
  MLNTransition get lineOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineOpacityTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineOpacity` property.
  ///
  /// This property corresponds to the `line-opacity-transition` property in the style JSON file format.
  set lineOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineOpacityTransition_, value);
  }

  /// Name of image in style images to use for drawing image lines. For seamless
  /// patterns, image width must be a factor of two (2, 4, 8, ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get linePattern {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_linePattern);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of image in style images to use for drawing image lines. For seamless
  /// patterns, image width must be a factor of two (2, 4, 8, ..., 512).
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set linePattern(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLinePattern_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `linePattern` property.
  ///
  /// This property corresponds to the `line-pattern-transition` property in the style JSON file format.
  MLNTransition get linePatternTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_linePatternTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_linePatternTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `linePattern` property.
  ///
  /// This property corresponds to the `line-pattern-transition` property in the style JSON file format.
  set linePatternTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLinePatternTransition_, value);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate"><code>line-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get lineTranslation {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The geometry's offset.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate"><code>line-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set lineTranslation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineTranslation` property.
  ///
  /// This property corresponds to the `line-translate-transition` property in the style JSON file format.
  MLNTransition get lineTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_lineTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineTranslation` property.
  ///
  /// This property corresponds to the `line-translate-transition` property in the style JSON file format.
  set lineTranslationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setLineTranslationTransition_, value);
  }

  /// lineTranslate
  NSExpression get lineTranslate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLineTranslate:
  set lineTranslate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `lineTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate-anchor"><code>line-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The line is translated relative to the map.
  /// `viewport`: The line is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get lineTranslationAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_lineTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `lineTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `lineTranslation` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate-anchor"><code>line-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNLineTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The line is translated relative to the map.
  /// `viewport`: The line is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set lineTranslationAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineTranslationAnchor_, value.ref.pointer);
  }

  /// lineTranslateAnchor
  NSExpression get lineTranslateAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_lineTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLineTranslateAnchor:
  set lineTranslateAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineTranslateAnchor_, value.ref.pointer);
  }

  /// Stroke thickness.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get lineWidth {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lineWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Stroke thickness.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set lineWidth(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setLineWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `lineWidth` property.
  ///
  /// This property corresponds to the `line-width-transition` property in the style JSON file format.
  MLNTransition get lineWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_lineWidthTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_lineWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `lineWidth` property.
  ///
  /// This property corresponds to the `line-width-transition` property in the style JSON file format.
  set lineWidthTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(this.ref.pointer, _sel_setLineWidthTransition_, value);
  }

  /// init
  MLNLineStyleLayer init() {
    objc.checkOsVersionInternal('MLNLineStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNLineStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNLineStyleLayer, _sel_new);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNLineStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNLineStyleLayer, _sel_allocWithZone_, zone);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNLineStyleLayer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNLineStyleLayer, _sel_alloc);
    return MLNLineStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNLineStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNLineStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNLineStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNLineStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNLineStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNLineStyleLayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNLineStyleLayer constructed with the default `new` method.
  factory MLNLineStyleLayer() => new$();
}

late final _class_MLNRasterStyleLayer = objc.getClass("MLNRasterStyleLayer");
late final _sel_maximumRasterBrightness =
    objc.registerName("maximumRasterBrightness");
late final _sel_setMaximumRasterBrightness_ =
    objc.registerName("setMaximumRasterBrightness:");
late final _sel_maximumRasterBrightnessTransition =
    objc.registerName("maximumRasterBrightnessTransition");
late final _sel_setMaximumRasterBrightnessTransition_ =
    objc.registerName("setMaximumRasterBrightnessTransition:");
late final _sel_rasterBrightnessMax = objc.registerName("rasterBrightnessMax");
late final _sel_setRasterBrightnessMax_ =
    objc.registerName("setRasterBrightnessMax:");
late final _sel_minimumRasterBrightness =
    objc.registerName("minimumRasterBrightness");
late final _sel_setMinimumRasterBrightness_ =
    objc.registerName("setMinimumRasterBrightness:");
late final _sel_minimumRasterBrightnessTransition =
    objc.registerName("minimumRasterBrightnessTransition");
late final _sel_setMinimumRasterBrightnessTransition_ =
    objc.registerName("setMinimumRasterBrightnessTransition:");
late final _sel_rasterBrightnessMin = objc.registerName("rasterBrightnessMin");
late final _sel_setRasterBrightnessMin_ =
    objc.registerName("setRasterBrightnessMin:");
late final _sel_rasterContrast = objc.registerName("rasterContrast");
late final _sel_setRasterContrast_ = objc.registerName("setRasterContrast:");
late final _sel_rasterContrastTransition =
    objc.registerName("rasterContrastTransition");
late final _sel_setRasterContrastTransition_ =
    objc.registerName("setRasterContrastTransition:");
late final _sel_rasterFadeDuration = objc.registerName("rasterFadeDuration");
late final _sel_setRasterFadeDuration_ =
    objc.registerName("setRasterFadeDuration:");
late final _sel_rasterHueRotation = objc.registerName("rasterHueRotation");
late final _sel_setRasterHueRotation_ =
    objc.registerName("setRasterHueRotation:");
late final _sel_rasterHueRotationTransition =
    objc.registerName("rasterHueRotationTransition");
late final _sel_setRasterHueRotationTransition_ =
    objc.registerName("setRasterHueRotationTransition:");
late final _sel_rasterHueRotate = objc.registerName("rasterHueRotate");
late final _sel_setRasterHueRotate_ = objc.registerName("setRasterHueRotate:");
late final _sel_rasterOpacity = objc.registerName("rasterOpacity");
late final _sel_setRasterOpacity_ = objc.registerName("setRasterOpacity:");
late final _sel_rasterOpacityTransition =
    objc.registerName("rasterOpacityTransition");
late final _sel_setRasterOpacityTransition_ =
    objc.registerName("setRasterOpacityTransition:");
late final _sel_rasterResamplingMode =
    objc.registerName("rasterResamplingMode");
late final _sel_setRasterResamplingMode_ =
    objc.registerName("setRasterResamplingMode:");
late final _sel_rasterResampling = objc.registerName("rasterResampling");
late final _sel_setRasterResampling_ =
    objc.registerName("setRasterResampling:");
late final _sel_rasterSaturation = objc.registerName("rasterSaturation");
late final _sel_setRasterSaturation_ =
    objc.registerName("setRasterSaturation:");
late final _sel_rasterSaturationTransition =
    objc.registerName("rasterSaturationTransition");
late final _sel_setRasterSaturationTransition_ =
    objc.registerName("setRasterSaturationTransition:");

/// An ``MLNRasterStyleLayer`` is a style layer that renders georeferenced raster
/// imagery on the map, especially raster tiles.
///
/// Use a raster style layer to configure the color parameters of raster tiles
/// loaded by an ``MLNRasterStyleLayer`` object or raster images loaded by an
/// ``MLNRasterStyleLayer`` object. For example, you could use a raster style layer
/// to render <a href="https://www.mapbox.com/satellite/">Mapbox Satellite</a>
/// imagery, a <a
/// href="https://docs.mapbox.com/help/glossary/tileset/#raster-tilesets">raster
/// tile set</a> uploaded to Mapbox Studio, or a raster map authored in <a
/// href="https://tilemill-project.github.io/tilemill/">TileMill</a>, the classic
/// Mapbox Editor, or Mapbox Studio Classic.
///
/// Raster images may also be used as icons or patterns in a style layer. To
/// register an image for use as an icon or pattern, use the
/// ``MLNStyle/setImage:forName:`` method. To configure a point annotation’s image,
/// use the ``MLNRasterStyleLayer`` class.
///
/// You can access an existing raster style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new raster style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a href="https://docs.mapbox.com/ios/maps/examples/image-source/">Add
/// an image</a> and <a
/// href="https://docs.mapbox.com/ios/maps/examples/source-custom-raster/">Add
/// raster imagery</a> examples to learn how to add imagery with this style layer.
///
/// ### Example
///
/// ```swift
/// ```
class MLNRasterStyleLayer extends MLNForegroundStyleLayer {
  MLNRasterStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNRasterStyleLayer] that points to the same underlying object as [other].
  MLNRasterStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNRasterStyleLayer] that wraps the given raw object pointer.
  MLNRasterStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNRasterStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterStyleLayer);
  }

  /// Returns a raster style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNRasterStyleLayer initWithIdentifier(objc.NSString identifier,
      {required MLNSource source}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Increase or reduce the brightness of the image. The value is the maximum
  /// brightness.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-max"><code>raster-brightness-max</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get maximumRasterBrightness {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_maximumRasterBrightness);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Increase or reduce the brightness of the image. The value is the maximum
  /// brightness.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-max"><code>raster-brightness-max</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set maximumRasterBrightness(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setMaximumRasterBrightness_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `maximumRasterBrightness` property.
  ///
  /// This property corresponds to the `raster-brightness-max-transition` property in the style JSON file format.
  MLNTransition get maximumRasterBrightnessTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_maximumRasterBrightnessTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_maximumRasterBrightnessTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `maximumRasterBrightness` property.
  ///
  /// This property corresponds to the `raster-brightness-max-transition` property in the style JSON file format.
  set maximumRasterBrightnessTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setMaximumRasterBrightnessTransition_, value);
  }

  /// rasterBrightnessMax
  NSExpression get rasterBrightnessMax {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterBrightnessMax);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRasterBrightnessMax:
  set rasterBrightnessMax(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterBrightnessMax_, value.ref.pointer);
  }

  /// Increase or reduce the brightness of the image. The value is the minimum
  /// brightness.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-min"><code>raster-brightness-min</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get minimumRasterBrightness {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_minimumRasterBrightness);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Increase or reduce the brightness of the image. The value is the minimum
  /// brightness.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-min"><code>raster-brightness-min</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set minimumRasterBrightness(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setMinimumRasterBrightness_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `minimumRasterBrightness` property.
  ///
  /// This property corresponds to the `raster-brightness-min-transition` property in the style JSON file format.
  MLNTransition get minimumRasterBrightnessTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_minimumRasterBrightnessTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_minimumRasterBrightnessTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `minimumRasterBrightness` property.
  ///
  /// This property corresponds to the `raster-brightness-min-transition` property in the style JSON file format.
  set minimumRasterBrightnessTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setMinimumRasterBrightnessTransition_, value);
  }

  /// rasterBrightnessMin
  NSExpression get rasterBrightnessMin {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterBrightnessMin);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRasterBrightnessMin:
  set rasterBrightnessMin(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterBrightnessMin_, value.ref.pointer);
  }

  /// Increase or reduce the contrast of the image.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between −1 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterContrast {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterContrast);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Increase or reduce the contrast of the image.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between −1 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterContrast(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterContrast_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `rasterContrast` property.
  ///
  /// This property corresponds to the `raster-contrast-transition` property in the style JSON file format.
  MLNTransition get rasterContrastTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_rasterContrastTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_rasterContrastTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `rasterContrast` property.
  ///
  /// This property corresponds to the `raster-contrast-transition` property in the style JSON file format.
  set rasterContrastTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setRasterContrastTransition_, value);
  }

  /// Fade duration when a new tile is added, or when a video is started or its
  /// coordinates are updated.
  ///
  /// This property is measured in milliseconds.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `300`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterFadeDuration {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterFadeDuration);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Fade duration when a new tile is added, or when a video is started or its
  /// coordinates are updated.
  ///
  /// This property is measured in milliseconds.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `300`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterFadeDuration(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterFadeDuration_, value.ref.pointer);
  }

  /// Rotates hues around the color wheel.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-hue-rotate"><code>raster-hue-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterHueRotation {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterHueRotation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Rotates hues around the color wheel.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-hue-rotate"><code>raster-hue-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterHueRotation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterHueRotation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `rasterHueRotation` property.
  ///
  /// This property corresponds to the `raster-hue-rotate-transition` property in the style JSON file format.
  MLNTransition get rasterHueRotationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_rasterHueRotationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_rasterHueRotationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `rasterHueRotation` property.
  ///
  /// This property corresponds to the `raster-hue-rotate-transition` property in the style JSON file format.
  set rasterHueRotationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setRasterHueRotationTransition_, value);
  }

  /// rasterHueRotate
  NSExpression get rasterHueRotate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterHueRotate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRasterHueRotate:
  set rasterHueRotate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterHueRotate_, value.ref.pointer);
  }

  /// The opacity at which the image will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterOpacity {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the image will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `rasterOpacity` property.
  ///
  /// This property corresponds to the `raster-opacity-transition` property in the style JSON file format.
  MLNTransition get rasterOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_rasterOpacityTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_rasterOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `rasterOpacity` property.
  ///
  /// This property corresponds to the `raster-opacity-transition` property in the style JSON file format.
  set rasterOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setRasterOpacityTransition_, value);
  }

  /// The resampling/interpolation method to use for overscaling, also known as
  /// texture magnification filter
  ///
  /// The default value of this property is an expression that evaluates to `linear`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-resampling"><code>raster-resampling</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNRasterResamplingMode` values
  /// Any of the following constant string values:
  /// `linear`: (Bi)linear filtering interpolates pixel values using the weighted
  /// average of the four closest original source pixels creating a smooth but blurry
  /// look when overscaled
  /// `nearest`: Nearest neighbor filtering interpolates pixel values using the
  /// nearest original source pixel creating a sharp but pixelated look when
  /// overscaled
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get rasterResamplingMode {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterResamplingMode);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The resampling/interpolation method to use for overscaling, also known as
  /// texture magnification filter
  ///
  /// The default value of this property is an expression that evaluates to `linear`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-raster-resampling"><code>raster-resampling</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNRasterResamplingMode` values
  /// Any of the following constant string values:
  /// `linear`: (Bi)linear filtering interpolates pixel values using the weighted
  /// average of the four closest original source pixels creating a smooth but blurry
  /// look when overscaled
  /// `nearest`: Nearest neighbor filtering interpolates pixel values using the
  /// nearest original source pixel creating a sharp but pixelated look when
  /// overscaled
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set rasterResamplingMode(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterResamplingMode_, value.ref.pointer);
  }

  /// rasterResampling
  NSExpression get rasterResampling {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterResampling);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRasterResampling:
  set rasterResampling(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterResampling_, value.ref.pointer);
  }

  /// Increase or reduce the saturation of the image.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between −1 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get rasterSaturation {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rasterSaturation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Increase or reduce the saturation of the image.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between −1 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set rasterSaturation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRasterSaturation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `rasterSaturation` property.
  ///
  /// This property corresponds to the `raster-saturation-transition` property in the style JSON file format.
  MLNTransition get rasterSaturationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_rasterSaturationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_rasterSaturationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `rasterSaturation` property.
  ///
  /// This property corresponds to the `raster-saturation-transition` property in the style JSON file format.
  set rasterSaturationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setRasterSaturationTransition_, value);
  }

  /// init
  MLNRasterStyleLayer init() {
    objc.checkOsVersionInternal('MLNRasterStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNRasterStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNRasterStyleLayer, _sel_new);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNRasterStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNRasterStyleLayer, _sel_allocWithZone_, zone);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNRasterStyleLayer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNRasterStyleLayer, _sel_alloc);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNRasterStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNRasterStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNRasterStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNRasterStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNRasterStyleLayer constructed with the default `new` method.
  factory MLNRasterStyleLayer() => new$();
}

late final _class_MLNSymbolStyleLayer = objc.getClass("MLNSymbolStyleLayer");
late final _sel_iconAllowsOverlap = objc.registerName("iconAllowsOverlap");
late final _sel_setIconAllowsOverlap_ =
    objc.registerName("setIconAllowsOverlap:");
late final _sel_iconAllowOverlap = objc.registerName("iconAllowOverlap");
late final _sel_setIconAllowOverlap_ =
    objc.registerName("setIconAllowOverlap:");
late final _sel_iconAnchor = objc.registerName("iconAnchor");
late final _sel_setIconAnchor_ = objc.registerName("setIconAnchor:");
late final _sel_iconIgnoresPlacement =
    objc.registerName("iconIgnoresPlacement");
late final _sel_setIconIgnoresPlacement_ =
    objc.registerName("setIconIgnoresPlacement:");
late final _sel_iconIgnorePlacement = objc.registerName("iconIgnorePlacement");
late final _sel_setIconIgnorePlacement_ =
    objc.registerName("setIconIgnorePlacement:");
late final _sel_iconImageName = objc.registerName("iconImageName");
late final _sel_setIconImageName_ = objc.registerName("setIconImageName:");
late final _sel_iconImage = objc.registerName("iconImage");
late final _sel_setIconImage_ = objc.registerName("setIconImage:");
late final _sel_iconOffset = objc.registerName("iconOffset");
late final _sel_setIconOffset_ = objc.registerName("setIconOffset:");
late final _sel_isIconOptional = objc.registerName("isIconOptional");
late final _sel_setIconOptional_ = objc.registerName("setIconOptional:");
late final _sel_iconPadding = objc.registerName("iconPadding");
late final _sel_setIconPadding_ = objc.registerName("setIconPadding:");
late final _sel_iconPitchAlignment = objc.registerName("iconPitchAlignment");
late final _sel_setIconPitchAlignment_ =
    objc.registerName("setIconPitchAlignment:");
late final _sel_iconRotation = objc.registerName("iconRotation");
late final _sel_setIconRotation_ = objc.registerName("setIconRotation:");
late final _sel_iconRotate = objc.registerName("iconRotate");
late final _sel_setIconRotate_ = objc.registerName("setIconRotate:");
late final _sel_iconRotationAlignment =
    objc.registerName("iconRotationAlignment");
late final _sel_setIconRotationAlignment_ =
    objc.registerName("setIconRotationAlignment:");
late final _sel_iconScale = objc.registerName("iconScale");
late final _sel_setIconScale_ = objc.registerName("setIconScale:");
late final _sel_iconSize = objc.registerName("iconSize");
late final _sel_setIconSize_ = objc.registerName("setIconSize:");
late final _sel_iconTextFit = objc.registerName("iconTextFit");
late final _sel_setIconTextFit_ = objc.registerName("setIconTextFit:");
late final _sel_iconTextFitPadding = objc.registerName("iconTextFitPadding");
late final _sel_setIconTextFitPadding_ =
    objc.registerName("setIconTextFitPadding:");
late final _sel_keepsIconUpright = objc.registerName("keepsIconUpright");
late final _sel_setKeepsIconUpright_ =
    objc.registerName("setKeepsIconUpright:");
late final _sel_iconKeepUpright = objc.registerName("iconKeepUpright");
late final _sel_setIconKeepUpright_ = objc.registerName("setIconKeepUpright:");
late final _sel_keepsTextUpright = objc.registerName("keepsTextUpright");
late final _sel_setKeepsTextUpright_ =
    objc.registerName("setKeepsTextUpright:");
late final _sel_textKeepUpright = objc.registerName("textKeepUpright");
late final _sel_setTextKeepUpright_ = objc.registerName("setTextKeepUpright:");
late final _sel_maximumTextAngle = objc.registerName("maximumTextAngle");
late final _sel_setMaximumTextAngle_ =
    objc.registerName("setMaximumTextAngle:");
late final _sel_textMaxAngle = objc.registerName("textMaxAngle");
late final _sel_setTextMaxAngle_ = objc.registerName("setTextMaxAngle:");
late final _sel_maximumTextWidth = objc.registerName("maximumTextWidth");
late final _sel_setMaximumTextWidth_ =
    objc.registerName("setMaximumTextWidth:");
late final _sel_textMaxWidth = objc.registerName("textMaxWidth");
late final _sel_setTextMaxWidth_ = objc.registerName("setTextMaxWidth:");
late final _sel_symbolAvoidsEdges = objc.registerName("symbolAvoidsEdges");
late final _sel_setSymbolAvoidsEdges_ =
    objc.registerName("setSymbolAvoidsEdges:");
late final _sel_symbolAvoidEdges = objc.registerName("symbolAvoidEdges");
late final _sel_setSymbolAvoidEdges_ =
    objc.registerName("setSymbolAvoidEdges:");
late final _sel_symbolPlacement = objc.registerName("symbolPlacement");
late final _sel_setSymbolPlacement_ = objc.registerName("setSymbolPlacement:");
late final _sel_symbolScreenSpace = objc.registerName("symbolScreenSpace");
late final _sel_setSymbolScreenSpace_ =
    objc.registerName("setSymbolScreenSpace:");
late final _sel_symbolSortKey = objc.registerName("symbolSortKey");
late final _sel_setSymbolSortKey_ = objc.registerName("setSymbolSortKey:");
late final _sel_symbolSpacing = objc.registerName("symbolSpacing");
late final _sel_setSymbolSpacing_ = objc.registerName("setSymbolSpacing:");
late final _sel_symbolZOrder = objc.registerName("symbolZOrder");
late final _sel_setSymbolZOrder_ = objc.registerName("setSymbolZOrder:");
late final _sel_textField = objc.registerName("textField");
late final _sel_setTextField_ = objc.registerName("setTextField:");
late final _sel_textAllowsOverlap = objc.registerName("textAllowsOverlap");
late final _sel_setTextAllowsOverlap_ =
    objc.registerName("setTextAllowsOverlap:");
late final _sel_textAllowOverlap = objc.registerName("textAllowOverlap");
late final _sel_setTextAllowOverlap_ =
    objc.registerName("setTextAllowOverlap:");
late final _sel_textAnchor = objc.registerName("textAnchor");
late final _sel_setTextAnchor_ = objc.registerName("setTextAnchor:");
late final _sel_textFontNames = objc.registerName("textFontNames");
late final _sel_setTextFontNames_ = objc.registerName("setTextFontNames:");
late final _sel_textFont = objc.registerName("textFont");
late final _sel_setTextFont_ = objc.registerName("setTextFont:");
late final _sel_textFontSize = objc.registerName("textFontSize");
late final _sel_setTextFontSize_ = objc.registerName("setTextFontSize:");
late final _sel_textSize = objc.registerName("textSize");
late final _sel_setTextSize_ = objc.registerName("setTextSize:");
late final _sel_textIgnoresPlacement =
    objc.registerName("textIgnoresPlacement");
late final _sel_setTextIgnoresPlacement_ =
    objc.registerName("setTextIgnoresPlacement:");
late final _sel_textIgnorePlacement = objc.registerName("textIgnorePlacement");
late final _sel_setTextIgnorePlacement_ =
    objc.registerName("setTextIgnorePlacement:");
late final _sel_textJustification = objc.registerName("textJustification");
late final _sel_setTextJustification_ =
    objc.registerName("setTextJustification:");
late final _sel_textJustify = objc.registerName("textJustify");
late final _sel_setTextJustify_ = objc.registerName("setTextJustify:");
late final _sel_textLetterSpacing = objc.registerName("textLetterSpacing");
late final _sel_setTextLetterSpacing_ =
    objc.registerName("setTextLetterSpacing:");
late final _sel_textLineHeight = objc.registerName("textLineHeight");
late final _sel_setTextLineHeight_ = objc.registerName("setTextLineHeight:");
late final _sel_textOffset = objc.registerName("textOffset");
late final _sel_setTextOffset_ = objc.registerName("setTextOffset:");
late final _sel_isTextOptional = objc.registerName("isTextOptional");
late final _sel_setTextOptional_ = objc.registerName("setTextOptional:");
late final _sel_textPadding = objc.registerName("textPadding");
late final _sel_setTextPadding_ = objc.registerName("setTextPadding:");
late final _sel_textPitchAlignment = objc.registerName("textPitchAlignment");
late final _sel_setTextPitchAlignment_ =
    objc.registerName("setTextPitchAlignment:");
late final _sel_textRadialOffset = objc.registerName("textRadialOffset");
late final _sel_setTextRadialOffset_ =
    objc.registerName("setTextRadialOffset:");
late final _sel_textRotation = objc.registerName("textRotation");
late final _sel_setTextRotation_ = objc.registerName("setTextRotation:");
late final _sel_textRotate = objc.registerName("textRotate");
late final _sel_setTextRotate_ = objc.registerName("setTextRotate:");
late final _sel_textRotationAlignment =
    objc.registerName("textRotationAlignment");
late final _sel_setTextRotationAlignment_ =
    objc.registerName("setTextRotationAlignment:");
late final _sel_textTransform = objc.registerName("textTransform");
late final _sel_setTextTransform_ = objc.registerName("setTextTransform:");
late final _sel_textVariableAnchor = objc.registerName("textVariableAnchor");
late final _sel_setTextVariableAnchor_ =
    objc.registerName("setTextVariableAnchor:");
late final _sel_textVariableAnchorOffset =
    objc.registerName("textVariableAnchorOffset");
late final _sel_setTextVariableAnchorOffset_ =
    objc.registerName("setTextVariableAnchorOffset:");
late final _sel_textWritingModes = objc.registerName("textWritingModes");
late final _sel_setTextWritingModes_ =
    objc.registerName("setTextWritingModes:");
late final _sel_textWritingMode = objc.registerName("textWritingMode");
late final _sel_setTextWritingMode_ = objc.registerName("setTextWritingMode:");
late final _sel_iconColor = objc.registerName("iconColor");
late final _sel_setIconColor_ = objc.registerName("setIconColor:");
late final _sel_iconColorTransition = objc.registerName("iconColorTransition");
late final _sel_setIconColorTransition_ =
    objc.registerName("setIconColorTransition:");
late final _sel_iconHaloBlur = objc.registerName("iconHaloBlur");
late final _sel_setIconHaloBlur_ = objc.registerName("setIconHaloBlur:");
late final _sel_iconHaloBlurTransition =
    objc.registerName("iconHaloBlurTransition");
late final _sel_setIconHaloBlurTransition_ =
    objc.registerName("setIconHaloBlurTransition:");
late final _sel_iconHaloColor = objc.registerName("iconHaloColor");
late final _sel_setIconHaloColor_ = objc.registerName("setIconHaloColor:");
late final _sel_iconHaloColorTransition =
    objc.registerName("iconHaloColorTransition");
late final _sel_setIconHaloColorTransition_ =
    objc.registerName("setIconHaloColorTransition:");
late final _sel_iconHaloWidth = objc.registerName("iconHaloWidth");
late final _sel_setIconHaloWidth_ = objc.registerName("setIconHaloWidth:");
late final _sel_iconHaloWidthTransition =
    objc.registerName("iconHaloWidthTransition");
late final _sel_setIconHaloWidthTransition_ =
    objc.registerName("setIconHaloWidthTransition:");
late final _sel_iconOpacity = objc.registerName("iconOpacity");
late final _sel_setIconOpacity_ = objc.registerName("setIconOpacity:");
late final _sel_iconOpacityTransition =
    objc.registerName("iconOpacityTransition");
late final _sel_setIconOpacityTransition_ =
    objc.registerName("setIconOpacityTransition:");
late final _sel_iconTranslation = objc.registerName("iconTranslation");
late final _sel_setIconTranslation_ = objc.registerName("setIconTranslation:");
late final _sel_iconTranslationTransition =
    objc.registerName("iconTranslationTransition");
late final _sel_setIconTranslationTransition_ =
    objc.registerName("setIconTranslationTransition:");
late final _sel_iconTranslate = objc.registerName("iconTranslate");
late final _sel_setIconTranslate_ = objc.registerName("setIconTranslate:");
late final _sel_iconTranslationAnchor =
    objc.registerName("iconTranslationAnchor");
late final _sel_setIconTranslationAnchor_ =
    objc.registerName("setIconTranslationAnchor:");
late final _sel_iconTranslateAnchor = objc.registerName("iconTranslateAnchor");
late final _sel_setIconTranslateAnchor_ =
    objc.registerName("setIconTranslateAnchor:");
late final _sel_textColorTransition = objc.registerName("textColorTransition");
late final _sel_setTextColorTransition_ =
    objc.registerName("setTextColorTransition:");
late final _sel_textHaloBlur = objc.registerName("textHaloBlur");
late final _sel_setTextHaloBlur_ = objc.registerName("setTextHaloBlur:");
late final _sel_textHaloBlurTransition =
    objc.registerName("textHaloBlurTransition");
late final _sel_setTextHaloBlurTransition_ =
    objc.registerName("setTextHaloBlurTransition:");
late final _sel_textHaloColor = objc.registerName("textHaloColor");
late final _sel_setTextHaloColor_ = objc.registerName("setTextHaloColor:");
late final _sel_textHaloColorTransition =
    objc.registerName("textHaloColorTransition");
late final _sel_setTextHaloColorTransition_ =
    objc.registerName("setTextHaloColorTransition:");
late final _sel_textHaloWidth = objc.registerName("textHaloWidth");
late final _sel_setTextHaloWidth_ = objc.registerName("setTextHaloWidth:");
late final _sel_textHaloWidthTransition =
    objc.registerName("textHaloWidthTransition");
late final _sel_setTextHaloWidthTransition_ =
    objc.registerName("setTextHaloWidthTransition:");
late final _sel_textOpacity = objc.registerName("textOpacity");
late final _sel_setTextOpacity_ = objc.registerName("setTextOpacity:");
late final _sel_textOpacityTransition =
    objc.registerName("textOpacityTransition");
late final _sel_setTextOpacityTransition_ =
    objc.registerName("setTextOpacityTransition:");
late final _sel_textTranslation = objc.registerName("textTranslation");
late final _sel_setTextTranslation_ = objc.registerName("setTextTranslation:");
late final _sel_textTranslationTransition =
    objc.registerName("textTranslationTransition");
late final _sel_setTextTranslationTransition_ =
    objc.registerName("setTextTranslationTransition:");
late final _sel_textTranslate = objc.registerName("textTranslate");
late final _sel_setTextTranslate_ = objc.registerName("setTextTranslate:");
late final _sel_textTranslationAnchor =
    objc.registerName("textTranslationAnchor");
late final _sel_setTextTranslationAnchor_ =
    objc.registerName("setTextTranslationAnchor:");
late final _sel_textTranslateAnchor = objc.registerName("textTranslateAnchor");
late final _sel_setTextTranslateAnchor_ =
    objc.registerName("setTextTranslateAnchor:");

/// An ``MLNSymbolStyleLayer`` is a style layer that renders icon and text labels
/// at points or along lines on the map.
///
/// Use a symbol style layer to configure the visual appearance of feature labels.
/// These features can come from vector tiles loaded by an ``MLNSymbolStyleLayer``
/// object, or they can be ``MLNSymbolStyleLayer`` or ``MLNSymbolStyleLayer``
/// instances in an ``MLNSymbolStyleLayer`` or ``MLNSymbolStyleLayer`` object.
///
/// You can access an existing symbol style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new symbol style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
///
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/runtime-multiple-annotations/">Dynamically
/// style interactive points</a> and <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
/// images to cluster point data</a> examples learn how to style data on your map
/// using this layer.
///
/// ### Example
///
/// ```swift
/// ```
class MLNSymbolStyleLayer extends MLNVectorStyleLayer {
  MLNSymbolStyleLayer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNSymbolStyleLayer] that points to the same underlying object as [other].
  MLNSymbolStyleLayer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNSymbolStyleLayer] that wraps the given raw object pointer.
  MLNSymbolStyleLayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNSymbolStyleLayer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNSymbolStyleLayer);
  }

  /// Returns a symbol style layer initialized with an identifier and source.
  ///
  /// After initializing and configuring the style layer, add it to a map view’s
  /// style using the ``MLNStyle/addLayer:`` or
  /// ``MLNStyle/insertLayer:belowLayer:`` method.
  ///
  /// @param identifier A string that uniquely identifies the source in the style to
  /// which it is added.
  /// @param source The source from which to obtain the data to style. If the source
  /// has not yet been added to the current style, the behavior is undefined.
  /// @return An initialized foreground style layer.
  MLNSymbolStyleLayer initWithIdentifier(objc.NSString identifier,
      {required MLNSource source}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIdentifier_source_,
        identifier.ref.pointer,
        source.ref.pointer);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// If true, the icon will be visible even if it collides with other previously
  /// drawn symbols.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconOverlap` is set to `nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-allow-overlap"><code>icon-allow-overlap</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconAllowsOverlap {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_iconAllowsOverlap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, the icon will be visible even if it collides with other previously
  /// drawn symbols.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconOverlap` is set to `nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-allow-overlap"><code>icon-allow-overlap</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconAllowsOverlap(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconAllowsOverlap_, value.ref.pointer);
  }

  /// iconAllowOverlap
  NSExpression get iconAllowOverlap {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconAllowOverlap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconAllowOverlap:
  set iconAllowOverlap(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconAllowOverlap_, value.ref.pointer);
  }

  /// Part of the icon placed closest to the anchor.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconAnchor` values
  /// Any of the following constant string values:
  /// `center`: The center of the icon is placed closest to the anchor.
  /// `left`: The left side of the icon is placed closest to the anchor.
  /// `right`: The right side of the icon is placed closest to the anchor.
  /// `top`: The top of the icon is placed closest to the anchor.
  /// `bottom`: The bottom of the icon is placed closest to the anchor.
  /// `top-left`: The top left corner of the icon is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the icon is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the icon is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the icon is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconAnchor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Part of the icon placed closest to the anchor.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconAnchor` values
  /// Any of the following constant string values:
  /// `center`: The center of the icon is placed closest to the anchor.
  /// `left`: The left side of the icon is placed closest to the anchor.
  /// `right`: The right side of the icon is placed closest to the anchor.
  /// `top`: The top of the icon is placed closest to the anchor.
  /// `bottom`: The bottom of the icon is placed closest to the anchor.
  /// `top-left`: The top left corner of the icon is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the icon is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the icon is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the icon is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconAnchor_, value.ref.pointer);
  }

  /// If true, other symbols can be visible even if they collide with the icon.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-ignore-placement"><code>icon-ignore-placement</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconIgnoresPlacement {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_iconIgnoresPlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, other symbols can be visible even if they collide with the icon.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-ignore-placement"><code>icon-ignore-placement</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconIgnoresPlacement(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconIgnoresPlacement_, value.ref.pointer);
  }

  /// iconIgnorePlacement
  NSExpression get iconIgnorePlacement {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_iconIgnorePlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconIgnorePlacement:
  set iconIgnorePlacement(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconIgnorePlacement_, value.ref.pointer);
  }

  /// Name of a style image to use for drawing an image background.
  ///
  /// Use the ``MLNStyle/setImage:forName:`` method to associate an image with a name
  /// that you can set this property to.
  ///
  /// Within a constant string value, a feature attribute name enclosed in curly
  /// braces (e.g., `{token}`) is replaced with the value of the named attribute.
  /// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
  /// and key path expressions.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-image"><code>icon-image</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  ///
  /// #### Related examples
  /// See the <a
  /// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
  /// images to cluster point data</a> example to learn how to dynamically set your
  /// icons with an expression.
  NSExpression get iconImageName {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconImageName);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of a style image to use for drawing an image background.
  ///
  /// Use the ``MLNStyle/setImage:forName:`` method to associate an image with a name
  /// that you can set this property to.
  ///
  /// Within a constant string value, a feature attribute name enclosed in curly
  /// braces (e.g., `{token}`) is replaced with the value of the named attribute.
  /// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
  /// and key path expressions.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-image"><code>icon-image</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  ///
  /// #### Related examples
  /// See the <a
  /// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
  /// images to cluster point data</a> example to learn how to dynamically set your
  /// icons with an expression.
  set iconImageName(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconImageName_, value.ref.pointer);
  }

  /// iconImage
  NSExpression get iconImage {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconImage);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconImage:
  set iconImage(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconImage_, value.ref.pointer);
  }

  /// Offset distance of icon from its anchor.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 rightward and 0
  /// downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconOffset {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Offset distance of icon from its anchor.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 rightward and 0
  /// downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconOffset(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconOffset_, value.ref.pointer);
  }

  /// If true, text will display without their corresponding icons when the icon
  /// collides with other symbols and the text does not.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconOptional {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_isIconOptional);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, text will display without their corresponding icons when the icon
  /// collides with other symbols and the text does not.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconOptional(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconOptional_, value.ref.pointer);
  }

  /// Size of additional area round the icon bounding box used for detecting symbol
  /// collisions.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `UIEdgeInsets` struct set to 2 points on all
  /// sides. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIEdgeInsets` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconPadding {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconPadding);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Size of additional area round the icon bounding box used for detecting symbol
  /// collisions.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `UIEdgeInsets` struct set to 2 points on all
  /// sides. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIEdgeInsets` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconPadding(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconPadding_, value.ref.pointer);
  }

  /// Orientation of icon when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconPitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The icon is aligned to the plane of the map.
  /// `viewport`: The icon is aligned to the plane of the viewport.
  /// `auto`: Automatically matches the value of `icon-rotation-alignment`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconPitchAlignment {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_iconPitchAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Orientation of icon when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconPitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The icon is aligned to the plane of the map.
  /// `viewport`: The icon is aligned to the plane of the viewport.
  /// `auto`: Automatically matches the value of `icon-rotation-alignment`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconPitchAlignment(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconPitchAlignment_, value.ref.pointer);
  }

  /// Rotates the icon clockwise.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-rotate"><code>icon-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconRotation {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconRotation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Rotates the icon clockwise.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-rotate"><code>icon-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconRotation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconRotation_, value.ref.pointer);
  }

  /// iconRotate
  NSExpression get iconRotate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconRotate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconRotate:
  set iconRotate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconRotate_, value.ref.pointer);
  }

  /// In combination with `symbolPlacement`, determines the rotation behavior of
  /// icons.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconRotationAlignment` values
  /// Any of the following constant string values:
  /// `map`: When `symbol-placement` is set to `point`, aligns icons east-west.
  /// When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes
  /// with the line.
  /// `viewport`: Produces icons whose x-axes are aligned with the x-axis of the
  /// viewport, regardless of the value of `symbol-placement`.
  /// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
  /// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
  /// equivalent to `map`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconRotationAlignment {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_iconRotationAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// In combination with `symbolPlacement`, determines the rotation behavior of
  /// icons.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconRotationAlignment` values
  /// Any of the following constant string values:
  /// `map`: When `symbol-placement` is set to `point`, aligns icons east-west.
  /// When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes
  /// with the line.
  /// `viewport`: Produces icons whose x-axes are aligned with the x-axis of the
  /// viewport, regardless of the value of `symbol-placement`.
  /// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
  /// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
  /// equivalent to `map`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconRotationAlignment(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconRotationAlignment_, value.ref.pointer);
  }

  /// Scales the original size of the icon by the provided factor. The new point size
  /// of the image will be the original point size multiplied by `iconScale`. 1 is
  /// the original size; 3 triples the size of the image.
  ///
  /// This property is measured in factor of the original icon sizes.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-size"><code>icon-size</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconScale {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconScale);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Scales the original size of the icon by the provided factor. The new point size
  /// of the image will be the original point size multiplied by `iconScale`. 1 is
  /// the original size; 3 triples the size of the image.
  ///
  /// This property is measured in factor of the original icon sizes.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-size"><code>icon-size</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconScale(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconScale_, value.ref.pointer);
  }

  /// iconSize
  NSExpression get iconSize {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconSize);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconSize:
  set iconSize(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconSize_, value.ref.pointer);
  }

  /// The directions in which the icon stretches to fit around the text. If the icon
  /// image is a resizable image, the resizable areas may be stretched, while the cap
  /// insets are always drawn at the original scale.
  ///
  /// The default value of this property is an expression that evaluates to `none`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconTextFit` values
  /// Any of the following constant string values:
  /// `none`: The icon is displayed at its intrinsic aspect ratio.
  /// `width`: The icon is scaled in the x-dimension to fit the width of the
  /// text.
  /// `height`: The icon is scaled in the y-dimension to fit the height of the
  /// text.
  /// `both`: The icon is scaled in both x- and y-dimensions.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconTextFit {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconTextFit);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The directions in which the icon stretches to fit around the text. If the icon
  /// image is a resizable image, the resizable areas may be stretched, while the cap
  /// insets are always drawn at the original scale.
  ///
  /// The default value of this property is an expression that evaluates to `none`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconTextFit` values
  /// Any of the following constant string values:
  /// `none`: The icon is displayed at its intrinsic aspect ratio.
  /// `width`: The icon is scaled in the x-dimension to fit the width of the
  /// text.
  /// `height`: The icon is scaled in the y-dimension to fit the height of the
  /// text.
  /// `both`: The icon is scaled in both x- and y-dimensions.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconTextFit(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconTextFit_, value.ref.pointer);
  }

  /// Size of the additional area added to dimensions determined by `iconTextFit`.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing `UIEdgeInsetsZero`. Set this property to `nil` to
  /// reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`, and `iconTextFit` is set to an expression that evaluates
  /// to `MLNIconTextFitBoth`, `MLNIconTextFitWidth`, or `MLNIconTextFitHeight`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIEdgeInsets` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get iconTextFitPadding {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_iconTextFitPadding);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Size of the additional area added to dimensions determined by `iconTextFit`.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing `UIEdgeInsetsZero`. Set this property to `nil` to
  /// reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `text` is non-`nil`, and `iconTextFit` is set to an expression that evaluates
  /// to `MLNIconTextFitBoth`, `MLNIconTextFitWidth`, or `MLNIconTextFitHeight`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIEdgeInsets` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set iconTextFitPadding(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconTextFitPadding_, value.ref.pointer);
  }

  /// If true, the icon may be flipped to prevent it from being rendered upside-down.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconRotationAlignment` is set to an expression that evaluates to `map`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-keep-upright"><code>icon-keep-upright</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get keepsIconUpright {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keepsIconUpright);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, the icon may be flipped to prevent it from being rendered upside-down.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconRotationAlignment` is set to an expression that evaluates to `map`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-keep-upright"><code>icon-keep-upright</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set keepsIconUpright(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setKeepsIconUpright_, value.ref.pointer);
  }

  /// iconKeepUpright
  NSExpression get iconKeepUpright {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconKeepUpright);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconKeepUpright:
  set iconKeepUpright(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconKeepUpright_, value.ref.pointer);
  }

  /// If true, the text may be flipped vertically to prevent it from being rendered
  /// upside-down.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textRotationAlignment` is set to an expression that evaluates to `map`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-keep-upright"><code>text-keep-upright</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get keepsTextUpright {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keepsTextUpright);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, the text may be flipped vertically to prevent it from being rendered
  /// upside-down.
  ///
  /// The default value of this property is an expression that evaluates to `YES`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textRotationAlignment` is set to an expression that evaluates to `map`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-keep-upright"><code>text-keep-upright</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set keepsTextUpright(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setKeepsTextUpright_, value.ref.pointer);
  }

  /// textKeepUpright
  NSExpression get textKeepUpright {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textKeepUpright);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextKeepUpright:
  set textKeepUpright(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextKeepUpright_, value.ref.pointer);
  }

  /// Maximum angle change between adjacent characters.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `45`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-angle"><code>text-max-angle</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get maximumTextAngle {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_maximumTextAngle);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Maximum angle change between adjacent characters.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `45`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to either
  /// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
  /// ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-angle"><code>text-max-angle</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set maximumTextAngle(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setMaximumTextAngle_, value.ref.pointer);
  }

  /// textMaxAngle
  NSExpression get textMaxAngle {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textMaxAngle);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextMaxAngle:
  set textMaxAngle(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextMaxAngle_, value.ref.pointer);
  }

  /// The maximum line width for text wrapping.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `10`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-width"><code>text-max-width</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get maximumTextWidth {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_maximumTextWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The maximum line width for text wrapping.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `10`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-width"><code>text-max-width</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set maximumTextWidth(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setMaximumTextWidth_, value.ref.pointer);
  }

  /// textMaxWidth
  NSExpression get textMaxWidth {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textMaxWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextMaxWidth:
  set textMaxWidth(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextMaxWidth_, value.ref.pointer);
  }

  /// Whether symbols in this layer avoid colliding with symbols in adjacent tiles.
  ///
  /// If this property is set to `true`, symbols in this layer avoid crossing the
  /// edge of a tile. You should set this property to `true` if the backing vector
  /// tiles don’t have enough padding to prevent collisions, or if this layer’s
  /// `symbolPlacement` property is set to
  /// ``MLNSymbolPlacement/MLNSymbolPlacementPoint`` but this layer is above a symbol
  /// layer whose `symbolPlacement` property is set to
  /// ``MLNSymbolPlacement/MLNSymbolPlacementPoint``. You do not need to enable this
  /// property to prevent clipped labels at tile boundaries.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-symbol-avoid-edges"><code>symbol-avoid-edges</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get symbolAvoidsEdges {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_symbolAvoidsEdges);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Whether symbols in this layer avoid colliding with symbols in adjacent tiles.
  ///
  /// If this property is set to `true`, symbols in this layer avoid crossing the
  /// edge of a tile. You should set this property to `true` if the backing vector
  /// tiles don’t have enough padding to prevent collisions, or if this layer’s
  /// `symbolPlacement` property is set to
  /// ``MLNSymbolPlacement/MLNSymbolPlacementPoint`` but this layer is above a symbol
  /// layer whose `symbolPlacement` property is set to
  /// ``MLNSymbolPlacement/MLNSymbolPlacementPoint``. You do not need to enable this
  /// property to prevent clipped labels at tile boundaries.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-symbol-avoid-edges"><code>symbol-avoid-edges</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set symbolAvoidsEdges(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSymbolAvoidsEdges_, value.ref.pointer);
  }

  /// symbolAvoidEdges
  NSExpression get symbolAvoidEdges {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_symbolAvoidEdges);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSymbolAvoidEdges:
  set symbolAvoidEdges(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSymbolAvoidEdges_, value.ref.pointer);
  }

  /// Label placement relative to its geometry.
  ///
  /// The default value of this property is an expression that evaluates to `point`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNSymbolPlacement` values
  /// Any of the following constant string values:
  /// `point`: The label is placed at the point where the geometry is located.
  /// `line`: The label is placed along the line of the geometry. Can only be
  /// used on `LineString` and `Polygon` geometries.
  /// `line-center`: The label is placed at the center of the line of the
  /// geometry. Can only be used on `LineString` and `Polygon` geometries. Note that
  /// a single feature in a vector tile may contain multiple line geometries.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get symbolPlacement {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_symbolPlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Label placement relative to its geometry.
  ///
  /// The default value of this property is an expression that evaluates to `point`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNSymbolPlacement` values
  /// Any of the following constant string values:
  /// `point`: The label is placed at the point where the geometry is located.
  /// `line`: The label is placed along the line of the geometry. Can only be
  /// used on `LineString` and `Polygon` geometries.
  /// `line-center`: The label is placed at the center of the line of the
  /// geometry. Can only be used on `LineString` and `Polygon` geometries. Note that
  /// a single feature in a vector tile may contain multiple line geometries.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set symbolPlacement(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSymbolPlacement_, value.ref.pointer);
  }

  /// Internal use only
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get symbolScreenSpace {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_symbolScreenSpace);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Internal use only
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set symbolScreenSpace(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSymbolScreenSpace_, value.ref.pointer);
  }

  /// Sorts features in ascending order based on this value. Features with lower sort
  /// keys are drawn and placed first.  When `iconAllowsOverlap` or
  /// `textAllowsOverlap` is `false`, features with a lower sort key will have
  /// priority during placement. When `iconAllowsOverlap` or `textAllowsOverlap` is
  /// set to `YES`, features with a higher sort key will overlap over features with a
  /// lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get symbolSortKey {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_symbolSortKey);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sorts features in ascending order based on this value. Features with lower sort
  /// keys are drawn and placed first.  When `iconAllowsOverlap` or
  /// `textAllowsOverlap` is `false`, features with a lower sort key will have
  /// priority during placement. When `iconAllowsOverlap` or `textAllowsOverlap` is
  /// set to `YES`, features with a higher sort key will overlap over features with a
  /// lower sort key.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set symbolSortKey(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSymbolSortKey_, value.ref.pointer);
  }

  /// Distance between two symbol anchors.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `250`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `symbolPlacement` is set to an
  /// expression that evaluates to `line`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 1
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get symbolSpacing {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_symbolSpacing);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance between two symbol anchors.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `250`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `symbolPlacement` is set to an
  /// expression that evaluates to `line`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 1
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set symbolSpacing(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSymbolSpacing_, value.ref.pointer);
  }

  /// Determines whether overlapping symbols in the same layer are rendered in the
  /// order that they appear in the data source or by their y-position relative to
  /// the viewport. To control the order and prioritization of symbols otherwise, use
  /// `symbolSortKey`.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNSymbolZOrder` values
  /// Any of the following constant string values:
  /// `auto`: Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols
  /// by their y-position relative to the viewport if `icon-allow-overlap` or
  /// `text-allow-overlap` is set to `true` or `icon-ignore-placement` or
  /// `text-ignore-placement` is `false`.
  /// `viewport-y`: Specify this z order if symbols’ appearance relies on lower
  /// features overlapping higher features. For example, symbols with a pin-like
  /// appearance would require this z order.
  /// `source`: Specify this z order if the order in which features appear in the
  /// source is significant.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get symbolZOrder {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_symbolZOrder);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Determines whether overlapping symbols in the same layer are rendered in the
  /// order that they appear in the data source or by their y-position relative to
  /// the viewport. To control the order and prioritization of symbols otherwise, use
  /// `symbolSortKey`.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNSymbolZOrder` values
  /// Any of the following constant string values:
  /// `auto`: Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols
  /// by their y-position relative to the viewport if `icon-allow-overlap` or
  /// `text-allow-overlap` is set to `true` or `icon-ignore-placement` or
  /// `text-ignore-placement` is `false`.
  /// `viewport-y`: Specify this z order if symbols’ appearance relies on lower
  /// features overlapping higher features. For example, symbols with a pin-like
  /// appearance would require this z order.
  /// `source`: Specify this z order if the order in which features appear in the
  /// source is significant.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set symbolZOrder(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSymbolZOrder_, value.ref.pointer);
  }

  /// Value to use for a text label.
  ///
  /// Within a constant string value, a feature attribute name enclosed in curly
  /// braces (e.g., `{token}`) is replaced with the value of the named attribute.
  /// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
  /// and key path expressions.
  ///
  /// The default value of this property is an expression that evaluates to the empty
  /// string. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-field"><code>text-field</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Formatted expressions.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  ///
  /// #### Related examples
  /// See the <a href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster
  /// point data</a> and <a
  /// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
  /// images to cluster point data</a> to learn how to use an expression to set this
  /// attribute to the number of markers within a cluster.
  NSExpression get text {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_text);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Value to use for a text label.
  ///
  /// Within a constant string value, a feature attribute name enclosed in curly
  /// braces (e.g., `{token}`) is replaced with the value of the named attribute.
  /// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
  /// and key path expressions.
  ///
  /// The default value of this property is an expression that evaluates to the empty
  /// string. Set this property to `nil` to reset it to the default value.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-field"><code>text-field</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant string values
  /// Formatted expressions.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  ///
  /// #### Related examples
  /// See the <a href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster
  /// point data</a> and <a
  /// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
  /// images to cluster point data</a> to learn how to use an expression to set this
  /// attribute to the number of markers within a cluster.
  set text(NSExpression value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setText_, value.ref.pointer);
  }

  /// textField
  NSExpression get textField {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textField);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextField:
  set textField(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextField_, value.ref.pointer);
  }

  /// If true, the text will be visible even if it collides with other previously
  /// drawn symbols.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-allow-overlap"><code>text-allow-overlap</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textAllowsOverlap {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textAllowsOverlap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, the text will be visible even if it collides with other previously
  /// drawn symbols.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-allow-overlap"><code>text-allow-overlap</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textAllowsOverlap(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextAllowsOverlap_, value.ref.pointer);
  }

  /// textAllowOverlap
  NSExpression get textAllowOverlap {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textAllowOverlap);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextAllowOverlap:
  set textAllowOverlap(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextAllowOverlap_, value.ref.pointer);
  }

  /// Part of the text placed closest to the anchor.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textVariableAnchor` is set to `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextAnchor` values
  /// Any of the following constant string values:
  /// `center`: The center of the text is placed closest to the anchor.
  /// `left`: The left side of the text is placed closest to the anchor.
  /// `right`: The right side of the text is placed closest to the anchor.
  /// `top`: The top of the text is placed closest to the anchor.
  /// `bottom`: The bottom of the text is placed closest to the anchor.
  /// `top-left`: The top left corner of the text is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the text is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the text is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the text is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textAnchor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Part of the text placed closest to the anchor.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textVariableAnchor` is set to `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextAnchor` values
  /// Any of the following constant string values:
  /// `center`: The center of the text is placed closest to the anchor.
  /// `left`: The left side of the text is placed closest to the anchor.
  /// `right`: The right side of the text is placed closest to the anchor.
  /// `top`: The top of the text is placed closest to the anchor.
  /// `bottom`: The bottom of the text is placed closest to the anchor.
  /// `top-left`: The top left corner of the text is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the text is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the text is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the text is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextAnchor_, value.ref.pointer);
  }

  /// An array of font face names used to display the text.
  ///
  /// The first font named in the array is applied to the text. For each character in
  /// the text, if the first font lacks a glyph for the character, the next font is
  /// applied as a fallback, and so on.
  ///
  /// See the “[Customizing Fonts](doc:Customizing_Fonts)” guide for details on how
  /// this SDK chooses and renders fonts based on the value of this property.
  ///
  /// The default value of this property is an expression that evaluates to the array
  /// `Open Sans Regular`, `Arial Unicode MS Regular`. Set this property to `nil` to
  /// reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-font"><code>text-font</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant array values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textFontNames {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textFontNames);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// An array of font face names used to display the text.
  ///
  /// The first font named in the array is applied to the text. For each character in
  /// the text, if the first font lacks a glyph for the character, the next font is
  /// applied as a fallback, and so on.
  ///
  /// See the “[Customizing Fonts](doc:Customizing_Fonts)” guide for details on how
  /// this SDK chooses and renders fonts based on the value of this property.
  ///
  /// The default value of this property is an expression that evaluates to the array
  /// `Open Sans Regular`, `Arial Unicode MS Regular`. Set this property to `nil` to
  /// reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-font"><code>text-font</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant array values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textFontNames(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextFontNames_, value.ref.pointer);
  }

  /// textFont
  NSExpression get textFont {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textFont);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextFont:
  set textFont(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextFont_, value.ref.pointer);
  }

  /// Font size.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `16`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-size"><code>text-size</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textFontSize {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textFontSize);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Font size.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `16`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-size"><code>text-size</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textFontSize(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextFontSize_, value.ref.pointer);
  }

  /// textSize
  NSExpression get textSize {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textSize);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextSize:
  set textSize(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextSize_, value.ref.pointer);
  }

  /// If true, other symbols can be visible even if they collide with the text.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-ignore-placement"><code>text-ignore-placement</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textIgnoresPlacement {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textIgnoresPlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, other symbols can be visible even if they collide with the text.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-ignore-placement"><code>text-ignore-placement</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textIgnoresPlacement(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextIgnoresPlacement_, value.ref.pointer);
  }

  /// textIgnorePlacement
  NSExpression get textIgnorePlacement {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textIgnorePlacement);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextIgnorePlacement:
  set textIgnorePlacement(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextIgnorePlacement_, value.ref.pointer);
  }

  /// Text justification options.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-justify"><code>text-justify</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextJustification` values
  /// Any of the following constant string values:
  /// `auto`: The text is aligned towards the anchor position.
  /// `left`: The text is aligned to the left.
  /// `center`: The text is centered.
  /// `right`: The text is aligned to the right.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textJustification {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textJustification);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Text justification options.
  ///
  /// The default value of this property is an expression that evaluates to `center`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-justify"><code>text-justify</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextJustification` values
  /// Any of the following constant string values:
  /// `auto`: The text is aligned towards the anchor position.
  /// `left`: The text is aligned to the left.
  /// `center`: The text is centered.
  /// `right`: The text is aligned to the right.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textJustification(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextJustification_, value.ref.pointer);
  }

  /// textJustify
  NSExpression get textJustify {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textJustify);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextJustify:
  set textJustify(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextJustify_, value.ref.pointer);
  }

  /// Text tracking amount.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textLetterSpacing {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textLetterSpacing);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Text tracking amount.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textLetterSpacing(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextLetterSpacing_, value.ref.pointer);
  }

  /// Text leading value for multi-line text.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1.2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get textLineHeight {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textLineHeight);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Text leading value for multi-line text.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1.2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set textLineHeight(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextLineHeight_, value.ref.pointer);
  }

  /// Offset distance of text from its anchor.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 ems rightward and 0
  /// ems downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textRadialOffset` is set to `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textOffset {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Offset distance of text from its anchor.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 ems rightward and 0
  /// ems downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textRadialOffset` is set to `nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textOffset(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextOffset_, value.ref.pointer);
  }

  /// If true, icons will display without their corresponding text when the text
  /// collides with other symbols and the icon does not.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `iconImageName` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textOptional {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_isTextOptional);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// If true, icons will display without their corresponding text when the text
  /// collides with other symbols and the icon does not.
  ///
  /// The default value of this property is an expression that evaluates to `NO`. Set
  /// this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `iconImageName` is non-`nil`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant Boolean values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textOptional(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextOptional_, value.ref.pointer);
  }

  /// Size of the additional area around the text bounding box used for detecting
  /// symbol collisions.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get textPadding {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textPadding);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Size of the additional area around the text bounding box used for detecting
  /// symbol collisions.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `2`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set textPadding(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextPadding_, value.ref.pointer);
  }

  /// Orientation of text when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextPitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The text is aligned to the plane of the map.
  /// `viewport`: The text is aligned to the plane of the viewport.
  /// `auto`: Automatically matches the value of `text-rotation-alignment`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textPitchAlignment {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textPitchAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Orientation of text when map is pitched.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextPitchAlignment` values
  /// Any of the following constant string values:
  /// `map`: The text is aligned to the plane of the map.
  /// `viewport`: The text is aligned to the plane of the viewport.
  /// `auto`: Automatically matches the value of `text-rotation-alignment`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textPitchAlignment(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextPitchAlignment_, value.ref.pointer);
  }

  /// Radial offset of text, in the direction of the symbol's anchor. Useful in
  /// combination with `textVariableAnchor`, which defaults to using the
  /// two-dimensional `textOffset` if present.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textRadialOffset {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textRadialOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Radial offset of text, in the direction of the symbol's anchor. Useful in
  /// combination with `textVariableAnchor`, which defaults to using the
  /// two-dimensional `textOffset` if present.
  ///
  /// This property is measured in ems.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textRadialOffset(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextRadialOffset_, value.ref.pointer);
  }

  /// Rotates the text clockwise.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-rotate"><code>text-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textRotation {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textRotation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Rotates the text clockwise.
  ///
  /// This property is measured in degrees.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-rotate"><code>text-rotate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textRotation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextRotation_, value.ref.pointer);
  }

  /// textRotate
  NSExpression get textRotate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textRotate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextRotate:
  set textRotate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextRotate_, value.ref.pointer);
  }

  /// In combination with `symbolPlacement`, determines the rotation behavior of the
  /// individual glyphs forming the text.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextRotationAlignment` values
  /// Any of the following constant string values:
  /// `map`: When `symbol-placement` is set to `point`, aligns text east-west.
  /// When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes
  /// with the line.
  /// `viewport`: Produces glyphs whose x-axes are aligned with the x-axis of the
  /// viewport, regardless of the value of `symbol-placement`.
  /// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
  /// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
  /// equivalent to `map`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textRotationAlignment {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textRotationAlignment);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// In combination with `symbolPlacement`, determines the rotation behavior of the
  /// individual glyphs forming the text.
  ///
  /// The default value of this property is an expression that evaluates to `auto`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextRotationAlignment` values
  /// Any of the following constant string values:
  /// `map`: When `symbol-placement` is set to `point`, aligns text east-west.
  /// When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes
  /// with the line.
  /// `viewport`: Produces glyphs whose x-axes are aligned with the x-axis of the
  /// viewport, regardless of the value of `symbol-placement`.
  /// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
  /// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
  /// equivalent to `map`.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textRotationAlignment(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextRotationAlignment_, value.ref.pointer);
  }

  /// Specifies how to capitalize text.
  ///
  /// The default value of this property is an expression that evaluates to `none`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextTransform` values
  /// Any of the following constant string values:
  /// `none`: The text is not altered.
  /// `uppercase`: Forces all letters to be displayed in uppercase.
  /// `lowercase`: Forces all letters to be displayed in lowercase.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textTransform {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textTransform);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Specifies how to capitalize text.
  ///
  /// The default value of this property is an expression that evaluates to `none`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextTransform` values
  /// Any of the following constant string values:
  /// `none`: The text is not altered.
  /// `uppercase`: Forces all letters to be displayed in uppercase.
  /// `lowercase`: Forces all letters to be displayed in lowercase.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textTransform(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextTransform_, value.ref.pointer);
  }

  /// To increase the chance of placing high-priority labels on the map, you can
  /// provide an array of `textAnchor` locations: the renderer will attempt to place
  /// the label at each location, in order, before moving onto the next label. Use
  /// `textJustify: auto` to choose justification based on anchor position. To apply
  /// an offset, use the `textRadialOffset` or the two-dimensional `textOffset`.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant ``MLNTextAnchor`` array values
  /// Constant array, in which each element is any of the following constant string
  /// values:
  /// `center`: The center of the text is placed closest to the anchor.
  /// `left`: The left side of the text is placed closest to the anchor.
  /// `right`: The right side of the text is placed closest to the anchor.
  /// `top`: The top of the text is placed closest to the anchor.
  /// `bottom`: The bottom of the text is placed closest to the anchor.
  /// `top-left`: The top left corner of the text is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the text is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the text is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the text is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textVariableAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textVariableAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// To increase the chance of placing high-priority labels on the map, you can
  /// provide an array of `textAnchor` locations: the renderer will attempt to place
  /// the label at each location, in order, before moving onto the next label. Use
  /// `textJustify: auto` to choose justification based on anchor position. To apply
  /// an offset, use the `textRadialOffset` or the two-dimensional `textOffset`.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant ``MLNTextAnchor`` array values
  /// Constant array, in which each element is any of the following constant string
  /// values:
  /// `center`: The center of the text is placed closest to the anchor.
  /// `left`: The left side of the text is placed closest to the anchor.
  /// `right`: The right side of the text is placed closest to the anchor.
  /// `top`: The top of the text is placed closest to the anchor.
  /// `bottom`: The bottom of the text is placed closest to the anchor.
  /// `top-left`: The top left corner of the text is placed closest to the
  /// anchor.
  /// `top-right`: The top right corner of the text is placed closest to the
  /// anchor.
  /// `bottom-left`: The bottom left corner of the text is placed closest to the
  /// anchor.
  /// `bottom-right`: The bottom right corner of the text is placed closest to
  /// the anchor.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textVariableAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextVariableAnchor_, value.ref.pointer);
  }

  /// To increase the chance of placing high-priority labels on the map, you can
  /// provide an array of `textAnchor` locations, each paired with an offset value.
  /// The renderer will attempt to place the label at each location, in order, before
  /// moving on to the next location+offset. Use `textJustify: auto` to choose
  /// justification based on anchor position.
  ///
  /// The length of the array must be even, and must alternate between enum and
  /// point entries. i.e., each anchor location must be accompanied by a point, and
  /// that point defines the offset when the corresponding anchor location is used.
  /// Positive offset values indicate right and down, while negative values indicate
  /// left and up. Anchor locations may repeat, allowing the renderer to try multiple
  /// offsets to try and place a label using the same anchor.
  ///
  /// When present, this property takes precedence over `textAnchor`,
  /// `textVariableAnchor`, `textOffset`, and `textRadialOffset`.
  ///
  /// ```json
  /// { "text-variable-anchor-offset": ["top", [0, 4], "left", [3,0], "bottom", [1,
  /// 1]] }
  /// ```
  ///
  /// When the renderer chooses the `top` anchor, `[0, 4]` will be used for
  /// `textOffset`; the text will be shifted down by 4 ems.
  ///
  /// When the renderer chooses the `left` anchor, `[3, 0]` will be used for
  /// `textOffset`; the text will be shifted right by 3 ems.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant interleaved `MLNTextAnchor` and `CGVector` array values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textVariableAnchorOffset {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textVariableAnchorOffset);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// To increase the chance of placing high-priority labels on the map, you can
  /// provide an array of `textAnchor` locations, each paired with an offset value.
  /// The renderer will attempt to place the label at each location, in order, before
  /// moving on to the next location+offset. Use `textJustify: auto` to choose
  /// justification based on anchor position.
  ///
  /// The length of the array must be even, and must alternate between enum and
  /// point entries. i.e., each anchor location must be accompanied by a point, and
  /// that point defines the offset when the corresponding anchor location is used.
  /// Positive offset values indicate right and down, while negative values indicate
  /// left and up. Anchor locations may repeat, allowing the renderer to try multiple
  /// offsets to try and place a label using the same anchor.
  ///
  /// When present, this property takes precedence over `textAnchor`,
  /// `textVariableAnchor`, `textOffset`, and `textRadialOffset`.
  ///
  /// ```json
  /// { "text-variable-anchor-offset": ["top", [0, 4], "left", [3,0], "bottom", [1,
  /// 1]] }
  /// ```
  ///
  /// When the renderer chooses the `top` anchor, `[0, 4]` will be used for
  /// `textOffset`; the text will be shifted down by 4 ems.
  ///
  /// When the renderer chooses the `left` anchor, `[3, 0]` will be used for
  /// `textOffset`; the text will be shifted right by 3 ems.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant interleaved `MLNTextAnchor` and `CGVector` array values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textVariableAnchorOffset(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextVariableAnchorOffset_, value.ref.pointer);
  }

  /// The property allows control over a symbol's orientation. Note that the property
  /// values act as a hint, so that a symbol whose language doesn’t support the
  /// provided orientation will be laid out in its natural orientation. Example:
  /// English point symbol will be rendered horizontally even if array value contains
  /// single 'vertical' enum value. The order of elements in an array define priority
  /// order for the placement of an orientation variant.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-writing-mode"><code>text-writing-mode</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant ``MLNTextWritingMode`` array values
  /// Constant array, in which each element is any of the following constant string
  /// values:
  /// `horizontal`: If a text's language supports horizontal writing mode,
  /// symbols with point placement would be laid out horizontally.
  /// `vertical`: If a text's language supports vertical writing mode, symbols
  /// with point placement would be laid out vertically.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textWritingModes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textWritingModes);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The property allows control over a symbol's orientation. Note that the property
  /// values act as a hint, so that a symbol whose language doesn’t support the
  /// provided orientation will be laid out in its natural orientation. Example:
  /// English point symbol will be rendered horizontally even if array value contains
  /// single 'vertical' enum value. The order of elements in an array define priority
  /// order for the placement of an orientation variant.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `symbolPlacement` is set to an expression that evaluates to or
  /// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-writing-mode"><code>text-writing-mode</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant ``MLNTextWritingMode`` array values
  /// Constant array, in which each element is any of the following constant string
  /// values:
  /// `horizontal`: If a text's language supports horizontal writing mode,
  /// symbols with point placement would be laid out horizontally.
  /// `vertical`: If a text's language supports vertical writing mode, symbols
  /// with point placement would be laid out vertically.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textWritingModes(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextWritingModes_, value.ref.pointer);
  }

  /// textWritingMode
  NSExpression get textWritingMode {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textWritingMode);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextWritingMode:
  set textWritingMode(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextWritingMode_, value.ref.pointer);
  }

  /// The tint color to apply to the icon. The `iconImageName` property must be set
  /// to a template image.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The tint color to apply to the icon. The `iconImageName` property must be set
  /// to a template image.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconColor` property.
  ///
  /// This property corresponds to the `icon-color-transition` property in the style JSON file format.
  MLNTransition get iconColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_iconColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconColor` property.
  ///
  /// This property corresponds to the `icon-color-transition` property in the style JSON file format.
  set iconColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(this.ref.pointer, _sel_setIconColorTransition_, value);
  }

  /// Fade out the halo towards the outside.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconHaloBlur {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconHaloBlur);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Fade out the halo towards the outside.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconHaloBlur(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconHaloBlur_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconHaloBlur` property.
  ///
  /// This property corresponds to the `icon-halo-blur-transition` property in the style JSON file format.
  MLNTransition get iconHaloBlurTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconHaloBlurTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_iconHaloBlurTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconHaloBlur` property.
  ///
  /// This property corresponds to the `icon-halo-blur-transition` property in the style JSON file format.
  set iconHaloBlurTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconHaloBlurTransition_, value);
  }

  /// The color of the icon’s halo. The `iconImageName` property must be set to a
  /// template image.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.clearColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconHaloColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconHaloColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color of the icon’s halo. The `iconImageName` property must be set to a
  /// template image.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.clearColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconHaloColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconHaloColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconHaloColor` property.
  ///
  /// This property corresponds to the `icon-halo-color-transition` property in the style JSON file format.
  MLNTransition get iconHaloColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconHaloColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_iconHaloColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconHaloColor` property.
  ///
  /// This property corresponds to the `icon-halo-color-transition` property in the style JSON file format.
  set iconHaloColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconHaloColorTransition_, value);
  }

  /// Distance of halo to the icon outline.
  /// The unit is in points only for SDF sprites that were created with a blur radius
  /// of 8, multiplied by the display density. I.e., the radius needs to be 16 for
  /// `@2x` sprites, etc.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconHaloWidth {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconHaloWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance of halo to the icon outline.
  /// The unit is in points only for SDF sprites that were created with a blur radius
  /// of 8, multiplied by the display density. I.e., the radius needs to be 16 for
  /// `@2x` sprites, etc.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconHaloWidth(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconHaloWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconHaloWidth` property.
  ///
  /// This property corresponds to the `icon-halo-width-transition` property in the style JSON file format.
  MLNTransition get iconHaloWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconHaloWidthTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_iconHaloWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconHaloWidth` property.
  ///
  /// This property corresponds to the `icon-halo-width-transition` property in the style JSON file format.
  set iconHaloWidthTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconHaloWidthTransition_, value);
  }

  /// The opacity at which the icon will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get iconOpacity {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the icon will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set iconOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconOpacity` property.
  ///
  /// This property corresponds to the `icon-opacity-transition` property in the style JSON file format.
  MLNTransition get iconOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconOpacityTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_iconOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconOpacity` property.
  ///
  /// This property corresponds to the `icon-opacity-transition` property in the style JSON file format.
  set iconOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconOpacityTransition_, value);
  }

  /// Distance that the icon's anchor is moved from its original placement.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate"><code>icon-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get iconTranslation {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance that the icon's anchor is moved from its original placement.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`.
  /// Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate"><code>icon-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set iconTranslation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `iconTranslation` property.
  ///
  /// This property corresponds to the `icon-translate-transition` property in the style JSON file format.
  MLNTransition get iconTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_iconTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_iconTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `iconTranslation` property.
  ///
  /// This property corresponds to the `icon-translate-transition` property in the style JSON file format.
  set iconTranslationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setIconTranslationTransition_, value);
  }

  /// iconTranslate
  NSExpression get iconTranslate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_iconTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconTranslate:
  set iconTranslate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `iconTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconTranslation` is non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate-anchor"><code>icon-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: Icons are translated relative to the map.
  /// `viewport`: Icons are translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get iconTranslationAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_iconTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `iconTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `iconImageName` is non-`nil`, and
  /// `iconTranslation` is non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate-anchor"><code>icon-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNIconTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: Icons are translated relative to the map.
  /// `viewport`: Icons are translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set iconTranslationAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconTranslationAnchor_, value.ref.pointer);
  }

  /// iconTranslateAnchor
  NSExpression get iconTranslateAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_iconTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setIconTranslateAnchor:
  set iconTranslateAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setIconTranslateAnchor_, value.ref.pointer);
  }

  /// The color with which the text will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color with which the text will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textColor` property.
  ///
  /// This property corresponds to the `text-color-transition` property in the style JSON file format.
  MLNTransition get textColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textColorTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_textColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textColor` property.
  ///
  /// This property corresponds to the `text-color-transition` property in the style JSON file format.
  set textColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(this.ref.pointer, _sel_setTextColorTransition_, value);
  }

  /// The halo's fadeout distance towards the outside.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textHaloBlur {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textHaloBlur);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The halo's fadeout distance towards the outside.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textHaloBlur(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextHaloBlur_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textHaloBlur` property.
  ///
  /// This property corresponds to the `text-halo-blur-transition` property in the style JSON file format.
  MLNTransition get textHaloBlurTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textHaloBlurTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_textHaloBlurTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textHaloBlur` property.
  ///
  /// This property corresponds to the `text-halo-blur-transition` property in the style JSON file format.
  set textHaloBlurTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextHaloBlurTransition_, value);
  }

  /// The color of the text's halo, which helps it stand out from backgrounds.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.clearColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textHaloColor {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textHaloColor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The color of the text's halo, which helps it stand out from backgrounds.
  ///
  /// The default value of this property is an expression that evaluates to
  /// `UIColor.clearColor`. Set this property to `nil` to reset it to the default
  /// value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `UIColor` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textHaloColor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextHaloColor_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textHaloColor` property.
  ///
  /// This property corresponds to the `text-halo-color-transition` property in the style JSON file format.
  MLNTransition get textHaloColorTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textHaloColorTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_textHaloColorTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textHaloColor` property.
  ///
  /// This property corresponds to the `text-halo-color-transition` property in the style JSON file format.
  set textHaloColorTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextHaloColorTransition_, value);
  }

  /// Distance of halo to the font outline. Max text halo width is 1/4 of the
  /// font-size.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textHaloWidth {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textHaloWidth);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance of halo to the font outline. Max text halo width is 1/4 of the
  /// font-size.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `0`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values no less than 0
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textHaloWidth(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextHaloWidth_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textHaloWidth` property.
  ///
  /// This property corresponds to the `text-halo-width-transition` property in the style JSON file format.
  MLNTransition get textHaloWidthTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textHaloWidthTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_textHaloWidthTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textHaloWidth` property.
  ///
  /// This property corresponds to the `text-halo-width-transition` property in the style JSON file format.
  set textHaloWidthTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextHaloWidthTransition_, value);
  }

  /// The opacity at which the text will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  NSExpression get textOpacity {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textOpacity);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// The opacity at which the text will be drawn.
  ///
  /// The default value of this property is an expression that evaluates to the float
  /// `1`. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant numeric values between 0 and 1 inclusive
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable and/or
  /// feature attributes
  set textOpacity(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextOpacity_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textOpacity` property.
  ///
  /// This property corresponds to the `text-opacity-transition` property in the style JSON file format.
  MLNTransition get textOpacityTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textOpacityTransition)
        : _ptr.ref =
            _objc_msgSend_1i0p3hy(this.ref.pointer, _sel_textOpacityTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textOpacity` property.
  ///
  /// This property corresponds to the `text-opacity-transition` property in the style JSON file format.
  set textOpacityTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextOpacityTransition_, value);
  }

  /// Distance that the text's anchor is moved from its original placement.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate"><code>text-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  NSExpression get textTranslation {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textTranslation);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Distance that the text's anchor is moved from its original placement.
  ///
  /// This property is measured in points.
  ///
  /// The default value of this property is an expression that evaluates to an
  /// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
  /// points downward. Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`. Otherwise,
  /// it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate"><code>text-translate</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `CGVector` values
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Interpolation and step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation or step functions to
  /// feature attributes.
  set textTranslation(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextTranslation_, value.ref.pointer);
  }

  /// The transition affecting any changes to this layer’s `textTranslation` property.
  ///
  /// This property corresponds to the `text-translate-transition` property in the style JSON file format.
  MLNTransition get textTranslationTransition {
    final _ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1i0p3hyStret(
            _ptr, this.ref.pointer, _sel_textTranslationTransition)
        : _ptr.ref = _objc_msgSend_1i0p3hy(
            this.ref.pointer, _sel_textTranslationTransition);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(_finalizable);
  }

  /// The transition affecting any changes to this layer’s `textTranslation` property.
  ///
  /// This property corresponds to the `text-translate-transition` property in the style JSON file format.
  set textTranslationTransition(MLNTransition value) {
    _objc_msgSend_z7lywk(
        this.ref.pointer, _sel_setTextTranslationTransition_, value);
  }

  /// textTranslate
  NSExpression get textTranslate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textTranslate);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextTranslate:
  set textTranslate(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextTranslate_, value.ref.pointer);
  }

  /// Controls the frame of reference for `textTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textTranslation` is non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate-anchor"><code>text-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The text is translated relative to the map.
  /// `viewport`: The text is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  NSExpression get textTranslationAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textTranslationAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// Controls the frame of reference for `textTranslation`.
  ///
  /// The default value of this property is an expression that evaluates to `map`.
  /// Set this property to `nil` to reset it to the default value.
  ///
  /// This property is only applied to the style if `text` is non-`nil`, and
  /// `textTranslation` is non-`nil`. Otherwise, it is ignored.
  ///
  /// This attribute corresponds to the <a
  /// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate-anchor"><code>text-translate-anchor</code></a>
  /// layout property in the MapLibre Style Spec.
  ///
  /// You can set this property to an expression containing any of the following:
  ///
  /// Constant `MLNTextTranslationAnchor` values
  /// Any of the following constant string values:
  /// `map`: The text is translated relative to the map.
  /// `viewport`: The text is translated relative to the viewport.
  /// Predefined functions, including mathematical and string operators
  /// Conditional expressions
  /// Variable assignments and references to assigned variables
  /// Step functions applied to the `$zoomLevel` variable
  ///
  /// This property does not support applying interpolation functions to the
  /// `$zoomLevel` variable or applying interpolation or step functions to feature
  /// attributes.
  set textTranslationAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextTranslationAnchor_, value.ref.pointer);
  }

  /// textTranslateAnchor
  NSExpression get textTranslateAnchor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_textTranslateAnchor);
    return NSExpression.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextTranslateAnchor:
  set textTranslateAnchor(NSExpression value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTextTranslateAnchor_, value.ref.pointer);
  }

  /// init
  MLNSymbolStyleLayer init() {
    objc.checkOsVersionInternal('MLNSymbolStyleLayer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNSymbolStyleLayer new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNSymbolStyleLayer, _sel_new);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNSymbolStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNSymbolStyleLayer, _sel_allocWithZone_, zone);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNSymbolStyleLayer alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNSymbolStyleLayer, _sel_alloc);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNSymbolStyleLayer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNSymbolStyleLayer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNSymbolStyleLayer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNSymbolStyleLayer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNSymbolStyleLayer constructed with the default `new` method.
  factory MLNSymbolStyleLayer() => new$();
}

/// The attribution info is represented in the longest format available.
enum MLNAttributionInfoStyle {
  /// Specifies a short attribution info style.
  MLNAttributionInfoStyleShort(1),

  /// Specifies a medium attribution info style.
  MLNAttributionInfoStyleMedium(2),

  /// Specifies a long attribution info style.
  MLNAttributionInfoStyleLong(3);

  final int value;
  const MLNAttributionInfoStyle(this.value);

  static MLNAttributionInfoStyle fromValue(int value) => switch (value) {
        1 => MLNAttributionInfoStyleShort,
        2 => MLNAttributionInfoStyleMedium,
        3 => MLNAttributionInfoStyleLong,
        _ => throw ArgumentError(
            'Unknown value for MLNAttributionInfoStyle: $value'),
      };
}

late final _class_MLNAttributionInfo = objc.getClass("MLNAttributionInfo");
late final _sel_initWithTitle_URL_ = objc.registerName("initWithTitle:URL:");
late final _sel_isFeedbackLink = objc.registerName("isFeedbackLink");
late final _sel_setFeedbackLink_ = objc.registerName("setFeedbackLink:");
late final _sel_titleWithStyle_ = objc.registerName("titleWithStyle:");
final _objc_msgSend_1sadrrm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// Information about an attribution statement, usually a copyright or trademark
/// statement, associated with a map content source.
class MLNAttributionInfo extends objc.NSObject {
  MLNAttributionInfo._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNAttributionInfo] that points to the same underlying object as [other].
  MLNAttributionInfo.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNAttributionInfo] that wraps the given raw object pointer.
  MLNAttributionInfo.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNAttributionInfo].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNAttributionInfo);
  }

  /// Returns an initialized attribution info object with the given title and URL.
  ///
  /// @param title The attribution statement’s title.
  /// @param URL A URL to more information about the entity named in the attribution.
  /// @return An initialized attribution info object.
  MLNAttributionInfo initWithTitle(NSAttributedString title,
      {objc.NSURL? URL}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithTitle_URL_,
        title.ref.pointer,
        URL?.ref.pointer ?? ffi.nullptr);
    return MLNAttributionInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// The attribution statement’s attributed title text.
  NSAttributedString get title {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// The attribution statement’s attributed title text.
  set title(NSAttributedString value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value.ref.pointer);
  }

  /// The URL to more information about the entity named in the attribution.
  ///
  /// If this property is set, the attribution statement should be displayed as a
  /// hyperlink or action button. Otherwise, if it is `nil`, the attribution
  /// statement should be displayed as plain text.
  objc.NSURL? get URL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_URL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// The URL to more information about the entity named in the attribution.
  ///
  /// If this property is set, the attribution statement should be displayed as a
  /// hyperlink or action button. Otherwise, if it is `nil`, the attribution
  /// statement should be displayed as plain text.
  set URL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// A Boolean value indicating whether the attribution statement is a shortcut to a
  /// feedback tool.
  ///
  /// If this property is set, the statement should be treated as a way for the user
  /// to provide feedback rather than an attribution statement.
  bool get feedbackLink {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFeedbackLink);
  }

  /// A Boolean value indicating whether the attribution statement is a shortcut to a
  /// feedback tool.
  ///
  /// If this property is set, the statement should be treated as a way for the user
  /// to provide feedback rather than an attribution statement.
  set feedbackLink(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setFeedbackLink_, value);
  }

  /// Returns a copy of the current `title` formatted accordingly to `style`.
  ///
  /// Example: If the `style` property is set to ``MLNAttributionInfoStyle/MLNAttributionInfoStyleShort``
  /// and the `title` property is set to `OpenStreetMap`, then this method returns `OSM`.
  ///
  /// @param style The attribution info style.
  ///
  /// @return The `NSAttributedString` styled title.
  NSAttributedString titleWithStyle(MLNAttributionInfoStyle style) {
    final _ret = _objc_msgSend_1sadrrm(
        this.ref.pointer, _sel_titleWithStyle_, style.value);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// init
  MLNAttributionInfo init() {
    objc.checkOsVersionInternal('MLNAttributionInfo.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNAttributionInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNAttributionInfo new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNAttributionInfo, _sel_new);
    return MLNAttributionInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNAttributionInfo allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNAttributionInfo, _sel_allocWithZone_, zone);
    return MLNAttributionInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNAttributionInfo alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNAttributionInfo, _sel_alloc);
    return MLNAttributionInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNAttributionInfo self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNAttributionInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNAttributionInfo retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNAttributionInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNAttributionInfo autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNAttributionInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of MLNAttributionInfo constructed with the default `new` method.
  factory MLNAttributionInfo() => new$();
}

late final _class_MLNOfflinePack = objc.getClass("MapLibre.MLNOfflinePack");
late final _protocol_MLNOfflineRegion = objc.getProtocol("MLNOfflineRegion");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSURL_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSURL_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSURL_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSURL_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSURL_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSURL_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSURL_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSURL_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSURL Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSURL_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSURL_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>)> {
  objc.NSURL call(ffi.Pointer<ffi.Void> arg0) => objc.NSURL.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_includesIdeographicGlyphs =
    objc.registerName("includesIdeographicGlyphs");
late final _sel_setIncludesIdeographicGlyphs_ =
    objc.registerName("setIncludesIdeographicGlyphs:");

/// An object conforming to the ``MLNOfflineRegion`` protocol determines which
/// resources are required by an ``MLNOfflinePack`` object.
interface class MLNOfflineRegion extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  MLNOfflineRegion._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNOfflineRegion] that points to the same underlying object as [other].
  MLNOfflineRegion.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNOfflineRegion] that wraps the given raw object pointer.
  MLNOfflineRegion.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNOfflineRegion].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNOfflineRegion);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNOfflineRegion.cast());

  /// Builds an object that implements the MLNOfflineRegion protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNOfflineRegion implement(
      {required objc.NSURL Function() styleURL,
      required bool Function() includesIdeographicGlyphs,
      required void Function(bool) setIncludesIdeographicGlyphs_,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNOfflineRegion');
    MLNOfflineRegion.styleURL.implement(builder, styleURL);
    MLNOfflineRegion.includesIdeographicGlyphs
        .implement(builder, includesIdeographicGlyphs);
    MLNOfflineRegion.setIncludesIdeographicGlyphs_
        .implement(builder, setIncludesIdeographicGlyphs_);
    builder.addProtocol($protocol);
    return MLNOfflineRegion.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNOfflineRegion protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required objc.NSURL Function() styleURL,
      required bool Function() includesIdeographicGlyphs,
      required void Function(bool) setIncludesIdeographicGlyphs_,
      bool $keepIsolateAlive = true}) {
    MLNOfflineRegion.styleURL.implement(builder, styleURL);
    MLNOfflineRegion.includesIdeographicGlyphs
        .implement(builder, includesIdeographicGlyphs);
    MLNOfflineRegion.setIncludesIdeographicGlyphs_
        .implement(builder, setIncludesIdeographicGlyphs_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the MLNOfflineRegion protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNOfflineRegion implementAsListener(
      {required objc.NSURL Function() styleURL,
      required bool Function() includesIdeographicGlyphs,
      required void Function(bool) setIncludesIdeographicGlyphs_,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNOfflineRegion');
    MLNOfflineRegion.styleURL.implement(builder, styleURL);
    MLNOfflineRegion.includesIdeographicGlyphs
        .implement(builder, includesIdeographicGlyphs);
    MLNOfflineRegion.setIncludesIdeographicGlyphs_
        .implementAsListener(builder, setIncludesIdeographicGlyphs_);
    builder.addProtocol($protocol);
    return MLNOfflineRegion.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNOfflineRegion protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {required objc.NSURL Function() styleURL,
      required bool Function() includesIdeographicGlyphs,
      required void Function(bool) setIncludesIdeographicGlyphs_,
      bool $keepIsolateAlive = true}) {
    MLNOfflineRegion.styleURL.implement(builder, styleURL);
    MLNOfflineRegion.includesIdeographicGlyphs
        .implement(builder, includesIdeographicGlyphs);
    MLNOfflineRegion.setIncludesIdeographicGlyphs_
        .implementAsListener(builder, setIncludesIdeographicGlyphs_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the MLNOfflineRegion protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNOfflineRegion implementAsBlocking(
      {required objc.NSURL Function() styleURL,
      required bool Function() includesIdeographicGlyphs,
      required void Function(bool) setIncludesIdeographicGlyphs_,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNOfflineRegion');
    MLNOfflineRegion.styleURL.implement(builder, styleURL);
    MLNOfflineRegion.includesIdeographicGlyphs
        .implement(builder, includesIdeographicGlyphs);
    MLNOfflineRegion.setIncludesIdeographicGlyphs_
        .implementAsBlocking(builder, setIncludesIdeographicGlyphs_);
    builder.addProtocol($protocol);
    return MLNOfflineRegion.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNOfflineRegion protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {required objc.NSURL Function() styleURL,
      required bool Function() includesIdeographicGlyphs,
      required void Function(bool) setIncludesIdeographicGlyphs_,
      bool $keepIsolateAlive = true}) {
    MLNOfflineRegion.styleURL.implement(builder, styleURL);
    MLNOfflineRegion.includesIdeographicGlyphs
        .implement(builder, includesIdeographicGlyphs);
    MLNOfflineRegion.setIncludesIdeographicGlyphs_
        .implementAsBlocking(builder, setIncludesIdeographicGlyphs_);
    builder.addProtocol($protocol);
  }

  /// URL of the style whose resources are required for offline viewing.
  ///
  /// In addition to the JSON stylesheet, different styles may require different font
  /// glyphs, sprite sheets, and other resources.
  ///
  /// The URL may be a full HTTP or HTTPS URL or a canonical URL
  static final styleURL = objc.ObjCProtocolMethod<objc.NSURL Function()>(
    _protocol_MLNOfflineRegion,
    _sel_styleURL,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOfflineRegion,
      _sel_styleURL,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.NSURL Function() func) => ObjCBlock_NSURL_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// Specifies whether to include ideographic glyphs in downloaded font data.
  /// Ideographic glyphs make up the majority of downloaded font data, but
  /// it is possible to configure the renderer to use locally installed fonts
  /// instead of relying on fonts downloaded as part of the offline pack.
  /// See `MLNIdeographicFontFamilyName` setting. Also, for regions outside of
  /// China, Japan, and Korea, these glyphs will rarely appear for non-CJK users.
  ///
  /// By default, this property is set to `NO`, so that the offline pack will
  /// include ideographic glyphs.
  static final includesIdeographicGlyphs =
      objc.ObjCProtocolMethod<bool Function()>(
    _protocol_MLNOfflineRegion,
    _sel_includesIdeographicGlyphs,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Bool Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _MapLibreFFi_protocolTrampoline_e3qsqz)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOfflineRegion,
      _sel_includesIdeographicGlyphs,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function() func) => ObjCBlock_bool_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// Specifies whether to include ideographic glyphs in downloaded font data.
  /// Ideographic glyphs make up the majority of downloaded font data, but
  /// it is possible to configure the renderer to use locally installed fonts
  /// instead of relying on fonts downloaded as part of the offline pack.
  /// See `MLNIdeographicFontFamilyName` setting. Also, for regions outside of
  /// China, Japan, and Korea, these glyphs will rarely appear for non-CJK users.
  ///
  /// By default, this property is set to `NO`, so that the offline pack will
  /// include ideographic glyphs.
  static final setIncludesIdeographicGlyphs_ =
      objc.ObjCProtocolListenableMethod<void Function(bool)>(
    _protocol_MLNOfflineRegion,
    _sel_setIncludesIdeographicGlyphs_,
    ffi.Native.addressOf<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Bool)>>(_MapLibreFFi_protocolTrampoline_10lndml)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOfflineRegion,
      _sel_setIncludesIdeographicGlyphs_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function(bool) func) => ObjCBlock_ffiVoid_ffiVoid_bool.fromFunction(
        (ffi.Pointer<ffi.Void> _, bool arg1) => func(arg1)),
    (void Function(bool) func) => ObjCBlock_ffiVoid_ffiVoid_bool.listener(
        (ffi.Pointer<ffi.Void> _, bool arg1) => func(arg1)),
    (void Function(bool) func) => ObjCBlock_ffiVoid_ffiVoid_bool.blocking(
        (ffi.Pointer<ffi.Void> _, bool arg1) => func(arg1)),
  );
}

late final _sel_region = objc.registerName("region");
late final _sel_setContext_completionHandler_ =
    objc.registerName("setContext:completionHandler:");

/// The state an offline pack is currently in.
enum MLNOfflinePackState {
  /// It is unknown whether the pack is inactive, active, or complete.
  ///
  /// This is the initial state of a pack. The state of a pack becomes known by
  /// the time the shared ``MLNOfflineStorage`` object sends the first
  /// ``MLNOfflinePackProgressChangedNotification`` about the pack. For inactive
  /// packs, you must explicitly request a progress update using the
  /// ``MLNOfflinePack/requestProgress`` method.
  ///
  /// An invalid pack always has a state of ``MLNOfflinePackStateInvalid``, never
  /// ``MLNOfflinePackState/MLNOfflinePackStateUnknown``.
  MLNOfflinePackStateUnknown(0),

  /// The pack is incomplete and is not currently downloading.
  ///
  /// This is the initial state of a pack that is created using the
  /// ``MLNOfflineStorage/addPackForRegion:withContext:completionHandler:``
  /// method, as well as after the ``MLNOfflinePack/suspend`` method is
  /// called.
  MLNOfflinePackStateInactive(1),

  /// The pack is incomplete and is currently downloading.
  ///
  /// This is the state of a pack after the ``MLNOfflinePack/resume`` method is
  /// called.
  MLNOfflinePackStateActive(2),

  /// The pack has downloaded to completion.
  MLNOfflinePackStateComplete(3),

  /// The pack has been removed using the
  /// ``MLNOfflineStorage/removePack:withCompletionHandler:`` method. Sending
  /// any message to the pack will raise an exception.
  MLNOfflinePackStateInvalid(4);

  final int value;
  const MLNOfflinePackState(this.value);

  static MLNOfflinePackState fromValue(int value) => switch (value) {
        0 => MLNOfflinePackStateUnknown,
        1 => MLNOfflinePackStateInactive,
        2 => MLNOfflinePackStateActive,
        3 => MLNOfflinePackStateComplete,
        4 => MLNOfflinePackStateInvalid,
        _ =>
          throw ArgumentError('Unknown value for MLNOfflinePackState: $value'),
      };
}

final _objc_msgSend_6gfr3p = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// A structure containing information about an offline pack’s current download
/// progress.
final class MLNOfflinePackProgress extends ffi.Struct {
  /// The number of resources, including tiles, that have been completely
  /// downloaded and are ready to use offline.
  @ffi.Uint64()
  external int countOfResourcesCompleted;

  /// The cumulative size of the downloaded resources on disk, including tiles,
  /// measured in bytes.
  @ffi.Uint64()
  external int countOfBytesCompleted;

  /// The number of tiles that have been completely downloaded and are ready
  /// to use offline.
  @ffi.Uint64()
  external int countOfTilesCompleted;

  /// The cumulative size of the downloaded tiles on disk, measured in bytes.
  @ffi.Uint64()
  external int countOfTileBytesCompleted;

  /// The minimum number of resources that must be downloaded in order to view
  /// the pack’s full region without any omissions.
  ///
  /// At the beginning of a download, this count is a lower bound; the number of
  /// expected resources may increase as the download progresses.
  @ffi.Uint64()
  external int countOfResourcesExpected;

  /// The maximum number of resources that must be downloaded in order to view
  /// the pack’s full region without any omissions.
  ///
  /// At the beginning of a download, when the exact number of required resources
  /// is unknown, this field is set to `UINT64_MAX`. Thus this count is always an
  /// upper bound.
  @ffi.Uint64()
  external int maximumResourcesExpected;
}

late final _sel_progress = objc.registerName("progress");
final _objc_msgSend_oftva = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            MLNOfflinePackProgress Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        MLNOfflinePackProgress Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_oftvaStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<MLNOfflinePackProgress>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<MLNOfflinePackProgress>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_resume = objc.registerName("resume");
late final _sel_suspend = objc.registerName("suspend");
late final _sel_requestProgress = objc.registerName("requestProgress");

/// An ``MLNOfflinePack`` represents a collection of resources necessary for viewing
/// a region offline to a local database.
///
/// To create an instance of ``MLNOfflinePack``, use the
/// ``MLNOfflineStorage/addPackForRegion:withContext:completionHandler:`` method.
/// A pack created using `MLNOfflinePack/init` is immediately invalid.
///
/// ### Example
/// ```swift
/// MLNOfflineStorage.shared.addPack(for: region, withContext: context) { (pack, error) in
/// guard let pack = pack else {
/// // If adding the pack fails, log an error to console.
/// print("Error:", error?.localizedDescription ?? "unknown error adding pack at
/// \(#file)(\(#line)) in \(#function)") return
/// }
///
/// // Start an MLNOfflinePack download
/// pack.resume()
/// }
/// ```
class MLNOfflinePack extends objc.NSObject {
  MLNOfflinePack._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNOfflinePack] that points to the same underlying object as [other].
  MLNOfflinePack.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNOfflinePack] that wraps the given raw object pointer.
  MLNOfflinePack.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNOfflinePack].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNOfflinePack);
  }

  /// The region for which the pack manages resources.
  MLNOfflineRegion get region {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_region);
    return MLNOfflineRegion.castFromPointer(_ret, retain: true, release: true);
  }

  /// Arbitrary data stored alongside the downloaded resources.
  ///
  /// The context typically holds application-specific information for identifying
  /// the pack, such as a user-selected name.
  ///
  /// To change the value of this property, use the `-setContext:completionHandler:`
  /// method. If you access this property after calling that method but before its
  /// completion handler is called, this property’s value may not reflect the new
  /// value that you specify.
  objc.NSData get context {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_context);
    return objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// Associates arbitrary contextual data with the offline pack, replacing any
  /// context that was previously associated with the offline pack.
  ///
  /// Setting the context is asynchronous. The `context` property may not be updated
  /// until the completion handler is called.
  ///
  /// @param context The new context to associate with the offline pack.
  /// @param completion The completion handler to call when the context has been
  /// updated. If there is an error setting the context, the error is passed into
  /// the completion handler.
  void setContext(objc.NSData context$1,
      {objc.ObjCBlock<ffi.Void Function(objc.NSError?)>? completionHandler}) {
    _objc_msgSend_o762yo(this.ref.pointer, _sel_setContext_completionHandler_,
        context$1.ref.pointer, completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// The pack’s current state.
  ///
  /// The state of an inactive or completed pack is computed lazily and is set to
  /// ``MLNOfflinePackState/MLNOfflinePackStateUnknown`` by default. To request the pack’s status, use
  /// the
  /// `-requestProgress` method. To get notified when the state becomes known and
  /// when it changes, observe KVO change notifications on this pack’s `state` key
  /// path. Alternatively, you can add an observer for
  /// ``MLNOfflinePackProgressChangedNotification``s about this pack that come from the
  /// default notification center.
  MLNOfflinePackState get state {
    final _ret = _objc_msgSend_6gfr3p(this.ref.pointer, _sel_state);
    return MLNOfflinePackState.fromValue(_ret);
  }

  /// The pack’s current progress.
  ///
  /// The progress of an inactive or completed pack is computed lazily, and all its
  /// fields are set to 0 by default. To request the pack’s progress, use the
  /// `-requestProgress` method. To get notified when the progress becomes
  /// known and when it changes, observe KVO change notifications on this pack’s
  /// `state` key path. Alternatively, you can add an observer for
  /// ``MLNOfflinePackProgressChangedNotification``s about this pack that come from the
  /// default notification center.
  MLNOfflinePackProgress get progress {
    final _ptr = pkg_ffi.calloc<MLNOfflinePackProgress>();
    objc.useMsgSendVariants
        ? _objc_msgSend_oftvaStret(_ptr, this.ref.pointer, _sel_progress)
        : _ptr.ref = _objc_msgSend_oftva(this.ref.pointer, _sel_progress);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNOfflinePackProgress>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNOfflinePackProgress>(_finalizable);
  }

  /// Resumes downloading if the pack is inactive.
  ///
  /// When a pack resumes after being suspended, it may begin by iterating over the
  /// already downloaded resources. As a result, the `progress` structure’s
  /// `countOfResourcesCompleted` field may revert to 0 before rapidly returning to
  /// the level of progress at the time the pack was suspended.
  ///
  /// To temporarily suspend downloading, call the `-suspend` method.
  void resume() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resume);
  }

  /// Temporarily stops downloading if the pack is active.
  ///
  /// A pack suspends asynchronously, so some network requests may be sent after this
  /// method is called. Regardless, the `progress` property will not be updated until
  /// `-resume` is called.
  ///
  /// If the pack previously reached a higher level of progress before being
  /// suspended, it may wait to suspend until it returns to that level.
  ///
  /// To resume downloading, call the `-resume` method.
  void suspend() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_suspend);
  }

  /// Request an asynchronous update to the pack’s `state` and `progress` properties.
  ///
  /// The state and progress of an inactive or completed pack are computed lazily. If
  /// you need the state or progress of a pack whose `state` property is currently
  /// set to ``MLNOfflinePackState/MLNOfflinePackStateUnknown``, observe KVO change notifications on this
  /// pack’s `state` key path, then call this method. Alternatively, you can add an
  /// observer for ``MLNOfflinePackProgressChangedNotification`` about this pack that
  /// come from the default notification center.
  void requestProgress() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_requestProgress);
  }

  /// init
  MLNOfflinePack init() {
    objc.checkOsVersionInternal('MLNOfflinePack.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNOfflinePack.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static MLNOfflinePack new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNOfflinePack, _sel_new);
    return MLNOfflinePack.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static MLNOfflinePack allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_MLNOfflinePack, _sel_allocWithZone_, zone);
    return MLNOfflinePack.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static MLNOfflinePack alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNOfflinePack, _sel_alloc);
    return MLNOfflinePack.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  MLNOfflinePack self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNOfflinePack.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNOfflinePack retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNOfflinePack.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNOfflinePack autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNOfflinePack.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNOfflinePack constructed with the default `new` method.
  factory MLNOfflinePack() => new$();
}

void _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_MLNOfflinePack_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_MLNOfflinePack_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> fromFunction(
          void Function(MLNOfflinePack?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : MLNOfflinePack.castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>
      listener(void Function(MLNOfflinePack?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : MLNOfflinePack.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>
      blocking(void Function(MLNOfflinePack?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : MLNOfflinePack.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_MLNOfflinePack_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : MLNOfflinePack.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_MLNOfflinePack_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> {
  void call(MLNOfflinePack? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
      arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

void _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSArray_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(objc.NSURL, objc.NSArray?,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSURL_NSArray_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> fromFunction(
          void Function(objc.NSURL, objc.NSArray?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                  objc.NSURL.castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSArray.castFromPointer(arg1, retain: true, release: true),
                  arg2.address == 0 ? null : objc.NSError.castFromPointer(arg2, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>
      listener(void Function(objc.NSURL, objc.NSArray?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                objc.NSURL.castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSArray.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_r8gdi7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSURL, objc.NSArray?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>
      blocking(void Function(objc.NSURL, objc.NSArray?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                objc.NSURL.castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSArray.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSArray_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                objc.NSURL.castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSArray.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_r8gdi7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSURL, objc.NSArray?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSArray_NSError_CallExtension on objc
    .ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> {
  void call(objc.NSURL arg0, objc.NSArray? arg1, objc.NSError? arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0.ref.pointer,
          arg1?.ref.pointer ?? ffi.nullptr,
          arg2?.ref.pointer ?? ffi.nullptr);
}

void _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURL_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSURL_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> fromFunction(
          void Function(objc.NSURL, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSURL_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  objc.NSURL.castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0
                      ? null
                      : objc.NSError.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> listener(
      void Function(objc.NSURL, objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                objc.NSURL.castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> blocking(
      void Function(objc.NSURL, objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                objc.NSURL.castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSError_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                objc.NSURL.castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _MapLibreFFi_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> {
  void call(objc.NSURL arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0.ref.pointer, arg1?.ref.pointer ?? ffi.nullptr);
}

/// The type of resource that is requested.
enum MLNResourceKind {
  /// Unknown type
  MLNResourceKindUnknown(0),

  /// Style sheet JSON file
  MLNResourceKindStyle(1),

  /// TileJSON file as specified in https://maplibre.org/maplibre-style-spec/root/#sources
  MLNResourceKindSource(2),

  /// A vector or raster tile as described in the style sheet at
  /// https://maplibre.org/maplibre-style-spec/sources/
  MLNResourceKindTile(3),

  /// Signed distance field glyphs for text rendering. These are the URLs specified in the style
  /// in https://maplibre.org/maplibre-style-spec/root/#glyphs
  MLNResourceKindGlyphs(4),

  /// Image part of a sprite sheet. It is constructed of the prefix in
  /// https://maplibre.org/maplibre-style-spec/root/#sprite and a PNG file extension.
  MLNResourceKindSpriteImage(5),

  /// JSON part of a sprite sheet. It is constructed of the prefix in
  /// https://maplibre.org/maplibre-style-spec/root/#sprite and a JSON file extension.
  MLNResourceKindSpriteJSON(6),

  /// Image data for a georeferenced image source.
  MLNResourceKindImage(7);

  final int value;
  const MLNResourceKind(this.value);

  static MLNResourceKind fromValue(int value) => switch (value) {
        0 => MLNResourceKindUnknown,
        1 => MLNResourceKindStyle,
        2 => MLNResourceKindSource,
        3 => MLNResourceKindTile,
        4 => MLNResourceKindGlyphs,
        5 => MLNResourceKindSpriteImage,
        6 => MLNResourceKindSpriteJSON,
        7 => MLNResourceKindImage,
        _ => throw ArgumentError('Unknown value for MLNResourceKind: $value'),
      };
}

late final _class_MLNOfflineStorage = objc.getClass("MLNOfflineStorage");
late final _sel_sharedOfflineStorage =
    objc.registerName("sharedOfflineStorage");
late final _protocol_MLNOfflineStorageDelegate =
    objc.getProtocol("MLNOfflineStorageDelegate");
late final _sel_offlineStorage_URLForResourceOfKind_withURL_ =
    objc.registerName("offlineStorage:URLForResourceOfKind:withURL:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            int arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.UnsignedLong arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    int,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.UnsignedLong,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            int arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.UnsignedLong,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>`.
abstract final class ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage,
              ffi.UnsignedLong, objc.NSURL)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.NSURL Function(
                  ffi.Pointer<ffi.Void>,
                  MLNOfflineStorage,
                  ffi.UnsignedLong,
                  objc.NSURL)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage,
              ffi.UnsignedLong, objc.NSURL)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.UnsignedLong arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage,
                      ffi.UnsignedLong, objc.NSURL)>(
              objc.newPointerBlock(_ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>
      fromFunction(objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, MLNResourceKind, objc.NSURL) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          int arg2,
                          ffi.Pointer<objc.ObjCObject> arg3) =>
                      fn(arg0, MLNOfflineStorage.castFromPointer(arg1, retain: true, release: true), MLNResourceKind.fromValue(arg2), objc.NSURL.castFromPointer(arg3, retain: true, release: true)).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>`.
extension ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL_CallExtension
    on objc.ObjCBlock<
        objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage,
            ffi.UnsignedLong, objc.NSURL)> {
  objc.NSURL call(ffi.Pointer<ffi.Void> arg0, MLNOfflineStorage arg1,
          MLNResourceKind arg2, objc.NSURL arg3) =>
      objc.NSURL.castFromPointer(
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.UnsignedLong arg2,
                              ffi.Pointer<objc.ObjCObject> arg3)>>()
                  .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, int, ffi.Pointer<objc.ObjCObject>)>()(
              ref.pointer,
              arg0,
              arg1.ref.pointer,
              arg2.value,
              arg3.ref.pointer),
          retain: true,
          release: true);
}

/// The ``MLNOfflineStorageDelegate`` protocol defines methods that a delegate of an
/// ``MLNOfflineStorage`` object can optionally implement to transform various types
/// of URLs before downloading them via the internet.
interface class MLNOfflineStorageDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  MLNOfflineStorageDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MLNOfflineStorageDelegate] that points to the same underlying object as [other].
  MLNOfflineStorageDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNOfflineStorageDelegate] that wraps the given raw object pointer.
  MLNOfflineStorageDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNOfflineStorageDelegate].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_MLNOfflineStorageDelegate);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MLNOfflineStorageDelegate.cast());

  /// Builds an object that implements the MLNOfflineStorageDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNOfflineStorageDelegate implement(
      {required objc.NSURL Function(
              MLNOfflineStorage, MLNResourceKind, objc.NSURL)
          offlineStorage_URLForResourceOfKind_withURL_,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'MLNOfflineStorageDelegate');
    MLNOfflineStorageDelegate.offlineStorage_URLForResourceOfKind_withURL_
        .implement(builder, offlineStorage_URLForResourceOfKind_withURL_);
    builder.addProtocol($protocol);
    return MLNOfflineStorageDelegate.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNOfflineStorageDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required objc.NSURL Function(
              MLNOfflineStorage, MLNResourceKind, objc.NSURL)
          offlineStorage_URLForResourceOfKind_withURL_,
      bool $keepIsolateAlive = true}) {
    MLNOfflineStorageDelegate.offlineStorage_URLForResourceOfKind_withURL_
        .implement(builder, offlineStorage_URLForResourceOfKind_withURL_);
    builder.addProtocol($protocol);
  }

  /// Sent whenever a URL needs to be transformed.
  ///
  /// @param storage The storage object processing the download.
  /// @param kind The kind of URL to be transformed.
  /// @param url The original URL to be transformed.
  /// @return A URL that will now be downloaded.
  static final offlineStorage_URLForResourceOfKind_withURL_ =
      objc.ObjCProtocolMethod<
          objc.NSURL Function(MLNOfflineStorage, MLNResourceKind, objc.NSURL)>(
    _protocol_MLNOfflineStorageDelegate,
    _sel_offlineStorage_URLForResourceOfKind_withURL_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.UnsignedLong,
                        ffi.Pointer<objc.ObjCObject>)>>(
            _MapLibreFFi_protocolTrampoline_1fy0zqa)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_MLNOfflineStorageDelegate,
      _sel_offlineStorage_URLForResourceOfKind_withURL_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.NSURL Function(MLNOfflineStorage, MLNResourceKind, objc.NSURL)
            func) =>
        ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL
            .fromFunction((ffi.Pointer<ffi.Void> _, MLNOfflineStorage arg1,
                    MLNResourceKind arg2, objc.NSURL arg3) =>
                func(arg1, arg2, arg3)),
  );
}

late final _sel_databasePath = objc.registerName("databasePath");
late final _sel_databaseURL = objc.registerName("databaseURL");
late final _sel_addContentsOfFile_withCompletionHandler_ =
    objc.registerName("addContentsOfFile:withCompletionHandler:");
late final _sel_addContentsOfURL_withCompletionHandler_ =
    objc.registerName("addContentsOfURL:withCompletionHandler:");
late final _sel_packs = objc.registerName("packs");
late final _sel_addPackForRegion_withContext_completionHandler_ =
    objc.registerName("addPackForRegion:withContext:completionHandler:");
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_removePack_withCompletionHandler_ =
    objc.registerName("removePack:withCompletionHandler:");
late final _sel_invalidatePack_withCompletionHandler_ =
    objc.registerName("invalidatePack:withCompletionHandler:");
late final _sel_reloadPacks = objc.registerName("reloadPacks");
late final _sel_setMaximumAllowedMapboxTiles_ =
    objc.registerName("setMaximumAllowedMapboxTiles:");
final _objc_msgSend_1xsl7ae = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint64)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_countOfBytesCompleted =
    objc.registerName("countOfBytesCompleted");
final _objc_msgSend_1p4gbjy = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLongLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setMaximumAmbientCacheSize_withCompletionHandler_ =
    objc.registerName("setMaximumAmbientCacheSize:withCompletionHandler:");
final _objc_msgSend_1sq2aut = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_invalidateAmbientCacheWithCompletionHandler_ =
    objc.registerName("invalidateAmbientCacheWithCompletionHandler:");
late final _sel_clearAmbientCacheWithCompletionHandler_ =
    objc.registerName("clearAmbientCacheWithCompletionHandler:");
late final _sel_resetDatabaseWithCompletionHandler_ =
    objc.registerName("resetDatabaseWithCompletionHandler:");
late final _sel_preloadData_forURL_modificationDate_expirationDate_eTag_mustRevalidate_ =
    objc.registerName(
        "preloadData:forURL:modificationDate:expirationDate:eTag:mustRevalidate:");
final _objc_msgSend_1xt2lpz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_putResourceWithUrl_data_modified_expires_etag_mustRevalidate_ =
    objc.registerName(
        "putResourceWithUrl:data:modified:expires:etag:mustRevalidate:");
late final _sel_preloadData_forURL_modificationDate_expirationDate_eTag_mustRevalidate_completionHandler_ =
    objc.registerName(
        "preloadData:forURL:modificationDate:expirationDate:eTag:mustRevalidate:completionHandler:");
final _objc_msgSend_899qho = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// MLNOfflineStorage implements a singleton (shared object) that manages offline
/// packs and ambient caching. All of this class’s instance methods are asynchronous,
/// reflecting the fact that offline resources are stored in a database. The shared
/// object maintains a canonical collection of offline packs in its `packs` property.
///
/// Mapbox resources downloaded via this API are subject to separate Vector Tile and
/// Raster Tile API pricing and are not included in the Maps SDK’s “unlimited” requests.
/// See <a href="https://www.mapbox.com/pricing/">our pricing page</a> for more
/// information.
///
/// #### Related examples
/// - <doc:OfflinePackExample>
/// - <doc:ManageOfflineRegionsExample>
class MLNOfflineStorage extends objc.NSObject {
  MLNOfflineStorage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNOfflineStorage] that points to the same underlying object as [other].
  MLNOfflineStorage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNOfflineStorage] that wraps the given raw object pointer.
  MLNOfflineStorage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNOfflineStorage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNOfflineStorage);
  }

  /// Returns the shared offline storage object.
  static MLNOfflineStorage getSharedOfflineStorage() {
    final _ret = _objc_msgSend_151sglz(
        _class_MLNOfflineStorage, _sel_sharedOfflineStorage);
    return MLNOfflineStorage.castFromPointer(_ret, retain: true, release: true);
  }

  /// The receiver’s delegate.
  ///
  /// An offline storage object sends messages to its delegate to allow it to
  /// transform URLs before they are requested from the internet. This can be used
  /// add or remove custom parameters, or reroute certain requests to other servers
  /// or endpoints.
  MLNOfflineStorageDelegate? get delegate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : MLNOfflineStorageDelegate.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// The receiver’s delegate.
  ///
  /// An offline storage object sends messages to its delegate to allow it to
  /// transform URLs before they are requested from the internet. This can be used
  /// add or remove custom parameters, or reroute certain requests to other servers
  /// or endpoints.
  set delegate(MLNOfflineStorageDelegate? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The file path at which offline packs and the ambient cache are stored.
  ///
  /// To customize this path, specify the
  /// `MLNOfflineStorageDatabasePath`
  /// key in Info.plist, see <doc:Info.plist_Keys>.
  objc.NSString get databasePath {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_databasePath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The file URL at which offline packs and the ambient cache are stored.
  ///
  /// To customize this path, specify the
  /// `MLNOfflineStorageDatabasePath` key in Info.plist, see <doc:Info.plist_Keys>.
  objc.NSURL get databaseURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_databaseURL);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// Adds the offline packs located at the given file path to offline storage.
  ///
  /// The file must be a valid offline pack database bundled with the application or
  /// downloaded separately.
  ///
  /// The resulting packs are added or updated to the shared offline storage object’s
  /// `packs` property, then the `completion` block is executed.
  ///
  /// @param filePath A string representation of the file path. The file path must be
  /// writable as schema updates may be perfomed.
  /// @param completion The completion handler to call once the contents of the given
  /// file has been added to offline storage. This handler is executed
  /// asynchronously on the main queue.
  void addContentsOfFile(objc.NSString filePath,
      {objc.ObjCBlock<
              ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>?
          withCompletionHandler}) {
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_addContentsOfFile_withCompletionHandler_,
        filePath.ref.pointer,
        withCompletionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Adds the offline packs located at the given URL to offline storage.
  ///
  /// The file must be a valid offline pack database bundled with the application or
  /// downloaded separately.
  ///
  /// The resulting packs are added or updated to the shared offline storage object’s
  /// `packs` property, then the `completion` block is executed.
  ///
  /// @param fileURL A file URL specifying the file to add. The URL should be a valid
  /// system path. The URL must be writable as schema updates may be performed.
  /// @param completion The completion handler to call once the contents of the given
  /// file has been added to offline storage. This handler is executed
  /// asynchronously on the main queue.
  void addContentsOfURL(objc.NSURL fileURL,
      {objc.ObjCBlock<
              ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>?
          withCompletionHandler}) {
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_addContentsOfURL_withCompletionHandler_,
        fileURL.ref.pointer,
        withCompletionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// An array of all known offline packs, in the order in which they were created.
  ///
  /// This property is set to `nil`, indicating that the receiver does not yet know
  /// the existing packs, for an undefined amount of time starting from the moment
  /// the shared offline storage object is initialized until the packs are fetched
  /// from the database. After that point, this property is always non-nil, but it
  /// may be empty to indicate that no packs are present.
  ///
  /// To detect when the shared offline storage object has finished loading its
  /// `packs` property, observe KVO change notifications on the `packs` key path.
  /// The initial load results in an `NSKeyValueChangeSetting` change.
  objc.NSArray? get packs {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_packs);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates and registers an offline pack that downloads the resources needed to
  /// use the given region offline.
  ///
  /// The resulting pack is added to the shared offline storage object’s `packs`
  /// property, then the `completion` block is executed with that pack passed in.
  ///
  /// The pack has an initial state of ``MLNOfflinePackState/MLNOfflinePackStateInactive``. To begin
  /// downloading resources, call ``MLNOfflinePack/resume`` on the pack from within
  /// the completion handler. To monitor download progress, add an observer for
  /// ``MLNOfflinePackProgressChangedNotification``s about that pack.
  ///
  /// To detect when any call to this method results in a new pack, observe KVO
  /// change notifications on the shared offline storage object’s `packs` key path.
  /// Additions to that array result in an `NSKeyValueChangeInsertion` change.
  ///
  /// @param region A region to download.
  /// @param context Arbitrary data to store alongside the downloaded resources.
  /// @param completion The completion handler to call once the pack has been added.
  /// This handler is executed asynchronously on the main queue.
  void addPackForRegion(MLNOfflineRegion region,
      {required objc.NSData withContext,
      objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>?
          completionHandler}) {
    _objc_msgSend_18qun1e(
        this.ref.pointer,
        _sel_addPackForRegion_withContext_completionHandler_,
        region.ref.pointer,
        withContext.ref.pointer,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Unregisters the given offline pack and allows resources that are no longer
  /// required by any remaining packs to be potentially freed.
  ///
  /// As soon as this method is called on a pack, the pack becomes invalid; any
  /// attempt to send it a message will result in an exception being thrown. If an
  /// error occurs and the pack cannot be removed, do not attempt to reuse the pack
  /// object. Instead, if you need continued access to the pack, suspend all packs
  /// and use the ``MLNOfflineStorage/reloadPacks`` method to obtain valid pointers to all the packs.
  ///
  /// To detect when any call to this method results in a pack being removed, observe
  /// KVO change notifications on the shared offline storage object’s `packs` key
  /// path. Removals from that array result in an `NSKeyValueChangeRemoval` change.
  ///
  /// When you remove an offline pack, any resources that are required by that pack,
  /// but not other packs, become eligible for deletion from offline storage. Because
  /// the backing store used for offline storage is also used as a general purpose
  /// cache for map resources, such resources may not be immediately removed if the
  /// implementation determines that they remain useful for general performance of
  /// the map.
  ///
  /// @param pack The offline pack to remove.
  /// @param completion The completion handler to call once the pack has been
  /// removed. This handler is executed asynchronously on the main queue.
  void removePack(MLNOfflinePack pack,
      {objc.ObjCBlock<ffi.Void Function(objc.NSError?)>?
          withCompletionHandler}) {
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_removePack_withCompletionHandler_,
        pack.ref.pointer,
        withCompletionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// Invalidates the specified offline pack. This method checks that the tiles
  /// in the specified offline pack match those from the server. Local tiles that
  /// do not match the latest version on the server are updated.
  ///
  /// This is more efficient than deleting the offline pack and downloading it
  /// again. If the data stored locally matches that on the server, new data will
  /// not be downloaded.
  ///
  /// @param pack The offline pack to be invalidated.
  /// @param completion The completion handler to call once the pack has been
  /// removed. This handler is executed asynchronously on the main queue.
  void invalidatePack(MLNOfflinePack pack,
      {required objc.ObjCBlock<ffi.Void Function(objc.NSError?)>
          withCompletionHandler}) {
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_invalidatePack_withCompletionHandler_,
        pack.ref.pointer,
        withCompletionHandler.ref.pointer);
  }

  /// Forcibly, asynchronously reloads the `packs` property. At some point after this
  /// method is called, the pointer values of the ``MLNOfflinePack`` objects in the
  /// `packs` property change, even if the underlying data for these packs has not
  /// changed. If this method is called while a pack is actively downloading, the
  /// behavior is undefined.
  ///
  /// You typically do not need to call this method.
  ///
  /// To detect when the shared offline storage object has finished reloading its
  /// `packs` property, observe KVO change notifications on the `packs` key path.
  /// A reload results in an `NSKeyValueChangeSetting` change.
  void reloadPacks() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_reloadPacks);
  }

  /// Sets the maximum number of tiles that may be downloaded and
  /// stored on the current device.
  ///
  /// Once this limit is reached, an
  /// ``MLNOfflinePackMaximumMapboxTilesReachedNotification`` is posted for every
  /// attempt to download additional tiles until already downloaded tiles are removed
  /// by calling the ``MLNOfflineStorage/removePack:withCompletionHandler:`` method.
  ///
  /// @param maximumCount The maximum number of tiles allowed to be downloaded.
  void setMaximumAllowedMapboxTiles(int maximumCount) {
    _objc_msgSend_1xsl7ae(
        this.ref.pointer, _sel_setMaximumAllowedMapboxTiles_, maximumCount);
  }

  /// The cumulative size, measured in bytes, of all downloaded resources on disk.
  ///
  /// The returned value includes all resources, including tiles, whether downloaded
  /// as part of an offline pack or due to caching during normal use of ``MLNMapView``.
  int get countOfBytesCompleted {
    return _objc_msgSend_1p4gbjy(this.ref.pointer, _sel_countOfBytesCompleted);
  }

  /// Sets the maximum ambient cache size in bytes. The default maximum cache
  /// size is 50 MB. To disable ambient caching, set the maximum ambient cache size
  /// to `0`. Setting the maximum ambient cache size does not impact the maximum size
  /// of offline packs.
  ///
  /// This method does not limit the space available to offline packs, and data in
  /// offline packs does not count towards this limit. If you set the maximum ambient
  /// cache size to 30 MB then download 20 MB of offline packs, 30 MB will remain
  /// available for the ambient cache.
  ///
  /// This method should be called before the map and map style have been loaded.
  ///
  /// This method is potentially expensive, as the database will trim cached data
  /// in order to prevent the ambient cache from being larger than the
  /// specified amount.
  ///
  /// @param cacheSize The maximum size in bytes for the ambient cache.
  /// @param completion The completion handler to call once the maximum ambient cache
  /// size has been set. This handler is executed synchronously on the main queue.
  void setMaximumAmbientCacheSize(int cacheSize,
      {required objc.ObjCBlock<ffi.Void Function(objc.NSError?)>
          withCompletionHandler}) {
    _objc_msgSend_1sq2aut(
        this.ref.pointer,
        _sel_setMaximumAmbientCacheSize_withCompletionHandler_,
        cacheSize,
        withCompletionHandler.ref.pointer);
  }

  /// Invalidates the ambient cache. This method checks that the tiles in the
  /// ambient cache match those from the server. If the local tiles do not match
  /// those on the server, they are re-downloaded.
  ///
  /// This is recommended over clearing the cache or resetting the database
  /// because valid local tiles will not be downloaded again.
  ///
  /// Resources shared with offline packs will not be affected by this method.
  ///
  /// @param completion The completion handler to call once the ambient cache has
  /// been revalidated. This handler is executed asynchronously on the main queue.
  void invalidateAmbientCacheWithCompletionHandler(
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completion) {
    _objc_msgSend_f167m6(
        this.ref.pointer,
        _sel_invalidateAmbientCacheWithCompletionHandler_,
        completion.ref.pointer);
  }

  /// Clears the ambient cache by deleting resources. This method does not affect
  /// resources shared with offline regions.
  ///
  /// @param completion The completion handler to call once resources from the
  /// ambient cache have been cleared. This handler is executed asynchronously on
  /// the main queue.
  void clearAmbientCacheWithCompletionHandler(
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completion) {
    _objc_msgSend_f167m6(this.ref.pointer,
        _sel_clearAmbientCacheWithCompletionHandler_, completion.ref.pointer);
  }

  /// Deletes the existing database, which includes both the ambient cache and
  /// offline packs, then reinitializes it.
  ///
  /// You typically do not need to call this method.
  ///
  /// @param completion The completion handler to call once the pack has database has
  /// been reset. This handler is executed asynchronously on the main queue.
  void resetDatabaseWithCompletionHandler(
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completion) {
    _objc_msgSend_f167m6(this.ref.pointer,
        _sel_resetDatabaseWithCompletionHandler_, completion.ref.pointer);
  }

  /// Inserts the provided resource into the ambient cache.
  ///
  /// This method mimics the caching that would take place if the equivalent resource
  /// were requested in the process of map rendering. Use this method to pre-warm the
  /// cache with resources you know will be requested.
  ///
  /// This method is asynchronous; the data may not be immediately available for
  /// in-progress requests, though subsequent requests should have access to the
  /// cached data.
  ///
  /// To find out when the resource is ready to retrieve from the cache, use the
  /// ``MLNOfflineStorage/preloadData:forURL:modificationDate:expirationDate:eTag:mustRevalidate:completionHandler:``
  /// method.
  ///
  /// @param data Response data to store for this resource. The data is expected to
  /// be uncompressed; internally, the cache will compress data as necessary.
  /// @param url The URL at which the data can normally be found.
  /// @param modified The date the resource was last modified.
  /// @param expires The date after which the resource is no longer valid.
  /// @param eTag An HTTP entity tag.
  /// @param mustRevalidate A Boolean value indicating whether the data is still
  /// usable past the expiration date.
  void preloadData(objc.NSData data,
      {required objc.NSURL forURL,
      objc.NSDate? modificationDate,
      objc.NSDate? expirationDate,
      objc.NSString? eTag,
      required bool mustRevalidate}) {
    _objc_msgSend_1xt2lpz(
        this.ref.pointer,
        _sel_preloadData_forURL_modificationDate_expirationDate_eTag_mustRevalidate_,
        data.ref.pointer,
        forURL.ref.pointer,
        modificationDate?.ref.pointer ?? ffi.nullptr,
        expirationDate?.ref.pointer ?? ffi.nullptr,
        eTag?.ref.pointer ?? ffi.nullptr,
        mustRevalidate);
  }

  /// putResourceWithUrl:data:modified:expires:etag:mustRevalidate:
  void putResourceWithUrl(objc.NSURL url,
      {required objc.NSData data,
      objc.NSDate? modified,
      objc.NSDate? expires,
      objc.NSString? etag,
      required bool mustRevalidate}) {
    _objc_msgSend_1xt2lpz(
        this.ref.pointer,
        _sel_putResourceWithUrl_data_modified_expires_etag_mustRevalidate_,
        url.ref.pointer,
        data.ref.pointer,
        modified?.ref.pointer ?? ffi.nullptr,
        expires?.ref.pointer ?? ffi.nullptr,
        etag?.ref.pointer ?? ffi.nullptr,
        mustRevalidate);
  }

  /// Inserts the provided resource into the ambient cache, calling a completion
  /// handler when finished.
  ///
  /// This method is asynchronous. The data is available for in-progress requests as
  /// soon as the completion handler is called.
  ///
  /// This method is asynchronous; the data may not be immediately available for
  /// in-progress requests, though subsequent requests should have access to the
  /// cached data.
  ///
  /// @param data Response data to store for this resource. The data is expected to
  /// be uncompressed; internally, the cache will compress data as necessary.
  /// @param url The URL at which the data can normally be found.
  /// @param modified The date the resource was last modified.
  /// @param expires The date after which the resource is no longer valid.
  /// @param eTag An HTTP entity tag.
  /// @param mustRevalidate A Boolean value indicating whether the data is still
  /// usable past the expiration date.
  /// @param completion The completion handler to call once the data has been
  /// preloaded. This handler is executed asynchronously on the main queue.
  void preloadData$1(objc.NSData data,
      {required objc.NSURL forURL,
      objc.NSDate? modificationDate,
      objc.NSDate? expirationDate,
      objc.NSString? eTag,
      required bool mustRevalidate,
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>?
          completionHandler}) {
    _objc_msgSend_899qho(
        this.ref.pointer,
        _sel_preloadData_forURL_modificationDate_expirationDate_eTag_mustRevalidate_completionHandler_,
        data.ref.pointer,
        forURL.ref.pointer,
        modificationDate?.ref.pointer ?? ffi.nullptr,
        expirationDate?.ref.pointer ?? ffi.nullptr,
        eTag?.ref.pointer ?? ffi.nullptr,
        mustRevalidate,
        completionHandler?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  MLNOfflineStorage init() {
    objc.checkOsVersionInternal('MLNOfflineStorage.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNOfflineStorage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNOfflineStorage new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNOfflineStorage, _sel_new);
    return MLNOfflineStorage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNOfflineStorage allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNOfflineStorage, _sel_allocWithZone_, zone);
    return MLNOfflineStorage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNOfflineStorage alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNOfflineStorage, _sel_alloc);
    return MLNOfflineStorage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNOfflineStorage self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNOfflineStorage.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNOfflineStorage retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNOfflineStorage.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNOfflineStorage autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNOfflineStorage.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNOfflineStorage constructed with the default `new` method.
  factory MLNOfflineStorage() => new$();
}

late final _class_MLNTilePyramidOfflineRegion =
    objc.getClass("MLNTilePyramidOfflineRegion");
late final _sel_initWithStyleURL_bounds_fromZoomLevel_toZoomLevel_ =
    objc.registerName("initWithStyleURL:bounds:fromZoomLevel:toZoomLevel:");
final _objc_msgSend_s3spq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                MLNCoordinateBounds,
                ffi.Double,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            MLNCoordinateBounds,
            double,
            double)>();

/// An offline region defined by a style URL, geographic coordinate bounds, and
/// range of zoom levels.
///
/// To minimize the resources required by an irregularly shaped offline region,
/// use the MLNShapeOfflineRegion class instead.
///
/// ### Example
/// ```swift
/// let northeast = CLLocationCoordinate2D(latitude: 40.989329, longitude: -102.062592)
/// let southwest = CLLocationCoordinate2D(latitude: 36.986207, longitude: -109.049896)
/// let bbox = MLNCoordinateBounds(sw: southwest, ne: northeast)
///
/// let region = MLNTilePyramidOfflineRegion(styleURL: MLNStyle.lightStyleURL, bounds: bbox,
/// fromZoomLevel: 11, toZoomLevel: 14) let context = "Tile Pyramid Region".data(using: .utf8)
/// MLNOfflineStorage.shared.addPack(for: region, withContext: context!)
/// ```
///
/// #### Related examples
/// TODO: Download an offline map, learn how to define an offline region
/// to be downloaded to a user's device.
class MLNTilePyramidOfflineRegion extends objc.NSObject
    implements MLNOfflineRegion, objc.NSSecureCoding, objc.NSCopying {
  MLNTilePyramidOfflineRegion._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNTilePyramidOfflineRegion] that points to the same underlying object as [other].
  MLNTilePyramidOfflineRegion.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNTilePyramidOfflineRegion] that wraps the given raw object pointer.
  MLNTilePyramidOfflineRegion.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNTilePyramidOfflineRegion].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_MLNTilePyramidOfflineRegion);
  }

  /// The coordinate bounds for the geographic region covered by the downloaded
  /// tiles.
  MLNCoordinateBounds get bounds {
    final _ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ygoa6aStret(_ptr, this.ref.pointer, _sel_bounds)
        : _ptr.ref = _objc_msgSend_ygoa6a(this.ref.pointer, _sel_bounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(_finalizable);
  }

  /// The minimum zoom level for which to download tiles and other resources.
  ///
  /// For more information about zoom levels, ``MLNMapView/zoomLevel``.
  double get minimumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumZoomLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumZoomLevel);
  }

  /// The maximum zoom level for which to download tiles and other resources.
  ///
  /// For more information about zoom levels, ``MLNMapView/zoomLevel``.
  double get maximumZoomLevel {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_maximumZoomLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_maximumZoomLevel);
  }

  /// init
  MLNTilePyramidOfflineRegion init() {
    objc.checkOsVersionInternal('MLNTilePyramidOfflineRegion.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNTilePyramidOfflineRegion.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Initializes a newly created offline region with the given style URL, geographic
  /// coordinate bounds, and range of zoom levels.
  ///
  /// This is the designated initializer for ``MLNTilePyramidOfflineRegion``.
  ///
  /// @param styleURL URL of the map style for which to download resources. The URL
  /// may be a full HTTP or HTTPS URL or a canonical style URL.
  /// Specify `nil` for the default style.
  /// Relative file URLs cannot be used as offline style URLs. To download the
  /// online resources required by a local style, specify a URL to an online copy
  /// of the style.
  /// @param bounds The coordinate bounds for the geographic region to be covered by
  /// the downloaded tiles.
  /// @param minimumZoomLevel The minimum zoom level to be covered by the downloaded
  /// tiles. This parameter should be set to at least 0 but no greater than the
  /// value of the `maximumZoomLevel` parameter. For each required tile source, if
  /// this parameter is set to a value less than the tile source’s minimum zoom
  /// level, the download covers zoom levels down to the tile source’s minimum
  /// zoom level.
  /// @param maximumZoomLevel The maximum zoom level to be covered by the downloaded
  /// tiles. This parameter should be set to at least the value of the
  /// `minimumZoomLevel` parameter. For each required tile source, if this
  /// parameter is set to a value greater than the tile source’s minimum zoom
  /// level, the download covers zoom levels up to the tile source’s maximum zoom
  /// level.
  MLNTilePyramidOfflineRegion initWithStyleURL(objc.NSURL? styleURL,
      {required MLNCoordinateBounds bounds$1,
      required double fromZoomLevel,
      required double toZoomLevel}) {
    final _ret = _objc_msgSend_s3spq(
        this.ref.retainAndReturnPointer(),
        _sel_initWithStyleURL_bounds_fromZoomLevel_toZoomLevel_,
        styleURL?.ref.pointer ?? ffi.nullptr,
        bounds$1,
        fromZoomLevel,
        toZoomLevel);
    return MLNTilePyramidOfflineRegion.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNTilePyramidOfflineRegion new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNTilePyramidOfflineRegion, _sel_new);
    return MLNTilePyramidOfflineRegion.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNTilePyramidOfflineRegion allocWithZone(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNTilePyramidOfflineRegion, _sel_allocWithZone_, zone);
    return MLNTilePyramidOfflineRegion.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNTilePyramidOfflineRegion alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_MLNTilePyramidOfflineRegion, _sel_alloc);
    return MLNTilePyramidOfflineRegion.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNTilePyramidOfflineRegion self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNTilePyramidOfflineRegion.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  MLNTilePyramidOfflineRegion retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNTilePyramidOfflineRegion.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  MLNTilePyramidOfflineRegion autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNTilePyramidOfflineRegion.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// URL of the style whose resources are required for offline viewing.
  ///
  /// In addition to the JSON stylesheet, different styles may require different font
  /// glyphs, sprite sheets, and other resources.
  ///
  /// The URL may be a full HTTP or HTTPS URL or a canonical URL
  objc.NSURL get styleURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_styleURL);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// Specifies whether to include ideographic glyphs in downloaded font data.
  /// Ideographic glyphs make up the majority of downloaded font data, but
  /// it is possible to configure the renderer to use locally installed fonts
  /// instead of relying on fonts downloaded as part of the offline pack.
  /// See `MLNIdeographicFontFamilyName` setting. Also, for regions outside of
  /// China, Japan, and Korea, these glyphs will rarely appear for non-CJK users.
  ///
  /// By default, this property is set to `NO`, so that the offline pack will
  /// include ideographic glyphs.
  bool get includesIdeographicGlyphs {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_includesIdeographicGlyphs);
  }

  /// Specifies whether to include ideographic glyphs in downloaded font data.
  /// Ideographic glyphs make up the majority of downloaded font data, but
  /// it is possible to configure the renderer to use locally installed fonts
  /// instead of relying on fonts downloaded as part of the offline pack.
  /// See `MLNIdeographicFontFamilyName` setting. Also, for regions outside of
  /// China, Japan, and Korea, these glyphs will rarely appear for non-CJK users.
  ///
  /// By default, this property is set to `NO`, so that the offline pack will
  /// include ideographic glyphs.
  set includesIdeographicGlyphs(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setIncludesIdeographicGlyphs_, value);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_MLNTilePyramidOfflineRegion, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  MLNTilePyramidOfflineRegion? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : MLNTilePyramidOfflineRegion.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// Returns a new instance of MLNTilePyramidOfflineRegion constructed with the default `new` method.
  factory MLNTilePyramidOfflineRegion() => new$();
}

late final _class_MLNFeatureWrapper = objc.getClass("MLNFeatureWrapper");

/// Stub interface, so that ffigen can generate a getter for MLNFeature#identifier
/// https://github.com/dart-lang/native/issues/2492
class MLNFeatureWrapper extends objc.NSObject implements MLNFeature {
  MLNFeatureWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [MLNFeatureWrapper] that points to the same underlying object as [other].
  MLNFeatureWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MLNFeatureWrapper] that wraps the given raw object pointer.
  MLNFeatureWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNFeatureWrapper].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_MLNFeatureWrapper);
  }

  /// init
  MLNFeatureWrapper init() {
    objc.checkOsVersionInternal('MLNFeatureWrapper.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return MLNFeatureWrapper.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static MLNFeatureWrapper new$() {
    final _ret = _objc_msgSend_151sglz(_class_MLNFeatureWrapper, _sel_new);
    return MLNFeatureWrapper.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static MLNFeatureWrapper allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_MLNFeatureWrapper, _sel_allocWithZone_, zone);
    return MLNFeatureWrapper.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static MLNFeatureWrapper alloc() {
    final _ret = _objc_msgSend_151sglz(_class_MLNFeatureWrapper, _sel_alloc);
    return MLNFeatureWrapper.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  MLNFeatureWrapper self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return MLNFeatureWrapper.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  MLNFeatureWrapper retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return MLNFeatureWrapper.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  MLNFeatureWrapper autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return MLNFeatureWrapper.castFromPointer(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  objc.ObjCObjectBase? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An object that uniquely identifies the feature in its containing content
  /// source.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
  /// to the feature’s identifier.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
  /// corresponds to the
  /// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
  /// identifier</a>
  /// (`id`). If the source does not specify the feature’s identifier, the value of
  /// this property is `nil`. If specified, the identifier may be an integer,
  /// floating-point number, or string. These data types are mapped to instances of
  /// the following Foundation classes:
  ///
  /// | In the tile source        | This property |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
  /// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
  /// String                    | `NSString` |
  ///
  /// The identifier should be set before adding the feature to an ``MLNShapeSource``
  /// object; setting it afterwards has no effect on the map’s contents. While it is
  /// possible to change this value on feature instances obtained from
  /// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
  /// has no effect on the map’s contents.
  set identifier(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// A dictionary of attributes for this feature.
  ///
  /// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
  /// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
  /// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
  /// dictionary to the value you want to include. For example, if you want an
  /// ``MLNLineStyleLayer`` object to display only important features, you might assign
  /// a value above 50 to the important features’ `importance` attribute, then set
  /// ``MLNVectorStyleLayer/predicate`` to an
  /// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
  /// `importance > 50`.
  ///
  /// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
  /// object to match the value of an attribute in this dictionary whenever it
  /// renders this feature. For example, if you display features in an
  /// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
  /// attribute to each of the source’s features, then set
  /// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
  ///
  /// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
  /// properties allow you to use attributes yet another way. For example, to label
  /// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
  /// attribute to each of the source’s features, then set
  /// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
  /// `{name}`. See the
  /// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
  /// guide for more information about expressions.
  ///
  /// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
  /// each feature’s attribute dictionary are determined by the source. Each
  /// attribute name is a string, while each attribute value may be a null value,
  /// Boolean value, integer, floating-point number, or string. These data types are
  /// mapped to instances of the following Foundation classes:
  ///
  /// | In the tile source        | In this dictionary |
  /// |---------------------------|-------------------------------------------------------------------------------|
  /// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
  /// `boolValue` property)                                     | | Integer                   |
  /// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
  /// number      | `NSNumber` (use the `doubleValue` property)                                  | |
  /// String                    | `NSString` |
  ///
  /// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
  /// listed above for each attribute value. In addition to the Foundation types, you
  /// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
  /// will be converted into its
  /// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
  /// when the feature is added to an ``MLNShapeSource``. This can be convenient when
  /// using the attribute to supply a value for a color-typed layout or paint
  /// attribute via a key path expression.
  ///
  /// Note that while it is possible to change this value on feature
  /// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
  /// methods, there will be no effect on the map. Setting this value can be useful
  /// when the feature instance is used to initialize an ``MLNShapeSource`` and that
  /// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAttributes_, value.ref.pointer);
  }

  /// Returns the feature attribute for the given attribute name.
  ///
  /// See the ``attributes`` property’s documentation for details on keys and values
  /// associated with this method.
  objc.ObjCObjectBase? attributeForKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
  /// of an instance of an ``MLNFeature`` subclass.
  ///
  /// The dictionary includes a `geometry` key corresponding to the receiver’s
  /// underlying geometry data, a `properties` key corresponding to the receiver’s
  /// `attributes` property, and an `id` key corresponding to the receiver’s
  /// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The center point (specified as a map coordinate) of the annotation. (required)
  /// (read-only)
  CLLocationCoordinate2D get coordinate {
    final _ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18o5nokStret(_ptr, this.ref.pointer, _sel_coordinate)
        : _ptr.ref = _objc_msgSend_18o5nok(this.ref.pointer, _sel_coordinate);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(_finalizable);
  }

  /// The string containing the annotation’s title.
  ///
  /// Although this property is optional, if you support the selection of annotations
  /// in your map view, you are expected to provide this property. This string is
  /// displayed in the callout for the associated annotation.
  objc.NSString? get title {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_title)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNFeatureWrapper', 'title');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The string containing the annotation’s subtitle.
  ///
  /// This string is displayed in the callout for the associated annotation.
  objc.NSString? get subtitle {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_subtitle)) {
      throw objc.UnimplementedOptionalMethodException(
          'MLNFeatureWrapper', 'subtitle');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of MLNFeatureWrapper constructed with the default `new` method.
  factory MLNFeatureWrapper() => new$();
}
