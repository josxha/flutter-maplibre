// ignore_for_file: type=lint, unused_element, unused_field
// dart format off

// AUTO GENERATED FILE, DO NOT EDIT.
// 
// Generated by `package:ffigen`.
// ignore_for_file: unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;
@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external ffi.Pointer<objc.ObjCObjectImpl> _NativeLibrary_protocolTrampoline_1mbt9g9(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external int _NativeLibrary_protocolTrampoline_1ldqghh(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>()
external ffi.Pointer<objc.ObjCObjectImpl> _NativeLibrary_protocolTrampoline_1q0i84(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
ffi.Pointer<objc.ObjCBlockImpl> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1a22wz(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1a22wz(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<instancetype Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external instancetype _NativeLibrary_protocolTrampoline_xr62hr(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_lmc3p5(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_lmc3p5(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_xtuoz7(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_xtuoz7(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external objc.CGSize _NativeLibrary_protocolTrampoline_1j20mp(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1l4hxwm(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1l4hxwm(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )>()
external void _NativeLibrary_protocolTrampoline_1l4hxwm(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCBlockImpl> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external ffi.Pointer<objc.ObjCObjectImpl> _NativeLibrary_protocolTrampoline_zi5eed(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external objc.CGPoint _NativeLibrary_protocolTrampoline_7ohnx8(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1bktu2(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1bktu2(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint )>()
external void _NativeLibrary_protocolTrampoline_1bktu2(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
objc.CGPoint arg1,
);

@ffi.Native<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external objc.CGRect _NativeLibrary_protocolTrampoline_1c3uc0w(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<CGAffineTransform Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external CGAffineTransform _NativeLibrary_protocolTrampoline_8o6he9(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1lznlw3(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1lznlw3(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , CGAffineTransform )>()
external void _NativeLibrary_protocolTrampoline_1lznlw3(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
CGAffineTransform arg1,
);

@ffi.Native<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external int _NativeLibrary_protocolTrampoline_ku69ws(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>()
external objc.CGPoint _NativeLibrary_protocolTrampoline_17ipln5(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
objc.CGPoint arg1,
ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>()
external objc.CGRect _NativeLibrary_protocolTrampoline_1sh7l9z(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
objc.CGRect arg1,
ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external int _NativeLibrary_protocolTrampoline_1qeotwu(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_ovsamd(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_ovsamd(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external void _NativeLibrary_protocolTrampoline_ovsamd(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external bool _NativeLibrary_protocolTrampoline_3su7tt(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_fjrv01(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_fjrv01(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external void _NativeLibrary_protocolTrampoline_fjrv01(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , objc.CGRect )>()
external ffi.Pointer<objc.ObjCObjectImpl> _NativeLibrary_protocolTrampoline_12thpau(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
objc.CGRect arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_qvcerx(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_qvcerx(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>()
external void _NativeLibrary_protocolTrampoline_qvcerx(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
ffi.Pointer<CGContext> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1pl9qdv(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1pl9qdv(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1s56lr9(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1s56lr9(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external UIEdgeInsets _NativeLibrary_protocolTrampoline_1rtilx3(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external objc.CGRect _NativeLibrary_protocolTrampoline_szn7s6(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external int _NativeLibrary_protocolTrampoline_1tmn9mr(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1lmpkp(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1lmpkp(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )>()
external void _NativeLibrary_protocolTrampoline_1lmpkp(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
int arg1,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external int _NativeLibrary_protocolTrampoline_gvl1rz(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1mm4s9d(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1mm4s9d(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Long )>()
external void _NativeLibrary_protocolTrampoline_1mm4s9d(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
int arg1,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external int _NativeLibrary_protocolTrampoline_1ctlj1n(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1wqrf61(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1wqrf61(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Long )>()
external void _NativeLibrary_protocolTrampoline_1wqrf61(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
int arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_10lndml(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_10lndml(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )>()
external void _NativeLibrary_protocolTrampoline_10lndml(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
bool arg1,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external bool _NativeLibrary_protocolTrampoline_2n06mv(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_6p7ndb(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_6p7ndb(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_13x5jor(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_13x5jor(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external int _NativeLibrary_protocolTrampoline_1ckyi24(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_r8gdi7(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_r8gdi7(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>()
external ffi.Pointer<objc.ObjCObjectImpl> _NativeLibrary_protocolTrampoline_1fy0zqa(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
int arg2,
ffi.Pointer<objc.ObjCObjectImpl> arg3,
);

final class CGVector extends ffi.Struct{
  @ffi.Double()
  external double dx;

  @ffi.Double()
  external double dy;

}

final class CGAffineTransform extends ffi.Struct{
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;

}

late final _class_NSString = objc.getClass("NSString");
late final _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_ = objc.registerName("stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:");
final _objc_msgSend_1q2ox4r = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<ffi.Bool> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<ffi.Bool> )>();

/// NSStringEncodingDetection
extension NSStringEncodingDetection on objc.NSString {

  /// stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:
  static int stringEncodingForData(objc.NSData data, {objc.NSDictionary? encodingOptions,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> convertedString,required ffi.Pointer<ffi.Bool> usedLossyConversion}) {
  objc.checkOsVersionInternal('NSString.stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
    return _objc_msgSend_1q2ox4r(_class_NSString, _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_, data.ref.pointer, encodingOptions?.ref.pointer ?? ffi.nullptr, convertedString, usedLossyConversion);

  }

}

late final _sel_readableTypeIdentifiersForItemProvider = objc.registerName("readableTypeIdentifiersForItemProvider");
final _objc_msgSend_151sglz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.NSArray Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid$CallExtension on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) =>objc.NSArray.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_objectWithItemProviderData_typeIdentifier_error_ = objc.registerName("objectWithItemProviderData:typeIdentifier:error:");
final _objc_msgSend_1pnyuds = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)> fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void> , objc.NSData , objc.NSString , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3) => fn(arg0, objc.NSData.fromPointer(arg1, retain: true, release: true), objc.NSString.fromPointer(arg2, retain: true, release: true), arg3)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSData arg1, objc.NSString arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3).address == 0 ? null : objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3), retain: true, release: true);
}

late final _sel_writableTypeIdentifiersForItemProvider = objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ = objc.registerName("itemProviderVisibilityForRepresentationWithTypeIdentifier:");
final _objc_msgSend_16fy0up = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(int Function(ffi.Pointer<ffi.Void> , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSString.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static int _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<int Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , 0).cast();
  static int _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , 0).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString$CallExtension on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  int call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(void Function(objc.NSData? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: true, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> listener(void Function(objc.NSData? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> blocking(void Function(objc.NSData? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ = objc.registerName("loadDataWithTypeIdentifier:forItemProviderCompletionHandler:");
final _objc_msgSend_r0bo0s = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// Construction methods for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>> ptr) =>
      objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> fromFunction(objc.NSProgress? Function(ffi.Pointer<ffi.Void> , objc.NSString , objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) => fn(arg0, objc.NSString.fromPointer(arg1, retain: true, release: true), ObjCBlock_ffiVoid_NSData_NSError.fromPointer(arg2, retain: true, release: true))?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError$CallExtension on objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> {
  objc.NSProgress? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer).address == 0 ? null : objc.NSProgress.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer), retain: true, release: true);
}


/// NSItemProvider
extension NSItemProvider on objc.NSString {

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  int itemProviderVisibilityForRepresentationWithTypeIdentifier(objc.NSString typeIdentifier) {
  objc.checkOsVersionInternal('NSString.itemProviderVisibilityForRepresentationWithTypeIdentifier:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSString', 'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    return _objc_msgSend_16fy0up(object$.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_, typeIdentifier.ref.pointer);

  }


  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  objc.NSProgress? loadDataWithTypeIdentifier(objc.NSString typeIdentifier, {required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> forItemProviderCompletionHandler}) {
  objc.checkOsVersionInternal('NSString.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_r0bo0s(object$.ref.pointer, _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_, typeIdentifier.ref.pointer, forItemProviderCompletionHandler.ref.pointer);
    return $ret.address == 0 ? null : objc.NSProgress.fromPointer($ret, retain: true, release: true);
  }


  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider {
  objc.checkOsVersionInternal('NSString.writableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException('NSString', 'writableTypeIdentifiersForItemProvider');
    }
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static int itemProviderVisibilityForRepresentationWithTypeIdentifier$1(objc.NSString typeIdentifier) {
  objc.checkOsVersionInternal('NSString.itemProviderVisibilityForRepresentationWithTypeIdentifier:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(_class_NSString, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSString', 'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    return _objc_msgSend_16fy0up(_class_NSString, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_, typeIdentifier.ref.pointer);

  }


  /// objectWithItemProviderData:typeIdentifier:error:
  static objc.NSString? objectWithItemProviderData(objc.NSData data, {required objc.NSString typeIdentifier}) {
  objc.checkOsVersionInternal('NSString.objectWithItemProviderData:typeIdentifier:error:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1pnyuds(_class_NSString, _sel_objectWithItemProviderData_typeIdentifier_error_, data.ref.pointer, typeIdentifier.ref.pointer, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
  objc.checkOsVersionInternal('NSString.readableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider$1() {
  objc.checkOsVersionInternal('NSString.writableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_propertyList = objc.registerName("propertyList");
late final _sel_propertyListFromStringsFileFormat = objc.registerName("propertyListFromStringsFileFormat");

/// NSExtendedStringPropertyListParsing
extension NSExtendedStringPropertyListParsing on objc.NSString {

  /// propertyList
  objc.ObjCObject propertyList() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_propertyList);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// propertyListFromStringsFileFormat
  objc.NSDictionary? propertyListFromStringsFileFormat() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_propertyListFromStringsFileFormat);
    return $ret.address == 0 ? null : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_cString = objc.registerName("cString");
final _objc_msgSend_1fuqfwb = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_lossyCString = objc.registerName("lossyCString");
late final _sel_cStringLength = objc.registerName("cStringLength");
final _objc_msgSend_xw2lbc = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_getCString_ = objc.registerName("getCString:");
final _objc_msgSend_1r7ue5f = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> )>();
late final _sel_getCString_maxLength_ = objc.registerName("getCString:maxLength:");
final _objc_msgSend_1h3mito = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int )>();
late final _sel_getCString_maxLength_range_remainingRange_ = objc.registerName("getCString:maxLength:range:remainingRange:");
final _objc_msgSend_3gpdva = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong , objc.NSRange , ffi.Pointer<objc.NSRange> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int , objc.NSRange , ffi.Pointer<objc.NSRange> )>();
late final _sel_writeToFile_atomically_ = objc.registerName("writeToFile:atomically:");
final _objc_msgSend_1iyq28l = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , bool )>();
late final _sel_writeToURL_atomically_ = objc.registerName("writeToURL:atomically:");
late final _sel_initWithContentsOfFile_ = objc.registerName("initWithContentsOfFile:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_initWithContentsOfURL_ = objc.registerName("initWithContentsOfURL:");
late final _sel_stringWithContentsOfFile_ = objc.registerName("stringWithContentsOfFile:");
late final _sel_stringWithContentsOfURL_ = objc.registerName("stringWithContentsOfURL:");
late final _sel_initWithCStringNoCopy_length_freeWhenDone_ = objc.registerName("initWithCStringNoCopy:length:freeWhenDone:");
final _objc_msgSend_1ojrli4 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong , ffi.Bool )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int , bool )>();
late final _sel_initWithCString_length_ = objc.registerName("initWithCString:length:");
final _objc_msgSend_erqryg = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int )>();
late final _sel_initWithCString_ = objc.registerName("initWithCString:");
final _objc_msgSend_56zxyn = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> )>();
late final _sel_stringWithCString_length_ = objc.registerName("stringWithCString:length:");
late final _sel_stringWithCString_ = objc.registerName("stringWithCString:");
late final _sel_getCharacters_ = objc.registerName("getCharacters:");
final _objc_msgSend_g3kdhc = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.UnsignedShort> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.UnsignedShort> )>();

/// NSStringDeprecated
extension NSStringDeprecated on objc.NSString {

  /// cString
  ffi.Pointer<ffi.Char> cString() {
  objc.checkOsVersionInternal('NSString.cString', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1fuqfwb(object$.ref.pointer, _sel_cString);

  }


  /// cStringLength
  int cStringLength() {
  objc.checkOsVersionInternal('NSString.cStringLength', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_cStringLength);

  }


  /// getCString:
  void getCString(ffi.Pointer<ffi.Char> bytes) {
  objc.checkOsVersionInternal('NSString.getCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_1r7ue5f(object$.ref.pointer, _sel_getCString_, bytes);

  }


  /// getCString:maxLength:
  void getCString$1(ffi.Pointer<ffi.Char> bytes, {required int maxLength}) {
  objc.checkOsVersionInternal('NSString.getCString:maxLength:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_1h3mito(object$.ref.pointer, _sel_getCString_maxLength_, bytes, maxLength);

  }


  /// getCString:maxLength:range:remainingRange:
  void getCString$2(ffi.Pointer<ffi.Char> bytes, {required int maxLength,required objc.NSRange range,required ffi.Pointer<objc.NSRange> remainingRange}) {
  objc.checkOsVersionInternal('NSString.getCString:maxLength:range:remainingRange:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_3gpdva(object$.ref.pointer, _sel_getCString_maxLength_range_remainingRange_, bytes, maxLength, range, remainingRange);

  }


  /// getCharacters:
  void getCharacters(ffi.Pointer<ffi.UnsignedShort> buffer) {
_objc_msgSend_g3kdhc(object$.ref.pointer, _sel_getCharacters_, buffer);

  }


  /// initWithCString:
  objc.ObjCObject? initWithCString(ffi.Pointer<ffi.Char> bytes) {
  objc.checkOsVersionInternal('NSString.initWithCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_56zxyn(object$.ref.retainAndReturnPointer(), _sel_initWithCString_, bytes);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// initWithCString:length:
  objc.ObjCObject? initWithCString$1(ffi.Pointer<ffi.Char> bytes, {required int length}) {
  objc.checkOsVersionInternal('NSString.initWithCString:length:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_erqryg(object$.ref.retainAndReturnPointer(), _sel_initWithCString_length_, bytes, length);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// initWithCStringNoCopy:length:freeWhenDone:
  objc.ObjCObject? initWithCStringNoCopy(ffi.Pointer<ffi.Char> bytes, {required int length,required bool freeWhenDone}) {
  objc.checkOsVersionInternal('NSString.initWithCStringNoCopy:length:freeWhenDone:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1ojrli4(object$.ref.retainAndReturnPointer(), _sel_initWithCStringNoCopy_length_freeWhenDone_, bytes, length, freeWhenDone);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// initWithContentsOfFile:
  objc.ObjCObject? initWithContentsOfFile(objc.NSString path) {
  objc.checkOsVersionInternal('NSString.initWithContentsOfFile:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// initWithContentsOfURL:
  objc.ObjCObject? initWithContentsOfURL(objc.NSURL url) {
  objc.checkOsVersionInternal('NSString.initWithContentsOfURL:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithContentsOfURL_, url.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// lossyCString
  ffi.Pointer<ffi.Char> lossyCString() {
  objc.checkOsVersionInternal('NSString.lossyCString', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1fuqfwb(object$.ref.pointer, _sel_lossyCString);

  }


  /// writeToFile:atomically:
  bool writeToFile(objc.NSString path, {required bool atomically}) {
  objc.checkOsVersionInternal('NSString.writeToFile:atomically:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(object$.ref.pointer, _sel_writeToFile_atomically_, path.ref.pointer, atomically);

  }


  /// writeToURL:atomically:
  bool writeToURL(objc.NSURL url, {required bool atomically}) {
  objc.checkOsVersionInternal('NSString.writeToURL:atomically:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(object$.ref.pointer, _sel_writeToURL_atomically_, url.ref.pointer, atomically);

  }


  /// stringWithCString:
  static objc.ObjCObject? stringWithCString(ffi.Pointer<ffi.Char> bytes) {
  objc.checkOsVersionInternal('NSString.stringWithCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_56zxyn(_class_NSString, _sel_stringWithCString_, bytes);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// stringWithCString:length:
  static objc.ObjCObject? stringWithCString$1(ffi.Pointer<ffi.Char> bytes, {required int length}) {
  objc.checkOsVersionInternal('NSString.stringWithCString:length:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_erqryg(_class_NSString, _sel_stringWithCString_length_, bytes, length);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// stringWithContentsOfFile:
  static objc.ObjCObject? stringWithContentsOfFile(objc.NSString path) {
  objc.checkOsVersionInternal('NSString.stringWithContentsOfFile:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSString, _sel_stringWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// stringWithContentsOfURL:
  static objc.ObjCObject? stringWithContentsOfURL(objc.NSURL url) {
  objc.checkOsVersionInternal('NSString.stringWithContentsOfURL:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSString, _sel_stringWithContentsOfURL_, url.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }

}

late final _sel_variantFittingPresentationWidth_ = objc.registerName("variantFittingPresentationWidth:");
final _objc_msgSend_qugqlf = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// NSBundleExtensionMethods
extension NSBundleExtensionMethods on objc.NSString {

  /// variantFittingPresentationWidth:
  objc.NSString variantFittingPresentationWidth(int width) {
  objc.checkOsVersionInternal('NSString.variantFittingPresentationWidth:', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ret = _objc_msgSend_qugqlf(object$.ref.pointer, _sel_variantFittingPresentationWidth_, width);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_NSAttributedString = objc.getClass("NSAttributedString");
late final _sel_length = objc.registerName("length");
late final _sel_attribute_atIndex_effectiveRange_ = objc.registerName("attribute:atIndex:effectiveRange:");
final _objc_msgSend_7km9vu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.NSRange> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.NSRange> )>();
late final _sel_attributedSubstringFromRange_ = objc.registerName("attributedSubstringFromRange:");
final _objc_msgSend_1k1o1s7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange )>();
late final _sel_attributesAtIndex_longestEffectiveRange_inRange_ = objc.registerName("attributesAtIndex:longestEffectiveRange:inRange:");
final _objc_msgSend_1pp2gs8 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong , ffi.Pointer<objc.NSRange> , objc.NSRange )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , ffi.Pointer<objc.NSRange> , objc.NSRange )>();
late final _sel_attribute_atIndex_longestEffectiveRange_inRange_ = objc.registerName("attribute:atIndex:longestEffectiveRange:inRange:");
final _objc_msgSend_1k1akuq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.NSRange> , objc.NSRange )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.NSRange> , objc.NSRange )>();
late final _sel_isEqualToAttributedString_ = objc.registerName("isEqualToAttributedString:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_initWithString_ = objc.registerName("initWithString:");
late final _sel_initWithString_attributes_ = objc.registerName("initWithString:attributes:");
final _objc_msgSend_15qeuct = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_initWithAttributedString_ = objc.registerName("initWithAttributedString:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSDictionary_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunction(void Function(objc.NSDictionary , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(objc.NSDictionary.fromPointer(arg0, retain: true, release: true), arg1, arg2), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> listener(void Function(objc.NSDictionary , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(objc.NSDictionary.fromPointer(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1a22wz(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> blocking(void Function(objc.NSDictionary , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(objc.NSDictionary.fromPointer(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(objc.NSDictionary.fromPointer(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1a22wz(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSDictionary_NSRange_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> {
  void call(objc.NSDictionary arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(
    ref.pointer, arg0.ref.pointer, arg1, arg2);
}

late final _sel_enumerateAttributesInRange_options_usingBlock_ = objc.registerName("enumerateAttributesInRange:options:usingBlock:");
final _objc_msgSend_1kok4b = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , int , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObjectImpl_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunction(void Function(objc.ObjCObject? , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: true, release: true), arg1, arg2), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> listener(void Function(objc.ObjCObject? , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1a22wz(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> blocking(void Function(objc.ObjCObject? , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1a22wz(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_objcObjCObjectImpl_NSRange_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> {
  void call(objc.ObjCObject? arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2);
}

late final _sel_enumerateAttribute_inRange_options_usingBlock_ = objc.registerName("enumerateAttribute:inRange:options:usingBlock:");
final _objc_msgSend_ipgwfh = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , int , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// NSExtendedAttributedString
extension NSExtendedAttributedString on objc.NSAttributedString {

  /// attribute:atIndex:effectiveRange:
  objc.ObjCObject? attribute(objc.NSString attrName, {required int atIndex,required ffi.Pointer<objc.NSRange> effectiveRange}) {
  objc.checkOsVersionInternal('NSAttributedString.attribute:atIndex:effectiveRange:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_7km9vu(object$.ref.pointer, _sel_attribute_atIndex_effectiveRange_, attrName.ref.pointer, atIndex, effectiveRange);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// attribute:atIndex:longestEffectiveRange:inRange:
  objc.ObjCObject? attribute$1(objc.NSString attrName, {required int atIndex,required ffi.Pointer<objc.NSRange> longestEffectiveRange,required objc.NSRange inRange}) {
  objc.checkOsVersionInternal('NSAttributedString.attribute:atIndex:longestEffectiveRange:inRange:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1k1akuq(object$.ref.pointer, _sel_attribute_atIndex_longestEffectiveRange_inRange_, attrName.ref.pointer, atIndex, longestEffectiveRange, inRange);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// attributedSubstringFromRange:
  objc.NSAttributedString attributedSubstringFromRange(objc.NSRange range) {
  objc.checkOsVersionInternal('NSAttributedString.attributedSubstringFromRange:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1k1o1s7(object$.ref.pointer, _sel_attributedSubstringFromRange_, range);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// attributesAtIndex:longestEffectiveRange:inRange:
  objc.NSDictionary attributesAtIndex$1(int location, {required ffi.Pointer<objc.NSRange> longestEffectiveRange,required objc.NSRange inRange}) {
  objc.checkOsVersionInternal('NSAttributedString.attributesAtIndex:longestEffectiveRange:inRange:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1pp2gs8(object$.ref.pointer, _sel_attributesAtIndex_longestEffectiveRange_inRange_, location, longestEffectiveRange, inRange);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// enumerateAttribute:inRange:options:usingBlock:
  void enumerateAttribute(objc.NSString attrName, {required objc.NSRange inRange,required int options,required objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> usingBlock}) {
  objc.checkOsVersionInternal('NSAttributedString.enumerateAttribute:inRange:options:usingBlock:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
_objc_msgSend_ipgwfh(object$.ref.pointer, _sel_enumerateAttribute_inRange_options_usingBlock_, attrName.ref.pointer, inRange, options, usingBlock.ref.pointer);

  }


  /// enumerateAttributesInRange:options:usingBlock:
  void enumerateAttributesInRange(objc.NSRange enumerationRange, {required int options,required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> usingBlock}) {
  objc.checkOsVersionInternal('NSAttributedString.enumerateAttributesInRange:options:usingBlock:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
_objc_msgSend_1kok4b(object$.ref.pointer, _sel_enumerateAttributesInRange_options_usingBlock_, enumerationRange, options, usingBlock.ref.pointer);

  }


  /// initWithAttributedString:
  objc.NSAttributedString initWithAttributedString(objc.NSAttributedString attrStr) {
  objc.checkOsVersionInternal('NSAttributedString.initWithAttributedString:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithAttributedString_, attrStr.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// initWithString:
  objc.NSAttributedString initWithString(objc.NSString str) {
  objc.checkOsVersionInternal('NSAttributedString.initWithString:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithString_, str.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// initWithString:attributes:
  objc.NSAttributedString initWithString$1(objc.NSString str, {objc.NSDictionary? attributes}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithString:attributes:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithString_attributes_, str.ref.pointer, attributes?.ref.pointer ?? ffi.nullptr);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// isEqualToAttributedString:
  bool isEqualToAttributedString(objc.NSAttributedString other) {
  objc.checkOsVersionInternal('NSAttributedString.isEqualToAttributedString:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_isEqualToAttributedString_, other.ref.pointer);

  }


  /// length
  int get length {
  objc.checkOsVersionInternal('NSAttributedString.length', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_length);

  }

}

late final _sel_initWithContentsOfMarkdownFileAtURL_options_baseURL_error_ = objc.registerName("initWithContentsOfMarkdownFileAtURL:options:baseURL:error:");
final _objc_msgSend_1k0ezzm = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();
late final _sel_initWithMarkdown_options_baseURL_error_ = objc.registerName("initWithMarkdown:options:baseURL:error:");
late final _sel_initWithMarkdownString_options_baseURL_error_ = objc.registerName("initWithMarkdownString:options:baseURL:error:");

/// NSAttributedStringCreateFromMarkdown
extension NSAttributedStringCreateFromMarkdown on objc.NSAttributedString {

  /// initWithContentsOfMarkdownFileAtURL:options:baseURL:error:
  objc.NSAttributedString? initWithContentsOfMarkdownFileAtURL(objc.NSURL markdownFile, {objc.NSAttributedStringMarkdownParsingOptions? options,objc.NSURL? baseURL}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithContentsOfMarkdownFileAtURL:options:baseURL:error:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1k0ezzm(object$.ref.retainAndReturnPointer(), _sel_initWithContentsOfMarkdownFileAtURL_options_baseURL_error_, markdownFile.ref.pointer, options?.ref.pointer ?? ffi.nullptr, baseURL?.ref.pointer ?? ffi.nullptr, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// initWithMarkdown:options:baseURL:error:
  objc.NSAttributedString? initWithMarkdown(objc.NSData markdown, {objc.NSAttributedStringMarkdownParsingOptions? options,objc.NSURL? baseURL}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithMarkdown:options:baseURL:error:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1k0ezzm(object$.ref.retainAndReturnPointer(), _sel_initWithMarkdown_options_baseURL_error_, markdown.ref.pointer, options?.ref.pointer ?? ffi.nullptr, baseURL?.ref.pointer ?? ffi.nullptr, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// initWithMarkdownString:options:baseURL:error:
  objc.NSAttributedString? initWithMarkdownString(objc.NSString markdownString, {objc.NSAttributedStringMarkdownParsingOptions? options,objc.NSURL? baseURL}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithMarkdownString:options:baseURL:error:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1k0ezzm(object$.ref.retainAndReturnPointer(), _sel_initWithMarkdownString_options_baseURL_error_, markdownString.ref.pointer, options?.ref.pointer ?? ffi.nullptr, baseURL?.ref.pointer ?? ffi.nullptr, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }

}

late final _sel_initWithFormat_options_locale_ = objc.registerName("initWithFormat:options:locale:");
final _objc_msgSend_187k8ck = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_localizedAttributedStringWithFormat_ = objc.registerName("localizedAttributedStringWithFormat:");
late final _sel_localizedAttributedStringWithFormat_options_ = objc.registerName("localizedAttributedStringWithFormat:options:");
final _objc_msgSend_s058d2 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
late final _sel_initWithFormat_options_locale_context_ = objc.registerName("initWithFormat:options:locale:context:");
final _objc_msgSend_3fn4ca = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_localizedAttributedStringWithFormat_context_ = objc.registerName("localizedAttributedStringWithFormat:context:");
late final _sel_localizedAttributedStringWithFormat_options_context_ = objc.registerName("localizedAttributedStringWithFormat:options:context:");

/// NSAttributedStringFormatting
extension NSAttributedStringFormatting on objc.NSAttributedString {

  /// initWithFormat:options:locale:
  objc.NSAttributedString initWithFormat(objc.NSAttributedString format, {required int options,objc.NSLocale? locale}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithFormat:options:locale:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_187k8ck(object$.ref.retainAndReturnPointer(), _sel_initWithFormat_options_locale_, format.ref.pointer, options, locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// initWithFormat:options:locale:context:
  objc.NSAttributedString initWithFormat$1(objc.NSAttributedString format, {required int options,objc.NSLocale? locale,required objc.NSDictionary context}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithFormat:options:locale:context:', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_3fn4ca(object$.ref.retainAndReturnPointer(), _sel_initWithFormat_options_locale_context_, format.ref.pointer, options, locale?.ref.pointer ?? ffi.nullptr, context.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// localizedAttributedStringWithFormat:
  static objc.NSAttributedString localizedAttributedStringWithFormat(objc.NSAttributedString format) {
  objc.checkOsVersionInternal('NSAttributedString.localizedAttributedStringWithFormat:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSAttributedString, _sel_localizedAttributedStringWithFormat_, format.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// localizedAttributedStringWithFormat:context:
  static objc.NSAttributedString localizedAttributedStringWithFormat$1(objc.NSAttributedString format, {required objc.NSDictionary context}) {
  objc.checkOsVersionInternal('NSAttributedString.localizedAttributedStringWithFormat:context:', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSAttributedString, _sel_localizedAttributedStringWithFormat_context_, format.ref.pointer, context.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// localizedAttributedStringWithFormat:options:
  static objc.NSAttributedString localizedAttributedStringWithFormat$2(objc.NSAttributedString format, {required int options}) {
  objc.checkOsVersionInternal('NSAttributedString.localizedAttributedStringWithFormat:options:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_s058d2(_class_NSAttributedString, _sel_localizedAttributedStringWithFormat_options_, format.ref.pointer, options);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// localizedAttributedStringWithFormat:options:context:
  static objc.NSAttributedString localizedAttributedStringWithFormat$3(objc.NSAttributedString format, {required int options,required objc.NSDictionary context}) {
  objc.checkOsVersionInternal('NSAttributedString.localizedAttributedStringWithFormat:options:context:', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_187k8ck(_class_NSAttributedString, _sel_localizedAttributedStringWithFormat_options_context_, format.ref.pointer, options, context.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_attributedStringByInflectingString = objc.registerName("attributedStringByInflectingString");

/// NSMorphology
extension NSMorphology on objc.NSAttributedString {

  /// attributedStringByInflectingString
  objc.NSAttributedString attributedStringByInflectingString() {
  objc.checkOsVersionInternal('NSAttributedString.attributedStringByInflectingString', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributedStringByInflectingString);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_pathWithComponents_ = objc.registerName("pathWithComponents:");
late final _sel_pathComponents = objc.registerName("pathComponents");
late final _sel_isAbsolutePath = objc.registerName("isAbsolutePath");
final _objc_msgSend_91o635 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_lastPathComponent = objc.registerName("lastPathComponent");
late final _sel_stringByDeletingLastPathComponent = objc.registerName("stringByDeletingLastPathComponent");
late final _sel_stringByAppendingPathComponent_ = objc.registerName("stringByAppendingPathComponent:");
late final _sel_pathExtension = objc.registerName("pathExtension");
late final _sel_stringByDeletingPathExtension = objc.registerName("stringByDeletingPathExtension");
late final _sel_stringByAppendingPathExtension_ = objc.registerName("stringByAppendingPathExtension:");
late final _sel_stringByAbbreviatingWithTildeInPath = objc.registerName("stringByAbbreviatingWithTildeInPath");
late final _sel_stringByExpandingTildeInPath = objc.registerName("stringByExpandingTildeInPath");
late final _sel_stringByStandardizingPath = objc.registerName("stringByStandardizingPath");
late final _sel_stringByResolvingSymlinksInPath = objc.registerName("stringByResolvingSymlinksInPath");
late final _sel_stringsByAppendingPaths_ = objc.registerName("stringsByAppendingPaths:");
late final _sel_completePathIntoString_caseSensitive_matchesIntoArray_filterTypes_ = objc.registerName("completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:");
final _objc_msgSend_8mvqcu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Bool , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , bool , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_fileSystemRepresentation = objc.registerName("fileSystemRepresentation");
late final _sel_getFileSystemRepresentation_maxLength_ = objc.registerName("getFileSystemRepresentation:maxLength:");
final _objc_msgSend_8cymbm = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int )>();

/// NSStringPathExtensions
extension NSStringPathExtensions on objc.NSString {

  /// completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:
  int completePathIntoString(ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> outputName, {required bool caseSensitive,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> matchesIntoArray,objc.NSArray? filterTypes}) {
    return _objc_msgSend_8mvqcu(object$.ref.pointer, _sel_completePathIntoString_caseSensitive_matchesIntoArray_filterTypes_, outputName, caseSensitive, matchesIntoArray, filterTypes?.ref.pointer ?? ffi.nullptr);

  }


  /// fileSystemRepresentation
  ffi.Pointer<ffi.Char> get fileSystemRepresentation {
    return _objc_msgSend_1fuqfwb(object$.ref.pointer, _sel_fileSystemRepresentation);

  }


  /// getFileSystemRepresentation:maxLength:
  bool getFileSystemRepresentation(ffi.Pointer<ffi.Char> cname, {required int maxLength}) {
    return _objc_msgSend_8cymbm(object$.ref.pointer, _sel_getFileSystemRepresentation_maxLength_, cname, maxLength);

  }


  /// isAbsolutePath
  bool get isAbsolutePath {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isAbsolutePath);

  }


  /// lastPathComponent
  objc.NSString get lastPathComponent {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lastPathComponent);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// pathComponents
  objc.NSArray get pathComponents {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_pathComponents);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// pathExtension
  objc.NSString get pathExtension {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_pathExtension);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByAbbreviatingWithTildeInPath
  objc.NSString get stringByAbbreviatingWithTildeInPath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByAbbreviatingWithTildeInPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByAppendingPathComponent:
  objc.NSString stringByAppendingPathComponent(objc.NSString str) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_stringByAppendingPathComponent_, str.ref.pointer);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByAppendingPathExtension:
  objc.NSString? stringByAppendingPathExtension(objc.NSString str) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_stringByAppendingPathExtension_, str.ref.pointer);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByDeletingLastPathComponent
  objc.NSString get stringByDeletingLastPathComponent {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByDeletingLastPathComponent);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByDeletingPathExtension
  objc.NSString get stringByDeletingPathExtension {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByDeletingPathExtension);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByExpandingTildeInPath
  objc.NSString get stringByExpandingTildeInPath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByExpandingTildeInPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByResolvingSymlinksInPath
  objc.NSString get stringByResolvingSymlinksInPath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByResolvingSymlinksInPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByStandardizingPath
  objc.NSString get stringByStandardizingPath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByStandardizingPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringsByAppendingPaths:
  objc.NSArray stringsByAppendingPaths(objc.NSArray paths) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_stringsByAppendingPaths_, paths.ref.pointer);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// pathWithComponents:
  static objc.NSString pathWithComponents(objc.NSArray components) {
    final $ret = _objc_msgSend_1sotr3r(_class_NSString, _sel_pathWithComponents_, components.ref.pointer);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

sealed class NSSearchPathDirectory {
  static const NSApplicationDirectory = 1;
  static const NSDemoApplicationDirectory = 2;
  static const NSDeveloperApplicationDirectory = 3;
  static const NSAdminApplicationDirectory = 4;
  static const NSLibraryDirectory = 5;
  static const NSDeveloperDirectory = 6;
  static const NSUserDirectory = 7;
  static const NSDocumentationDirectory = 8;
  static const NSDocumentDirectory = 9;
  static const NSCoreServiceDirectory = 10;
  static const NSAutosavedInformationDirectory = 11;
  static const NSDesktopDirectory = 12;
  static const NSCachesDirectory = 13;
  static const NSApplicationSupportDirectory = 14;
  static const NSDownloadsDirectory = 15;
  static const NSInputMethodsDirectory = 16;
  static const NSMoviesDirectory = 17;
  static const NSMusicDirectory = 18;
  static const NSPicturesDirectory = 19;
  static const NSPrinterDescriptionDirectory = 20;
  static const NSSharedPublicDirectory = 21;
  static const NSPreferencePanesDirectory = 22;
  static const NSApplicationScriptsDirectory = 23;
  static const NSItemReplacementDirectory = 99;
  static const NSAllApplicationsDirectory = 100;
  static const NSAllLibrariesDirectory = 101;
  static const NSTrashDirectory = 102;}

sealed class NSSearchPathDomainMask {
  static const NSUserDomainMask = 1;
  static const NSLocalDomainMask = 2;
  static const NSNetworkDomainMask = 4;
  static const NSSystemDomainMask = 8;
  static const NSAllDomainsMask = 65535;}

late final _sel_stringByAddingPercentEncodingWithAllowedCharacters_ = objc.registerName("stringByAddingPercentEncodingWithAllowedCharacters:");
late final _sel_stringByRemovingPercentEncoding = objc.registerName("stringByRemovingPercentEncoding");
late final _sel_stringByAddingPercentEscapesUsingEncoding_ = objc.registerName("stringByAddingPercentEscapesUsingEncoding:");
final _objc_msgSend_14hpxwa = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_stringByReplacingPercentEscapesUsingEncoding_ = objc.registerName("stringByReplacingPercentEscapesUsingEncoding:");

/// NSURLUtilities
extension NSURLUtilities on objc.NSString {

  /// stringByAddingPercentEncodingWithAllowedCharacters:
  objc.NSString? stringByAddingPercentEncodingWithAllowedCharacters(objc.NSCharacterSet allowedCharacters) {
  objc.checkOsVersionInternal('NSString.stringByAddingPercentEncodingWithAllowedCharacters:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_stringByAddingPercentEncodingWithAllowedCharacters_, allowedCharacters.ref.pointer);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByAddingPercentEscapesUsingEncoding:
  objc.NSString? stringByAddingPercentEscapesUsingEncoding(int enc) {
  objc.checkOsVersionInternal('NSString.stringByAddingPercentEscapesUsingEncoding:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_14hpxwa(object$.ref.pointer, _sel_stringByAddingPercentEscapesUsingEncoding_, enc);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByRemovingPercentEncoding
  objc.NSString? get stringByRemovingPercentEncoding {
  objc.checkOsVersionInternal('NSString.stringByRemovingPercentEncoding', iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByRemovingPercentEncoding);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByReplacingPercentEscapesUsingEncoding:
  objc.NSString? stringByReplacingPercentEscapesUsingEncoding(int enc) {
  objc.checkOsVersionInternal('NSString.stringByReplacingPercentEscapesUsingEncoding:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_14hpxwa(object$.ref.pointer, _sel_stringByReplacingPercentEscapesUsingEncoding_, enc);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

sealed class NSVolumeEnumerationOptions {
  static const NSVolumeEnumerationSkipHiddenVolumes = 2;
  static const NSVolumeEnumerationProduceFileReferenceURLs = 4;}

sealed class NSDirectoryEnumerationOptions {
  static const NSDirectoryEnumerationSkipsSubdirectoryDescendants = 1;
  static const NSDirectoryEnumerationSkipsPackageDescendants = 2;
  static const NSDirectoryEnumerationSkipsHiddenFiles = 4;
  static const NSDirectoryEnumerationIncludesDirectoriesPostOrder = 8;
  static const NSDirectoryEnumerationProducesRelativePathURLs = 16;}

sealed class NSFileManagerItemReplacementOptions {
  static const NSFileManagerItemReplacementUsingNewMetadataOnly = 1;
  static const NSFileManagerItemReplacementWithoutDeletingBackupItem = 2;}

sealed class NSURLRelationship {
  static const NSURLRelationshipContains = 0;
  static const NSURLRelationshipSame = 1;
  static const NSURLRelationshipOther = 2;}

sealed class NSFileManagerUnmountOptions {
  static const NSFileManagerUnmountAllPartitionsAndEjectDisk = 1;
  static const NSFileManagerUnmountWithoutUI = 2;}

sealed class NSFileManagerResumeSyncBehavior {
  static const NSFileManagerResumeSyncBehaviorPreserveLocalChanges = 0;
  static const NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict = 1;
  static const NSFileManagerResumeSyncBehaviorDropLocalChanges = 2;}

sealed class NSFileManagerUploadLocalVersionConflictPolicy {
  static const NSFileManagerUploadConflictPolicyDefault = 0;
  static const NSFileManagerUploadConflictPolicyFailOnConflict = 1;}

sealed class NSOperationQueuePriority {
  static const NSOperationQueuePriorityVeryLow = -8;
  static const NSOperationQueuePriorityLow = -4;
  static const NSOperationQueuePriorityNormal = 0;
  static const NSOperationQueuePriorityHigh = 4;
  static const NSOperationQueuePriorityVeryHigh = 8;}


/// WARNING: NSOrthography is a stub. To generate bindings for this class, include
/// NSOrthography in your config's objc-interfaces list.
///
/// NSOrthography
extension type NSOrthography._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [NSOrthography] that points to the same underlying object as [other].
  NSOrthography.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSOrthography', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
  }

  /// Constructs a [NSOrthography] that wraps the given raw object pointer.
  NSOrthography.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSOrthography', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
  }


}


/// WARNING: NSPredicate is a stub. To generate bindings for this class, include
/// NSPredicate in your config's objc-interfaces list.
///
/// NSPredicate
extension type NSPredicate._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [NSPredicate] that points to the same underlying object as [other].
  NSPredicate.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSPredicate', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [NSPredicate] that wraps the given raw object pointer.
  NSPredicate.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSPredicate', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
  }


}

sealed class NSExpressionType {
  static const NSConstantValueExpressionType = 0;
  static const NSEvaluatedObjectExpressionType = 1;
  static const NSVariableExpressionType = 2;
  static const NSKeyPathExpressionType = 3;
  static const NSFunctionExpressionType = 4;
  static const NSUnionSetExpressionType = 5;
  static const NSIntersectSetExpressionType = 6;
  static const NSMinusSetExpressionType = 7;
  static const NSSubqueryExpressionType = 13;
  static const NSAggregateExpressionType = 14;
  static const NSAnyKeyExpressionType = 15;
  static const NSBlockExpressionType = 19;
  static const NSConditionalExpressionType = 20;}

late final _class_NSExpression = objc.getClass("NSExpression");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
late final _sel_expressionWithFormat_argumentArray_ = objc.registerName("expressionWithFormat:argumentArray:");
late final _sel_expressionWithFormat_ = objc.registerName("expressionWithFormat:");
late final _sel_expressionForConstantValue_ = objc.registerName("expressionForConstantValue:");
late final _sel_expressionForEvaluatedObject = objc.registerName("expressionForEvaluatedObject");
late final _sel_expressionForVariable_ = objc.registerName("expressionForVariable:");
late final _sel_expressionForKeyPath_ = objc.registerName("expressionForKeyPath:");
late final _sel_expressionForFunction_arguments_ = objc.registerName("expressionForFunction:arguments:");
late final _sel_expressionForAggregate_ = objc.registerName("expressionForAggregate:");
late final _sel_expressionForUnionSet_with_ = objc.registerName("expressionForUnionSet:with:");
late final _sel_expressionForIntersectSet_with_ = objc.registerName("expressionForIntersectSet:with:");
late final _sel_expressionForMinusSet_with_ = objc.registerName("expressionForMinusSet:with:");
late final _sel_expressionForSubquery_usingIteratorVariable_predicate_ = objc.registerName("expressionForSubquery:usingIteratorVariable:predicate:");
final _objc_msgSend_11spmsz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_expressionForFunction_selectorName_arguments_ = objc.registerName("expressionForFunction:selectorName:arguments:");
late final _sel_expressionForAnyKey = objc.registerName("expressionForAnyKey");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_objcObjCObjectImpl_NSArray_NSMutableDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> fromFunction(objc.ObjCObject Function(objc.ObjCObject? , objc.NSArray , objc.NSMutableDictionary? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: true, release: true), objc.NSArray.fromPointer(arg1, retain: true, release: true), arg2.address == 0 ? null : objc.NSMutableDictionary.fromPointer(arg2, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>`.
extension ObjCBlock_objcObjCObjectImpl_objcObjCObjectImpl_NSArray_NSMutableDictionary$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> {
  objc.ObjCObject call(objc.ObjCObject? arg0, objc.NSArray arg1, objc.NSMutableDictionary? arg2) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1.ref.pointer, arg2?.ref.pointer ?? ffi.nullptr), retain: true, release: true);
}

late final _sel_expressionForBlock_arguments_ = objc.registerName("expressionForBlock:arguments:");
final _objc_msgSend_27lb7c = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_expressionForConditional_trueExpression_falseExpression_ = objc.registerName("expressionForConditional:trueExpression:falseExpression:");
late final _sel_initWithExpressionType_ = objc.registerName("initWithExpressionType:");
final _objc_msgSend_1rz5npq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void> , objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true))?.ref.retainAndReturnPointer() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension on objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer).address == 0 ? null : objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer), retain: false, release: true);
}

late final _sel_expressionType = objc.registerName("expressionType");
final _objc_msgSend_1ts4niw = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_constantValue = objc.registerName("constantValue");
late final _sel_keyPath = objc.registerName("keyPath");
late final _sel_function = objc.registerName("function");
late final _sel_variable = objc.registerName("variable");
late final _sel_operand = objc.registerName("operand");
late final _sel_arguments = objc.registerName("arguments");
late final _sel_collection = objc.registerName("collection");
late final _sel_predicate = objc.registerName("predicate");
late final _sel_leftExpression = objc.registerName("leftExpression");
late final _sel_rightExpression = objc.registerName("rightExpression");
late final _sel_trueExpression = objc.registerName("trueExpression");
late final _sel_falseExpression = objc.registerName("falseExpression");
late final _sel_expressionBlock = objc.registerName("expressionBlock");
final _objc_msgSend_uwvaik = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_expressionValueWithObject_context_ = objc.registerName("expressionValueWithObject:context:");
late final _sel_allowEvaluation = objc.registerName("allowEvaluation");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.NSZone> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.NSZone> )>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_supportsSecureCoding = objc.registerName("supportsSecureCoding");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(bool Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> listener(void Function(ffi.Pointer<ffi.Void> , objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_mgl_expressionForConditional_trueExpression_falseExpresssion_ = objc.registerName("mgl_expressionForConditional:trueExpression:falseExpresssion:");
late final _sel_mgl_expressionForSteppingExpression_fromExpression_stops_ = objc.registerName("mgl_expressionForSteppingExpression:fromExpression:stops:");
late final _sel_mgl_expressionForInterpolatingExpression_withCurveType_parameters_stops_ = objc.registerName("mgl_expressionForInterpolatingExpression:withCurveType:parameters:stops:");
final _objc_msgSend_s92gih = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_mgl_expressionForMatchingExpression_inDictionary_defaultExpression_ = objc.registerName("mgl_expressionForMatchingExpression:inDictionary:defaultExpression:");
late final _sel_mgl_expressionForAttributedExpressions_ = objc.registerName("mgl_expressionForAttributedExpressions:");
late final _sel_mgl_expressionByAppendingExpression_ = objc.registerName("mgl_expressionByAppendingExpression:");
late final _sel_expressionWithMLNJSONObject_ = objc.registerName("expressionWithMLNJSONObject:");
late final _sel_zoomLevelVariableExpression = objc.registerName("zoomLevelVariableExpression");
late final _sel_heatmapDensityVariableExpression = objc.registerName("heatmapDensityVariableExpression");
late final _sel_lineProgressVariableExpression = objc.registerName("lineProgressVariableExpression");
late final _sel_geometryTypeVariableExpression = objc.registerName("geometryTypeVariableExpression");
late final _sel_featureIdentifierVariableExpression = objc.registerName("featureIdentifierVariableExpression");
late final _sel_featureAccumulatedVariableExpression = objc.registerName("featureAccumulatedVariableExpression");
late final _sel_featureAttributesVariableExpression = objc.registerName("featureAttributesVariableExpression");
late final _sel_featurePropertiesVariableExpression = objc.registerName("featurePropertiesVariableExpression");
late final _sel_mgl_jsonExpressionObject = objc.registerName("mgl_jsonExpressionObject");
late final _sel_mgl_expressionLocalizedIntoLocale_ = objc.registerName("mgl_expressionLocalizedIntoLocale:");

/// Methods for creating expressions that use Mapbox-specific functionality and for
/// converting to and from the JSON format defined in the
/// <a href="https://maplibre.org/maplibre-style-spec/expressions/">MapLibre Style Spec</a>.
extension MLNAdditions on NSExpression {

  /// Returns a copy of the receiver localized into the given locale.
/// 
/// This method assumes the receiver refers to the feature attributes that are
/// available in vector tiles supplied by the
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets-v8/#overview">Mapbox Streets
/// source</a>. On iOS, the user can set the systems preferred language in Settings, General Settings,
/// Language & Region. On macOS, the user can set the systems preferred language in the Language &
/// Region pane of System Preferences.
/// 
/// @param locale The locale into which labels should be localized. To use the
/// systems preferred language, if supported, specify `nil`. To use the local
/// language, specify a locale with the identifier `mul`.
  NSExpression mgl_expressionLocalizedIntoLocale(objc.NSLocale? locale) {
  objc.checkOsVersionInternal('NSExpression.mgl_expressionLocalizedIntoLocale:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_mgl_expressionLocalizedIntoLocale_, locale?.ref.pointer ?? ffi.nullptr);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// An equivalent Foundation object that can be serialized as JSON.
/// 
/// The Foundation object conforms to the
/// [MapLibre Style Spec](https://maplibre.org/maplibre-style-spec/expressions/).
/// See the
/// [Information for Style Authors](../for-style-authors.html#setting-attribute-values)
/// guide for a correspondence of operators and types between the style
/// specification and the `NSExpression` representation used by this SDK.
/// 
/// You can use `NSJSONSerialization` to serialize the Foundation object as data to
/// write to a file.
  objc.ObjCObject get mgl_jsonExpressionObject {
  objc.checkOsVersionInternal('NSExpression.mgl_jsonExpressionObject', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mgl_jsonExpressionObject);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// `NSExpression` variable that corresponds to the
/// <a href="https://docs.mapbox.com/mapbox-gl-js/style-spec/#accumulated"><code>id</code></a>
/// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureAccumulatedVariableExpression() {
  objc.checkOsVersionInternal('NSExpression.featureAccumulatedVariableExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_featureAccumulatedVariableExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// `NSExpression` variable that corresponds to the
/// <a
/// href="https://maplibre.org/maplibre-style-spec/expressions/#properties"><code>properties</code></a>
/// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureAttributesVariableExpression() {
  objc.checkOsVersionInternal('NSExpression.featureAttributesVariableExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_featureAttributesVariableExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// `NSExpression` variable that corresponds to the
/// <a href="https://maplibre.org/maplibre-style-spec/expressions/#id"><code>id</code></a>
/// expression operator in the MapLibre Style Spec.
  static NSExpression getFeatureIdentifierVariableExpression() {
  objc.checkOsVersionInternal('NSExpression.featureIdentifierVariableExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_featureIdentifierVariableExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// featurePropertiesVariableExpression
  static NSExpression getFeaturePropertiesVariableExpression() {
  objc.checkOsVersionInternal('NSExpression.featurePropertiesVariableExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_featurePropertiesVariableExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// `NSExpression` variable that corresponds to the
/// <a
/// href="https://maplibre.org/maplibre-style-spec/expressions/#geometry-type"><code>geometry-type</code></a>
/// expression operator in the MapLibre Style Spec.
  static NSExpression getGeometryTypeVariableExpression() {
  objc.checkOsVersionInternal('NSExpression.geometryTypeVariableExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_geometryTypeVariableExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// `NSExpression` variable that corresponds to the
/// <a
/// href="https://maplibre.org/maplibre-style-spec/expressions/#heatmap-density"><code>heatmap-density</code></a>
/// expression operator in the MapLibre Style Spec.
  static NSExpression getHeatmapDensityVariableExpression() {
  objc.checkOsVersionInternal('NSExpression.heatmapDensityVariableExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_heatmapDensityVariableExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// `NSExpression` variable that corresponds to the
/// <a
/// href="https://maplibre.org/maplibre-style-spec/expressions/#line-progress"><code>line-progress</code></a>
/// expression operator in the MapLibre Style Spec.
  static NSExpression getLineProgressVariableExpression() {
  objc.checkOsVersionInternal('NSExpression.lineProgressVariableExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_lineProgressVariableExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// `NSExpression` variable that corresponds to the
/// <a href="https://maplibre.org/maplibre-style-spec/expressions/#zoom"><code>zoom</code></a>
/// expression operator in the MapLibre Style Spec.
  static NSExpression getZoomLevelVariableExpression() {
  objc.checkOsVersionInternal('NSExpression.zoomLevelVariableExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_zoomLevelVariableExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }

}


/// NSExpression
extension type NSExpression._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [NSExpression] that points to the same underlying object as [other].
  NSExpression.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    assert(isA(object$));
  }

  /// Constructs a [NSExpression] that wraps the given raw object pointer.
  NSExpression.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSExpression].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_NSExpression);

  /// alloc
  static NSExpression alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_alloc);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static NSExpression allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_NSExpression, _sel_allocWithZone_, zone);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// expressionForAggregate:
  static NSExpression expressionForAggregate(objc.NSArray subexpressions) {
  objc.checkOsVersionInternal('NSExpression.expressionForAggregate:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionForAggregate_, subexpressions.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForAnyKey
  static NSExpression expressionForAnyKey() {
  objc.checkOsVersionInternal('NSExpression.expressionForAnyKey', iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_expressionForAnyKey);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForBlock:arguments:
  static NSExpression expressionForBlock(objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> block, {objc.NSArray? arguments}) {
  objc.checkOsVersionInternal('NSExpression.expressionForBlock:arguments:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final $ret = _objc_msgSend_27lb7c(_class_NSExpression, _sel_expressionForBlock_arguments_, block.ref.pointer, arguments?.ref.pointer ?? ffi.nullptr);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForConditional:trueExpression:falseExpression:
  static NSExpression expressionForConditional(NSPredicate predicate, {required NSExpression trueExpression,required NSExpression falseExpression}) {
  objc.checkOsVersionInternal('NSExpression.expressionForConditional:trueExpression:falseExpression:', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_expressionForConditional_trueExpression_falseExpression_, predicate.ref.pointer, trueExpression.ref.pointer, falseExpression.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForConstantValue:
  static NSExpression expressionForConstantValue(objc.ObjCObject? obj) {
  objc.checkOsVersionInternal('NSExpression.expressionForConstantValue:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionForConstantValue_, obj?.ref.pointer ?? ffi.nullptr);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForEvaluatedObject
  static NSExpression expressionForEvaluatedObject() {
  objc.checkOsVersionInternal('NSExpression.expressionForEvaluatedObject', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_expressionForEvaluatedObject);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForFunction:arguments:
  static NSExpression expressionForFunction(objc.NSString name, {required objc.NSArray arguments}) {
  objc.checkOsVersionInternal('NSExpression.expressionForFunction:arguments:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionForFunction_arguments_, name.ref.pointer, arguments.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForFunction:selectorName:arguments:
  static NSExpression expressionForFunction$1(NSExpression target, {required objc.NSString selectorName,objc.NSArray? arguments}) {
  objc.checkOsVersionInternal('NSExpression.expressionForFunction:selectorName:arguments:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_expressionForFunction_selectorName_arguments_, target.ref.pointer, selectorName.ref.pointer, arguments?.ref.pointer ?? ffi.nullptr);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForIntersectSet:with:
  static NSExpression expressionForIntersectSet(NSExpression left, {required NSExpression with$}) {
  objc.checkOsVersionInternal('NSExpression.expressionForIntersectSet:with:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionForIntersectSet_with_, left.ref.pointer, with$.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForKeyPath:
  static NSExpression expressionForKeyPath(objc.NSString keyPath) {
  objc.checkOsVersionInternal('NSExpression.expressionForKeyPath:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionForKeyPath_, keyPath.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForMinusSet:with:
  static NSExpression expressionForMinusSet(NSExpression left, {required NSExpression with$}) {
  objc.checkOsVersionInternal('NSExpression.expressionForMinusSet:with:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionForMinusSet_with_, left.ref.pointer, with$.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForSubquery:usingIteratorVariable:predicate:
  static NSExpression expressionForSubquery(NSExpression expression, {required objc.NSString usingIteratorVariable,required NSPredicate predicate}) {
  objc.checkOsVersionInternal('NSExpression.expressionForSubquery:usingIteratorVariable:predicate:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_expressionForSubquery_usingIteratorVariable_predicate_, expression.ref.pointer, usingIteratorVariable.ref.pointer, predicate.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForUnionSet:with:
  static NSExpression expressionForUnionSet(NSExpression left, {required NSExpression with$}) {
  objc.checkOsVersionInternal('NSExpression.expressionForUnionSet:with:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionForUnionSet_with_, left.ref.pointer, with$.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForVariable:
  static NSExpression expressionForVariable(objc.NSString string) {
  objc.checkOsVersionInternal('NSExpression.expressionForVariable:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionForVariable_, string.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionWithFormat:
  static NSExpression expressionWithFormat(objc.NSString expressionFormat) {
  objc.checkOsVersionInternal('NSExpression.expressionWithFormat:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionWithFormat_, expressionFormat.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionWithFormat:argumentArray:
  static NSExpression expressionWithFormat$1(objc.NSString expressionFormat, {required objc.NSArray argumentArray}) {
  objc.checkOsVersionInternal('NSExpression.expressionWithFormat:argumentArray:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionWithFormat_argumentArray_, expressionFormat.ref.pointer, argumentArray.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an expression equivalent to the given Foundation object deserialized
/// from JSON data.
/// 
/// The Foundation object is interpreted according to the
/// [MapLibre Style Spec](https://maplibre.org/maplibre-style-spec/expressions/).
/// See the
/// [Information for Style Authors](../for-style-authors.html#setting-attribute-values)
/// guide for a correspondence of operators and types between the style
/// specification and the `NSExpression` representation used by this SDK.
/// 
/// @param object A Foundation object deserialized from JSON data, for example
/// using `NSJSONSerialization`.
/// @return An initialized expression equivalent to `object`, suitable for use as
/// the value of a style layer attribute.
  static NSExpression expressionWithMLNJSONObject(objc.ObjCObject object) {
  objc.checkOsVersionInternal('NSExpression.expressionWithMLNJSONObject:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionWithMLNJSONObject_, object.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an attributed function expression specifying an ``MLNAttributedExpression`` constant
/// expression array.
/// 
/// @param attributedExpressions The ``MLNAttributedExpression`` constant expression array.
  static NSExpression mgl_expressionForAttributedExpressions(objc.NSArray attributedExpressions) {
  objc.checkOsVersionInternal('NSExpression.mgl_expressionForAttributedExpressions:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_mgl_expressionForAttributedExpressions_, attributedExpressions.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a conditional function expression specifying the string predicate, and
/// expressions for each condition.
/// 
/// @param conditionPredicate The predicate to get evaluated.
/// @param trueExpression The expression for conditions equal to true.
/// @param falseExpression The expression for conditions equal to false.
  static NSExpression mgl_expressionForConditional(NSPredicate conditionPredicate, {required NSExpression trueExpression,required NSExpression falseExpresssion}) {
  objc.checkOsVersionInternal('NSExpression.mgl_expressionForConditional:trueExpression:falseExpresssion:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_mgl_expressionForConditional_trueExpression_falseExpresssion_, conditionPredicate.ref.pointer, trueExpression.ref.pointer, falseExpresssion.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an interpolated function expression specifying the function operator, curve type,
/// parameters and steps.
/// 
/// @param inputExpression The interpolating expression input.
/// @param curveType The curve type could be ``MLNExpressionInterpolationModeLinear``,
/// ``MLNExpressionInterpolationModeExponential`` and
/// ``MLNExpressionInterpolationModeCubicBezier``.
/// @param parameters The parameters expression.
/// @param stops The stops expression.
/// 
/// #### Related examples
/// TODO: Create a heatmap layer, learn how to style an ``MLNHeatmapStyleLayer``
/// based on zoom level and point density with this expression.
  static NSExpression mgl_expressionForInterpolatingExpression(NSExpression inputExpression, {required objc.NSString withCurveType,NSExpression? parameters,required NSExpression stops}) {
  objc.checkOsVersionInternal('NSExpression.mgl_expressionForInterpolatingExpression:withCurveType:parameters:stops:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_s92gih(_class_NSExpression, _sel_mgl_expressionForInterpolatingExpression_withCurveType_parameters_stops_, inputExpression.ref.pointer, withCurveType.ref.pointer, parameters?.ref.pointer ?? ffi.nullptr, stops.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a match function expression specifying the input, matching values,
/// and default value.
/// 
/// @param inputExpression The matching expression.
/// @param matchedExpressions The matched values expression dictionary must be condition : value.
/// @param defaultExpression The defaultValue expression to be used in case there is no match.
  static NSExpression mgl_expressionForMatchingExpression(NSExpression inputExpression, {required objc.NSDictionary inDictionary,required NSExpression defaultExpression}) {
  objc.checkOsVersionInternal('NSExpression.mgl_expressionForMatchingExpression:inDictionary:defaultExpression:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_mgl_expressionForMatchingExpression_inDictionary_defaultExpression_, inputExpression.ref.pointer, inDictionary.ref.pointer, defaultExpression.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a step function expression specifying the stepping, from expression
/// and stops.
/// 
/// @param steppingExpression The stepping expression.
/// @param minimumExpression The expression which could be a constant or function expression.
/// @param stops The stops must be an `NSDictionary` constant `NSExpression`.
/// 
/// #### Related examples
/// TODO: Data-driven circles
/// TODO: Cluster point data
/// TODO: Use images to cluster point data
/// Learn how to use this expression to style a map layer based on an attribute value.
  static NSExpression mgl_expressionForSteppingExpression(NSExpression steppingExpression, {required NSExpression fromExpression,required NSExpression stops}) {
  objc.checkOsVersionInternal('NSExpression.mgl_expressionForSteppingExpression:fromExpression:stops:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_mgl_expressionForSteppingExpression_fromExpression_stops_, steppingExpression.ref.pointer, fromExpression.ref.pointer, stops.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static NSExpression new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_new);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSExpression, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of NSExpression constructed with the default `new` method.
  NSExpression() : this.as(new$().object$);

}

extension NSExpression$Methods on NSExpression {

  /// allowEvaluation
  void allowEvaluation() {
  objc.checkOsVersionInternal('NSExpression.allowEvaluation', iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_allowEvaluation);

  }


  /// arguments
  objc.NSArray? get arguments {
  objc.checkOsVersionInternal('NSExpression.arguments', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_arguments);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// collection
  objc.ObjCObject get collection {
  objc.checkOsVersionInternal('NSExpression.collection', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_collection);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// constantValue
  objc.ObjCObject? get constantValue {
  objc.checkOsVersionInternal('NSExpression.constantValue', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_constantValue);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// expressionBlock
  objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> get expressionBlock {
  objc.checkOsVersionInternal('NSExpression.expressionBlock', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final $ret = _objc_msgSend_uwvaik(object$.ref.pointer, _sel_expressionBlock);
    return ObjCBlock_objcObjCObjectImpl_objcObjCObjectImpl_NSArray_NSMutableDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// expressionType
  int get expressionType {
  objc.checkOsVersionInternal('NSExpression.expressionType', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    return _objc_msgSend_1ts4niw(object$.ref.pointer, _sel_expressionType);

  }


  /// expressionValueWithObject:context:
  objc.ObjCObject? expressionValueWithObject(objc.ObjCObject? object, {objc.NSMutableDictionary? context}) {
  objc.checkOsVersionInternal('NSExpression.expressionValueWithObject:context:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_15qeuct(object$.ref.pointer, _sel_expressionValueWithObject_context_, object?.ref.pointer ?? ffi.nullptr, context?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// falseExpression
  NSExpression get falseExpression {
  objc.checkOsVersionInternal('NSExpression.falseExpression', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_falseExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// function
  objc.NSString get function {
  objc.checkOsVersionInternal('NSExpression.function', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_function);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// init
  NSExpression init() {
  objc.checkOsVersionInternal('NSExpression.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  NSExpression? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// initWithExpressionType:
  NSExpression initWithExpressionType(int type) {
  objc.checkOsVersionInternal('NSExpression.initWithExpressionType:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1rz5npq(object$.ref.retainAndReturnPointer(), _sel_initWithExpressionType_, type);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// keyPath
  objc.NSString get keyPath {
  objc.checkOsVersionInternal('NSExpression.keyPath', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_keyPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// leftExpression
  NSExpression get leftExpression {
  objc.checkOsVersionInternal('NSExpression.leftExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leftExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a constant expression appending the passed expression.
/// 
/// > Note: Both the receiver and the given expression must be an `NSString` constant
/// expression type; otherwise, an exception is rised.
/// 
/// @param expression The expression to append to the receiver.
  NSExpression mgl_expressionByAppendingExpression(NSExpression expression) {
  objc.checkOsVersionInternal('NSExpression.mgl_expressionByAppendingExpression:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_mgl_expressionByAppendingExpression_, expression.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// operand
  NSExpression get operand {
  objc.checkOsVersionInternal('NSExpression.operand', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_operand);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// predicate
  NSPredicate get predicate {
  objc.checkOsVersionInternal('NSExpression.predicate', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_predicate);
    return NSPredicate.fromPointer($ret, retain: true, release: true);
  }


  /// rightExpression
  NSExpression get rightExpression {
  objc.checkOsVersionInternal('NSExpression.rightExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rightExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// trueExpression
  NSExpression get trueExpression {
  objc.checkOsVersionInternal('NSExpression.trueExpression', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_trueExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// variable
  objc.NSString get variable {
  objc.checkOsVersionInternal('NSExpression.variable', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_variable);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

sealed class NSFileVersionAddingOptions {
  static const NSFileVersionAddingByMoving = 1;}

sealed class NSFileVersionReplacingOptions {
  static const NSFileVersionReplacingByMoving = 1;}

sealed class NSFileWrapperReadingOptions {
  static const NSFileWrapperReadingImmediate = 1;
  static const NSFileWrapperReadingWithoutMapping = 2;}

sealed class NSFileWrapperWritingOptions {
  static const NSFileWrapperWritingAtomic = 1;
  static const NSFileWrapperWritingWithNameUpdating = 2;}


/// WARNING: NSFileWrapper is a stub. To generate bindings for this class, include
/// NSFileWrapper in your config's objc-interfaces list.
///
/// NSFileWrapper
extension type NSFileWrapper._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding {
  /// Constructs a [NSFileWrapper] that points to the same underlying object as [other].
  NSFileWrapper.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSFileWrapper', iOS: (false, (4, 0, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSFileWrapper] that wraps the given raw object pointer.
  NSFileWrapper.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSFileWrapper', iOS: (false, (4, 0, 0)), macOS: (false, (10, 0, 0)));
  }


}

late final _sel_linguisticTagsInRange_scheme_options_orthography_tokenRanges_ = objc.registerName("linguisticTagsInRange:scheme:options:orthography:tokenRanges:");
final _objc_msgSend_1l09uru = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunction(void Function(objc.NSString? , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: true, release: true), arg1, arg2, arg3), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> listener(void Function(objc.NSString? , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2, arg3), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_lmc3p5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> blocking(void Function(objc.NSString? , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2, arg3), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2, arg3), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_lmc3p5(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> {
  void call(objc.NSString? arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2, arg3);
}

late final _sel_enumerateLinguisticTagsInRange_scheme_options_orthography_usingBlock_ = objc.registerName("enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:");
final _objc_msgSend_vij4rw = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// NSLinguisticAnalysis
extension NSLinguisticAnalysis on objc.NSString {

  /// enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:
  void enumerateLinguisticTagsInRange(objc.NSRange range, {required objc.NSString scheme,required int options,NSOrthography? orthography,required objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> usingBlock}) {
  objc.checkOsVersionInternal('NSString.enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:', iOS: (false, (5, 0, 0)), macOS: (false, (10, 7, 0)));
_objc_msgSend_vij4rw(object$.ref.pointer, _sel_enumerateLinguisticTagsInRange_scheme_options_orthography_usingBlock_, range, scheme.ref.pointer, options, orthography?.ref.pointer ?? ffi.nullptr, usingBlock.ref.pointer);

  }


  /// linguisticTagsInRange:scheme:options:orthography:tokenRanges:
  objc.NSArray linguisticTagsInRange(objc.NSRange range, {required objc.NSString scheme,required int options,NSOrthography? orthography,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> tokenRanges}) {
  objc.checkOsVersionInternal('NSString.linguisticTagsInRange:scheme:options:orthography:tokenRanges:', iOS: (false, (5, 0, 0)), macOS: (false, (10, 7, 0)));
    final $ret = _objc_msgSend_1l09uru(object$.ref.pointer, _sel_linguisticTagsInRange_scheme_options_orthography_tokenRanges_, range, scheme.ref.pointer, options, orthography?.ref.pointer ?? ffi.nullptr, tokenRanges);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}


/// WARNING: NSUndoManager is a stub. To generate bindings for this class, include
/// NSUndoManager in your config's objc-interfaces list.
///
/// NSUndoManager
extension type NSUndoManager._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [NSUndoManager] that points to the same underlying object as [other].
  NSUndoManager.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSUndoManager', iOS: (false, (3, 0, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSUndoManager] that wraps the given raw object pointer.
  NSUndoManager.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUndoManager', iOS: (false, (3, 0, 0)), macOS: (false, (10, 0, 0)));
  }


}


/// WARNING: NSUserActivity is a stub. To generate bindings for this class, include
/// NSUserActivity in your config's objc-interfaces list.
///
/// NSUserActivity
extension type NSUserActivity._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [NSUserActivity] that points to the same underlying object as [other].
  NSUserActivity.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSUserActivity', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
  }

  /// Constructs a [NSUserActivity] that wraps the given raw object pointer.
  NSUserActivity.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUserActivity', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
  }


}

late final _class_Helpers = objc.getClass("Helpers");
late final _sel_addImageToStyleWithTarget_field_expression_ = objc.registerName("addImageToStyleWithTarget:field:expression:");
final _objc_msgSend_r8gdi7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_setValueWithTarget_field_value_ = objc.registerName("setValueWithTarget:field:value:");
late final _sel_parsePredicateWithRaw_ = objc.registerName("parsePredicateWithRaw:");
late final _sel_parseExpressionWithPropertyName_expression_ = objc.registerName("parseExpressionWithPropertyName:expression:");

/// Helpers
extension type Helpers._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [Helpers] that points to the same underlying object as [other].
  Helpers.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [Helpers] that wraps the given raw object pointer.
  Helpers.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [Helpers].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_Helpers);

  /// addImageToStyleWithTarget:field:expression:
  static void addImageToStyleWithTarget(objc.NSObject target, {required objc.NSString field,required NSExpression expression}) {
_objc_msgSend_r8gdi7(_class_Helpers, _sel_addImageToStyleWithTarget_field_expression_, target.ref.pointer, field.ref.pointer, expression.ref.pointer);

  }


  /// alloc
  static Helpers alloc() {
    final $ret = _objc_msgSend_151sglz(_class_Helpers, _sel_alloc);
    return Helpers.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static Helpers allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_Helpers, _sel_allocWithZone_, zone);
    return Helpers.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static Helpers new$() {
    final $ret = _objc_msgSend_151sglz(_class_Helpers, _sel_new);
    return Helpers.fromPointer($ret, retain: false, release: true);
  }


  /// parseExpressionWithPropertyName:expression:
  static NSExpression? parseExpressionWithPropertyName(objc.NSString propertyName, {required objc.NSString expression}) {
    final $ret = _objc_msgSend_15qeuct(_class_Helpers, _sel_parseExpressionWithPropertyName_expression_, propertyName.ref.pointer, expression.ref.pointer);
    return $ret.address == 0 ? null : NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// parsePredicateWithRaw:
  static NSPredicate? parsePredicateWithRaw(objc.NSString raw) {
    final $ret = _objc_msgSend_1sotr3r(_class_Helpers, _sel_parsePredicateWithRaw_, raw.ref.pointer);
    return $ret.address == 0 ? null : NSPredicate.fromPointer($ret, retain: true, release: true);
  }


  /// setValueWithTarget:field:value:
  static void setValueWithTarget(objc.NSObject target, {required objc.NSString field,required objc.NSObject value}) {
_objc_msgSend_r8gdi7(_class_Helpers, _sel_setValueWithTarget_field_value_, target.ref.pointer, field.ref.pointer, value.ref.pointer);

  }
  /// Returns a new instance of Helpers constructed with the default `new` method.
  Helpers() : this.as(new$().object$);

}

extension Helpers$Methods on Helpers {

  /// init
  Helpers init() {
  objc.checkOsVersionInternal('Helpers.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return Helpers.fromPointer($ret, retain: false, release: true);
  }

}

late final _class_MapLibreRegistry = objc.getClass("MapLibreRegistry");
late final _sel_getMapWithViewId_ = objc.registerName("getMapWithViewId:");
final _objc_msgSend_1ya1kjn = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Int64 )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_activity = objc.registerName("activity");
late final _sel_setActivity_ = objc.registerName("setActivity:");
late final _sel_context = objc.registerName("context");
late final _sel_setContext_ = objc.registerName("setContext:");

/// MapLibreRegistry
extension type MapLibreRegistry._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MapLibreRegistry] that points to the same underlying object as [other].
  MapLibreRegistry.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MapLibreRegistry] that wraps the given raw object pointer.
  MapLibreRegistry.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MapLibreRegistry].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MapLibreRegistry);

  /// activity
  static objc.ObjCObject? getActivity() {
    final $ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_activity);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// alloc
  static MapLibreRegistry alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_alloc);
    return MapLibreRegistry.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MapLibreRegistry allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MapLibreRegistry, _sel_allocWithZone_, zone);
    return MapLibreRegistry.fromPointer($ret, retain: false, release: true);
  }


  /// context
  static objc.ObjCObject? getContext() {
    final $ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_context);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// getMapWithViewId:
  static objc.ObjCObject? getMapWithViewId(int viewId) {
    final $ret = _objc_msgSend_1ya1kjn(_class_MapLibreRegistry, _sel_getMapWithViewId_, viewId);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// new
  static MapLibreRegistry new$() {
    final $ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_new);
    return MapLibreRegistry.fromPointer($ret, retain: false, release: true);
  }


  /// setActivity:
  static void setActivity(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(_class_MapLibreRegistry, _sel_setActivity_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setContext:
  static void setContext(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(_class_MapLibreRegistry, _sel_setContext_, value?.ref.pointer ?? ffi.nullptr);

  }
  /// Returns a new instance of MapLibreRegistry constructed with the default `new` method.
  MapLibreRegistry() : this.as(new$().object$);

}

extension MapLibreRegistry$Methods on MapLibreRegistry {

  /// init
  MapLibreRegistry init() {
  objc.checkOsVersionInternal('MapLibreRegistry.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MapLibreRegistry.fromPointer($ret, retain: false, release: true);
  }

}

final class __IOSurface extends ffi.Opaque{
}

final class CGContext extends ffi.Opaque{
}

final class CGColor extends ffi.Opaque{
}

final class CGColorSpace extends ffi.Opaque{
}

final class CGImage extends ffi.Opaque{
}

final class CGPath extends ffi.Opaque{
}

sealed class CGLineJoin {
  static const kCGLineJoinMiter = 0;
  static const kCGLineJoinRound = 1;
  static const kCGLineJoinBevel = 2;}

sealed class CGLineCap {
  static const kCGLineCapButt = 0;
  static const kCGLineCapRound = 1;
  static const kCGLineCapSquare = 2;}

sealed class CGBlendMode {
  static const kCGBlendModeNormal = 0;
  static const kCGBlendModeMultiply = 1;
  static const kCGBlendModeScreen = 2;
  static const kCGBlendModeOverlay = 3;
  static const kCGBlendModeDarken = 4;
  static const kCGBlendModeLighten = 5;
  static const kCGBlendModeColorDodge = 6;
  static const kCGBlendModeColorBurn = 7;
  static const kCGBlendModeSoftLight = 8;
  static const kCGBlendModeHardLight = 9;
  static const kCGBlendModeDifference = 10;
  static const kCGBlendModeExclusion = 11;
  static const kCGBlendModeHue = 12;
  static const kCGBlendModeSaturation = 13;
  static const kCGBlendModeColor = 14;
  static const kCGBlendModeLuminosity = 15;
  static const kCGBlendModeClear = 16;
  static const kCGBlendModeCopy = 17;
  static const kCGBlendModeSourceIn = 18;
  static const kCGBlendModeSourceOut = 19;
  static const kCGBlendModeSourceAtop = 20;
  static const kCGBlendModeDestinationOver = 21;
  static const kCGBlendModeDestinationIn = 22;
  static const kCGBlendModeDestinationOut = 23;
  static const kCGBlendModeDestinationAtop = 24;
  static const kCGBlendModeXOR = 25;
  static const kCGBlendModePlusDarker = 26;
  static const kCGBlendModePlusLighter = 27;}

final class CGLayer extends ffi.Opaque{
}

sealed class UIRectEdge {
  static const UIRectEdgeNone = 0;
  static const UIRectEdgeTop = 1;
  static const UIRectEdgeLeft = 2;
  static const UIRectEdgeBottom = 4;
  static const UIRectEdgeRight = 8;
  static const UIRectEdgeAll = 15;}

sealed class UIAxis {
  static const UIAxisNeither = 0;
  static const UIAxisHorizontal = 1;
  static const UIAxisVertical = 2;
  static const UIAxisBoth = 3;}

final class UIEdgeInsets extends ffi.Struct{
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double left;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double right;

}

final class NSDirectionalEdgeInsets extends ffi.Struct{
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double leading;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double trailing;

}

final class UIOffset extends ffi.Struct{
  @ffi.Double()
  external double horizontal;

  @ffi.Double()
  external double vertical;

}

sealed class UIRectCorner {
  static const UIRectCornerTopLeft = 1;
  static const UIRectCornerTopRight = 2;
  static const UIRectCornerBottomLeft = 4;
  static const UIRectCornerBottomRight = 8;
  static const UIRectCornerAllCorners = -1;}

sealed class NSDirectionalRectEdge {
  static const NSDirectionalRectEdgeNone = 0;
  static const NSDirectionalRectEdgeTop = 1;
  static const NSDirectionalRectEdgeLeading = 2;
  static const NSDirectionalRectEdgeBottom = 4;
  static const NSDirectionalRectEdgeTrailing = 8;
  static const NSDirectionalRectEdgeAll = 15;}


/// WARNING: UIBezierPath is a stub. To generate bindings for this class, include
/// UIBezierPath in your config's objc-interfaces list.
///
/// UIBezierPath
extension type UIBezierPath._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [UIBezierPath] that points to the same underlying object as [other].
  UIBezierPath.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIBezierPath', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIBezierPath] that wraps the given raw object pointer.
  UIBezierPath.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBezierPath', iOS: (false, (3, 2, 0)));
  }


}

final class __CVBuffer extends ffi.Opaque{
}

final class CGImageSource extends ffi.Opaque{
}

sealed class CGImagePropertyOrientation {
  static const kCGImagePropertyOrientationUp = 1;
  static const kCGImagePropertyOrientationUpMirrored = 2;
  static const kCGImagePropertyOrientationDown = 3;
  static const kCGImagePropertyOrientationDownMirrored = 4;
  static const kCGImagePropertyOrientationLeftMirrored = 5;
  static const kCGImagePropertyOrientationRight = 6;
  static const kCGImagePropertyOrientationRightMirrored = 7;
  static const kCGImagePropertyOrientationLeft = 8;}


/// WARNING: CIImage is a stub. To generate bindings for this class, include
/// CIImage in your config's objc-interfaces list.
///
/// CIImage
extension type CIImage._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [CIImage] that points to the same underlying object as [other].
  CIImage.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CIImage', iOS: (false, (5, 0, 0)));
  }

  /// Constructs a [CIImage] that wraps the given raw object pointer.
  CIImage.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIImage', iOS: (false, (5, 0, 0)));
  }


}

sealed class UIColorProminence {
  static const UIColorProminencePrimary = 0;
  static const UIColorProminenceSecondary = 1;
  static const UIColorProminenceTertiary = 2;
  static const UIColorProminenceQuaternary = 3;}


/// WARNING: UIColor is a stub. To generate bindings for this class, include
/// UIColor in your config's objc-interfaces list.
///
/// UIColor
extension type UIColor._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [UIColor] that points to the same underlying object as [other].
  UIColor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIColor] that wraps the given raw object pointer.
  UIColor.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }


}

sealed class UIFontDescriptorSymbolicTraits {
  static const UIFontDescriptorTraitItalic = 1;
  static const UIFontDescriptorTraitBold = 2;
  static const UIFontDescriptorTraitExpanded = 32;
  static const UIFontDescriptorTraitCondensed = 64;
  static const UIFontDescriptorTraitMonoSpace = 1024;
  static const UIFontDescriptorTraitVertical = 2048;
  static const UIFontDescriptorTraitUIOptimized = 4096;
  static const UIFontDescriptorTraitTightLeading = 32768;
  static const UIFontDescriptorTraitLooseLeading = 65536;
  static const UIFontDescriptorClassMask = -268435456;
  static const UIFontDescriptorClassUnknown = 0;
  static const UIFontDescriptorClassOldStyleSerifs = 268435456;
  static const UIFontDescriptorClassTransitionalSerifs = 536870912;
  static const UIFontDescriptorClassModernSerifs = 805306368;
  static const UIFontDescriptorClassClarendonSerifs = 1073741824;
  static const UIFontDescriptorClassSlabSerifs = 1342177280;
  static const UIFontDescriptorClassFreeformSerifs = 1879048192;
  static const UIFontDescriptorClassSansSerif = -2147483648;
  static const UIFontDescriptorClassOrnamentals = -1879048192;
  static const UIFontDescriptorClassScripts = -1610612736;
  static const UIFontDescriptorClassSymbolic = -1073741824;}


/// WARNING: UIFont is a stub. To generate bindings for this class, include
/// UIFont in your config's objc-interfaces list.
///
/// UIFont
extension type UIFont._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [UIFont] that points to the same underlying object as [other].
  UIFont.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIFont', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIFont] that wraps the given raw object pointer.
  UIFont.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFont', iOS: (false, (2, 0, 0)));
  }


}


/// WARNING: UIItemProviderPresentationSizeProviding is a stub. To generate bindings for this class, include
/// UIItemProviderPresentationSizeProviding in your config's objc-protocols list.
///
/// UIItemProviderPresentationSizeProviding
extension type UIItemProviderPresentationSizeProviding._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIItemProviderPresentationSizeProviding] that points to the same underlying object as [other].
  UIItemProviderPresentationSizeProviding.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIItemProviderPresentationSizeProviding] that wraps the given raw object pointer.
  UIItemProviderPresentationSizeProviding.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// WARNING: NSTextAttachmentLayout is a stub. To generate bindings for this class, include
/// NSTextAttachmentLayout in your config's objc-protocols list.
///
/// NSTextAttachmentLayout
extension type NSTextAttachmentLayout._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSTextAttachmentLayout] that points to the same underlying object as [other].
  NSTextAttachmentLayout.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSTextAttachmentLayout] that wraps the given raw object pointer.
  NSTextAttachmentLayout.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// WARNING: NSTextAttachment is a stub. To generate bindings for this class, include
/// NSTextAttachment in your config's objc-interfaces list.
///
/// NSTextAttachment
extension type NSTextAttachment._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,NSTextAttachmentLayout,objc.NSSecureCoding {
  /// Constructs a [NSTextAttachment] that points to the same underlying object as [other].
  NSTextAttachment.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSTextAttachment', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSTextAttachment] that wraps the given raw object pointer.
  NSTextAttachment.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSTextAttachment', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
  }


}

late final _sel_attributedStringWithAttachment_ = objc.registerName("attributedStringWithAttachment:");
late final _sel_attributedStringWithAttachment_attributes_ = objc.registerName("attributedStringWithAttachment:attributes:");

/// NSAttributedStringAttachmentConveniences
extension NSAttributedStringAttachmentConveniences on objc.NSAttributedString {

  /// attributedStringWithAttachment:
  static objc.NSAttributedString attributedStringWithAttachment(NSTextAttachment attachment) {
  objc.checkOsVersionInternal('NSAttributedString.attributedStringWithAttachment:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSAttributedString, _sel_attributedStringWithAttachment_, attachment.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// attributedStringWithAttachment:attributes:
  static objc.NSAttributedString attributedStringWithAttachment$1(NSTextAttachment attachment, {required objc.NSDictionary attributes}) {
  objc.checkOsVersionInternal('NSAttributedString.attributedStringWithAttachment:attributes:', iOS: (false, (18, 0, 0)), macOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSAttributedString, _sel_attributedStringWithAttachment_attributes_, attachment.ref.pointer, attributes.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }

}

sealed class UIImageOrientation {
  static const UIImageOrientationUp = 0;
  static const UIImageOrientationDown = 1;
  static const UIImageOrientationLeft = 2;
  static const UIImageOrientationRight = 3;
  static const UIImageOrientationUpMirrored = 4;
  static const UIImageOrientationDownMirrored = 5;
  static const UIImageOrientationLeftMirrored = 6;
  static const UIImageOrientationRightMirrored = 7;}

sealed class UIImageResizingMode {
  static const UIImageResizingModeTile = 0;
  static const UIImageResizingModeStretch = 1;}

sealed class UIImageRenderingMode {
  static const UIImageRenderingModeAutomatic = 0;
  static const UIImageRenderingModeAlwaysOriginal = 1;
  static const UIImageRenderingModeAlwaysTemplate = 2;}

late final _class_UIImage = objc.getClass("UIImage");
late final _sel_systemImageNamed_ = objc.registerName("systemImageNamed:");

/// WARNING: UIImageConfiguration is a stub. To generate bindings for this class, include
/// UIImageConfiguration in your config's objc-interfaces list.
///
/// UIImageConfiguration
extension type UIImageConfiguration._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [UIImageConfiguration] that points to the same underlying object as [other].
  UIImageConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIImageConfiguration', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIImageConfiguration] that wraps the given raw object pointer.
  UIImageConfiguration.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImageConfiguration', iOS: (false, (13, 0, 0)));
  }


}

late final _sel_systemImageNamed_withConfiguration_ = objc.registerName("systemImageNamed:withConfiguration:");

/// WARNING: UITraitCollection is a stub. To generate bindings for this class, include
/// UITraitCollection in your config's objc-interfaces list.
///
/// UITraitCollection
extension type UITraitCollection._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [UITraitCollection] that points to the same underlying object as [other].
  UITraitCollection.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITraitCollection', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UITraitCollection] that wraps the given raw object pointer.
  UITraitCollection.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITraitCollection', iOS: (false, (8, 0, 0)));
  }


}

late final _sel_systemImageNamed_compatibleWithTraitCollection_ = objc.registerName("systemImageNamed:compatibleWithTraitCollection:");
late final _sel_systemImageNamed_variableValue_withConfiguration_ = objc.registerName("systemImageNamed:variableValue:withConfiguration:");
final _objc_msgSend_17i4wqy = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_imageNamed_ = objc.registerName("imageNamed:");
late final _sel_imageNamed_inBundle_withConfiguration_ = objc.registerName("imageNamed:inBundle:withConfiguration:");
late final _sel_imageNamed_inBundle_compatibleWithTraitCollection_ = objc.registerName("imageNamed:inBundle:compatibleWithTraitCollection:");
late final _sel_imageNamed_inBundle_variableValue_withConfiguration_ = objc.registerName("imageNamed:inBundle:variableValue:withConfiguration:");
final _objc_msgSend_1vft1l4 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_imageWithContentsOfFile_ = objc.registerName("imageWithContentsOfFile:");
late final _sel_imageWithData_ = objc.registerName("imageWithData:");
late final _sel_imageWithData_scale_ = objc.registerName("imageWithData:scale:");
final _objc_msgSend_6plvbo = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double )>();
late final _sel_imageWithCGImage_ = objc.registerName("imageWithCGImage:");
final _objc_msgSend_2tjjtl = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CGImage> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CGImage> )>();
late final _sel_imageWithCGImage_scale_orientation_ = objc.registerName("imageWithCGImage:scale:orientation:");
final _objc_msgSend_16go90j = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CGImage> , ffi.Double , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CGImage> , double , int )>();
late final _sel_imageWithCIImage_ = objc.registerName("imageWithCIImage:");
late final _sel_imageWithCIImage_scale_orientation_ = objc.registerName("imageWithCIImage:scale:orientation:");
final _objc_msgSend_2xggvt = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , int )>();
late final _sel_initWithData_ = objc.registerName("initWithData:");
late final _sel_initWithData_scale_ = objc.registerName("initWithData:scale:");
late final _sel_initWithCGImage_ = objc.registerName("initWithCGImage:");
late final _sel_initWithCGImage_scale_orientation_ = objc.registerName("initWithCGImage:scale:orientation:");
late final _sel_initWithCIImage_ = objc.registerName("initWithCIImage:");
late final _sel_initWithCIImage_scale_orientation_ = objc.registerName("initWithCIImage:scale:orientation:");
late final _sel_size = objc.registerName("size");
final _objc_msgSend_1vdfken = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_CGImage = objc.registerName("CGImage");
final _objc_msgSend_y1izi1 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<CGImage> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<CGImage> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_CIImage = objc.registerName("CIImage");
late final _sel_imageOrientation = objc.registerName("imageOrientation");
final _objc_msgSend_fkvhxy = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_scale = objc.registerName("scale");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer.cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_isSymbolImage = objc.registerName("isSymbolImage");
late final _sel_animatedImageNamed_duration_ = objc.registerName("animatedImageNamed:duration:");
late final _sel_animatedResizableImageNamed_capInsets_duration_ = objc.registerName("animatedResizableImageNamed:capInsets:duration:");
final _objc_msgSend_lxcnyc = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , double )>();
late final _sel_animatedResizableImageNamed_capInsets_resizingMode_duration_ = objc.registerName("animatedResizableImageNamed:capInsets:resizingMode:duration:");
final _objc_msgSend_25drz7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , ffi.Long , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , int , double )>();
late final _sel_animatedImageWithImages_duration_ = objc.registerName("animatedImageWithImages:duration:");
late final _sel_images = objc.registerName("images");
late final _sel_duration = objc.registerName("duration");
late final _sel_drawAtPoint_ = objc.registerName("drawAtPoint:");
final _objc_msgSend_iy8iz6 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint )>();
late final _sel_drawAtPoint_blendMode_alpha_ = objc.registerName("drawAtPoint:blendMode:alpha:");
final _objc_msgSend_yg3i7f = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Int32 , ffi.Double )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , int , double )>();
late final _sel_drawInRect_ = objc.registerName("drawInRect:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect )>();
late final _sel_drawInRect_blendMode_alpha_ = objc.registerName("drawInRect:blendMode:alpha:");
final _objc_msgSend_1ggt4c3 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Int32 , ffi.Double )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , int , double )>();
late final _sel_drawAsPatternInRect_ = objc.registerName("drawAsPatternInRect:");
late final _sel_resizableImageWithCapInsets_ = objc.registerName("resizableImageWithCapInsets:");
final _objc_msgSend_1mhd1pt = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets )>();
late final _sel_resizableImageWithCapInsets_resizingMode_ = objc.registerName("resizableImageWithCapInsets:resizingMode:");
final _objc_msgSend_1utaosa = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets , int )>();
late final _sel_capInsets = objc.registerName("capInsets");
final _objc_msgSend_ct4cu5 = objc.msgSendPointer.cast<ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_ct4cu5Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<UIEdgeInsets> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<UIEdgeInsets> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_resizingMode = objc.registerName("resizingMode");
final _objc_msgSend_knxebs = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_imageWithAlignmentRectInsets_ = objc.registerName("imageWithAlignmentRectInsets:");
late final _sel_alignmentRectInsets = objc.registerName("alignmentRectInsets");
late final _sel_imageWithRenderingMode_ = objc.registerName("imageWithRenderingMode:");
final _objc_msgSend_1o8rmw3 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_renderingMode = objc.registerName("renderingMode");
final _objc_msgSend_s2io2v = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// WARNING: UIGraphicsImageRendererFormat is a stub. To generate bindings for this class, include
/// UIGraphicsImageRendererFormat in your config's objc-interfaces list.
///
/// UIGraphicsImageRendererFormat
extension type UIGraphicsImageRendererFormat._(objc.ObjCObject object$) implements objc.ObjCObject,UIGraphicsRendererFormat {
  /// Constructs a [UIGraphicsImageRendererFormat] that points to the same underlying object as [other].
  UIGraphicsImageRendererFormat.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIGraphicsImageRendererFormat', iOS: (false, (10, 0, 0)));
  }

  /// Constructs a [UIGraphicsImageRendererFormat] that wraps the given raw object pointer.
  UIGraphicsImageRendererFormat.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIGraphicsImageRendererFormat', iOS: (false, (10, 0, 0)));
  }


}

late final _sel_imageRendererFormat = objc.registerName("imageRendererFormat");
late final _sel_traitCollection = objc.registerName("traitCollection");

/// WARNING: UIImageAsset is a stub. To generate bindings for this class, include
/// UIImageAsset in your config's objc-interfaces list.
///
/// UIImageAsset
extension type UIImageAsset._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding {
  /// Constructs a [UIImageAsset] that points to the same underlying object as [other].
  UIImageAsset.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIImageAsset', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UIImageAsset] that wraps the given raw object pointer.
  UIImageAsset.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImageAsset', iOS: (false, (8, 0, 0)));
  }


}

late final _sel_imageAsset = objc.registerName("imageAsset");
late final _sel_imageFlippedForRightToLeftLayoutDirection = objc.registerName("imageFlippedForRightToLeftLayoutDirection");
late final _sel_flipsForRightToLeftLayoutDirection = objc.registerName("flipsForRightToLeftLayoutDirection");
late final _sel_imageWithHorizontallyFlippedOrientation = objc.registerName("imageWithHorizontallyFlippedOrientation");
late final _sel_baselineOffsetFromBottom = objc.registerName("baselineOffsetFromBottom");
late final _sel_hasBaseline = objc.registerName("hasBaseline");
late final _sel_imageWithBaselineOffsetFromBottom_ = objc.registerName("imageWithBaselineOffsetFromBottom:");
final _objc_msgSend_oa8mke = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double )>();
late final _sel_imageWithoutBaseline = objc.registerName("imageWithoutBaseline");
late final _sel_configuration = objc.registerName("configuration");
late final _sel_imageWithConfiguration_ = objc.registerName("imageWithConfiguration:");

/// WARNING: UIImageSymbolConfiguration is a stub. To generate bindings for this class, include
/// UIImageSymbolConfiguration in your config's objc-interfaces list.
///
/// UIImageSymbolConfiguration
extension type UIImageSymbolConfiguration._(objc.ObjCObject object$) implements objc.ObjCObject,UIImageConfiguration {
  /// Constructs a [UIImageSymbolConfiguration] that points to the same underlying object as [other].
  UIImageSymbolConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIImageSymbolConfiguration', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIImageSymbolConfiguration] that wraps the given raw object pointer.
  UIImageSymbolConfiguration.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImageSymbolConfiguration', iOS: (false, (13, 0, 0)));
  }


}

late final _sel_symbolConfiguration = objc.registerName("symbolConfiguration");
late final _sel_imageByApplyingSymbolConfiguration_ = objc.registerName("imageByApplyingSymbolConfiguration:");
late final _sel_imageWithTintColor_ = objc.registerName("imageWithTintColor:");
late final _sel_imageWithTintColor_renderingMode_ = objc.registerName("imageWithTintColor:renderingMode:");
final _objc_msgSend_15gm1s5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
late final _sel_imageByPreparingForDisplay = objc.registerName("imageByPreparingForDisplay");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIImage?)>`.
abstract final class ObjCBlock_ffiVoid_UIImage {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIImage?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(UIImage?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIImage?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(UIImage?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIImage?)> fromFunction(void Function(UIImage? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UIImage?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0 ? null : UIImage.fromPointer(arg0, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIImage?)> listener(void Function(UIImage? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0 ? null : UIImage.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIImage?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIImage?)> blocking(void Function(UIImage? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0 ? null : UIImage.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0 ? null : UIImage.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIImage?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIImage?)>`.
extension ObjCBlock_ffiVoid_UIImage$CallExtension on objc.ObjCBlock<ffi.Void Function(UIImage?)> {
  void call(UIImage? arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_prepareForDisplayWithCompletionHandler_ = objc.registerName("prepareForDisplayWithCompletionHandler:");
final _objc_msgSend_f167m6 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_imageByPreparingThumbnailOfSize_ = objc.registerName("imageByPreparingThumbnailOfSize:");
final _objc_msgSend_1c2zpn3 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize )>();
late final _sel_prepareThumbnailOfSize_completionHandler_ = objc.registerName("prepareThumbnailOfSize:completionHandler:");
final _objc_msgSend_1awx4w = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_isHighDynamicRange = objc.registerName("isHighDynamicRange");
late final _sel_imageRestrictedToStandardDynamicRange = objc.registerName("imageRestrictedToStandardDynamicRange");
late final _sel_actionsImage = objc.registerName("actionsImage");
late final _sel_addImage = objc.registerName("addImage");
late final _sel_removeImage = objc.registerName("removeImage");
late final _sel_checkmarkImage = objc.registerName("checkmarkImage");
late final _sel_strokedCheckmarkImage = objc.registerName("strokedCheckmarkImage");

/// PreconfiguredSystemImages
extension PreconfiguredSystemImages on UIImage {

  /// actionsImage
  static UIImage getActionsImage() {
  objc.checkOsVersionInternal('UIImage.actionsImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_actionsImage);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// addImage
  static UIImage getAddImage() {
  objc.checkOsVersionInternal('UIImage.addImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_addImage);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// checkmarkImage
  static UIImage getCheckmarkImage() {
  objc.checkOsVersionInternal('UIImage.checkmarkImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_checkmarkImage);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// removeImage
  static UIImage getRemoveImage() {
  objc.checkOsVersionInternal('UIImage.removeImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_removeImage);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// strokedCheckmarkImage
  static UIImage getStrokedCheckmarkImage() {
  objc.checkOsVersionInternal('UIImage.strokedCheckmarkImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_strokedCheckmarkImage);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_preferredPresentationSizeForItemProvider = objc.registerName("preferredPresentationSizeForItemProvider");

/// Construction methods for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGSize_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.CGSize Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static objc.CGSize _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<objc.CGSize Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static objc.CGSize _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as objc.CGSize Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGSize_ffiVoid$CallExtension on objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> {
  objc.CGSize call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}


/// NSItemProvider
extension NSItemProvider$1 on UIImage {

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  int itemProviderVisibilityForRepresentationWithTypeIdentifier(objc.NSString typeIdentifier) {
  objc.checkOsVersionInternal('UIImage.itemProviderVisibilityForRepresentationWithTypeIdentifier:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('UIImage', 'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    return _objc_msgSend_16fy0up(object$.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_, typeIdentifier.ref.pointer);

  }


  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  objc.NSProgress? loadDataWithTypeIdentifier(objc.NSString typeIdentifier, {required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> forItemProviderCompletionHandler}) {
  objc.checkOsVersionInternal('UIImage.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_r0bo0s(object$.ref.pointer, _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_, typeIdentifier.ref.pointer, forItemProviderCompletionHandler.ref.pointer);
    return $ret.address == 0 ? null : objc.NSProgress.fromPointer($ret, retain: true, release: true);
  }


  /// preferredPresentationSizeForItemProvider
  objc.CGSize get preferredPresentationSizeForItemProvider {
  objc.checkOsVersionInternal('UIImage.preferredPresentationSizeForItemProvider', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1vdfkenStret($ptr, object$.ref.pointer, _sel_preferredPresentationSizeForItemProvider) : $ptr.ref = _objc_msgSend_1vdfken(object$.ref.pointer, _sel_preferredPresentationSizeForItemProvider);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider {
  objc.checkOsVersionInternal('UIImage.writableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException('UIImage', 'writableTypeIdentifiersForItemProvider');
    }
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static int itemProviderVisibilityForRepresentationWithTypeIdentifier$1(objc.NSString typeIdentifier) {
  objc.checkOsVersionInternal('UIImage.itemProviderVisibilityForRepresentationWithTypeIdentifier:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(_class_UIImage, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('UIImage', 'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    return _objc_msgSend_16fy0up(_class_UIImage, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_, typeIdentifier.ref.pointer);

  }


  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
  objc.checkOsVersionInternal('UIImage.readableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider$1() {
  objc.checkOsVersionInternal('UIImage.writableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_stretchableImageWithLeftCapWidth_topCapHeight_ = objc.registerName("stretchableImageWithLeftCapWidth:topCapHeight:");
final _objc_msgSend_1nzyvs1 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , int )>();
late final _sel_leftCapWidth = objc.registerName("leftCapWidth");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_topCapHeight = objc.registerName("topCapHeight");

/// UIImageDeprecated
extension UIImageDeprecated on UIImage {

  /// leftCapWidth
  int get leftCapWidth {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_leftCapWidth);

  }


  /// stretchableImageWithLeftCapWidth:topCapHeight:
  UIImage stretchableImageWithLeftCapWidth(int leftCapWidth, {required int topCapHeight}) {
    final $ret = _objc_msgSend_1nzyvs1(object$.ref.pointer, _sel_stretchableImageWithLeftCapWidth_topCapHeight_, leftCapWidth, topCapHeight);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// topCapHeight
  int get topCapHeight {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_topCapHeight);

  }

}

late final _sel_accessibilityIdentifier = objc.registerName("accessibilityIdentifier");

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.NSString? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid$1$CallExtension on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : objc.NSString.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_setAccessibilityIdentifier_ = objc.registerName("setAccessibilityIdentifier:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.NSString? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.NSString.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> listener(void Function(ffi.Pointer<ffi.Void> , objc.NSString? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.NSString.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.NSString? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.NSString.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.NSString.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSString$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSString? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}


/// WARNING: UIAccessibilityIdentification is a stub. To generate bindings for this class, include
/// UIAccessibilityIdentification in your config's objc-protocols list.
///
/// UIAccessibilityIdentification
extension type UIAccessibilityIdentification._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAccessibilityIdentification] that points to the same underlying object as [other].
  UIAccessibilityIdentification.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAccessibilityIdentification] that wraps the given raw object pointer.
  UIAccessibilityIdentification.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// UIAccessibility
extension UIAccessibility on UIImage {

  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
  objc.checkOsVersionInternal('UIImage.accessibilityIdentifier', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_accessibilityIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
  objc.checkOsVersionInternal('UIImage.setAccessibilityIdentifier:', iOS: (false, (5, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAccessibilityIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}


/// UIImage
extension type UIImage._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding {
  /// Constructs a [UIImage] that points to the same underlying object as [other].
  UIImage.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIImage', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIImage] that wraps the given raw object pointer.
  UIImage.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImage', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIImage].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIImage);

  /// alloc
  static UIImage alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_alloc);
    return UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIImage allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIImage, _sel_allocWithZone_, zone);
    return UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// animatedImageNamed:duration:
  static UIImage? animatedImageNamed(objc.NSString name, {required double duration}) {
  objc.checkOsVersionInternal('UIImage.animatedImageNamed:duration:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_6plvbo(_class_UIImage, _sel_animatedImageNamed_duration_, name.ref.pointer, duration);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// animatedImageWithImages:duration:
  static UIImage? animatedImageWithImages(objc.NSArray images, {required double duration}) {
  objc.checkOsVersionInternal('UIImage.animatedImageWithImages:duration:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_6plvbo(_class_UIImage, _sel_animatedImageWithImages_duration_, images.ref.pointer, duration);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// animatedResizableImageNamed:capInsets:duration:
  static UIImage? animatedResizableImageNamed(objc.NSString name, {required UIEdgeInsets capInsets,required double duration}) {
  objc.checkOsVersionInternal('UIImage.animatedResizableImageNamed:capInsets:duration:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_lxcnyc(_class_UIImage, _sel_animatedResizableImageNamed_capInsets_duration_, name.ref.pointer, capInsets, duration);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// animatedResizableImageNamed:capInsets:resizingMode:duration:
  static UIImage? animatedResizableImageNamed$1(objc.NSString name, {required UIEdgeInsets capInsets,required int resizingMode,required double duration}) {
  objc.checkOsVersionInternal('UIImage.animatedResizableImageNamed:capInsets:resizingMode:duration:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_25drz7(_class_UIImage, _sel_animatedResizableImageNamed_capInsets_resizingMode_duration_, name.ref.pointer, capInsets, resizingMode, duration);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageNamed:
  static UIImage? imageNamed(objc.NSString name) {
  objc.checkOsVersionInternal('UIImage.imageNamed:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIImage, _sel_imageNamed_, name.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageNamed:inBundle:compatibleWithTraitCollection:
  static UIImage? imageNamed$1(objc.NSString name, {objc.NSBundle? inBundle,UITraitCollection? compatibleWithTraitCollection}) {
  objc.checkOsVersionInternal('UIImage.imageNamed:inBundle:compatibleWithTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_UIImage, _sel_imageNamed_inBundle_compatibleWithTraitCollection_, name.ref.pointer, inBundle?.ref.pointer ?? ffi.nullptr, compatibleWithTraitCollection?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageNamed:inBundle:variableValue:withConfiguration:
  static UIImage? imageNamed$2(objc.NSString name, {objc.NSBundle? inBundle,required double variableValue,UIImageConfiguration? withConfiguration}) {
  objc.checkOsVersionInternal('UIImage.imageNamed:inBundle:variableValue:withConfiguration:', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_1vft1l4(_class_UIImage, _sel_imageNamed_inBundle_variableValue_withConfiguration_, name.ref.pointer, inBundle?.ref.pointer ?? ffi.nullptr, variableValue, withConfiguration?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageNamed:inBundle:withConfiguration:
  static UIImage? imageNamed$3(objc.NSString name, {objc.NSBundle? inBundle,UIImageConfiguration? withConfiguration}) {
  objc.checkOsVersionInternal('UIImage.imageNamed:inBundle:withConfiguration:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_UIImage, _sel_imageNamed_inBundle_withConfiguration_, name.ref.pointer, inBundle?.ref.pointer ?? ffi.nullptr, withConfiguration?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithCGImage:
  static UIImage imageWithCGImage(ffi.Pointer<CGImage> cgImage) {
  objc.checkOsVersionInternal('UIImage.imageWithCGImage:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_2tjjtl(_class_UIImage, _sel_imageWithCGImage_, cgImage);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithCGImage:scale:orientation:
  static UIImage imageWithCGImage$1(ffi.Pointer<CGImage> cgImage, {required double scale,required int orientation}) {
  objc.checkOsVersionInternal('UIImage.imageWithCGImage:scale:orientation:', iOS: (false, (4, 0, 0)));
    final $ret = _objc_msgSend_16go90j(_class_UIImage, _sel_imageWithCGImage_scale_orientation_, cgImage, scale, orientation);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithCIImage:
  static UIImage imageWithCIImage(CIImage ciImage) {
  objc.checkOsVersionInternal('UIImage.imageWithCIImage:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIImage, _sel_imageWithCIImage_, ciImage.ref.pointer);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithCIImage:scale:orientation:
  static UIImage imageWithCIImage$1(CIImage ciImage, {required double scale,required int orientation}) {
  objc.checkOsVersionInternal('UIImage.imageWithCIImage:scale:orientation:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_2xggvt(_class_UIImage, _sel_imageWithCIImage_scale_orientation_, ciImage.ref.pointer, scale, orientation);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithContentsOfFile:
  static UIImage? imageWithContentsOfFile(objc.NSString path) {
  objc.checkOsVersionInternal('UIImage.imageWithContentsOfFile:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIImage, _sel_imageWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithData:
  static UIImage? imageWithData(objc.NSData data) {
  objc.checkOsVersionInternal('UIImage.imageWithData:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIImage, _sel_imageWithData_, data.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithData:scale:
  static UIImage? imageWithData$1(objc.NSData data, {required double scale}) {
  objc.checkOsVersionInternal('UIImage.imageWithData:scale:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_6plvbo(_class_UIImage, _sel_imageWithData_scale_, data.ref.pointer, scale);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static UIImage new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIImage, _sel_new);
    return UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIImage, _sel_supportsSecureCoding);

  }


  /// systemImageNamed:
  static UIImage? systemImageNamed(objc.NSString name) {
  objc.checkOsVersionInternal('UIImage.systemImageNamed:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIImage, _sel_systemImageNamed_, name.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// systemImageNamed:compatibleWithTraitCollection:
  static UIImage? systemImageNamed$1(objc.NSString name, {UITraitCollection? compatibleWithTraitCollection}) {
  objc.checkOsVersionInternal('UIImage.systemImageNamed:compatibleWithTraitCollection:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIImage, _sel_systemImageNamed_compatibleWithTraitCollection_, name.ref.pointer, compatibleWithTraitCollection?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// systemImageNamed:variableValue:withConfiguration:
  static UIImage? systemImageNamed$2(objc.NSString name, {required double variableValue,UIImageConfiguration? withConfiguration}) {
  objc.checkOsVersionInternal('UIImage.systemImageNamed:variableValue:withConfiguration:', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_17i4wqy(_class_UIImage, _sel_systemImageNamed_variableValue_withConfiguration_, name.ref.pointer, variableValue, withConfiguration?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// systemImageNamed:withConfiguration:
  static UIImage? systemImageNamed$3(objc.NSString name, {UIImageConfiguration? withConfiguration}) {
  objc.checkOsVersionInternal('UIImage.systemImageNamed:withConfiguration:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIImage, _sel_systemImageNamed_withConfiguration_, name.ref.pointer, withConfiguration?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }
  /// Returns a new instance of UIImage constructed with the default `new` method.
  UIImage() : this.as(new$().object$);

}

extension UIImage$Methods on UIImage {

  /// CGImage
  ffi.Pointer<CGImage> get CGImage$1 {
  objc.checkOsVersionInternal('UIImage.CGImage', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_y1izi1(object$.ref.pointer, _sel_CGImage);

  }


  /// CIImage
  CIImage? get CIImage$1 {
  objc.checkOsVersionInternal('UIImage.CIImage', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_CIImage);
    return $ret.address == 0 ? null : CIImage.fromPointer($ret, retain: true, release: true);
  }


  /// alignmentRectInsets
  UIEdgeInsets get alignmentRectInsets {
  objc.checkOsVersionInternal('UIImage.alignmentRectInsets', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_alignmentRectInsets) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_alignmentRectInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// baselineOffsetFromBottom
  double get baselineOffsetFromBottom {
  objc.checkOsVersionInternal('UIImage.baselineOffsetFromBottom', iOS: (false, (13, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_baselineOffsetFromBottom) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_baselineOffsetFromBottom);

  }


  /// capInsets
  UIEdgeInsets get capInsets {
  objc.checkOsVersionInternal('UIImage.capInsets', iOS: (false, (5, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_capInsets) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_capInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// configuration
  UIImageConfiguration? get configuration {
  objc.checkOsVersionInternal('UIImage.configuration', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_configuration);
    return $ret.address == 0 ? null : UIImageConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// drawAsPatternInRect:
  void drawAsPatternInRect(objc.CGRect rect) {
  objc.checkOsVersionInternal('UIImage.drawAsPatternInRect:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1okkq16(object$.ref.pointer, _sel_drawAsPatternInRect_, rect);

  }


  /// drawAtPoint:
  void drawAtPoint(objc.CGPoint point) {
  objc.checkOsVersionInternal('UIImage.drawAtPoint:', iOS: (false, (2, 0, 0)));
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_drawAtPoint_, point);

  }


  /// drawAtPoint:blendMode:alpha:
  void drawAtPoint$1(objc.CGPoint point, {required int blendMode,required double alpha}) {
  objc.checkOsVersionInternal('UIImage.drawAtPoint:blendMode:alpha:', iOS: (false, (2, 0, 0)));
_objc_msgSend_yg3i7f(object$.ref.pointer, _sel_drawAtPoint_blendMode_alpha_, point, blendMode, alpha);

  }


  /// drawInRect:
  void drawInRect(objc.CGRect rect) {
  objc.checkOsVersionInternal('UIImage.drawInRect:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1okkq16(object$.ref.pointer, _sel_drawInRect_, rect);

  }


  /// drawInRect:blendMode:alpha:
  void drawInRect$1(objc.CGRect rect, {required int blendMode,required double alpha}) {
  objc.checkOsVersionInternal('UIImage.drawInRect:blendMode:alpha:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1ggt4c3(object$.ref.pointer, _sel_drawInRect_blendMode_alpha_, rect, blendMode, alpha);

  }


  /// duration
  double get duration {
  objc.checkOsVersionInternal('UIImage.duration', iOS: (false, (5, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_duration) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_duration);

  }


  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// flipsForRightToLeftLayoutDirection
  bool get flipsForRightToLeftLayoutDirection {
  objc.checkOsVersionInternal('UIImage.flipsForRightToLeftLayoutDirection', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_flipsForRightToLeftLayoutDirection);

  }


  /// hasBaseline
  bool get hasBaseline {
  objc.checkOsVersionInternal('UIImage.hasBaseline', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_hasBaseline);

  }


  /// imageAsset
  UIImageAsset? get imageAsset {
  objc.checkOsVersionInternal('UIImage.imageAsset', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageAsset);
    return $ret.address == 0 ? null : UIImageAsset.fromPointer($ret, retain: true, release: true);
  }


  /// imageByApplyingSymbolConfiguration:
  UIImage? imageByApplyingSymbolConfiguration(UIImageSymbolConfiguration configuration) {
  objc.checkOsVersionInternal('UIImage.imageByApplyingSymbolConfiguration:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_imageByApplyingSymbolConfiguration_, configuration.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageByPreparingForDisplay
  UIImage? imageByPreparingForDisplay() {
  objc.checkOsVersionInternal('UIImage.imageByPreparingForDisplay', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageByPreparingForDisplay);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageByPreparingThumbnailOfSize:
  UIImage? imageByPreparingThumbnailOfSize(objc.CGSize size) {
  objc.checkOsVersionInternal('UIImage.imageByPreparingThumbnailOfSize:', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_1c2zpn3(object$.ref.pointer, _sel_imageByPreparingThumbnailOfSize_, size);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageFlippedForRightToLeftLayoutDirection
  UIImage imageFlippedForRightToLeftLayoutDirection() {
  objc.checkOsVersionInternal('UIImage.imageFlippedForRightToLeftLayoutDirection', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageFlippedForRightToLeftLayoutDirection);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageOrientation
  int get imageOrientation {
  objc.checkOsVersionInternal('UIImage.imageOrientation', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_fkvhxy(object$.ref.pointer, _sel_imageOrientation);

  }


  /// imageRendererFormat
  UIGraphicsImageRendererFormat get imageRendererFormat {
  objc.checkOsVersionInternal('UIImage.imageRendererFormat', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageRendererFormat);
    return UIGraphicsImageRendererFormat.fromPointer($ret, retain: true, release: true);
  }


  /// imageRestrictedToStandardDynamicRange
  UIImage imageRestrictedToStandardDynamicRange() {
  objc.checkOsVersionInternal('UIImage.imageRestrictedToStandardDynamicRange', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageRestrictedToStandardDynamicRange);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithAlignmentRectInsets:
  UIImage imageWithAlignmentRectInsets(UIEdgeInsets alignmentInsets) {
  objc.checkOsVersionInternal('UIImage.imageWithAlignmentRectInsets:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_1mhd1pt(object$.ref.pointer, _sel_imageWithAlignmentRectInsets_, alignmentInsets);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithBaselineOffsetFromBottom:
  UIImage imageWithBaselineOffsetFromBottom(double baselineOffset) {
  objc.checkOsVersionInternal('UIImage.imageWithBaselineOffsetFromBottom:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_oa8mke(object$.ref.pointer, _sel_imageWithBaselineOffsetFromBottom_, baselineOffset);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithConfiguration:
  UIImage imageWithConfiguration(UIImageConfiguration configuration) {
  objc.checkOsVersionInternal('UIImage.imageWithConfiguration:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_imageWithConfiguration_, configuration.ref.pointer);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithHorizontallyFlippedOrientation
  UIImage imageWithHorizontallyFlippedOrientation() {
  objc.checkOsVersionInternal('UIImage.imageWithHorizontallyFlippedOrientation', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageWithHorizontallyFlippedOrientation);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithRenderingMode:
  UIImage imageWithRenderingMode(int renderingMode) {
  objc.checkOsVersionInternal('UIImage.imageWithRenderingMode:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1o8rmw3(object$.ref.pointer, _sel_imageWithRenderingMode_, renderingMode);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithTintColor:
  UIImage imageWithTintColor(UIColor color) {
  objc.checkOsVersionInternal('UIImage.imageWithTintColor:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_imageWithTintColor_, color.ref.pointer);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithTintColor:renderingMode:
  UIImage imageWithTintColor$1(UIColor color, {required int renderingMode}) {
  objc.checkOsVersionInternal('UIImage.imageWithTintColor:renderingMode:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_15gm1s5(object$.ref.pointer, _sel_imageWithTintColor_renderingMode_, color.ref.pointer, renderingMode);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageWithoutBaseline
  UIImage imageWithoutBaseline() {
  objc.checkOsVersionInternal('UIImage.imageWithoutBaseline', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageWithoutBaseline);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// images
  objc.NSArray? get images {
  objc.checkOsVersionInternal('UIImage.images', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_images);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// init
  UIImage init() {
  objc.checkOsVersionInternal('UIImage.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCGImage:
  UIImage initWithCGImage(ffi.Pointer<CGImage> cgImage) {
  objc.checkOsVersionInternal('UIImage.initWithCGImage:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_2tjjtl(object$.ref.retainAndReturnPointer(), _sel_initWithCGImage_, cgImage);
    return UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCGImage:scale:orientation:
  UIImage initWithCGImage$1(ffi.Pointer<CGImage> cgImage, {required double scale,required int orientation}) {
  objc.checkOsVersionInternal('UIImage.initWithCGImage:scale:orientation:', iOS: (false, (4, 0, 0)));
    final $ret = _objc_msgSend_16go90j(object$.ref.retainAndReturnPointer(), _sel_initWithCGImage_scale_orientation_, cgImage, scale, orientation);
    return UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCIImage:
  UIImage initWithCIImage(CIImage ciImage) {
  objc.checkOsVersionInternal('UIImage.initWithCIImage:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCIImage_, ciImage.ref.pointer);
    return UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCIImage:scale:orientation:
  UIImage initWithCIImage$1(CIImage ciImage, {required double scale,required int orientation}) {
  objc.checkOsVersionInternal('UIImage.initWithCIImage:scale:orientation:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_2xggvt(object$.ref.retainAndReturnPointer(), _sel_initWithCIImage_scale_orientation_, ciImage.ref.pointer, scale, orientation);
    return UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UIImage? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// initWithContentsOfFile:
  UIImage? initWithContentsOfFile(objc.NSString path) {
  objc.checkOsVersionInternal('UIImage.initWithContentsOfFile:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// initWithData:
  UIImage? initWithData(objc.NSData data) {
  objc.checkOsVersionInternal('UIImage.initWithData:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithData_, data.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// initWithData:scale:
  UIImage? initWithData$1(objc.NSData data, {required double scale}) {
  objc.checkOsVersionInternal('UIImage.initWithData:scale:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_6plvbo(object$.ref.retainAndReturnPointer(), _sel_initWithData_scale_, data.ref.pointer, scale);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: false, release: true);
  }


  /// isHighDynamicRange
  bool get isHighDynamicRange {
  objc.checkOsVersionInternal('UIImage.isHighDynamicRange', iOS: (false, (17, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHighDynamicRange);

  }


  /// isSymbolImage
  bool get isSymbolImage {
  objc.checkOsVersionInternal('UIImage.isSymbolImage', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSymbolImage);

  }


  /// prepareForDisplayWithCompletionHandler:
  void prepareForDisplayWithCompletionHandler(objc.ObjCBlock<ffi.Void Function(UIImage?)> completionHandler) {
  objc.checkOsVersionInternal('UIImage.prepareForDisplayWithCompletionHandler:', iOS: (false, (15, 0, 0)));
_objc_msgSend_f167m6(object$.ref.pointer, _sel_prepareForDisplayWithCompletionHandler_, completionHandler.ref.pointer);

  }


  /// prepareThumbnailOfSize:completionHandler:
  void prepareThumbnailOfSize(objc.CGSize size, {required objc.ObjCBlock<ffi.Void Function(UIImage?)> completionHandler}) {
  objc.checkOsVersionInternal('UIImage.prepareThumbnailOfSize:completionHandler:', iOS: (false, (15, 0, 0)));
_objc_msgSend_1awx4w(object$.ref.pointer, _sel_prepareThumbnailOfSize_completionHandler_, size, completionHandler.ref.pointer);

  }


  /// renderingMode
  int get renderingMode {
  objc.checkOsVersionInternal('UIImage.renderingMode', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_s2io2v(object$.ref.pointer, _sel_renderingMode);

  }


  /// resizableImageWithCapInsets:
  UIImage resizableImageWithCapInsets(UIEdgeInsets capInsets) {
  objc.checkOsVersionInternal('UIImage.resizableImageWithCapInsets:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1mhd1pt(object$.ref.pointer, _sel_resizableImageWithCapInsets_, capInsets);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// resizableImageWithCapInsets:resizingMode:
  UIImage resizableImageWithCapInsets$1(UIEdgeInsets capInsets, {required int resizingMode}) {
  objc.checkOsVersionInternal('UIImage.resizableImageWithCapInsets:resizingMode:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_1utaosa(object$.ref.pointer, _sel_resizableImageWithCapInsets_resizingMode_, capInsets, resizingMode);
    return UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// resizingMode
  int get resizingMode {
  objc.checkOsVersionInternal('UIImage.resizingMode', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_knxebs(object$.ref.pointer, _sel_resizingMode);

  }


  /// scale
  double get scale {
  objc.checkOsVersionInternal('UIImage.scale', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_scale) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_scale);

  }


  /// size
  objc.CGSize get size {
  objc.checkOsVersionInternal('UIImage.size', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1vdfkenStret($ptr, object$.ref.pointer, _sel_size) : $ptr.ref = _objc_msgSend_1vdfken(object$.ref.pointer, _sel_size);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// symbolConfiguration
  UIImageSymbolConfiguration? get symbolConfiguration {
  objc.checkOsVersionInternal('UIImage.symbolConfiguration', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_symbolConfiguration);
    return $ret.address == 0 ? null : UIImageSymbolConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// traitCollection
  UITraitCollection get traitCollection {
  objc.checkOsVersionInternal('UIImage.traitCollection', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_traitCollection);
    return UITraitCollection.fromPointer($ret, retain: true, release: true);
  }

}

sealed class UIImageSymbolScale {
  static const UIImageSymbolScaleDefault = -1;
  static const UIImageSymbolScaleUnspecified = 0;
  static const UIImageSymbolScaleSmall = 1;
  static const UIImageSymbolScaleMedium = 2;
  static const UIImageSymbolScaleLarge = 3;}

sealed class UIImageSymbolWeight {
  static const UIImageSymbolWeightUnspecified = 0;
  static const UIImageSymbolWeightUltraLight = 1;
  static const UIImageSymbolWeightThin = 2;
  static const UIImageSymbolWeightLight = 3;
  static const UIImageSymbolWeightRegular = 4;
  static const UIImageSymbolWeightMedium = 5;
  static const UIImageSymbolWeightSemibold = 6;
  static const UIImageSymbolWeightBold = 7;
  static const UIImageSymbolWeightHeavy = 8;
  static const UIImageSymbolWeightBlack = 9;}

sealed class UIImageSymbolVariableValueMode {
  static const UIImageSymbolVariableValueModeAutomatic = 0;
  static const UIImageSymbolVariableValueModeColor = 1;
  static const UIImageSymbolVariableValueModeDraw = 2;}

sealed class UIImageSymbolColorRenderingMode {
  static const UIImageSymbolColorRenderingModeAutomatic = 0;
  static const UIImageSymbolColorRenderingModeFlat = 1;
  static const UIImageSymbolColorRenderingModeGradient = 2;}

sealed class NSUnderlineStyle {
  static const NSUnderlineStyleNone = 0;
  static const NSUnderlineStyleSingle = 1;
  static const NSUnderlineStyleThick = 2;
  static const NSUnderlineStyleDouble = 9;
  static const NSUnderlineStylePatternSolid = 0;
  static const NSUnderlineStylePatternDot = 256;
  static const NSUnderlineStylePatternDash = 512;
  static const NSUnderlineStylePatternDashDot = 768;
  static const NSUnderlineStylePatternDashDotDot = 1024;
  static const NSUnderlineStyleByWord = 32768;}

late final _sel_initWithURL_options_documentAttributes_error_ = objc.registerName("initWithURL:options:documentAttributes:error:");
final _objc_msgSend_of3pfd = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();
late final _sel_initWithData_options_documentAttributes_error_ = objc.registerName("initWithData:options:documentAttributes:error:");
late final _sel_dataFromRange_documentAttributes_error_ = objc.registerName("dataFromRange:documentAttributes:error:");
final _objc_msgSend_193219c = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();
late final _sel_fileWrapperFromRange_documentAttributes_error_ = objc.registerName("fileWrapperFromRange:documentAttributes:error:");

/// NSAttributedStringDocumentFormats
extension NSAttributedStringDocumentFormats on objc.NSAttributedString {

  /// dataFromRange:documentAttributes:error:
  objc.NSData? dataFromRange(objc.NSRange range, {required objc.NSDictionary documentAttributes}) {
  objc.checkOsVersionInternal('NSAttributedString.dataFromRange:documentAttributes:error:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_193219c(object$.ref.pointer, _sel_dataFromRange_documentAttributes_error_, range, documentAttributes.ref.pointer, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSData.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// fileWrapperFromRange:documentAttributes:error:
  NSFileWrapper? fileWrapperFromRange(objc.NSRange range, {required objc.NSDictionary documentAttributes}) {
  objc.checkOsVersionInternal('NSAttributedString.fileWrapperFromRange:documentAttributes:error:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_193219c(object$.ref.pointer, _sel_fileWrapperFromRange_documentAttributes_error_, range, documentAttributes.ref.pointer, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : NSFileWrapper.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// initWithData:options:documentAttributes:error:
  objc.NSAttributedString? initWithData(objc.NSData data, {required objc.NSDictionary options,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> documentAttributes}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithData:options:documentAttributes:error:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_of3pfd(object$.ref.retainAndReturnPointer(), _sel_initWithData_options_documentAttributes_error_, data.ref.pointer, options.ref.pointer, documentAttributes, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// initWithURL:options:documentAttributes:error:
  objc.NSAttributedString? initWithURL(objc.NSURL url, {required objc.NSDictionary options,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> documentAttributes}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithURL:options:documentAttributes:error:', iOS: (false, (9, 0, 0)), macOS: (false, (10, 4, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_of3pfd(object$.ref.retainAndReturnPointer(), _sel_initWithURL_options_documentAttributes_error_, url.ref.pointer, options.ref.pointer, documentAttributes, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }

}

late final _sel_containsAttachmentsInRange_ = objc.registerName("containsAttachmentsInRange:");
final _objc_msgSend_p4nurx = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange )>();
late final _sel_prefersRTFDInRange_ = objc.registerName("prefersRTFDInRange:");

/// NSAttributedStringKitAdditions
extension NSAttributedStringKitAdditions on objc.NSAttributedString {

  /// containsAttachmentsInRange:
  bool containsAttachmentsInRange(objc.NSRange range) {
  objc.checkOsVersionInternal('NSAttributedString.containsAttachmentsInRange:', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    return _objc_msgSend_p4nurx(object$.ref.pointer, _sel_containsAttachmentsInRange_, range);

  }


  /// prefersRTFDInRange:
  bool prefersRTFDInRange(objc.NSRange range) {
  objc.checkOsVersionInternal('NSAttributedString.prefersRTFDInRange:', iOS: (false, (18, 0, 0)), macOS: (false, (15, 0, 0)));
    return _objc_msgSend_p4nurx(object$.ref.pointer, _sel_prefersRTFDInRange_, range);

  }

}


/// NSAttributedString_ItemProvider
extension NSAttributedString_ItemProvider on objc.NSAttributedString {

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  int itemProviderVisibilityForRepresentationWithTypeIdentifier(objc.NSString typeIdentifier) {
  objc.checkOsVersionInternal('NSAttributedString.itemProviderVisibilityForRepresentationWithTypeIdentifier:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSAttributedString', 'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    return _objc_msgSend_16fy0up(object$.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_, typeIdentifier.ref.pointer);

  }


  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  objc.NSProgress? loadDataWithTypeIdentifier(objc.NSString typeIdentifier, {required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> forItemProviderCompletionHandler}) {
  objc.checkOsVersionInternal('NSAttributedString.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_r0bo0s(object$.ref.pointer, _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_, typeIdentifier.ref.pointer, forItemProviderCompletionHandler.ref.pointer);
    return $ret.address == 0 ? null : objc.NSProgress.fromPointer($ret, retain: true, release: true);
  }


  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider {
  objc.checkOsVersionInternal('NSAttributedString.writableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException('NSAttributedString', 'writableTypeIdentifiersForItemProvider');
    }
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static int itemProviderVisibilityForRepresentationWithTypeIdentifier$1(objc.NSString typeIdentifier) {
  objc.checkOsVersionInternal('NSAttributedString.itemProviderVisibilityForRepresentationWithTypeIdentifier:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(_class_NSAttributedString, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSAttributedString', 'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    return _objc_msgSend_16fy0up(_class_NSAttributedString, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_, typeIdentifier.ref.pointer);

  }


  /// objectWithItemProviderData:typeIdentifier:error:
  static objc.NSAttributedString? objectWithItemProviderData(objc.NSData data, {required objc.NSString typeIdentifier}) {
  objc.checkOsVersionInternal('NSAttributedString.objectWithItemProviderData:typeIdentifier:error:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1pnyuds(_class_NSAttributedString, _sel_objectWithItemProviderData_typeIdentifier_error_, data.ref.pointer, typeIdentifier.ref.pointer, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
  objc.checkOsVersionInternal('NSAttributedString.readableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSAttributedString, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider$1() {
  objc.checkOsVersionInternal('NSAttributedString.writableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSAttributedString, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_initWithFileURL_options_documentAttributes_error_ = objc.registerName("initWithFileURL:options:documentAttributes:error:");

/// NSDeprecatedKitAdditions
extension NSDeprecatedKitAdditions on objc.NSAttributedString {

  /// initWithFileURL:options:documentAttributes:error:
  objc.NSAttributedString? initWithFileURL(objc.NSURL url, {required objc.NSDictionary options,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> documentAttributes}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithFileURL:options:documentAttributes:error:', iOS: (false, (7, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_of3pfd(object$.ref.retainAndReturnPointer(), _sel_initWithFileURL_options_documentAttributes_error_, url.ref.pointer, options.ref.pointer, documentAttributes, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }

}

sealed class NSWritingDirection {
  static const NSWritingDirectionNatural = -1;
  static const NSWritingDirectionLeftToRight = 0;
  static const NSWritingDirectionRightToLeft = 1;}

sealed class NSTextAlignment {
  static const NSTextAlignmentLeft = 0;
  static const NSTextAlignmentCenter = 1;
  static const NSTextAlignmentRight = 2;
  static const NSTextAlignmentJustified = 3;
  static const NSTextAlignmentNatural = 4;}

sealed class NSLineBreakMode {
  static const NSLineBreakByWordWrapping = 0;
  static const NSLineBreakByCharWrapping = 1;
  static const NSLineBreakByClipping = 2;
  static const NSLineBreakByTruncatingHead = 3;
  static const NSLineBreakByTruncatingTail = 4;
  static const NSLineBreakByTruncatingMiddle = 5;}

sealed class NSLineBreakStrategy {
  static const NSLineBreakStrategyNone = 0;
  static const NSLineBreakStrategyPushOut = 1;
  static const NSLineBreakStrategyHangulWordPriority = 2;
  static const NSLineBreakStrategyStandard = 65535;}


/// WARNING: NSStringDrawingContext is a stub. To generate bindings for this class, include
/// NSStringDrawingContext in your config's objc-interfaces list.
///
/// NSStringDrawingContext
extension type NSStringDrawingContext._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [NSStringDrawingContext] that points to the same underlying object as [other].
  NSStringDrawingContext.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSStringDrawingContext', iOS: (false, (6, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSStringDrawingContext] that wraps the given raw object pointer.
  NSStringDrawingContext.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSStringDrawingContext', iOS: (false, (6, 0, 0)), macOS: (false, (10, 11, 0)));
  }


}

late final _sel_sizeWithAttributes_ = objc.registerName("sizeWithAttributes:");
final _objc_msgSend_18r320v = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_18r320vStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_drawAtPoint_withAttributes_ = objc.registerName("drawAtPoint:withAttributes:");
final _objc_msgSend_bkebbk = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_drawInRect_withAttributes_ = objc.registerName("drawInRect:withAttributes:");
final _objc_msgSend_f227js = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// NSStringDrawing
extension NSStringDrawing on objc.NSString {

  /// drawAtPoint:withAttributes:
  void drawAtPoint(objc.CGPoint point, {objc.NSDictionary? withAttributes}) {
  objc.checkOsVersionInternal('NSString.drawAtPoint:withAttributes:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_bkebbk(object$.ref.pointer, _sel_drawAtPoint_withAttributes_, point, withAttributes?.ref.pointer ?? ffi.nullptr);

  }


  /// drawInRect:withAttributes:
  void drawInRect(objc.CGRect rect, {objc.NSDictionary? withAttributes}) {
  objc.checkOsVersionInternal('NSString.drawInRect:withAttributes:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_f227js(object$.ref.pointer, _sel_drawInRect_withAttributes_, rect, withAttributes?.ref.pointer ?? ffi.nullptr);

  }


  /// sizeWithAttributes:
  objc.CGSize sizeWithAttributes(objc.NSDictionary? attrs) {
  objc.checkOsVersionInternal('NSString.sizeWithAttributes:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_18r320vStret($ptr, object$.ref.pointer, _sel_sizeWithAttributes_, attrs?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_18r320v(object$.ref.pointer, _sel_sizeWithAttributes_, attrs?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }

}


/// NSStringDrawing
extension NSStringDrawing$1 on objc.NSAttributedString {

  /// drawAtPoint:
  void drawAtPoint(objc.CGPoint point) {
  objc.checkOsVersionInternal('NSAttributedString.drawAtPoint:', iOS: (false, (6, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_drawAtPoint_, point);

  }


  /// drawInRect:
  void drawInRect(objc.CGRect rect) {
  objc.checkOsVersionInternal('NSAttributedString.drawInRect:', iOS: (false, (6, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_1okkq16(object$.ref.pointer, _sel_drawInRect_, rect);

  }


  /// size
  objc.CGSize size() {
  objc.checkOsVersionInternal('NSAttributedString.size', iOS: (false, (6, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1vdfkenStret($ptr, object$.ref.pointer, _sel_size) : $ptr.ref = _objc_msgSend_1vdfken(object$.ref.pointer, _sel_size);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }

}

sealed class NSStringDrawingOptions {
  static const NSStringDrawingUsesLineFragmentOrigin = 1;
  static const NSStringDrawingUsesFontLeading = 2;
  static const NSStringDrawingUsesDeviceMetrics = 8;
  static const NSStringDrawingTruncatesLastVisibleLine = 32;
  static const NSStringDrawingOptionsResolvesNaturalAlignmentWithBaseWritingDirection = 512;}

late final _sel_drawWithRect_options_attributes_context_ = objc.registerName("drawWithRect:options:attributes:context:");
final _objc_msgSend_1dr66uk = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_boundingRectWithSize_options_attributes_context_ = objc.registerName("boundingRectWithSize:options:attributes:context:");
final _objc_msgSend_k8g3u = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_k8g3uStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// NSExtendedStringDrawing
extension NSExtendedStringDrawing on objc.NSString {

  /// boundingRectWithSize:options:attributes:context:
  objc.CGRect boundingRectWithSize(objc.CGSize size, {required int options,objc.NSDictionary? attributes,NSStringDrawingContext? context}) {
  objc.checkOsVersionInternal('NSString.boundingRectWithSize:options:attributes:context:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_k8g3uStret($ptr, object$.ref.pointer, _sel_boundingRectWithSize_options_attributes_context_, size, options, attributes?.ref.pointer ?? ffi.nullptr, context?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_k8g3u(object$.ref.pointer, _sel_boundingRectWithSize_options_attributes_context_, size, options, attributes?.ref.pointer ?? ffi.nullptr, context?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// drawWithRect:options:attributes:context:
  void drawWithRect(objc.CGRect rect, {required int options,objc.NSDictionary? attributes,NSStringDrawingContext? context}) {
  objc.checkOsVersionInternal('NSString.drawWithRect:options:attributes:context:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 11, 0)));
_objc_msgSend_1dr66uk(object$.ref.pointer, _sel_drawWithRect_options_attributes_context_, rect, options, attributes?.ref.pointer ?? ffi.nullptr, context?.ref.pointer ?? ffi.nullptr);

  }

}

late final _sel_drawWithRect_options_context_ = objc.registerName("drawWithRect:options:context:");
final _objc_msgSend_g5bnri = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , int , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_boundingRectWithSize_options_context_ = objc.registerName("boundingRectWithSize:options:context:");
final _objc_msgSend_1y1y0ic = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , int , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_1y1y0icStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , int , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// NSExtendedStringDrawing
extension NSExtendedStringDrawing$1 on objc.NSAttributedString {

  /// boundingRectWithSize:options:context:
  objc.CGRect boundingRectWithSize(objc.CGSize size, {required int options,NSStringDrawingContext? context}) {
  objc.checkOsVersionInternal('NSAttributedString.boundingRectWithSize:options:context:', iOS: (false, (6, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_1y1y0icStret($ptr, object$.ref.pointer, _sel_boundingRectWithSize_options_context_, size, options, context?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_1y1y0ic(object$.ref.pointer, _sel_boundingRectWithSize_options_context_, size, options, context?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// drawWithRect:options:context:
  void drawWithRect(objc.CGRect rect, {required int options,NSStringDrawingContext? context}) {
  objc.checkOsVersionInternal('NSAttributedString.drawWithRect:options:context:', iOS: (false, (6, 0, 0)), macOS: (false, (10, 11, 0)));
_objc_msgSend_g5bnri(object$.ref.pointer, _sel_drawWithRect_options_context_, rect, options, context?.ref.pointer ?? ffi.nullptr);

  }

}

final class CATransform3D extends ffi.Struct{
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m13;

  @ffi.Double()
  external double m14;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double m23;

  @ffi.Double()
  external double m24;

  @ffi.Double()
  external double m31;

  @ffi.Double()
  external double m32;

  @ffi.Double()
  external double m33;

  @ffi.Double()
  external double m34;

  @ffi.Double()
  external double m41;

  @ffi.Double()
  external double m42;

  @ffi.Double()
  external double m43;

  @ffi.Double()
  external double m44;

}


/// WARNING: CAMediaTiming is a stub. To generate bindings for this class, include
/// CAMediaTiming in your config's objc-protocols list.
///
/// CAMediaTiming
extension type CAMediaTiming._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [CAMediaTiming] that points to the same underlying object as [other].
  CAMediaTiming.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CAMediaTiming] that wraps the given raw object pointer.
  CAMediaTiming.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class CAAutoresizingMask {
  static const kCALayerNotSizable = 0;
  static const kCALayerMinXMargin = 1;
  static const kCALayerWidthSizable = 2;
  static const kCALayerMaxXMargin = 4;
  static const kCALayerMinYMargin = 8;
  static const kCALayerHeightSizable = 16;
  static const kCALayerMaxYMargin = 32;}

sealed class CAEdgeAntialiasingMask {
  static const kCALayerLeftEdge = 1;
  static const kCALayerRightEdge = 2;
  static const kCALayerBottomEdge = 4;
  static const kCALayerTopEdge = 8;}

sealed class CACornerMask {
  static const kCALayerMinXMinYCorner = 1;
  static const kCALayerMaxXMinYCorner = 2;
  static const kCALayerMinXMaxYCorner = 4;
  static const kCALayerMaxXMaxYCorner = 8;}


/// WARNING: CALayer is a stub. To generate bindings for this class, include
/// CALayer in your config's objc-interfaces list.
///
/// CALayer
extension type CALayer._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,CAMediaTiming {
  /// Constructs a [CALayer] that points to the same underlying object as [other].
  CALayer.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CALayer', iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }

  /// Constructs a [CALayer] that wraps the given raw object pointer.
  CALayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CALayer', iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }


}


/// WARNING: CAAction is a stub. To generate bindings for this class, include
/// CAAction in your config's objc-protocols list.
///
/// CAAction
extension type CAAction._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [CAAction] that points to the same underlying object as [other].
  CAAction.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CAAction] that wraps the given raw object pointer.
  CAAction.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// WARNING: CALayerDelegate is a stub. To generate bindings for this class, include
/// CALayerDelegate in your config's objc-protocols list.
///
/// CALayerDelegate
extension type CALayerDelegate._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [CALayerDelegate] that points to the same underlying object as [other].
  CALayerDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CALayerDelegate] that wraps the given raw object pointer.
  CALayerDelegate.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

final class CAFrameRateRange extends ffi.Struct{
  @ffi.Float()
  external double minimum;

  @ffi.Float()
  external double maximum;

  @ffi.Float()
  external double preferred;

}

sealed class CAConstraintAttribute {
  static const kCAConstraintMinX = 0;
  static const kCAConstraintMidX = 1;
  static const kCAConstraintMaxX = 2;
  static const kCAConstraintWidth = 3;
  static const kCAConstraintMinY = 4;
  static const kCAConstraintMidY = 5;
  static const kCAConstraintMaxY = 6;
  static const kCAConstraintHeight = 7;}


/// WARNING: CADisplayLink is a stub. To generate bindings for this class, include
/// CADisplayLink in your config's objc-interfaces list.
///
/// CADisplayLink
extension type CADisplayLink._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [CADisplayLink] that points to the same underlying object as [other].
  CADisplayLink.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CADisplayLink', iOS: (false, (3, 1, 0)), macOS: (false, (14, 0, 0)));
  }

  /// Constructs a [CADisplayLink] that wraps the given raw object pointer.
  CADisplayLink.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CADisplayLink', iOS: (false, (3, 1, 0)), macOS: (false, (14, 0, 0)));
  }


}


/// WARNING: CAMediaTimingFunction is a stub. To generate bindings for this class, include
/// CAMediaTimingFunction in your config's objc-interfaces list.
///
/// CAMediaTimingFunction
extension type CAMediaTimingFunction._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding {
  /// Constructs a [CAMediaTimingFunction] that points to the same underlying object as [other].
  CAMediaTimingFunction.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CAMediaTimingFunction', iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }

  /// Constructs a [CAMediaTimingFunction] that wraps the given raw object pointer.
  CAMediaTimingFunction.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CAMediaTimingFunction', iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }


}

sealed class UIMenuElementState {
  static const UIMenuElementStateOff = 0;
  static const UIMenuElementStateOn = 1;
  static const UIMenuElementStateMixed = 2;}

sealed class UIMenuElementAttributes {
  static const UIMenuElementAttributesDisabled = 1;
  static const UIMenuElementAttributesDestructive = 2;
  static const UIMenuElementAttributesHidden = 4;
  static const UIMenuElementAttributesKeepsMenuPresented = 8;}

sealed class UIMenuElementRepeatBehavior {
  static const UIMenuElementRepeatBehaviorAutomatic = 0;
  static const UIMenuElementRepeatBehaviorRepeatable = 1;
  static const UIMenuElementRepeatBehaviorNonRepeatable = 2;}

late final _class_UIMenuElement = objc.getClass("UIMenuElement");
late final _sel_title = objc.registerName("title");
late final _sel_subtitle = objc.registerName("subtitle");
late final _sel_setSubtitle_ = objc.registerName("setSubtitle:");
late final _sel_image = objc.registerName("image");

/// UIAccessibility
extension UIAccessibility$1 on UIMenuElement {

  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
  objc.checkOsVersionInternal('UIMenuElement.accessibilityIdentifier', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_accessibilityIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
  objc.checkOsVersionInternal('UIMenuElement.setAccessibilityIdentifier:', iOS: (false, (5, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAccessibilityIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}


/// UIMenuElement
extension type UIMenuElement._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [UIMenuElement] that points to the same underlying object as [other].
  UIMenuElement.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIMenuElement', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIMenuElement] that wraps the given raw object pointer.
  UIMenuElement.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenuElement', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIMenuElement].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIMenuElement);

  /// alloc
  static UIMenuElement alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_alloc);
    return UIMenuElement.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIMenuElement allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIMenuElement, _sel_allocWithZone_, zone);
    return UIMenuElement.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static UIMenuElement new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_new);
    return UIMenuElement.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIMenuElement, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of UIMenuElement constructed with the default `new` method.
  UIMenuElement() : this.as(new$().object$);

}

extension UIMenuElement$Methods on UIMenuElement {

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// image
  UIImage? get image {
  objc.checkOsVersionInternal('UIMenuElement.image', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_image);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// init
  UIMenuElement init() {
  objc.checkOsVersionInternal('UIMenuElement.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIMenuElement.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UIMenuElement? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIMenuElement.fromPointer($ret, retain: false, release: true);
  }


  /// setSubtitle:
  set subtitle(objc.NSString? value) {
  objc.checkOsVersionInternal('UIMenuElement.setSubtitle:', iOS: (false, (15, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSubtitle_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// subtitle
  objc.NSString? get subtitle {
  objc.checkOsVersionInternal('UIMenuElement.subtitle', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_subtitle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// title
  objc.NSString get title {
  objc.checkOsVersionInternal('UIMenuElement.title', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}


/// WARNING: UIMenuDisplayPreferences is a stub. To generate bindings for this class, include
/// UIMenuDisplayPreferences in your config's objc-interfaces list.
///
/// UIMenuDisplayPreferences
extension type UIMenuDisplayPreferences._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [UIMenuDisplayPreferences] that points to the same underlying object as [other].
  UIMenuDisplayPreferences.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIMenuDisplayPreferences', iOS: (false, (17, 4, 0)));
  }

  /// Constructs a [UIMenuDisplayPreferences] that wraps the given raw object pointer.
  UIMenuDisplayPreferences.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenuDisplayPreferences', iOS: (false, (17, 4, 0)));
  }


}

sealed class UIMenuOptions {
  static const UIMenuOptionsDisplayInline = 1;
  static const UIMenuOptionsDestructive = 2;
  static const UIMenuOptionsSingleSelection = 32;
  static const UIMenuOptionsDisplayAsPalette = 128;}

sealed class UIMenuElementSize {
  static const UIMenuElementSizeSmall = 0;
  static const UIMenuElementSizeMedium = 1;
  static const UIMenuElementSizeLarge = 2;
  static const UIMenuElementSizeAutomatic = -1;}

late final _class_UIMenu = objc.getClass("UIMenu");
late final _sel_identifier = objc.registerName("identifier");
late final _sel_options = objc.registerName("options");
final _objc_msgSend_1cz0z8u = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_preferredElementSize = objc.registerName("preferredElementSize");
final _objc_msgSend_xjcq8x = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setPreferredElementSize_ = objc.registerName("setPreferredElementSize:");
final _objc_msgSend_b88ef1 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_children = objc.registerName("children");
late final _sel_selectedElements = objc.registerName("selectedElements");
late final _sel_displayPreferences = objc.registerName("displayPreferences");
late final _sel_setDisplayPreferences_ = objc.registerName("setDisplayPreferences:");
late final _sel_menuWithChildren_ = objc.registerName("menuWithChildren:");
late final _sel_menuWithTitle_children_ = objc.registerName("menuWithTitle:children:");
late final _sel_menuWithTitle_image_identifier_options_children_ = objc.registerName("menuWithTitle:image:identifier:options:children:");
final _objc_msgSend_zjuvxo = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_menuByReplacingChildren_ = objc.registerName("menuByReplacingChildren:");

/// UIMenu
extension type UIMenu._(objc.ObjCObject object$) implements objc.ObjCObject,UIMenuElement {
  /// Constructs a [UIMenu] that points to the same underlying object as [other].
  UIMenu.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIMenu', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIMenu] that wraps the given raw object pointer.
  UIMenu.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenu', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIMenu].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIMenu);

  /// alloc
  static UIMenu alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_alloc);
    return UIMenu.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIMenu allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIMenu, _sel_allocWithZone_, zone);
    return UIMenu.fromPointer($ret, retain: false, release: true);
  }


  /// menuWithChildren:
  static UIMenu menuWithChildren(objc.NSArray children) {
  objc.checkOsVersionInternal('UIMenu.menuWithChildren:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIMenu, _sel_menuWithChildren_, children.ref.pointer);
    return UIMenu.fromPointer($ret, retain: true, release: true);
  }


  /// menuWithTitle:children:
  static UIMenu menuWithTitle(objc.NSString title, {required objc.NSArray children}) {
    final $ret = _objc_msgSend_15qeuct(_class_UIMenu, _sel_menuWithTitle_children_, title.ref.pointer, children.ref.pointer);
    return UIMenu.fromPointer($ret, retain: true, release: true);
  }


  /// menuWithTitle:image:identifier:options:children:
  static UIMenu menuWithTitle$1(objc.NSString title, {UIImage? image,objc.NSString? identifier,required int options,required objc.NSArray children}) {
    final $ret = _objc_msgSend_zjuvxo(_class_UIMenu, _sel_menuWithTitle_image_identifier_options_children_, title.ref.pointer, image?.ref.pointer ?? ffi.nullptr, identifier?.ref.pointer ?? ffi.nullptr, options, children.ref.pointer);
    return UIMenu.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static UIMenu new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_new);
    return UIMenu.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIMenu, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of UIMenu constructed with the default `new` method.
  UIMenu() : this.as(new$().object$);

}

extension UIMenu$Methods on UIMenu {

  /// children
  objc.NSArray get children {
  objc.checkOsVersionInternal('UIMenu.children', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_children);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// displayPreferences
  UIMenuDisplayPreferences? get displayPreferences {
  objc.checkOsVersionInternal('UIMenu.displayPreferences', iOS: (false, (17, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_displayPreferences);
    return $ret.address == 0 ? null : UIMenuDisplayPreferences.fromPointer($ret, retain: true, release: true);
  }


  /// identifier
  objc.NSString get identifier {
  objc.checkOsVersionInternal('UIMenu.identifier', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// init
  UIMenu init() {
  objc.checkOsVersionInternal('UIMenu.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIMenu.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UIMenu? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIMenu.fromPointer($ret, retain: false, release: true);
  }


  /// menuByReplacingChildren:
  UIMenu menuByReplacingChildren(objc.NSArray newChildren) {
  objc.checkOsVersionInternal('UIMenu.menuByReplacingChildren:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_menuByReplacingChildren_, newChildren.ref.pointer);
    return UIMenu.fromPointer($ret, retain: true, release: true);
  }


  /// options
  int get options {
  objc.checkOsVersionInternal('UIMenu.options', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_1cz0z8u(object$.ref.pointer, _sel_options);

  }


  /// preferredElementSize
  int get preferredElementSize {
  objc.checkOsVersionInternal('UIMenu.preferredElementSize', iOS: (false, (16, 0, 0)));
    return _objc_msgSend_xjcq8x(object$.ref.pointer, _sel_preferredElementSize);

  }


  /// selectedElements
  objc.NSArray get selectedElements {
  objc.checkOsVersionInternal('UIMenu.selectedElements', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_selectedElements);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// setDisplayPreferences:
  set displayPreferences(UIMenuDisplayPreferences? value) {
  objc.checkOsVersionInternal('UIMenu.setDisplayPreferences:', iOS: (false, (17, 4, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setDisplayPreferences_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setPreferredElementSize:
  set preferredElementSize(int value) {
  objc.checkOsVersionInternal('UIMenu.setPreferredElementSize:', iOS: (false, (16, 0, 0)));
_objc_msgSend_b88ef1(object$.ref.pointer, _sel_setPreferredElementSize_, value);

  }

}


/// WARNING: UIMenuLeaf is a stub. To generate bindings for this class, include
/// UIMenuLeaf in your config's objc-protocols list.
///
/// UIMenuLeaf
extension type UIMenuLeaf._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIMenuLeaf] that points to the same underlying object as [other].
  UIMenuLeaf.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIMenuLeaf] that wraps the given raw object pointer.
  UIMenuLeaf.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class UIKeyModifierFlags {
  static const UIKeyModifierAlphaShift = 65536;
  static const UIKeyModifierShift = 131072;
  static const UIKeyModifierControl = 262144;
  static const UIKeyModifierAlternate = 524288;
  static const UIKeyModifierCommand = 1048576;
  static const UIKeyModifierNumericPad = 2097152;}


/// WARNING: UICommand is a stub. To generate bindings for this class, include
/// UICommand in your config's objc-interfaces list.
///
/// UICommand
extension type UICommand._(objc.ObjCObject object$) implements objc.ObjCObject,UIMenuElement,UIMenuLeaf {
  /// Constructs a [UICommand] that points to the same underlying object as [other].
  UICommand.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UICommand', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UICommand] that wraps the given raw object pointer.
  UICommand.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UICommand', iOS: (false, (13, 0, 0)));
  }


}

sealed class UIEventType {
  static const UIEventTypeTouches = 0;
  static const UIEventTypeMotion = 1;
  static const UIEventTypeRemoteControl = 2;
  static const UIEventTypePresses = 3;
  static const UIEventTypeScroll = 10;
  static const UIEventTypeHover = 11;
  static const UIEventTypeTransform = 14;}

sealed class UIEventSubtype {
  static const UIEventSubtypeNone = 0;
  static const UIEventSubtypeMotionShake = 1;
  static const UIEventSubtypeRemoteControlPlay = 100;
  static const UIEventSubtypeRemoteControlPause = 101;
  static const UIEventSubtypeRemoteControlStop = 102;
  static const UIEventSubtypeRemoteControlTogglePlayPause = 103;
  static const UIEventSubtypeRemoteControlNextTrack = 104;
  static const UIEventSubtypeRemoteControlPreviousTrack = 105;
  static const UIEventSubtypeRemoteControlBeginSeekingBackward = 106;
  static const UIEventSubtypeRemoteControlEndSeekingBackward = 107;
  static const UIEventSubtypeRemoteControlBeginSeekingForward = 108;
  static const UIEventSubtypeRemoteControlEndSeekingForward = 109;}

sealed class UIEventButtonMask {
  static const UIEventButtonMaskPrimary = 1;
  static const UIEventButtonMaskSecondary = 2;}


/// WARNING: UIEvent is a stub. To generate bindings for this class, include
/// UIEvent in your config's objc-interfaces list.
///
/// UIEvent
extension type UIEvent._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UIEvent] that points to the same underlying object as [other].
  UIEvent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIEvent] that wraps the given raw object pointer.
  UIEvent.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }


}


/// WARNING: UIPasteConfigurationSupporting$1 is a stub. To generate bindings for this class, include
/// UIPasteConfigurationSupporting in your config's objc-protocols list.
///
/// UIPasteConfigurationSupporting
extension type UIPasteConfigurationSupporting$1._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIPasteConfigurationSupporting$1] that points to the same underlying object as [other].
  UIPasteConfigurationSupporting$1.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIPasteConfigurationSupporting$1] that wraps the given raw object pointer.
  UIPasteConfigurationSupporting$1.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// WARNING: UIUserActivityRestoring is a stub. To generate bindings for this class, include
/// UIUserActivityRestoring in your config's objc-protocols list.
///
/// UIUserActivityRestoring
extension type UIUserActivityRestoring._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIUserActivityRestoring] that points to the same underlying object as [other].
  UIUserActivityRestoring.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIUserActivityRestoring] that wraps the given raw object pointer.
  UIUserActivityRestoring.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
abstract final class ObjCBlock_NSDictionary_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> fromFunction(objc.NSDictionary Function(objc.NSDictionary ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(objc.NSDictionary.fromPointer(arg0, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
extension ObjCBlock_NSDictionary_NSDictionary$CallExtension on objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> {
  objc.NSDictionary call(objc.NSDictionary arg0) =>objc.NSDictionary.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer), retain: true, release: true);
}

sealed class UIEditingInteractionConfiguration {
  static const UIEditingInteractionConfigurationNone = 0;
  static const UIEditingInteractionConfigurationDefault = 1;}


/// WARNING: UIResponderStandardEditActions is a stub. To generate bindings for this class, include
/// UIResponderStandardEditActions in your config's objc-protocols list.
///
/// UIResponderStandardEditActions
extension type UIResponderStandardEditActions._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIResponderStandardEditActions] that points to the same underlying object as [other].
  UIResponderStandardEditActions.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIResponderStandardEditActions] that wraps the given raw object pointer.
  UIResponderStandardEditActions.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _class_UIResponder = objc.getClass("UIResponder");
late final _sel_nextResponder = objc.registerName("nextResponder");
late final _sel_canBecomeFirstResponder = objc.registerName("canBecomeFirstResponder");
late final _sel_becomeFirstResponder = objc.registerName("becomeFirstResponder");
late final _sel_canResignFirstResponder = objc.registerName("canResignFirstResponder");
late final _sel_resignFirstResponder = objc.registerName("resignFirstResponder");
late final _sel_isFirstResponder = objc.registerName("isFirstResponder");
late final _sel_touchesBegan_withEvent_ = objc.registerName("touchesBegan:withEvent:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_touchesMoved_withEvent_ = objc.registerName("touchesMoved:withEvent:");
late final _sel_touchesEnded_withEvent_ = objc.registerName("touchesEnded:withEvent:");
late final _sel_touchesCancelled_withEvent_ = objc.registerName("touchesCancelled:withEvent:");
late final _sel_touchesEstimatedPropertiesUpdated_ = objc.registerName("touchesEstimatedPropertiesUpdated:");

/// WARNING: UIPressesEvent is a stub. To generate bindings for this class, include
/// UIPressesEvent in your config's objc-interfaces list.
///
/// UIPressesEvent
extension type UIPressesEvent._(objc.ObjCObject object$) implements objc.ObjCObject,UIEvent {
  /// Constructs a [UIPressesEvent] that points to the same underlying object as [other].
  UIPressesEvent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPressesEvent', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIPressesEvent] that wraps the given raw object pointer.
  UIPressesEvent.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPressesEvent', iOS: (false, (9, 0, 0)));
  }


}

late final _sel_pressesBegan_withEvent_ = objc.registerName("pressesBegan:withEvent:");
late final _sel_pressesChanged_withEvent_ = objc.registerName("pressesChanged:withEvent:");
late final _sel_pressesEnded_withEvent_ = objc.registerName("pressesEnded:withEvent:");
late final _sel_pressesCancelled_withEvent_ = objc.registerName("pressesCancelled:withEvent:");
late final _sel_motionBegan_withEvent_ = objc.registerName("motionBegan:withEvent:");
final _objc_msgSend_pov02z = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_motionEnded_withEvent_ = objc.registerName("motionEnded:withEvent:");
late final _sel_motionCancelled_withEvent_ = objc.registerName("motionCancelled:withEvent:");
late final _sel_remoteControlReceivedWithEvent_ = objc.registerName("remoteControlReceivedWithEvent:");
late final _sel_canPerformAction_withSender_ = objc.registerName("canPerformAction:withSender:");
final _objc_msgSend_1f04296 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_targetForAction_withSender_ = objc.registerName("targetForAction:withSender:");
final _objc_msgSend_gx50so = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// WARNING: UIMenuBuilder is a stub. To generate bindings for this class, include
/// UIMenuBuilder in your config's objc-protocols list.
///
/// UIMenuBuilder
extension type UIMenuBuilder._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [UIMenuBuilder] that points to the same underlying object as [other].
  UIMenuBuilder.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIMenuBuilder] that wraps the given raw object pointer.
  UIMenuBuilder.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_buildMenuWithBuilder_ = objc.registerName("buildMenuWithBuilder:");
late final _sel_validateCommand_ = objc.registerName("validateCommand:");

/// WARNING: UIDeferredMenuElementProvider is a stub. To generate bindings for this class, include
/// UIDeferredMenuElementProvider in your config's objc-interfaces list.
///
/// UIDeferredMenuElementProvider
extension type UIDeferredMenuElementProvider._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UIDeferredMenuElementProvider] that points to the same underlying object as [other].
  UIDeferredMenuElementProvider.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIDeferredMenuElementProvider', iOS: (false, (26, 0, 0)));
  }

  /// Constructs a [UIDeferredMenuElementProvider] that wraps the given raw object pointer.
  UIDeferredMenuElementProvider.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIDeferredMenuElementProvider', iOS: (false, (26, 0, 0)));
  }


}


/// WARNING: UIDeferredMenuElement is a stub. To generate bindings for this class, include
/// UIDeferredMenuElement in your config's objc-interfaces list.
///
/// UIDeferredMenuElement
extension type UIDeferredMenuElement._(objc.ObjCObject object$) implements objc.ObjCObject,UIMenuElement {
  /// Constructs a [UIDeferredMenuElement] that points to the same underlying object as [other].
  UIDeferredMenuElement.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIDeferredMenuElement', iOS: (false, (14, 0, 0)));
  }

  /// Constructs a [UIDeferredMenuElement] that wraps the given raw object pointer.
  UIDeferredMenuElement.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIDeferredMenuElement', iOS: (false, (14, 0, 0)));
  }


}

late final _sel_providerForDeferredMenuElement_ = objc.registerName("providerForDeferredMenuElement:");
late final _sel_undoManager = objc.registerName("undoManager");
late final _sel_editingInteractionConfiguration = objc.registerName("editingInteractionConfiguration");
final _objc_msgSend_15pfzxv = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_cut_ = objc.registerName("cut:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> listener(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_copy_ = objc.registerName("copy:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> listener(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$1$CallExtension on objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_paste_ = objc.registerName("paste:");
late final _sel_pasteAndMatchStyle_ = objc.registerName("pasteAndMatchStyle:");
late final _sel_pasteAndGo_ = objc.registerName("pasteAndGo:");
late final _sel_pasteAndSearch_ = objc.registerName("pasteAndSearch:");
late final _sel_newFromPasteboard_ = objc.registerName("newFromPasteboard:");
late final _sel_select_ = objc.registerName("select:");
late final _sel_selectAll_ = objc.registerName("selectAll:");
late final _sel_delete_ = objc.registerName("delete:");
late final _sel_makeTextWritingDirectionLeftToRight_ = objc.registerName("makeTextWritingDirectionLeftToRight:");
late final _sel_makeTextWritingDirectionRightToLeft_ = objc.registerName("makeTextWritingDirectionRightToLeft:");
late final _sel_toggleBoldface_ = objc.registerName("toggleBoldface:");
late final _sel_toggleItalics_ = objc.registerName("toggleItalics:");
late final _sel_toggleUnderline_ = objc.registerName("toggleUnderline:");
late final _sel_increaseSize_ = objc.registerName("increaseSize:");
late final _sel_decreaseSize_ = objc.registerName("decreaseSize:");
late final _sel_alignLeft_ = objc.registerName("alignLeft:");
late final _sel_alignCenter_ = objc.registerName("alignCenter:");
late final _sel_alignJustified_ = objc.registerName("alignJustified:");
late final _sel_alignRight_ = objc.registerName("alignRight:");
late final _sel_find_ = objc.registerName("find:");
late final _sel_findAndReplace_ = objc.registerName("findAndReplace:");
late final _sel_findNext_ = objc.registerName("findNext:");
late final _sel_findPrevious_ = objc.registerName("findPrevious:");
late final _sel_useSelectionForFind_ = objc.registerName("useSelectionForFind:");
late final _sel_updateTextAttributesWithConversionHandler_ = objc.registerName("updateTextAttributesWithConversionHandler:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(void Function(objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0 ? null : objc.NSError.fromPointer(arg0, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(void Function(objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0 ? null : objc.NSError.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(void Function(objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0 ? null : objc.NSError.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0 ? null : objc.NSError.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(arg0, ObjCBlock_NSDictionary_NSDictionary.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)> listener(void Function(ffi.Pointer<ffi.Void> , objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(arg0, ObjCBlock_NSDictionary_NSDictionary.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1l4hxwm(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(arg0, ObjCBlock_NSDictionary_NSDictionary.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(arg0, ObjCBlock_NSDictionary_NSDictionary.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1l4hxwm(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCBlockImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_print_ = objc.registerName("print:");
late final _sel_rename_ = objc.registerName("rename:");
late final _sel_duplicate_ = objc.registerName("duplicate:");
late final _sel_move_ = objc.registerName("move:");
late final _sel_export_ = objc.registerName("export:");
late final _sel_toggleSidebar_ = objc.registerName("toggleSidebar:");
late final _sel_toggleInspector_ = objc.registerName("toggleInspector:");
late final _sel_performClose_ = objc.registerName("performClose:");
late final _sel_showWritingTools_ = objc.registerName("showWritingTools:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$2 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.ObjCObject(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)> listener(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$2$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_keyCommands = objc.registerName("keyCommands");

/// UIResponderKeyCommands
extension UIResponderKeyCommands on UIResponder {

  /// keyCommands
  objc.NSArray? get keyCommands {
  objc.checkOsVersionInternal('UIResponder.keyCommands', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_keyCommands);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_UIView = objc.getClass("UIView");
late final _sel_layerClass = objc.registerName("layerClass");
late final _sel_initWithFrame_ = objc.registerName("initWithFrame:");
final _objc_msgSend_15yz4e6 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect )>();
late final _sel_isUserInteractionEnabled = objc.registerName("isUserInteractionEnabled");
late final _sel_setUserInteractionEnabled_ = objc.registerName("setUserInteractionEnabled:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , bool )>();
late final _sel_tag = objc.registerName("tag");
late final _sel_setTag_ = objc.registerName("setTag:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_layer = objc.registerName("layer");
late final _sel_canBecomeFocused = objc.registerName("canBecomeFocused");
late final _sel_isFocused = objc.registerName("isFocused");
late final _sel_focusGroupIdentifier = objc.registerName("focusGroupIdentifier");
late final _sel_setFocusGroupIdentifier_ = objc.registerName("setFocusGroupIdentifier:");
late final _sel_focusGroupPriority = objc.registerName("focusGroupPriority");
late final _sel_setFocusGroupPriority_ = objc.registerName("setFocusGroupPriority:");

/// WARNING: UIFocusEffect is a stub. To generate bindings for this class, include
/// UIFocusEffect in your config's objc-interfaces list.
///
/// UIFocusEffect
extension type UIFocusEffect._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying {
  /// Constructs a [UIFocusEffect] that points to the same underlying object as [other].
  UIFocusEffect.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIFocusEffect', iOS: (false, (15, 0, 0)));
  }

  /// Constructs a [UIFocusEffect] that wraps the given raw object pointer.
  UIFocusEffect.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusEffect', iOS: (false, (15, 0, 0)));
  }


}

late final _sel_focusEffect = objc.registerName("focusEffect");
late final _sel_setFocusEffect_ = objc.registerName("setFocusEffect:");
sealed class UISemanticContentAttribute {
  static const UISemanticContentAttributeUnspecified = 0;
  static const UISemanticContentAttributePlayback = 1;
  static const UISemanticContentAttributeSpatial = 2;
  static const UISemanticContentAttributeForceLeftToRight = 3;
  static const UISemanticContentAttributeForceRightToLeft = 4;}

late final _sel_semanticContentAttribute = objc.registerName("semanticContentAttribute");
final _objc_msgSend_i2u4x4 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setSemanticContentAttribute_ = objc.registerName("setSemanticContentAttribute:");
final _objc_msgSend_162qwxu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
sealed class UIUserInterfaceLayoutDirection {
  static const UIUserInterfaceLayoutDirectionLeftToRight = 0;
  static const UIUserInterfaceLayoutDirectionRightToLeft = 1;}

late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_ = objc.registerName("userInterfaceLayoutDirectionForSemanticContentAttribute:");
final _objc_msgSend_racczx = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_ = objc.registerName("userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:");
final _objc_msgSend_tz4p54 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long , ffi.Long )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , int )>();
late final _sel_effectiveUserInterfaceLayoutDirection = objc.registerName("effectiveUserInterfaceLayoutDirection");
final _objc_msgSend_qj4fey = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_appearance = objc.registerName("appearance");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.ObjCObject Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObject call(ffi.Pointer<ffi.Void> arg0) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}


/// WARNING: UIAppearanceContainer is a stub. To generate bindings for this class, include
/// UIAppearanceContainer in your config's objc-protocols list.
///
/// UIAppearanceContainer
extension type UIAppearanceContainer._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAppearanceContainer] that points to the same underlying object as [other].
  UIAppearanceContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAppearanceContainer] that wraps the given raw object pointer.
  UIAppearanceContainer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_appearanceWhenContainedIn_ = objc.registerName("appearanceWhenContainedIn:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void> , UIAppearanceContainer? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIAppearanceContainer.fromPointer(arg1, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UIAppearanceContainer? arg1) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr), retain: true, release: true);
}

late final _sel_appearanceWhenContainedInInstancesOfClasses_ = objc.registerName("appearanceWhenContainedInInstancesOfClasses:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void> , objc.NSArray ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSArray.fromPointer(arg1, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_NSArray$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer), retain: true, release: true);
}

late final _sel_appearanceForTraitCollection_ = objc.registerName("appearanceForTraitCollection:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void> , UITraitCollection ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UITraitCollection.fromPointer(arg1, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer), retain: true, release: true);
}

late final _sel_appearanceForTraitCollection_whenContainedIn_ = objc.registerName("appearanceForTraitCollection:whenContainedIn:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void> , UITraitCollection , UIAppearanceContainer? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UITraitCollection.fromPointer(arg1, retain: true, release: true), arg2.address == 0 ? null : UIAppearanceContainer.fromPointer(arg2, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1, UIAppearanceContainer? arg2) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2?.ref.pointer ?? ffi.nullptr), retain: true, release: true);
}

late final _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_ = objc.registerName("appearanceForTraitCollection:whenContainedInInstancesOfClasses:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)> fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void> , UITraitCollection , objc.NSArray ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UITraitCollection.fromPointer(arg1, retain: true, release: true), objc.NSArray.fromPointer(arg2, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1, objc.NSArray arg2) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer), retain: true, release: true);
}

late final _sel_center = objc.registerName("center");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGPoint_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.CGPoint Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static objc.CGPoint _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static objc.CGPoint _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as objc.CGPoint Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGPoint_ffiVoid$CallExtension on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_setCenter_ = objc.registerName("setCenter:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGPoint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.CGPoint ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> listener(void Function(ffi.Pointer<ffi.Void> , objc.CGPoint ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1bktu2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.CGPoint ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1bktu2(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , objc.CGPoint ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , objc.CGPoint ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , objc.CGPoint )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , objc.CGPoint )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , objc.CGPoint )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , objc.CGPoint )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , objc.CGPoint )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , objc.CGPoint ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGPoint$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint )>()(
    ref.pointer, arg0, arg1);
}

late final _sel_bounds = objc.registerName("bounds");
final _objc_msgSend_bu1hbw = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.CGRect Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static objc.CGRect _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static objc.CGRect _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as objc.CGRect Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGRect_ffiVoid$CallExtension on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_transform = objc.registerName("transform");
final _objc_msgSend_5qswvj = objc.msgSendPointer.cast<ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_5qswvjStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CGAffineTransform> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<CGAffineTransform> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGAffineTransform_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> fromFunction(CGAffineTransform Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static CGAffineTransform _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static CGAffineTransform _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as CGAffineTransform Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGAffineTransform_ffiVoid$CallExtension on objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> {
  CGAffineTransform call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_setTransform_ = objc.registerName("setTransform:");
final _objc_msgSend_qgt66z = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CGAffineTransform )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CGAffineTransform )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> fromFunction(void Function(ffi.Pointer<ffi.Void> , CGAffineTransform ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> listener(void Function(ffi.Pointer<ffi.Void> , CGAffineTransform ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1lznlw3(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> blocking(void Function(ffi.Pointer<ffi.Void> , CGAffineTransform ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1lznlw3(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , CGAffineTransform ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , CGAffineTransform )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , CGAffineTransform )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , CGAffineTransform ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , CGAffineTransform )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , CGAffineTransform )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , CGAffineTransform )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , CGAffineTransform )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , CGAffineTransform )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , CGAffineTransform )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , CGAffineTransform ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , CGAffineTransform )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> {
  void call(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , CGAffineTransform )>()(
    ref.pointer, arg0, arg1);
}

sealed class UIDynamicItemCollisionBoundsType {
  static const UIDynamicItemCollisionBoundsTypeRectangle = 0;
  static const UIDynamicItemCollisionBoundsTypeEllipse = 1;
  static const UIDynamicItemCollisionBoundsTypePath = 2;}

late final _sel_collisionBoundsType = objc.registerName("collisionBoundsType");
final _objc_msgSend_k9iunc = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunction(int Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static int _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<int Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline , 0).cast();
  static int _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline , 0).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid$CallExtension on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_collisionBoundingPath = objc.registerName("collisionBoundingPath");

/// Construction methods for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIBezierPath_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> fromFunction(UIBezierPath Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIBezierPath_ffiVoid$CallExtension on objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> {
  UIBezierPath call(ffi.Pointer<ffi.Void> arg0) =>UIBezierPath.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}


/// Construction methods for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UITraitCollection_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> fromFunction(UITraitCollection Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UITraitCollection_ffiVoid$CallExtension on objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> {
  UITraitCollection call(ffi.Pointer<ffi.Void> arg0) =>UITraitCollection.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_traitCollectionDidChange_ = objc.registerName("traitCollectionDidChange:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromFunction(void Function(ffi.Pointer<ffi.Void> , UITraitCollection? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UITraitCollection.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> listener(void Function(ffi.Pointer<ffi.Void> , UITraitCollection? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> blocking(void Function(ffi.Pointer<ffi.Void> , UITraitCollection? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}


/// WARNING: UICoordinateSpace is a stub. To generate bindings for this class, include
/// UICoordinateSpace in your config's objc-protocols list.
///
/// UICoordinateSpace
extension type UICoordinateSpace._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UICoordinateSpace] that points to the same underlying object as [other].
  UICoordinateSpace.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UICoordinateSpace] that wraps the given raw object pointer.
  UICoordinateSpace.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_convertPoint_toCoordinateSpace_ = objc.registerName("convertPoint:toCoordinateSpace:");
final _objc_msgSend_3l1tu1 = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_3l1tu1Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)> fromFunction(objc.CGPoint Function(ffi.Pointer<ffi.Void> , objc.CGPoint , UICoordinateSpace ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1, UICoordinateSpace.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static objc.CGPoint _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static objc.CGPoint _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as objc.CGPoint Function(ffi.Pointer<ffi.Void> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace$CallExtension on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, UICoordinateSpace arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertPoint_fromCoordinateSpace_ = objc.registerName("convertPoint:fromCoordinateSpace:");
late final _sel_convertRect_toCoordinateSpace_ = objc.registerName("convertRect:toCoordinateSpace:");
final _objc_msgSend_2olghr = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_2olghrStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)> fromFunction(objc.CGRect Function(ffi.Pointer<ffi.Void> , objc.CGRect , UICoordinateSpace ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1, UICoordinateSpace.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static objc.CGRect _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static objc.CGRect _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as objc.CGRect Function(ffi.Pointer<ffi.Void> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace$CallExtension on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, UICoordinateSpace arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertRect_fromCoordinateSpace_ = objc.registerName("convertRect:fromCoordinateSpace:");
late final _sel_frame = objc.registerName("frame");
sealed class UIFocusItemDeferralMode {
  static const UIFocusItemDeferralModeAutomatic = 0;
  static const UIFocusItemDeferralModeAlways = 1;
  static const UIFocusItemDeferralModeNever = 2;}

late final _sel_focusItemDeferralMode = objc.registerName("focusItemDeferralMode");
final _objc_msgSend_1lv2zxu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIFocusItemDeferralMode_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(int Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static int _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<int Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline , 0).cast();
  static int _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline , 0).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIFocusItemDeferralMode_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_isTransparentFocusItem = objc.registerName("isTransparentFocusItem");

/// WARNING: UIFocusMovementHint is a stub. To generate bindings for this class, include
/// UIFocusMovementHint in your config's objc-interfaces list.
///
/// UIFocusMovementHint
extension type UIFocusMovementHint._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying {
  /// Constructs a [UIFocusMovementHint] that points to the same underlying object as [other].
  UIFocusMovementHint.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIFocusMovementHint', iOS: (false, (12, 0, 0)));
  }

  /// Constructs a [UIFocusMovementHint] that wraps the given raw object pointer.
  UIFocusMovementHint.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusMovementHint', iOS: (false, (12, 0, 0)));
  }


}

late final _sel_didHintFocusMovement_ = objc.registerName("didHintFocusMovement:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromFunction(void Function(ffi.Pointer<ffi.Void> , UIFocusMovementHint ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UIFocusMovementHint.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> listener(void Function(ffi.Pointer<ffi.Void> , UIFocusMovementHint ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UIFocusMovementHint.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> blocking(void Function(ffi.Pointer<ffi.Void> , UIFocusMovementHint ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UIFocusMovementHint.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UIFocusMovementHint.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusMovementHint arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_preferredFocusEnvironments = objc.registerName("preferredFocusEnvironments");

/// WARNING: UIFocusEnvironment is a stub. To generate bindings for this class, include
/// UIFocusEnvironment in your config's objc-protocols list.
///
/// UIFocusEnvironment
extension type UIFocusEnvironment._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIFocusEnvironment] that points to the same underlying object as [other].
  UIFocusEnvironment.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusEnvironment] that wraps the given raw object pointer.
  UIFocusEnvironment.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_parentFocusEnvironment = objc.registerName("parentFocusEnvironment");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusEnvironment_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunction(UIFocusEnvironment? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusEnvironment_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusEnvironment? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : UIFocusEnvironment.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}


/// WARNING: UIFocusItemContainer is a stub. To generate bindings for this class, include
/// UIFocusItemContainer in your config's objc-protocols list.
///
/// UIFocusItemContainer
extension type UIFocusItemContainer._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIFocusItemContainer] that points to the same underlying object as [other].
  UIFocusItemContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusItemContainer] that wraps the given raw object pointer.
  UIFocusItemContainer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_focusItemContainer = objc.registerName("focusItemContainer");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusItemContainer_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunction(UIFocusItemContainer? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusItemContainer_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusItemContainer? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : UIFocusItemContainer.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_setNeedsFocusUpdate = objc.registerName("setNeedsFocusUpdate");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(void Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(void Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(void Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_ovsamd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> ))(arg0);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> ))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_updateFocusIfNeeded = objc.registerName("updateFocusIfNeeded");

/// WARNING: UIFocusUpdateContext is a stub. To generate bindings for this class, include
/// UIFocusUpdateContext in your config's objc-interfaces list.
///
/// UIFocusUpdateContext
extension type UIFocusUpdateContext._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UIFocusUpdateContext] that points to the same underlying object as [other].
  UIFocusUpdateContext.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIFocusUpdateContext', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusUpdateContext] that wraps the given raw object pointer.
  UIFocusUpdateContext.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusUpdateContext', iOS: (false, (9, 0, 0)));
  }


}

late final _sel_shouldUpdateFocusInContext_ = objc.registerName("shouldUpdateFocusInContext:");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunction(bool Function(ffi.Pointer<ffi.Void> , UIFocusUpdateContext ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UIFocusUpdateContext.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_bool_ffiVoid_UIFocusUpdateContext$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}


/// WARNING: UIFocusAnimationCoordinator is a stub. To generate bindings for this class, include
/// UIFocusAnimationCoordinator in your config's objc-interfaces list.
///
/// UIFocusAnimationCoordinator
extension type UIFocusAnimationCoordinator._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UIFocusAnimationCoordinator] that points to the same underlying object as [other].
  UIFocusAnimationCoordinator.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIFocusAnimationCoordinator', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusAnimationCoordinator] that wraps the given raw object pointer.
  UIFocusAnimationCoordinator.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusAnimationCoordinator', iOS: (false, (9, 0, 0)));
  }


}

late final _sel_didUpdateFocusInContext_withAnimationCoordinator_ = objc.registerName("didUpdateFocusInContext:withAnimationCoordinator:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> fromFunction(void Function(ffi.Pointer<ffi.Void> , UIFocusUpdateContext , UIFocusAnimationCoordinator ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UIFocusUpdateContext.fromPointer(arg1, retain: true, release: true), UIFocusAnimationCoordinator.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> listener(void Function(ffi.Pointer<ffi.Void> , UIFocusUpdateContext , UIFocusAnimationCoordinator ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UIFocusUpdateContext.fromPointer(arg1, retain: false, release: true), UIFocusAnimationCoordinator.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> blocking(void Function(ffi.Pointer<ffi.Void> , UIFocusUpdateContext , UIFocusAnimationCoordinator ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UIFocusUpdateContext.fromPointer(arg1, retain: false, release: true), UIFocusAnimationCoordinator.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UIFocusUpdateContext.fromPointer(arg1, retain: false, release: true), UIFocusAnimationCoordinator.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1, UIFocusAnimationCoordinator arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_soundIdentifierForFocusUpdateInContext_ = objc.registerName("soundIdentifierForFocusUpdateInContext:");

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunction(objc.NSString? Function(ffi.Pointer<ffi.Void> , UIFocusUpdateContext ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UIFocusUpdateContext.fromPointer(arg1, retain: true, release: true))?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext$CallExtension on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer).address == 0 ? null : objc.NSString.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer), retain: true, release: true);
}

late final _sel_preferredFocusedView = objc.registerName("preferredFocusedView");

/// Construction methods for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIView_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunction(UIView? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIView_ffiVoid$CallExtension on objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> {
  UIView? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : UIView.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_coordinateSpace = objc.registerName("coordinateSpace");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUICoordinateSpace_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)> fromFunction(UICoordinateSpace Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUICoordinateSpace_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)> {
  UICoordinateSpace call(ffi.Pointer<ffi.Void> arg0) =>UICoordinateSpace.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_focusItemsInRect_ = objc.registerName("focusItemsInRect:");

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_CGRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>> ptr) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> fromFunction(objc.NSArray Function(ffi.Pointer<ffi.Void> , objc.CGRect ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => fn(arg0, arg1).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , objc.CGRect )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGRect )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , objc.CGRect ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGRect )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
extension ObjCBlock_NSArray_ffiVoid_CGRect$CallExtension on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) =>objc.NSArray.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , objc.CGRect )>()(
    ref.pointer, arg0, arg1), retain: true, release: true);
}

late final _sel_displayLayer_ = objc.registerName("displayLayer:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> fromFunction(void Function(ffi.Pointer<ffi.Void> , CALayer ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, CALayer.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> listener(void Function(ffi.Pointer<ffi.Void> , CALayer ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> blocking(void Function(ffi.Pointer<ffi.Void> , CALayer ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_drawLayer_inContext_ = objc.registerName("drawLayer:inContext:");
final _objc_msgSend_a4xp11 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> fromFunction(void Function(ffi.Pointer<ffi.Void> , CALayer , ffi.Pointer<CGContext> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2) => fn(arg0, CALayer.fromPointer(arg1, retain: true, release: true), arg2), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> listener(void Function(ffi.Pointer<ffi.Void> , CALayer , ffi.Pointer<CGContext> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2) => fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true), arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_qvcerx(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> blocking(void Function(ffi.Pointer<ffi.Void> , CALayer , ffi.Pointer<CGContext> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2) => fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true), arg2), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2) => fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true), arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_qvcerx(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1, ffi.Pointer<CGContext> arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<CGContext> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<CGContext> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2);
}

late final _sel_layerWillDraw_ = objc.registerName("layerWillDraw:");
late final _sel_layoutSublayersOfLayer_ = objc.registerName("layoutSublayersOfLayer:");
late final _sel_actionForLayer_forKey_ = objc.registerName("actionForLayer:forKey:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
abstract final class ObjCBlock_idCAAction_ffiVoid_CALayer_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)> fromFunction(CAAction? Function(ffi.Pointer<ffi.Void> , CALayer , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, CALayer.fromPointer(arg1, retain: true, release: true), objc.NSString.fromPointer(arg2, retain: true, release: true))?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
extension ObjCBlock_idCAAction_ffiVoid_CALayer_NSString$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)> {
  CAAction? call(ffi.Pointer<ffi.Void> arg0, CALayer arg1, objc.NSString arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer).address == 0 ? null : CAAction.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer), retain: true, release: true);
}


/// WARNING: UITraitOverrides is a stub. To generate bindings for this class, include
/// UITraitOverrides in your config's objc-protocols list.
///
/// UITraitOverrides
extension type UITraitOverrides._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, UIMutableTraits {
  /// Constructs a [UITraitOverrides] that points to the same underlying object as [other].
  UITraitOverrides.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITraitOverrides] that wraps the given raw object pointer.
  UITraitOverrides.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_traitOverrides = objc.registerName("traitOverrides");
late final _sel_updateTraitsIfNeeded = objc.registerName("updateTraitsIfNeeded");
late final _sel_setFrame_ = objc.registerName("setFrame:");
late final _sel_setBounds_ = objc.registerName("setBounds:");
late final _sel_transform3D = objc.registerName("transform3D");
final _objc_msgSend_5qlg3j = objc.msgSendPointer.cast<ffi.NativeFunction<CATransform3D Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<CATransform3D Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_5qlg3jStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CATransform3D> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<CATransform3D> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setTransform3D_ = objc.registerName("setTransform3D:");
final _objc_msgSend_1s50tpz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CATransform3D )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CATransform3D )>();
late final _sel_contentScaleFactor = objc.registerName("contentScaleFactor");
late final _sel_setContentScaleFactor_ = objc.registerName("setContentScaleFactor:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double )>();
late final _sel_anchorPoint = objc.registerName("anchorPoint");
late final _sel_setAnchorPoint_ = objc.registerName("setAnchorPoint:");
late final _sel_isMultipleTouchEnabled = objc.registerName("isMultipleTouchEnabled");
late final _sel_setMultipleTouchEnabled_ = objc.registerName("setMultipleTouchEnabled:");
late final _sel_isExclusiveTouch = objc.registerName("isExclusiveTouch");
late final _sel_setExclusiveTouch_ = objc.registerName("setExclusiveTouch:");
late final _sel_hitTest_withEvent_ = objc.registerName("hitTest:withEvent:");
final _objc_msgSend_u7nfz8 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_pointInside_withEvent_ = objc.registerName("pointInside:withEvent:");
final _objc_msgSend_yvwe5y = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_convertPoint_toView_ = objc.registerName("convertPoint:toView:");
late final _sel_convertPoint_fromView_ = objc.registerName("convertPoint:fromView:");
late final _sel_convertRect_toView_ = objc.registerName("convertRect:toView:");
late final _sel_convertRect_fromView_ = objc.registerName("convertRect:fromView:");
late final _sel_autoresizesSubviews = objc.registerName("autoresizesSubviews");
late final _sel_setAutoresizesSubviews_ = objc.registerName("setAutoresizesSubviews:");
sealed class UIViewAutoresizing {
  static const UIViewAutoresizingNone = 0;
  static const UIViewAutoresizingFlexibleLeftMargin = 1;
  static const UIViewAutoresizingFlexibleWidth = 2;
  static const UIViewAutoresizingFlexibleRightMargin = 4;
  static const UIViewAutoresizingFlexibleTopMargin = 8;
  static const UIViewAutoresizingFlexibleHeight = 16;
  static const UIViewAutoresizingFlexibleBottomMargin = 32;}

late final _sel_autoresizingMask = objc.registerName("autoresizingMask");
final _objc_msgSend_sq30wq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setAutoresizingMask_ = objc.registerName("setAutoresizingMask:");
final _objc_msgSend_qjq6uk = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_sizeThatFits_ = objc.registerName("sizeThatFits:");
final _objc_msgSend_1owrp3b = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize )>();
final _objc_msgSend_1owrp3bStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize )>();
late final _sel_sizeToFit = objc.registerName("sizeToFit");

/// UIViewGeometry
extension UIViewGeometry on UIView {

  /// anchorPoint
  objc.CGPoint get anchorPoint {
  objc.checkOsVersionInternal('UIView.anchorPoint', iOS: (false, (16, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_anchorPoint) : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_anchorPoint);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// autoresizesSubviews
  bool get autoresizesSubviews {
  objc.checkOsVersionInternal('UIView.autoresizesSubviews', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_autoresizesSubviews);

  }


  /// autoresizingMask
  int get autoresizingMask {
  objc.checkOsVersionInternal('UIView.autoresizingMask', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_sq30wq(object$.ref.pointer, _sel_autoresizingMask);

  }


  /// bounds
  objc.CGRect get bounds$1 {
  objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_bounds) : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// center
  objc.CGPoint get center$1 {
  objc.checkOsVersionInternal('UIView.center', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_center) : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_center);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// contentScaleFactor
  double get contentScaleFactor {
  objc.checkOsVersionInternal('UIView.contentScaleFactor', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_contentScaleFactor) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_contentScaleFactor);

  }


  /// convertPoint:fromView:
  objc.CGPoint convertPoint$2(objc.CGPoint point, {UIView? fromView}) {
  objc.checkOsVersionInternal('UIView.convertPoint:fromView:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_3l1tu1Stret($ptr, object$.ref.pointer, _sel_convertPoint_fromView_, point, fromView?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_3l1tu1(object$.ref.pointer, _sel_convertPoint_fromView_, point, fromView?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// convertPoint:toView:
  objc.CGPoint convertPoint$3(objc.CGPoint point, {UIView? toView}) {
  objc.checkOsVersionInternal('UIView.convertPoint:toView:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_3l1tu1Stret($ptr, object$.ref.pointer, _sel_convertPoint_toView_, point, toView?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_3l1tu1(object$.ref.pointer, _sel_convertPoint_toView_, point, toView?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// convertRect:fromView:
  objc.CGRect convertRect$2(objc.CGRect rect, {UIView? fromView}) {
  objc.checkOsVersionInternal('UIView.convertRect:fromView:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_2olghrStret($ptr, object$.ref.pointer, _sel_convertRect_fromView_, rect, fromView?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_2olghr(object$.ref.pointer, _sel_convertRect_fromView_, rect, fromView?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// convertRect:toView:
  objc.CGRect convertRect$3(objc.CGRect rect, {UIView? toView}) {
  objc.checkOsVersionInternal('UIView.convertRect:toView:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_2olghrStret($ptr, object$.ref.pointer, _sel_convertRect_toView_, rect, toView?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_2olghr(object$.ref.pointer, _sel_convertRect_toView_, rect, toView?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// frame
  objc.CGRect get frame$1 {
  objc.checkOsVersionInternal('UIView.frame', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame) : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// hitTest:withEvent:
  UIView? hitTest(objc.CGPoint point, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIView.hitTest:withEvent:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_u7nfz8(object$.ref.pointer, _sel_hitTest_withEvent_, point, withEvent?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// isExclusiveTouch
  bool get isExclusiveTouch {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isExclusiveTouch);

  }


  /// isMultipleTouchEnabled
  bool get isMultipleTouchEnabled {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isMultipleTouchEnabled);

  }


  /// pointInside:withEvent:
  bool pointInside(objc.CGPoint point, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIView.pointInside:withEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_yvwe5y(object$.ref.pointer, _sel_pointInside_withEvent_, point, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// setAnchorPoint:
  set anchorPoint(objc.CGPoint value) {
  objc.checkOsVersionInternal('UIView.setAnchorPoint:', iOS: (false, (16, 0, 0)));
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setAnchorPoint_, value);

  }


  /// setAutoresizesSubviews:
  set autoresizesSubviews(bool value) {
  objc.checkOsVersionInternal('UIView.setAutoresizesSubviews:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAutoresizesSubviews_, value);

  }


  /// setAutoresizingMask:
  set autoresizingMask(int value) {
  objc.checkOsVersionInternal('UIView.setAutoresizingMask:', iOS: (false, (2, 0, 0)));
_objc_msgSend_qjq6uk(object$.ref.pointer, _sel_setAutoresizingMask_, value);

  }


  /// setBounds:
  set bounds$1(objc.CGRect value) {
  objc.checkOsVersionInternal('UIView.setBounds:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1okkq16(object$.ref.pointer, _sel_setBounds_, value);

  }


  /// setCenter:
  set center$1(objc.CGPoint value) {
  objc.checkOsVersionInternal('UIView.setCenter:', iOS: (false, (2, 0, 0)));
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setCenter_, value);

  }


  /// setContentScaleFactor:
  set contentScaleFactor(double value) {
  objc.checkOsVersionInternal('UIView.setContentScaleFactor:', iOS: (false, (4, 0, 0)));
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setContentScaleFactor_, value);

  }


  /// setExclusiveTouch:
  set isExclusiveTouch(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setExclusiveTouch_, value);

  }


  /// setFrame:
  set frame$1(objc.CGRect value) {
  objc.checkOsVersionInternal('UIView.setFrame:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1okkq16(object$.ref.pointer, _sel_setFrame_, value);

  }


  /// setMultipleTouchEnabled:
  set isMultipleTouchEnabled(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setMultipleTouchEnabled_, value);

  }


  /// setTransform3D:
  set transform3D(CATransform3D value) {
  objc.checkOsVersionInternal('UIView.setTransform3D:', iOS: (false, (13, 0, 0)));
_objc_msgSend_1s50tpz(object$.ref.pointer, _sel_setTransform3D_, value);

  }


  /// setTransform:
  set transform$1(CGAffineTransform value) {
  objc.checkOsVersionInternal('UIView.setTransform:', iOS: (false, (2, 0, 0)));
_objc_msgSend_qgt66z(object$.ref.pointer, _sel_setTransform_, value);

  }


  /// sizeThatFits:
  objc.CGSize sizeThatFits(objc.CGSize size) {
  objc.checkOsVersionInternal('UIView.sizeThatFits:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1owrp3bStret($ptr, object$.ref.pointer, _sel_sizeThatFits_, size) : $ptr.ref = _objc_msgSend_1owrp3b(object$.ref.pointer, _sel_sizeThatFits_, size);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// sizeToFit
  void sizeToFit() {
  objc.checkOsVersionInternal('UIView.sizeToFit', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_sizeToFit);

  }


  /// transform
  CGAffineTransform get transform$1 {
  objc.checkOsVersionInternal('UIView.transform', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants ? _objc_msgSend_5qswvjStret($ptr, object$.ref.pointer, _sel_transform) : $ptr.ref = _objc_msgSend_5qswvj(object$.ref.pointer, _sel_transform);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGAffineTransform>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGAffineTransform>(
        $finalizable);

  }


  /// transform3D
  CATransform3D get transform3D {
  objc.checkOsVersionInternal('UIView.transform3D', iOS: (false, (13, 0, 0)));
    final $ptr = pkg_ffi.calloc<CATransform3D>();
    objc.useMsgSendVariants ? _objc_msgSend_5qlg3jStret($ptr, object$.ref.pointer, _sel_transform3D) : $ptr.ref = _objc_msgSend_5qlg3j(object$.ref.pointer, _sel_transform3D);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CATransform3D>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CATransform3D>(
        $finalizable);

  }

}

late final _sel_superview = objc.registerName("superview");
late final _sel_subviews = objc.registerName("subviews");

/// WARNING: UIWindow is a stub. To generate bindings for this class, include
/// UIWindow in your config's objc-interfaces list.
///
/// UIWindow
extension type UIWindow._(objc.ObjCObject object$) implements objc.ObjCObject,UIView {
  /// Constructs a [UIWindow] that points to the same underlying object as [other].
  UIWindow.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIWindow', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIWindow] that wraps the given raw object pointer.
  UIWindow.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIWindow', iOS: (false, (2, 0, 0)));
  }


}

late final _sel_window = objc.registerName("window");
late final _sel_removeFromSuperview = objc.registerName("removeFromSuperview");
late final _sel_insertSubview_atIndex_ = objc.registerName("insertSubview:atIndex:");
final _objc_msgSend_1nvl641 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
late final _sel_exchangeSubviewAtIndex_withSubviewAtIndex_ = objc.registerName("exchangeSubviewAtIndex:withSubviewAtIndex:");
final _objc_msgSend_1w5k0al = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , int )>();
late final _sel_addSubview_ = objc.registerName("addSubview:");
late final _sel_insertSubview_belowSubview_ = objc.registerName("insertSubview:belowSubview:");
late final _sel_insertSubview_aboveSubview_ = objc.registerName("insertSubview:aboveSubview:");
late final _sel_bringSubviewToFront_ = objc.registerName("bringSubviewToFront:");
late final _sel_sendSubviewToBack_ = objc.registerName("sendSubviewToBack:");
late final _sel_didAddSubview_ = objc.registerName("didAddSubview:");
late final _sel_willRemoveSubview_ = objc.registerName("willRemoveSubview:");
late final _sel_willMoveToSuperview_ = objc.registerName("willMoveToSuperview:");
late final _sel_didMoveToSuperview = objc.registerName("didMoveToSuperview");
late final _sel_willMoveToWindow_ = objc.registerName("willMoveToWindow:");
late final _sel_didMoveToWindow = objc.registerName("didMoveToWindow");
late final _sel_isDescendantOfView_ = objc.registerName("isDescendantOfView:");
late final _sel_viewWithTag_ = objc.registerName("viewWithTag:");
late final _sel_setNeedsUpdateProperties = objc.registerName("setNeedsUpdateProperties");
late final _sel_updateProperties = objc.registerName("updateProperties");
late final _sel_updatePropertiesIfNeeded = objc.registerName("updatePropertiesIfNeeded");
late final _sel_setNeedsLayout = objc.registerName("setNeedsLayout");
late final _sel_layoutIfNeeded = objc.registerName("layoutIfNeeded");
late final _sel_layoutSubviews = objc.registerName("layoutSubviews");
late final _sel_layoutMargins = objc.registerName("layoutMargins");
late final _sel_setLayoutMargins_ = objc.registerName("setLayoutMargins:");
final _objc_msgSend_1g8fos5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets )>();
late final _sel_directionalLayoutMargins = objc.registerName("directionalLayoutMargins");
final _objc_msgSend_12yjd2m = objc.msgSendPointer.cast<ffi.NativeFunction<NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_12yjd2mStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NSDirectionalEdgeInsets> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<NSDirectionalEdgeInsets> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setDirectionalLayoutMargins_ = objc.registerName("setDirectionalLayoutMargins:");
final _objc_msgSend_s0isf8 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , NSDirectionalEdgeInsets )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , NSDirectionalEdgeInsets )>();
late final _sel_preservesSuperviewLayoutMargins = objc.registerName("preservesSuperviewLayoutMargins");
late final _sel_setPreservesSuperviewLayoutMargins_ = objc.registerName("setPreservesSuperviewLayoutMargins:");
late final _sel_insetsLayoutMarginsFromSafeArea = objc.registerName("insetsLayoutMarginsFromSafeArea");
late final _sel_setInsetsLayoutMarginsFromSafeArea_ = objc.registerName("setInsetsLayoutMarginsFromSafeArea:");
late final _sel_layoutMarginsDidChange = objc.registerName("layoutMarginsDidChange");
late final _sel_safeAreaInsets = objc.registerName("safeAreaInsets");
late final _sel_safeAreaInsetsDidChange = objc.registerName("safeAreaInsetsDidChange");

/// WARNING: UILayoutGuide is a stub. To generate bindings for this class, include
/// UILayoutGuide in your config's objc-interfaces list.
///
/// UILayoutGuide
extension type UILayoutGuide._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCoding {
  /// Constructs a [UILayoutGuide] that points to the same underlying object as [other].
  UILayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UILayoutGuide] that wraps the given raw object pointer.
  UILayoutGuide.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }


}

late final _sel_layoutMarginsGuide = objc.registerName("layoutMarginsGuide");
late final _sel_readableContentGuide = objc.registerName("readableContentGuide");
late final _sel_safeAreaLayoutGuide = objc.registerName("safeAreaLayoutGuide");

/// WARNING: UIKeyboardLayoutGuide is a stub. To generate bindings for this class, include
/// UIKeyboardLayoutGuide in your config's objc-interfaces list.
///
/// UIKeyboardLayoutGuide
extension type UIKeyboardLayoutGuide._(objc.ObjCObject object$) implements objc.ObjCObject,UITrackingLayoutGuide {
  /// Constructs a [UIKeyboardLayoutGuide] that points to the same underlying object as [other].
  UIKeyboardLayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIKeyboardLayoutGuide', iOS: (false, (15, 0, 0)));
  }

  /// Constructs a [UIKeyboardLayoutGuide] that wraps the given raw object pointer.
  UIKeyboardLayoutGuide.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIKeyboardLayoutGuide', iOS: (false, (15, 0, 0)));
  }


}

late final _sel_keyboardLayoutGuide = objc.registerName("keyboardLayoutGuide");

/// UIViewHierarchy
extension UIViewHierarchy on UIView {

  /// addSubview:
  void addSubview(UIView view) {
  objc.checkOsVersionInternal('UIView.addSubview:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addSubview_, view.ref.pointer);

  }


  /// bringSubviewToFront:
  void bringSubviewToFront(UIView view) {
  objc.checkOsVersionInternal('UIView.bringSubviewToFront:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_bringSubviewToFront_, view.ref.pointer);

  }


  /// didAddSubview:
  void didAddSubview(UIView subview) {
  objc.checkOsVersionInternal('UIView.didAddSubview:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_didAddSubview_, subview.ref.pointer);

  }


  /// didMoveToSuperview
  void didMoveToSuperview() {
  objc.checkOsVersionInternal('UIView.didMoveToSuperview', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_didMoveToSuperview);

  }


  /// didMoveToWindow
  void didMoveToWindow() {
  objc.checkOsVersionInternal('UIView.didMoveToWindow', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_didMoveToWindow);

  }


  /// directionalLayoutMargins
  NSDirectionalEdgeInsets get directionalLayoutMargins {
  objc.checkOsVersionInternal('UIView.directionalLayoutMargins', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_12yjd2mStret($ptr, object$.ref.pointer, _sel_directionalLayoutMargins) : $ptr.ref = _objc_msgSend_12yjd2m(object$.ref.pointer, _sel_directionalLayoutMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSDirectionalEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSDirectionalEdgeInsets>(
        $finalizable);

  }


  /// exchangeSubviewAtIndex:withSubviewAtIndex:
  void exchangeSubviewAtIndex(int index1, {required int withSubviewAtIndex}) {
  objc.checkOsVersionInternal('UIView.exchangeSubviewAtIndex:withSubviewAtIndex:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1w5k0al(object$.ref.pointer, _sel_exchangeSubviewAtIndex_withSubviewAtIndex_, index1, withSubviewAtIndex);

  }


  /// insertSubview:aboveSubview:
  void insertSubview(UIView view, {required UIView aboveSubview}) {
  objc.checkOsVersionInternal('UIView.insertSubview:aboveSubview:', iOS: (false, (2, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_insertSubview_aboveSubview_, view.ref.pointer, aboveSubview.ref.pointer);

  }


  /// insertSubview:atIndex:
  void insertSubview$1(UIView view, {required int atIndex}) {
  objc.checkOsVersionInternal('UIView.insertSubview:atIndex:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1nvl641(object$.ref.pointer, _sel_insertSubview_atIndex_, view.ref.pointer, atIndex);

  }


  /// insertSubview:belowSubview:
  void insertSubview$2(UIView view, {required UIView belowSubview}) {
  objc.checkOsVersionInternal('UIView.insertSubview:belowSubview:', iOS: (false, (2, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_insertSubview_belowSubview_, view.ref.pointer, belowSubview.ref.pointer);

  }


  /// insetsLayoutMarginsFromSafeArea
  bool get insetsLayoutMarginsFromSafeArea {
  objc.checkOsVersionInternal('UIView.insetsLayoutMarginsFromSafeArea', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_insetsLayoutMarginsFromSafeArea);

  }


  /// isDescendantOfView:
  bool isDescendantOfView(UIView view) {
  objc.checkOsVersionInternal('UIView.isDescendantOfView:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_isDescendantOfView_, view.ref.pointer);

  }


  /// keyboardLayoutGuide
  UIKeyboardLayoutGuide get keyboardLayoutGuide {
  objc.checkOsVersionInternal('UIView.keyboardLayoutGuide', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_keyboardLayoutGuide);
    return UIKeyboardLayoutGuide.fromPointer($ret, retain: true, release: true);
  }


  /// layoutIfNeeded
  void layoutIfNeeded() {
  objc.checkOsVersionInternal('UIView.layoutIfNeeded', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutIfNeeded);

  }


  /// layoutMargins
  UIEdgeInsets get layoutMargins {
  objc.checkOsVersionInternal('UIView.layoutMargins', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_layoutMargins) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_layoutMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// layoutMarginsDidChange
  void layoutMarginsDidChange() {
  objc.checkOsVersionInternal('UIView.layoutMarginsDidChange', iOS: (false, (8, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutMarginsDidChange);

  }


  /// layoutMarginsGuide
  UILayoutGuide get layoutMarginsGuide {
  objc.checkOsVersionInternal('UIView.layoutMarginsGuide', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layoutMarginsGuide);
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }


  /// layoutSubviews
  void layoutSubviews() {
  objc.checkOsVersionInternal('UIView.layoutSubviews', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutSubviews);

  }


  /// preservesSuperviewLayoutMargins
  bool get preservesSuperviewLayoutMargins {
  objc.checkOsVersionInternal('UIView.preservesSuperviewLayoutMargins', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_preservesSuperviewLayoutMargins);

  }


  /// readableContentGuide
  UILayoutGuide get readableContentGuide {
  objc.checkOsVersionInternal('UIView.readableContentGuide', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_readableContentGuide);
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }


  /// removeFromSuperview
  void removeFromSuperview() {
  objc.checkOsVersionInternal('UIView.removeFromSuperview', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_removeFromSuperview);

  }


  /// safeAreaInsets
  UIEdgeInsets get safeAreaInsets {
  objc.checkOsVersionInternal('UIView.safeAreaInsets', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_safeAreaInsets) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_safeAreaInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// safeAreaInsetsDidChange
  void safeAreaInsetsDidChange() {
  objc.checkOsVersionInternal('UIView.safeAreaInsetsDidChange', iOS: (false, (11, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_safeAreaInsetsDidChange);

  }


  /// safeAreaLayoutGuide
  UILayoutGuide get safeAreaLayoutGuide {
  objc.checkOsVersionInternal('UIView.safeAreaLayoutGuide', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_safeAreaLayoutGuide);
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }


  /// sendSubviewToBack:
  void sendSubviewToBack(UIView view) {
  objc.checkOsVersionInternal('UIView.sendSubviewToBack:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_sendSubviewToBack_, view.ref.pointer);

  }


  /// setDirectionalLayoutMargins:
  set directionalLayoutMargins(NSDirectionalEdgeInsets value) {
  objc.checkOsVersionInternal('UIView.setDirectionalLayoutMargins:', iOS: (false, (11, 0, 0)));
_objc_msgSend_s0isf8(object$.ref.pointer, _sel_setDirectionalLayoutMargins_, value);

  }


  /// setInsetsLayoutMarginsFromSafeArea:
  set insetsLayoutMarginsFromSafeArea(bool value) {
  objc.checkOsVersionInternal('UIView.setInsetsLayoutMarginsFromSafeArea:', iOS: (false, (11, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setInsetsLayoutMarginsFromSafeArea_, value);

  }


  /// setLayoutMargins:
  set layoutMargins(UIEdgeInsets value) {
  objc.checkOsVersionInternal('UIView.setLayoutMargins:', iOS: (false, (8, 0, 0)));
_objc_msgSend_1g8fos5(object$.ref.pointer, _sel_setLayoutMargins_, value);

  }


  /// setNeedsLayout
  void setNeedsLayout() {
  objc.checkOsVersionInternal('UIView.setNeedsLayout', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsLayout);

  }


  /// setNeedsUpdateProperties
  void setNeedsUpdateProperties() {
  objc.checkOsVersionInternal('UIView.setNeedsUpdateProperties', iOS: (false, (26, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsUpdateProperties);

  }


  /// setPreservesSuperviewLayoutMargins:
  set preservesSuperviewLayoutMargins(bool value) {
  objc.checkOsVersionInternal('UIView.setPreservesSuperviewLayoutMargins:', iOS: (false, (8, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setPreservesSuperviewLayoutMargins_, value);

  }


  /// subviews
  objc.NSArray get subviews {
  objc.checkOsVersionInternal('UIView.subviews', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_subviews);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// superview
  UIView? get superview {
  objc.checkOsVersionInternal('UIView.superview', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_superview);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// updateProperties
  void updateProperties() {
  objc.checkOsVersionInternal('UIView.updateProperties', iOS: (false, (26, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateProperties);

  }


  /// updatePropertiesIfNeeded
  void updatePropertiesIfNeeded() {
  objc.checkOsVersionInternal('UIView.updatePropertiesIfNeeded', iOS: (false, (26, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updatePropertiesIfNeeded);

  }


  /// viewWithTag:
  UIView? viewWithTag(int tag) {
  objc.checkOsVersionInternal('UIView.viewWithTag:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_qugqlf(object$.ref.pointer, _sel_viewWithTag_, tag);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// willMoveToSuperview:
  void willMoveToSuperview(UIView? newSuperview) {
  objc.checkOsVersionInternal('UIView.willMoveToSuperview:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_willMoveToSuperview_, newSuperview?.ref.pointer ?? ffi.nullptr);

  }


  /// willMoveToWindow:
  void willMoveToWindow(UIWindow? newWindow) {
  objc.checkOsVersionInternal('UIView.willMoveToWindow:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_willMoveToWindow_, newWindow?.ref.pointer ?? ffi.nullptr);

  }


  /// willRemoveSubview:
  void willRemoveSubview(UIView subview) {
  objc.checkOsVersionInternal('UIView.willRemoveSubview:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_willRemoveSubview_, subview.ref.pointer);

  }


  /// window
  UIWindow? get window {
  objc.checkOsVersionInternal('UIView.window', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_window);
    return $ret.address == 0 ? null : UIWindow.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_drawRect_ = objc.registerName("drawRect:");
late final _sel_setNeedsDisplay = objc.registerName("setNeedsDisplay");
late final _sel_setNeedsDisplayInRect_ = objc.registerName("setNeedsDisplayInRect:");
late final _sel_clipsToBounds = objc.registerName("clipsToBounds");
late final _sel_setClipsToBounds_ = objc.registerName("setClipsToBounds:");
late final _sel_backgroundColor = objc.registerName("backgroundColor");
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
late final _sel_alpha = objc.registerName("alpha");
late final _sel_setAlpha_ = objc.registerName("setAlpha:");
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_setOpaque_ = objc.registerName("setOpaque:");
late final _sel_clearsContextBeforeDrawing = objc.registerName("clearsContextBeforeDrawing");
late final _sel_setClearsContextBeforeDrawing_ = objc.registerName("setClearsContextBeforeDrawing:");
late final _sel_isHidden = objc.registerName("isHidden");
late final _sel_setHidden_ = objc.registerName("setHidden:");
sealed class UIViewContentMode {
  static const UIViewContentModeScaleToFill = 0;
  static const UIViewContentModeScaleAspectFit = 1;
  static const UIViewContentModeScaleAspectFill = 2;
  static const UIViewContentModeRedraw = 3;
  static const UIViewContentModeCenter = 4;
  static const UIViewContentModeTop = 5;
  static const UIViewContentModeBottom = 6;
  static const UIViewContentModeLeft = 7;
  static const UIViewContentModeRight = 8;
  static const UIViewContentModeTopLeft = 9;
  static const UIViewContentModeTopRight = 10;
  static const UIViewContentModeBottomLeft = 11;
  static const UIViewContentModeBottomRight = 12;}

late final _sel_contentMode = objc.registerName("contentMode");
final _objc_msgSend_12r2l30 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setContentMode_ = objc.registerName("setContentMode:");
final _objc_msgSend_26z7iq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_contentStretch = objc.registerName("contentStretch");
late final _sel_setContentStretch_ = objc.registerName("setContentStretch:");
late final _sel_maskView = objc.registerName("maskView");
late final _sel_setMaskView_ = objc.registerName("setMaskView:");
late final _sel_tintColor = objc.registerName("tintColor");
late final _sel_setTintColor_ = objc.registerName("setTintColor:");
sealed class UIViewTintAdjustmentMode {
  static const UIViewTintAdjustmentModeAutomatic = 0;
  static const UIViewTintAdjustmentModeNormal = 1;
  static const UIViewTintAdjustmentModeDimmed = 2;}

late final _sel_tintAdjustmentMode = objc.registerName("tintAdjustmentMode");
final _objc_msgSend_1tlsbkb = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setTintAdjustmentMode_ = objc.registerName("setTintAdjustmentMode:");
final _objc_msgSend_15t6owj = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_tintColorDidChange = objc.registerName("tintColorDidChange");

/// UIViewRendering
extension UIViewRendering on UIView {

  /// alpha
  double get alpha {
  objc.checkOsVersionInternal('UIView.alpha', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_alpha) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_alpha);

  }


  /// backgroundColor
  UIColor? get backgroundColor {
  objc.checkOsVersionInternal('UIView.backgroundColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_backgroundColor);
    return $ret.address == 0 ? null : UIColor.fromPointer($ret, retain: true, release: true);
  }


  /// clearsContextBeforeDrawing
  bool get clearsContextBeforeDrawing {
  objc.checkOsVersionInternal('UIView.clearsContextBeforeDrawing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_clearsContextBeforeDrawing);

  }


  /// clipsToBounds
  bool get clipsToBounds {
  objc.checkOsVersionInternal('UIView.clipsToBounds', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_clipsToBounds);

  }


  /// contentMode
  int get contentMode {
  objc.checkOsVersionInternal('UIView.contentMode', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_12r2l30(object$.ref.pointer, _sel_contentMode);

  }


  /// contentStretch
  objc.CGRect get contentStretch {
  objc.checkOsVersionInternal('UIView.contentStretch', iOS: (false, (3, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_contentStretch) : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_contentStretch);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// drawRect:
  void drawRect(objc.CGRect rect) {
  objc.checkOsVersionInternal('UIView.drawRect:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1okkq16(object$.ref.pointer, _sel_drawRect_, rect);

  }


  /// isHidden
  bool get isHidden {
  objc.checkOsVersionInternal('UIView.isHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHidden);

  }


  /// isOpaque
  bool get isOpaque {
  objc.checkOsVersionInternal('UIView.isOpaque', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isOpaque);

  }


  /// maskView
  UIView? get maskView {
  objc.checkOsVersionInternal('UIView.maskView', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_maskView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// setAlpha:
  set alpha(double value) {
  objc.checkOsVersionInternal('UIView.setAlpha:', iOS: (false, (2, 0, 0)));
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setAlpha_, value);

  }


  /// setBackgroundColor:
  set backgroundColor(UIColor? value) {
  objc.checkOsVersionInternal('UIView.setBackgroundColor:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBackgroundColor_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setClearsContextBeforeDrawing:
  set clearsContextBeforeDrawing(bool value) {
  objc.checkOsVersionInternal('UIView.setClearsContextBeforeDrawing:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setClearsContextBeforeDrawing_, value);

  }


  /// setClipsToBounds:
  set clipsToBounds(bool value) {
  objc.checkOsVersionInternal('UIView.setClipsToBounds:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setClipsToBounds_, value);

  }


  /// setContentMode:
  set contentMode(int value) {
  objc.checkOsVersionInternal('UIView.setContentMode:', iOS: (false, (2, 0, 0)));
_objc_msgSend_26z7iq(object$.ref.pointer, _sel_setContentMode_, value);

  }


  /// setContentStretch:
  set contentStretch(objc.CGRect value) {
  objc.checkOsVersionInternal('UIView.setContentStretch:', iOS: (false, (3, 0, 0)));
_objc_msgSend_1okkq16(object$.ref.pointer, _sel_setContentStretch_, value);

  }


  /// setHidden:
  set isHidden(bool value) {
  objc.checkOsVersionInternal('UIView.setHidden:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHidden_, value);

  }


  /// setMaskView:
  set maskView(UIView? value) {
  objc.checkOsVersionInternal('UIView.setMaskView:', iOS: (false, (8, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMaskView_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setNeedsDisplay
  void setNeedsDisplay() {
  objc.checkOsVersionInternal('UIView.setNeedsDisplay', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsDisplay);

  }


  /// setNeedsDisplayInRect:
  void setNeedsDisplayInRect(objc.CGRect rect) {
  objc.checkOsVersionInternal('UIView.setNeedsDisplayInRect:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1okkq16(object$.ref.pointer, _sel_setNeedsDisplayInRect_, rect);

  }


  /// setOpaque:
  set isOpaque(bool value) {
  objc.checkOsVersionInternal('UIView.setOpaque:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setOpaque_, value);

  }


  /// setTintAdjustmentMode:
  set tintAdjustmentMode(int value) {
  objc.checkOsVersionInternal('UIView.setTintAdjustmentMode:', iOS: (false, (7, 0, 0)));
_objc_msgSend_15t6owj(object$.ref.pointer, _sel_setTintAdjustmentMode_, value);

  }


  /// setTintColor:
  set tintColor(UIColor value) {
  objc.checkOsVersionInternal('UIView.setTintColor:', iOS: (false, (7, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTintColor_, value.ref.pointer);

  }


  /// tintAdjustmentMode
  int get tintAdjustmentMode {
  objc.checkOsVersionInternal('UIView.tintAdjustmentMode', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_1tlsbkb(object$.ref.pointer, _sel_tintAdjustmentMode);

  }


  /// tintColor
  UIColor get tintColor {
  objc.checkOsVersionInternal('UIView.tintColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tintColor);
    return UIColor.fromPointer($ret, retain: true, release: true);
  }


  /// tintColorDidChange
  void tintColorDidChange() {
  objc.checkOsVersionInternal('UIView.tintColorDidChange', iOS: (false, (7, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_tintColorDidChange);

  }

}

late final _sel_setAnimationsEnabled_ = objc.registerName("setAnimationsEnabled:");
late final _sel_areAnimationsEnabled = objc.registerName("areAnimationsEnabled");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function()>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr) =>
      objc.ObjCBlock<ffi.Void Function()>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(void Function() fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function()>(objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(void Function() fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        () => fn(), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(void Function() fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        () => fn(), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        () => fn(), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1pl9qdv(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function()>>()
              .asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ) =>
      (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> )>()(
    ref.pointer, );
}

late final _sel_performWithoutAnimation_ = objc.registerName("performWithoutAnimation:");
late final _sel_inheritedAnimationDuration = objc.registerName("inheritedAnimationDuration");

/// UIViewAnimation
extension UIViewAnimation on UIView {

  /// areAnimationsEnabled
  static bool getAreAnimationsEnabled() {
  objc.checkOsVersionInternal('UIView.areAnimationsEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(_class_UIView, _sel_areAnimationsEnabled);

  }


  /// inheritedAnimationDuration
  static double getInheritedAnimationDuration() {
  objc.checkOsVersionInternal('UIView.inheritedAnimationDuration', iOS: (false, (9, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(_class_UIView, _sel_inheritedAnimationDuration) : _objc_msgSend_1ukqyt8(_class_UIView, _sel_inheritedAnimationDuration);

  }


  /// performWithoutAnimation:
  static void performWithoutAnimation(objc.ObjCBlock<ffi.Void Function()> actionsWithoutAnimation) {
  objc.checkOsVersionInternal('UIView.performWithoutAnimation:', iOS: (false, (7, 0, 0)));
_objc_msgSend_f167m6(_class_UIView, _sel_performWithoutAnimation_, actionsWithoutAnimation.ref.pointer);

  }


  /// setAnimationsEnabled:
  static void setAnimationsEnabled(bool enabled) {
  objc.checkOsVersionInternal('UIView.setAnimationsEnabled:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationsEnabled_, enabled);

  }

}

sealed class UIViewAnimationOptions {
  static const UIViewAnimationOptionLayoutSubviews = 1;
  static const UIViewAnimationOptionAllowUserInteraction = 2;
  static const UIViewAnimationOptionBeginFromCurrentState = 4;
  static const UIViewAnimationOptionRepeat = 8;
  static const UIViewAnimationOptionAutoreverse = 16;
  static const UIViewAnimationOptionOverrideInheritedDuration = 32;
  static const UIViewAnimationOptionOverrideInheritedCurve = 64;
  static const UIViewAnimationOptionAllowAnimatedContent = 128;
  static const UIViewAnimationOptionShowHideTransitionViews = 256;
  static const UIViewAnimationOptionOverrideInheritedOptions = 512;
  static const UIViewAnimationOptionCurveEaseInOut = 0;
  static const UIViewAnimationOptionCurveEaseIn = 65536;
  static const UIViewAnimationOptionCurveEaseOut = 131072;
  static const UIViewAnimationOptionCurveLinear = 196608;
  static const UIViewAnimationOptionTransitionNone = 0;
  static const UIViewAnimationOptionTransitionFlipFromLeft = 1048576;
  static const UIViewAnimationOptionTransitionFlipFromRight = 2097152;
  static const UIViewAnimationOptionTransitionCurlUp = 3145728;
  static const UIViewAnimationOptionTransitionCurlDown = 4194304;
  static const UIViewAnimationOptionTransitionCrossDissolve = 5242880;
  static const UIViewAnimationOptionTransitionFlipFromTop = 6291456;
  static const UIViewAnimationOptionTransitionFlipFromBottom = 7340032;
  static const UIViewAnimationOptionPreferredFramesPerSecondDefault = 0;
  static const UIViewAnimationOptionPreferredFramesPerSecond60 = 50331648;
  static const UIViewAnimationOptionPreferredFramesPerSecond30 = 117440512;
  static const UIViewAnimationOptionFlushUpdates = 268435456;}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(void Function(bool ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(objc.newClosureBlock(_closureCallable, (bool arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(void Function(bool ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(void Function(bool ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1s56lr9(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) {
    (objc.getBlockClosure(block) as void Function(bool ))(arg0);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Bool )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Bool )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, bool arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(bool ))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
              .asFunction<void Function(bool )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Bool )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
      (objc.getBlockClosure(block) as void Function(bool ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Bool )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Bool arg0)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , bool )>()(
    ref.pointer, arg0);
}

late final _sel_animateWithDuration_delay_options_animations_completion_ = objc.registerName("animateWithDuration:delay:options:animations:completion:");
final _objc_msgSend_1pforg = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.Double , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , double , int , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_animateWithDuration_animations_completion_ = objc.registerName("animateWithDuration:animations:completion:");
final _objc_msgSend_1isavsq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_animateWithDuration_animations_ = objc.registerName("animateWithDuration:animations:");
final _objc_msgSend_16dy26p = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion_ = objc.registerName("animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:");
final _objc_msgSend_r4l13g = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.Double , ffi.Double , ffi.Double , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , double , double , double , int , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_ = objc.registerName("animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:");
late final _sel_transitionWithView_duration_options_animations_completion_ = objc.registerName("transitionWithView:duration:options:animations:completion:");
final _objc_msgSend_q6v4dl = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , int , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_transitionFromView_toView_duration_options_completion_ = objc.registerName("transitionFromView:toView:duration:options:completion:");
final _objc_msgSend_1eh0loo = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , double , int , ffi.Pointer<objc.ObjCBlockImpl> )>();
sealed class UISystemAnimation {
  static const UISystemAnimationDelete = 0;}

late final _sel_performSystemAnimation_onViews_options_animations_completion_ = objc.registerName("performSystemAnimation:onViews:options:animations:completion:");
final _objc_msgSend_fqrtz5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_ = objc.registerName("modifyAnimationsWithRepeatCount:autoreverses:animations:");
final _objc_msgSend_nxk2e9 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// UIViewAnimationWithBlocks
extension UIViewAnimationWithBlocks on UIView {

  /// animateWithDuration:animations:
  static void animateWithDuration(double duration, {required objc.ObjCBlock<ffi.Void Function()> animations}) {
  objc.checkOsVersionInternal('UIView.animateWithDuration:animations:', iOS: (false, (4, 0, 0)));
_objc_msgSend_16dy26p(_class_UIView, _sel_animateWithDuration_animations_, duration, animations.ref.pointer);

  }


  /// animateWithDuration:animations:completion:
  static void animateWithDuration$1(double duration, {required objc.ObjCBlock<ffi.Void Function()> animations,objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
  objc.checkOsVersionInternal('UIView.animateWithDuration:animations:completion:', iOS: (false, (4, 0, 0)));
_objc_msgSend_1isavsq(_class_UIView, _sel_animateWithDuration_animations_completion_, duration, animations.ref.pointer, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// animateWithDuration:delay:options:animations:completion:
  static void animateWithDuration$2(double duration, {required double delay,required int options,required objc.ObjCBlock<ffi.Void Function()> animations,objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
  objc.checkOsVersionInternal('UIView.animateWithDuration:delay:options:animations:completion:', iOS: (false, (4, 0, 0)));
_objc_msgSend_1pforg(_class_UIView, _sel_animateWithDuration_delay_options_animations_completion_, duration, delay, options, animations.ref.pointer, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:
  static void animateWithDuration$3(double duration, {required double delay,required double usingSpringWithDamping,required double initialSpringVelocity,required int options,required objc.ObjCBlock<ffi.Void Function()> animations,objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
  objc.checkOsVersionInternal('UIView.animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:', iOS: (false, (7, 0, 0)));
_objc_msgSend_r4l13g(_class_UIView, _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_, duration, delay, usingSpringWithDamping, initialSpringVelocity, options, animations.ref.pointer, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:
  static void animateWithSpringDuration(double duration, {required double bounce,required double initialSpringVelocity,required double delay,required int options,required objc.ObjCBlock<ffi.Void Function()> animations,objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
  objc.checkOsVersionInternal('UIView.animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:', iOS: (false, (17, 0, 0)));
_objc_msgSend_r4l13g(_class_UIView, _sel_animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion_, duration, bounce, initialSpringVelocity, delay, options, animations.ref.pointer, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// modifyAnimationsWithRepeatCount:autoreverses:animations:
  static void modifyAnimationsWithRepeatCount(double count, {required bool autoreverses,required objc.ObjCBlock<ffi.Void Function()> animations}) {
  objc.checkOsVersionInternal('UIView.modifyAnimationsWithRepeatCount:autoreverses:animations:', iOS: (false, (13, 0, 0)));
_objc_msgSend_nxk2e9(_class_UIView, _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_, count, autoreverses, animations.ref.pointer);

  }


  /// performSystemAnimation:onViews:options:animations:completion:
  static void performSystemAnimation(int animation, {required objc.NSArray onViews,required int options,objc.ObjCBlock<ffi.Void Function()>? animations,objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
  objc.checkOsVersionInternal('UIView.performSystemAnimation:onViews:options:animations:completion:', iOS: (false, (7, 0, 0)));
_objc_msgSend_fqrtz5(_class_UIView, _sel_performSystemAnimation_onViews_options_animations_completion_, animation, onViews.ref.pointer, options, animations?.ref.pointer ?? ffi.nullptr, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// transitionFromView:toView:duration:options:completion:
  static void transitionFromView(UIView fromView, {required UIView toView,required double duration,required int options,objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
  objc.checkOsVersionInternal('UIView.transitionFromView:toView:duration:options:completion:', iOS: (false, (4, 0, 0)));
_objc_msgSend_1eh0loo(_class_UIView, _sel_transitionFromView_toView_duration_options_completion_, fromView.ref.pointer, toView.ref.pointer, duration, options, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// transitionWithView:duration:options:animations:completion:
  static void transitionWithView(UIView view, {required double duration,required int options,objc.ObjCBlock<ffi.Void Function()>? animations,objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
  objc.checkOsVersionInternal('UIView.transitionWithView:duration:options:animations:completion:', iOS: (false, (4, 0, 0)));
_objc_msgSend_q6v4dl(_class_UIView, _sel_transitionWithView_duration_options_animations_completion_, view.ref.pointer, duration, options, animations?.ref.pointer ?? ffi.nullptr, completion?.ref.pointer ?? ffi.nullptr);

  }

}

sealed class UIViewKeyframeAnimationOptions {
  static const UIViewKeyframeAnimationOptionLayoutSubviews = 1;
  static const UIViewKeyframeAnimationOptionAllowUserInteraction = 2;
  static const UIViewKeyframeAnimationOptionBeginFromCurrentState = 4;
  static const UIViewKeyframeAnimationOptionRepeat = 8;
  static const UIViewKeyframeAnimationOptionAutoreverse = 16;
  static const UIViewKeyframeAnimationOptionOverrideInheritedDuration = 32;
  static const UIViewKeyframeAnimationOptionOverrideInheritedOptions = 512;
  static const UIViewKeyframeAnimationOptionCalculationModeLinear = 0;
  static const UIViewKeyframeAnimationOptionCalculationModeDiscrete = 1024;
  static const UIViewKeyframeAnimationOptionCalculationModePaced = 2048;
  static const UIViewKeyframeAnimationOptionCalculationModeCubic = 3072;
  static const UIViewKeyframeAnimationOptionCalculationModeCubicPaced = 4096;}

late final _sel_animateKeyframesWithDuration_delay_options_animations_completion_ = objc.registerName("animateKeyframesWithDuration:delay:options:animations:completion:");
final _objc_msgSend_ciuhtc = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.Double , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , double , int , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_ = objc.registerName("addKeyframeWithRelativeStartTime:relativeDuration:animations:");
final _objc_msgSend_6jt11a = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.Double , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , double , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// UIViewKeyframeAnimations
extension UIViewKeyframeAnimations on UIView {

  /// addKeyframeWithRelativeStartTime:relativeDuration:animations:
  static void addKeyframeWithRelativeStartTime(double frameStartTime, {required double relativeDuration,required objc.ObjCBlock<ffi.Void Function()> animations}) {
  objc.checkOsVersionInternal('UIView.addKeyframeWithRelativeStartTime:relativeDuration:animations:', iOS: (false, (7, 0, 0)));
_objc_msgSend_6jt11a(_class_UIView, _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_, frameStartTime, relativeDuration, animations.ref.pointer);

  }


  /// animateKeyframesWithDuration:delay:options:animations:completion:
  static void animateKeyframesWithDuration(double duration, {required double delay,required int options,required objc.ObjCBlock<ffi.Void Function()> animations,objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion}) {
  objc.checkOsVersionInternal('UIView.animateKeyframesWithDuration:delay:options:animations:completion:', iOS: (false, (7, 0, 0)));
_objc_msgSend_ciuhtc(_class_UIView, _sel_animateKeyframesWithDuration_delay_options_animations_completion_, duration, delay, options, animations.ref.pointer, completion?.ref.pointer ?? ffi.nullptr);

  }

}

late final _sel_gestureRecognizers = objc.registerName("gestureRecognizers");
late final _sel_setGestureRecognizers_ = objc.registerName("setGestureRecognizers:");

/// WARNING: UIGestureRecognizer is a stub. To generate bindings for this class, include
/// UIGestureRecognizer in your config's objc-interfaces list.
///
/// UIGestureRecognizer
extension type UIGestureRecognizer._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UIGestureRecognizer] that points to the same underlying object as [other].
  UIGestureRecognizer.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIGestureRecognizer', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIGestureRecognizer] that wraps the given raw object pointer.
  UIGestureRecognizer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIGestureRecognizer', iOS: (false, (3, 2, 0)));
  }


}

late final _sel_addGestureRecognizer_ = objc.registerName("addGestureRecognizer:");
late final _sel_removeGestureRecognizer_ = objc.registerName("removeGestureRecognizer:");
late final _sel_gestureRecognizerShouldBegin_ = objc.registerName("gestureRecognizerShouldBegin:");

/// UIViewGestureRecognizers
extension UIViewGestureRecognizers on UIView {

  /// addGestureRecognizer:
  void addGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
  objc.checkOsVersionInternal('UIView.addGestureRecognizer:', iOS: (false, (3, 2, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addGestureRecognizer_, gestureRecognizer.ref.pointer);

  }


  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
  objc.checkOsVersionInternal('UIView.gestureRecognizerShouldBegin:', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_gestureRecognizerShouldBegin_, gestureRecognizer.ref.pointer);

  }


  /// gestureRecognizers
  objc.NSArray? get gestureRecognizers {
  objc.checkOsVersionInternal('UIView.gestureRecognizers', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_gestureRecognizers);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// removeGestureRecognizer:
  void removeGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
  objc.checkOsVersionInternal('UIView.removeGestureRecognizer:', iOS: (false, (3, 2, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeGestureRecognizer_, gestureRecognizer.ref.pointer);

  }


  /// setGestureRecognizers:
  set gestureRecognizers(objc.NSArray? value) {
  objc.checkOsVersionInternal('UIView.setGestureRecognizers:', iOS: (false, (3, 2, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setGestureRecognizers_, value?.ref.pointer ?? ffi.nullptr);

  }

}


/// WARNING: UIMotionEffect is a stub. To generate bindings for this class, include
/// UIMotionEffect in your config's objc-interfaces list.
///
/// UIMotionEffect
extension type UIMotionEffect._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSCoding {
  /// Constructs a [UIMotionEffect] that points to the same underlying object as [other].
  UIMotionEffect.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIMotionEffect', iOS: (false, (7, 0, 0)));
  }

  /// Constructs a [UIMotionEffect] that wraps the given raw object pointer.
  UIMotionEffect.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMotionEffect', iOS: (false, (7, 0, 0)));
  }


}

late final _sel_addMotionEffect_ = objc.registerName("addMotionEffect:");
late final _sel_removeMotionEffect_ = objc.registerName("removeMotionEffect:");
late final _sel_motionEffects = objc.registerName("motionEffects");
late final _sel_setMotionEffects_ = objc.registerName("setMotionEffects:");

/// UIViewMotionEffects
extension UIViewMotionEffects on UIView {

  /// addMotionEffect:
  void addMotionEffect(UIMotionEffect effect) {
  objc.checkOsVersionInternal('UIView.addMotionEffect:', iOS: (false, (7, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addMotionEffect_, effect.ref.pointer);

  }


  /// motionEffects
  objc.NSArray get motionEffects {
  objc.checkOsVersionInternal('UIView.motionEffects', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_motionEffects);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// removeMotionEffect:
  void removeMotionEffect(UIMotionEffect effect) {
  objc.checkOsVersionInternal('UIView.removeMotionEffect:', iOS: (false, (7, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeMotionEffect_, effect.ref.pointer);

  }


  /// setMotionEffects:
  set motionEffects(objc.NSArray value) {
  objc.checkOsVersionInternal('UIView.setMotionEffects:', iOS: (false, (7, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMotionEffects_, value.ref.pointer);

  }

}

late final _sel_constraints = objc.registerName("constraints");

/// WARNING: NSLayoutConstraint is a stub. To generate bindings for this class, include
/// NSLayoutConstraint in your config's objc-interfaces list.
///
/// NSLayoutConstraint
extension type NSLayoutConstraint._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [NSLayoutConstraint] that points to the same underlying object as [other].
  NSLayoutConstraint.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSLayoutConstraint', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [NSLayoutConstraint] that wraps the given raw object pointer.
  NSLayoutConstraint.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutConstraint', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
  }


}

late final _sel_addConstraint_ = objc.registerName("addConstraint:");
late final _sel_addConstraints_ = objc.registerName("addConstraints:");
late final _sel_removeConstraint_ = objc.registerName("removeConstraint:");
late final _sel_removeConstraints_ = objc.registerName("removeConstraints:");

/// UIConstraintBasedLayoutInstallingConstraints
extension UIConstraintBasedLayoutInstallingConstraints on UIView {

  /// addConstraint:
  void addConstraint(NSLayoutConstraint constraint) {
  objc.checkOsVersionInternal('UIView.addConstraint:', iOS: (false, (6, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addConstraint_, constraint.ref.pointer);

  }


  /// addConstraints:
  void addConstraints(objc.NSArray constraints) {
  objc.checkOsVersionInternal('UIView.addConstraints:', iOS: (false, (6, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addConstraints_, constraints.ref.pointer);

  }


  /// constraints
  objc.NSArray get constraints {
  objc.checkOsVersionInternal('UIView.constraints', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_constraints);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// removeConstraint:
  void removeConstraint(NSLayoutConstraint constraint) {
  objc.checkOsVersionInternal('UIView.removeConstraint:', iOS: (false, (6, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeConstraint_, constraint.ref.pointer);

  }


  /// removeConstraints:
  void removeConstraints(objc.NSArray constraints) {
  objc.checkOsVersionInternal('UIView.removeConstraints:', iOS: (false, (6, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeConstraints_, constraints.ref.pointer);

  }

}

late final _sel_updateConstraintsIfNeeded = objc.registerName("updateConstraintsIfNeeded");
late final _sel_updateConstraints = objc.registerName("updateConstraints");
late final _sel_needsUpdateConstraints = objc.registerName("needsUpdateConstraints");
late final _sel_setNeedsUpdateConstraints = objc.registerName("setNeedsUpdateConstraints");

/// UIConstraintBasedLayoutCoreMethods
extension UIConstraintBasedLayoutCoreMethods on UIView {

  /// needsUpdateConstraints
  bool needsUpdateConstraints() {
  objc.checkOsVersionInternal('UIView.needsUpdateConstraints', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_needsUpdateConstraints);

  }


  /// setNeedsUpdateConstraints
  void setNeedsUpdateConstraints() {
  objc.checkOsVersionInternal('UIView.setNeedsUpdateConstraints', iOS: (false, (6, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsUpdateConstraints);

  }


  /// updateConstraints
  void updateConstraints() {
  objc.checkOsVersionInternal('UIView.updateConstraints', iOS: (false, (6, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateConstraints);

  }


  /// updateConstraintsIfNeeded
  void updateConstraintsIfNeeded() {
  objc.checkOsVersionInternal('UIView.updateConstraintsIfNeeded', iOS: (false, (6, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateConstraintsIfNeeded);

  }

}

late final _sel_translatesAutoresizingMaskIntoConstraints = objc.registerName("translatesAutoresizingMaskIntoConstraints");
late final _sel_setTranslatesAutoresizingMaskIntoConstraints_ = objc.registerName("setTranslatesAutoresizingMaskIntoConstraints:");
late final _sel_requiresConstraintBasedLayout = objc.registerName("requiresConstraintBasedLayout");

/// UIConstraintBasedCompatibility
extension UIConstraintBasedCompatibility on UIView {

  /// setTranslatesAutoresizingMaskIntoConstraints:
  set translatesAutoresizingMaskIntoConstraints(bool value) {
  objc.checkOsVersionInternal('UIView.setTranslatesAutoresizingMaskIntoConstraints:', iOS: (false, (6, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setTranslatesAutoresizingMaskIntoConstraints_, value);

  }


  /// translatesAutoresizingMaskIntoConstraints
  bool get translatesAutoresizingMaskIntoConstraints {
  objc.checkOsVersionInternal('UIView.translatesAutoresizingMaskIntoConstraints', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_translatesAutoresizingMaskIntoConstraints);

  }


  /// requiresConstraintBasedLayout
  static bool getRequiresConstraintBasedLayout() {
  objc.checkOsVersionInternal('UIView.requiresConstraintBasedLayout', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(_class_UIView, _sel_requiresConstraintBasedLayout);

  }

}

late final _sel_alignmentRectForFrame_ = objc.registerName("alignmentRectForFrame:");
final _objc_msgSend_1gn1s3d = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect )>>().asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect )>();
final _objc_msgSend_1gn1s3dStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect )>>().asFunction<void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect )>();
late final _sel_frameForAlignmentRect_ = objc.registerName("frameForAlignmentRect:");
late final _sel_viewForBaselineLayout = objc.registerName("viewForBaselineLayout");
late final _sel_viewForFirstBaselineLayout = objc.registerName("viewForFirstBaselineLayout");
late final _sel_viewForLastBaselineLayout = objc.registerName("viewForLastBaselineLayout");
late final _sel_intrinsicContentSize = objc.registerName("intrinsicContentSize");
late final _sel_invalidateIntrinsicContentSize = objc.registerName("invalidateIntrinsicContentSize");
sealed class UILayoutConstraintAxis {
  static const UILayoutConstraintAxisHorizontal = 0;
  static const UILayoutConstraintAxisVertical = 1;}

late final _sel_contentHuggingPriorityForAxis_ = objc.registerName("contentHuggingPriorityForAxis:");
final _objc_msgSend_qigf85 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
final _objc_msgSend_qigf85Fpret = objc.msgSendFpretPointer.cast<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_setContentHuggingPriority_forAxis_ = objc.registerName("setContentHuggingPriority:forAxis:");
final _objc_msgSend_wd7esz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Float , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , int )>();
late final _sel_contentCompressionResistancePriorityForAxis_ = objc.registerName("contentCompressionResistancePriorityForAxis:");
late final _sel_setContentCompressionResistancePriority_forAxis_ = objc.registerName("setContentCompressionResistancePriority:forAxis:");

/// UIConstraintBasedLayoutLayering
extension UIConstraintBasedLayoutLayering on UIView {

  /// alignmentRectForFrame:
  objc.CGRect alignmentRectForFrame(objc.CGRect frame) {
  objc.checkOsVersionInternal('UIView.alignmentRectForFrame:', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_1gn1s3dStret($ptr, object$.ref.pointer, _sel_alignmentRectForFrame_, frame) : $ptr.ref = _objc_msgSend_1gn1s3d(object$.ref.pointer, _sel_alignmentRectForFrame_, frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// alignmentRectInsets
  UIEdgeInsets get alignmentRectInsets {
  objc.checkOsVersionInternal('UIView.alignmentRectInsets', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_alignmentRectInsets) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_alignmentRectInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// contentCompressionResistancePriorityForAxis:
  double contentCompressionResistancePriorityForAxis(int axis) {
  objc.checkOsVersionInternal('UIView.contentCompressionResistancePriorityForAxis:', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_qigf85Fpret(object$.ref.pointer, _sel_contentCompressionResistancePriorityForAxis_, axis) : _objc_msgSend_qigf85(object$.ref.pointer, _sel_contentCompressionResistancePriorityForAxis_, axis);

  }


  /// contentHuggingPriorityForAxis:
  double contentHuggingPriorityForAxis(int axis) {
  objc.checkOsVersionInternal('UIView.contentHuggingPriorityForAxis:', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_qigf85Fpret(object$.ref.pointer, _sel_contentHuggingPriorityForAxis_, axis) : _objc_msgSend_qigf85(object$.ref.pointer, _sel_contentHuggingPriorityForAxis_, axis);

  }


  /// frameForAlignmentRect:
  objc.CGRect frameForAlignmentRect(objc.CGRect alignmentRect) {
  objc.checkOsVersionInternal('UIView.frameForAlignmentRect:', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_1gn1s3dStret($ptr, object$.ref.pointer, _sel_frameForAlignmentRect_, alignmentRect) : $ptr.ref = _objc_msgSend_1gn1s3d(object$.ref.pointer, _sel_frameForAlignmentRect_, alignmentRect);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// intrinsicContentSize
  objc.CGSize get intrinsicContentSize {
  objc.checkOsVersionInternal('UIView.intrinsicContentSize', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1vdfkenStret($ptr, object$.ref.pointer, _sel_intrinsicContentSize) : $ptr.ref = _objc_msgSend_1vdfken(object$.ref.pointer, _sel_intrinsicContentSize);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// invalidateIntrinsicContentSize
  void invalidateIntrinsicContentSize() {
  objc.checkOsVersionInternal('UIView.invalidateIntrinsicContentSize', iOS: (false, (6, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_invalidateIntrinsicContentSize);

  }


  /// setContentCompressionResistancePriority:forAxis:
  void setContentCompressionResistancePriority(double priority, {required int forAxis}) {
  objc.checkOsVersionInternal('UIView.setContentCompressionResistancePriority:forAxis:', iOS: (false, (6, 0, 0)));
_objc_msgSend_wd7esz(object$.ref.pointer, _sel_setContentCompressionResistancePriority_forAxis_, priority, forAxis);

  }


  /// setContentHuggingPriority:forAxis:
  void setContentHuggingPriority(double priority, {required int forAxis}) {
  objc.checkOsVersionInternal('UIView.setContentHuggingPriority:forAxis:', iOS: (false, (6, 0, 0)));
_objc_msgSend_wd7esz(object$.ref.pointer, _sel_setContentHuggingPriority_forAxis_, priority, forAxis);

  }


  /// viewForBaselineLayout
  UIView viewForBaselineLayout() {
  objc.checkOsVersionInternal('UIView.viewForBaselineLayout', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_viewForBaselineLayout);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// viewForFirstBaselineLayout
  UIView get viewForFirstBaselineLayout {
  objc.checkOsVersionInternal('UIView.viewForFirstBaselineLayout', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_viewForFirstBaselineLayout);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// viewForLastBaselineLayout
  UIView get viewForLastBaselineLayout {
  objc.checkOsVersionInternal('UIView.viewForLastBaselineLayout', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_viewForLastBaselineLayout);
    return UIView.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_systemLayoutSizeFittingSize_ = objc.registerName("systemLayoutSizeFittingSize:");
late final _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_ = objc.registerName("systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:");
final _objc_msgSend_3fx2qn = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , ffi.Float , ffi.Float )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , double , double )>();
final _objc_msgSend_3fx2qnStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , ffi.Float , ffi.Float )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGSize , double , double )>();

/// UIConstraintBasedLayoutFittingSize
extension UIConstraintBasedLayoutFittingSize on UIView {

  /// systemLayoutSizeFittingSize:
  objc.CGSize systemLayoutSizeFittingSize(objc.CGSize targetSize) {
  objc.checkOsVersionInternal('UIView.systemLayoutSizeFittingSize:', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1owrp3bStret($ptr, object$.ref.pointer, _sel_systemLayoutSizeFittingSize_, targetSize) : $ptr.ref = _objc_msgSend_1owrp3b(object$.ref.pointer, _sel_systemLayoutSizeFittingSize_, targetSize);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:
  objc.CGSize systemLayoutSizeFittingSize$1(objc.CGSize targetSize, {required double withHorizontalFittingPriority,required double verticalFittingPriority}) {
  objc.checkOsVersionInternal('UIView.systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_3fx2qnStret($ptr, object$.ref.pointer, _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_, targetSize, withHorizontalFittingPriority, verticalFittingPriority) : $ptr.ref = _objc_msgSend_3fx2qn(object$.ref.pointer, _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_, targetSize, withHorizontalFittingPriority, verticalFittingPriority);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }

}

late final _sel_layoutGuides = objc.registerName("layoutGuides");
late final _sel_addLayoutGuide_ = objc.registerName("addLayoutGuide:");
late final _sel_removeLayoutGuide_ = objc.registerName("removeLayoutGuide:");

/// UILayoutGuideSupport
extension UILayoutGuideSupport on UIView {

  /// addLayoutGuide:
  void addLayoutGuide(UILayoutGuide layoutGuide) {
  objc.checkOsVersionInternal('UIView.addLayoutGuide:', iOS: (false, (9, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addLayoutGuide_, layoutGuide.ref.pointer);

  }


  /// layoutGuides
  objc.NSArray get layoutGuides {
  objc.checkOsVersionInternal('UIView.layoutGuides', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layoutGuides);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// removeLayoutGuide:
  void removeLayoutGuide(UILayoutGuide layoutGuide) {
  objc.checkOsVersionInternal('UIView.removeLayoutGuide:', iOS: (false, (9, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeLayoutGuide_, layoutGuide.ref.pointer);

  }

}


/// WARNING: NSLayoutXAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutXAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutXAxisAnchor
extension type NSLayoutXAxisAnchor._(objc.ObjCObject object$) implements objc.ObjCObject,NSLayoutAnchor {
  /// Constructs a [NSLayoutXAxisAnchor] that points to the same underlying object as [other].
  NSLayoutXAxisAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSLayoutXAxisAnchor', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSLayoutXAxisAnchor] that wraps the given raw object pointer.
  NSLayoutXAxisAnchor.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutXAxisAnchor', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }


}

late final _sel_leadingAnchor = objc.registerName("leadingAnchor");
late final _sel_trailingAnchor = objc.registerName("trailingAnchor");
late final _sel_leftAnchor = objc.registerName("leftAnchor");
late final _sel_rightAnchor = objc.registerName("rightAnchor");

/// WARNING: NSLayoutYAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutYAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutYAxisAnchor
extension type NSLayoutYAxisAnchor._(objc.ObjCObject object$) implements objc.ObjCObject,NSLayoutAnchor {
  /// Constructs a [NSLayoutYAxisAnchor] that points to the same underlying object as [other].
  NSLayoutYAxisAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSLayoutYAxisAnchor', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSLayoutYAxisAnchor] that wraps the given raw object pointer.
  NSLayoutYAxisAnchor.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutYAxisAnchor', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }


}

late final _sel_topAnchor = objc.registerName("topAnchor");
late final _sel_bottomAnchor = objc.registerName("bottomAnchor");

/// WARNING: NSLayoutDimension is a stub. To generate bindings for this class, include
/// NSLayoutDimension in your config's objc-interfaces list.
///
/// NSLayoutDimension
extension type NSLayoutDimension._(objc.ObjCObject object$) implements objc.ObjCObject,NSLayoutAnchor {
  /// Constructs a [NSLayoutDimension] that points to the same underlying object as [other].
  NSLayoutDimension.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSLayoutDimension', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSLayoutDimension] that wraps the given raw object pointer.
  NSLayoutDimension.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutDimension', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }


}

late final _sel_widthAnchor = objc.registerName("widthAnchor");
late final _sel_heightAnchor = objc.registerName("heightAnchor");
late final _sel_centerXAnchor = objc.registerName("centerXAnchor");
late final _sel_centerYAnchor = objc.registerName("centerYAnchor");
late final _sel_firstBaselineAnchor = objc.registerName("firstBaselineAnchor");
late final _sel_lastBaselineAnchor = objc.registerName("lastBaselineAnchor");

/// UIViewLayoutConstraintCreation
extension UIViewLayoutConstraintCreation on UIView {

  /// bottomAnchor
  NSLayoutYAxisAnchor get bottomAnchor {
  objc.checkOsVersionInternal('UIView.bottomAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_bottomAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// centerXAnchor
  NSLayoutXAxisAnchor get centerXAnchor {
  objc.checkOsVersionInternal('UIView.centerXAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_centerXAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// centerYAnchor
  NSLayoutYAxisAnchor get centerYAnchor {
  objc.checkOsVersionInternal('UIView.centerYAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_centerYAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// firstBaselineAnchor
  NSLayoutYAxisAnchor get firstBaselineAnchor {
  objc.checkOsVersionInternal('UIView.firstBaselineAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_firstBaselineAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// heightAnchor
  NSLayoutDimension get heightAnchor {
  objc.checkOsVersionInternal('UIView.heightAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heightAnchor);
    return NSLayoutDimension.fromPointer($ret, retain: true, release: true);
  }


  /// lastBaselineAnchor
  NSLayoutYAxisAnchor get lastBaselineAnchor {
  objc.checkOsVersionInternal('UIView.lastBaselineAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lastBaselineAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// leadingAnchor
  NSLayoutXAxisAnchor get leadingAnchor {
  objc.checkOsVersionInternal('UIView.leadingAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leadingAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// leftAnchor
  NSLayoutXAxisAnchor get leftAnchor {
  objc.checkOsVersionInternal('UIView.leftAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leftAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// rightAnchor
  NSLayoutXAxisAnchor get rightAnchor {
  objc.checkOsVersionInternal('UIView.rightAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rightAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// topAnchor
  NSLayoutYAxisAnchor get topAnchor {
  objc.checkOsVersionInternal('UIView.topAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_topAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// trailingAnchor
  NSLayoutXAxisAnchor get trailingAnchor {
  objc.checkOsVersionInternal('UIView.trailingAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_trailingAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }


  /// widthAnchor
  NSLayoutDimension get widthAnchor {
  objc.checkOsVersionInternal('UIView.widthAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_widthAnchor);
    return NSLayoutDimension.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_constraintsAffectingLayoutForAxis_ = objc.registerName("constraintsAffectingLayoutForAxis:");
final _objc_msgSend_5swr7b = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_hasAmbiguousLayout = objc.registerName("hasAmbiguousLayout");
late final _sel_exerciseAmbiguityInLayout = objc.registerName("exerciseAmbiguityInLayout");

/// UIConstraintBasedLayoutDebugging
extension UIConstraintBasedLayoutDebugging on UIView {

  /// constraintsAffectingLayoutForAxis:
  objc.NSArray constraintsAffectingLayoutForAxis(int axis) {
  objc.checkOsVersionInternal('UIView.constraintsAffectingLayoutForAxis:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_5swr7b(object$.ref.pointer, _sel_constraintsAffectingLayoutForAxis_, axis);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// exerciseAmbiguityInLayout
  void exerciseAmbiguityInLayout() {
  objc.checkOsVersionInternal('UIView.exerciseAmbiguityInLayout', iOS: (false, (6, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_exerciseAmbiguityInLayout);

  }


  /// hasAmbiguousLayout
  bool get hasAmbiguousLayout {
  objc.checkOsVersionInternal('UIView.hasAmbiguousLayout', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_hasAmbiguousLayout);

  }

}

late final _sel_restorationIdentifier = objc.registerName("restorationIdentifier");
late final _sel_setRestorationIdentifier_ = objc.registerName("setRestorationIdentifier:");
late final _sel_encodeRestorableStateWithCoder_ = objc.registerName("encodeRestorableStateWithCoder:");
late final _sel_decodeRestorableStateWithCoder_ = objc.registerName("decodeRestorableStateWithCoder:");

/// UIStateRestoration
extension UIStateRestoration on UIView {

  /// decodeRestorableStateWithCoder:
  void decodeRestorableStateWithCoder(objc.NSCoder coder) {
  objc.checkOsVersionInternal('UIView.decodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_decodeRestorableStateWithCoder_, coder.ref.pointer);

  }


  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
  objc.checkOsVersionInternal('UIView.encodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeRestorableStateWithCoder_, coder.ref.pointer);

  }


  /// restorationIdentifier
  objc.NSString? get restorationIdentifier {
  objc.checkOsVersionInternal('UIView.restorationIdentifier', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_restorationIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// setRestorationIdentifier:
  set restorationIdentifier(objc.NSString? value) {
  objc.checkOsVersionInternal('UIView.setRestorationIdentifier:', iOS: (false, (6, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRestorationIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _sel_snapshotViewAfterScreenUpdates_ = objc.registerName("snapshotViewAfterScreenUpdates:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Bool )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , bool )>();
late final _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_ = objc.registerName("resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:");
final _objc_msgSend_qvletk = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Bool , UIEdgeInsets )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , bool , UIEdgeInsets )>();
late final _sel_drawViewHierarchyInRect_afterScreenUpdates_ = objc.registerName("drawViewHierarchyInRect:afterScreenUpdates:");
final _objc_msgSend_19ljaqg = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Bool )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , bool )>();

/// UISnapshotting
extension UISnapshotting on UIView {

  /// drawViewHierarchyInRect:afterScreenUpdates:
  bool drawViewHierarchyInRect(objc.CGRect rect, {required bool afterScreenUpdates}) {
  objc.checkOsVersionInternal('UIView.drawViewHierarchyInRect:afterScreenUpdates:', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_19ljaqg(object$.ref.pointer, _sel_drawViewHierarchyInRect_afterScreenUpdates_, rect, afterScreenUpdates);

  }


  /// resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:
  UIView? resizableSnapshotViewFromRect(objc.CGRect rect, {required bool afterScreenUpdates,required UIEdgeInsets withCapInsets}) {
  objc.checkOsVersionInternal('UIView.resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_qvletk(object$.ref.pointer, _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_, rect, afterScreenUpdates, withCapInsets);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// snapshotViewAfterScreenUpdates:
  UIView? snapshotViewAfterScreenUpdates(bool afterUpdates) {
  objc.checkOsVersionInternal('UIView.snapshotViewAfterScreenUpdates:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1t6aok9(object$.ref.pointer, _sel_snapshotViewAfterScreenUpdates_, afterUpdates);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_beginAnimations_context_ = objc.registerName("beginAnimations:context:");
final _objc_msgSend_1lzqwav = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>();
late final _sel_commitAnimations = objc.registerName("commitAnimations");
late final _sel_setAnimationDelegate_ = objc.registerName("setAnimationDelegate:");
late final _sel_setAnimationWillStartSelector_ = objc.registerName("setAnimationWillStartSelector:");
final _objc_msgSend_1d9e4oe = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setAnimationDidStopSelector_ = objc.registerName("setAnimationDidStopSelector:");
late final _sel_setAnimationDuration_ = objc.registerName("setAnimationDuration:");
late final _sel_setAnimationDelay_ = objc.registerName("setAnimationDelay:");
late final _sel_setAnimationStartDate_ = objc.registerName("setAnimationStartDate:");
sealed class UIViewAnimationCurve {
  static const UIViewAnimationCurveEaseInOut = 0;
  static const UIViewAnimationCurveEaseIn = 1;
  static const UIViewAnimationCurveEaseOut = 2;
  static const UIViewAnimationCurveLinear = 3;}

late final _sel_setAnimationCurve_ = objc.registerName("setAnimationCurve:");
final _objc_msgSend_up32gn = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_setAnimationRepeatCount_ = objc.registerName("setAnimationRepeatCount:");
final _objc_msgSend_v5hmet = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Float )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double )>();
late final _sel_setAnimationRepeatAutoreverses_ = objc.registerName("setAnimationRepeatAutoreverses:");
late final _sel_setAnimationBeginsFromCurrentState_ = objc.registerName("setAnimationBeginsFromCurrentState:");
sealed class UIViewAnimationTransition {
  static const UIViewAnimationTransitionNone = 0;
  static const UIViewAnimationTransitionFlipFromLeft = 1;
  static const UIViewAnimationTransitionFlipFromRight = 2;
  static const UIViewAnimationTransitionCurlUp = 3;
  static const UIViewAnimationTransitionCurlDown = 4;}

late final _sel_setAnimationTransition_forView_cache_ = objc.registerName("setAnimationTransition:forView:cache:");
final _objc_msgSend_1ftk3d5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , ffi.Pointer<objc.ObjCObjectImpl> , bool )>();

/// DeprecatedAnimations
extension DeprecatedAnimations on UIView {

  /// beginAnimations:context:
  static void beginAnimations(objc.NSString? animationID, {required ffi.Pointer<ffi.Void> context}) {
  objc.checkOsVersionInternal('UIView.beginAnimations:context:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1lzqwav(_class_UIView, _sel_beginAnimations_context_, animationID?.ref.pointer ?? ffi.nullptr, context);

  }


  /// commitAnimations
  static void commitAnimations() {
  objc.checkOsVersionInternal('UIView.commitAnimations', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(_class_UIView, _sel_commitAnimations);

  }


  /// setAnimationBeginsFromCurrentState:
  static void setAnimationBeginsFromCurrentState(bool fromCurrentState) {
  objc.checkOsVersionInternal('UIView.setAnimationBeginsFromCurrentState:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationBeginsFromCurrentState_, fromCurrentState);

  }


  /// setAnimationCurve:
  static void setAnimationCurve(int curve) {
  objc.checkOsVersionInternal('UIView.setAnimationCurve:', iOS: (false, (2, 0, 0)));
_objc_msgSend_up32gn(_class_UIView, _sel_setAnimationCurve_, curve);

  }


  /// setAnimationDelay:
  static void setAnimationDelay(double delay) {
  objc.checkOsVersionInternal('UIView.setAnimationDelay:', iOS: (false, (2, 0, 0)));
_objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDelay_, delay);

  }


  /// setAnimationDelegate:
  static void setAnimationDelegate(objc.ObjCObject? delegate) {
  objc.checkOsVersionInternal('UIView.setAnimationDelegate:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(_class_UIView, _sel_setAnimationDelegate_, delegate?.ref.pointer ?? ffi.nullptr);

  }


  /// setAnimationDidStopSelector:
  static void setAnimationDidStopSelector(ffi.Pointer<objc.ObjCSelector> selector) {
  objc.checkOsVersionInternal('UIView.setAnimationDidStopSelector:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1d9e4oe(_class_UIView, _sel_setAnimationDidStopSelector_, selector);

  }


  /// setAnimationDuration:
  static void setAnimationDuration(double duration) {
  objc.checkOsVersionInternal('UIView.setAnimationDuration:', iOS: (false, (2, 0, 0)));
_objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDuration_, duration);

  }


  /// setAnimationRepeatAutoreverses:
  static void setAnimationRepeatAutoreverses(bool repeatAutoreverses) {
  objc.checkOsVersionInternal('UIView.setAnimationRepeatAutoreverses:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationRepeatAutoreverses_, repeatAutoreverses);

  }


  /// setAnimationRepeatCount:
  static void setAnimationRepeatCount(double repeatCount) {
  objc.checkOsVersionInternal('UIView.setAnimationRepeatCount:', iOS: (false, (2, 0, 0)));
_objc_msgSend_v5hmet(_class_UIView, _sel_setAnimationRepeatCount_, repeatCount);

  }


  /// setAnimationStartDate:
  static void setAnimationStartDate(objc.NSDate startDate) {
  objc.checkOsVersionInternal('UIView.setAnimationStartDate:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(_class_UIView, _sel_setAnimationStartDate_, startDate.ref.pointer);

  }


  /// setAnimationTransition:forView:cache:
  static void setAnimationTransition(int transition, {required UIView forView,required bool cache}) {
  objc.checkOsVersionInternal('UIView.setAnimationTransition:forView:cache:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1ftk3d5(_class_UIView, _sel_setAnimationTransition_forView_cache_, transition, forView.ref.pointer, cache);

  }


  /// setAnimationWillStartSelector:
  static void setAnimationWillStartSelector(ffi.Pointer<objc.ObjCSelector> selector) {
  objc.checkOsVersionInternal('UIView.setAnimationWillStartSelector:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1d9e4oe(_class_UIView, _sel_setAnimationWillStartSelector_, selector);

  }

}

sealed class UIUserInterfaceStyle {
  static const UIUserInterfaceStyleUnspecified = 0;
  static const UIUserInterfaceStyleLight = 1;
  static const UIUserInterfaceStyleDark = 2;}

late final _sel_overrideUserInterfaceStyle = objc.registerName("overrideUserInterfaceStyle");
final _objc_msgSend_2x5ago = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setOverrideUserInterfaceStyle_ = objc.registerName("setOverrideUserInterfaceStyle:");
final _objc_msgSend_15dz1ky = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// UserInterfaceStyle
extension UserInterfaceStyle on UIView {

  /// overrideUserInterfaceStyle
  int get overrideUserInterfaceStyle {
  objc.checkOsVersionInternal('UIView.overrideUserInterfaceStyle', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_2x5ago(object$.ref.pointer, _sel_overrideUserInterfaceStyle);

  }


  /// setOverrideUserInterfaceStyle:
  set overrideUserInterfaceStyle(int value) {
  objc.checkOsVersionInternal('UIView.setOverrideUserInterfaceStyle:', iOS: (false, (13, 0, 0)));
_objc_msgSend_15dz1ky(object$.ref.pointer, _sel_setOverrideUserInterfaceStyle_, value);

  }

}

late final _sel_minimumContentSizeCategory = objc.registerName("minimumContentSizeCategory");
late final _sel_setMinimumContentSizeCategory_ = objc.registerName("setMinimumContentSizeCategory:");
late final _sel_maximumContentSizeCategory = objc.registerName("maximumContentSizeCategory");
late final _sel_setMaximumContentSizeCategory_ = objc.registerName("setMaximumContentSizeCategory:");
late final _sel_appliedContentSizeCategoryLimitsDescription = objc.registerName("appliedContentSizeCategoryLimitsDescription");

/// UIContentSizeCategoryLimit
extension UIContentSizeCategoryLimit on UIView {

  /// appliedContentSizeCategoryLimitsDescription
  objc.NSString get appliedContentSizeCategoryLimitsDescription {
  objc.checkOsVersionInternal('UIView.appliedContentSizeCategoryLimitsDescription', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_appliedContentSizeCategoryLimitsDescription);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// maximumContentSizeCategory
  objc.NSString? get maximumContentSizeCategory {
  objc.checkOsVersionInternal('UIView.maximumContentSizeCategory', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_maximumContentSizeCategory);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// minimumContentSizeCategory
  objc.NSString? get minimumContentSizeCategory {
  objc.checkOsVersionInternal('UIView.minimumContentSizeCategory', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_minimumContentSizeCategory);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// setMaximumContentSizeCategory:
  set maximumContentSizeCategory(objc.NSString? value) {
  objc.checkOsVersionInternal('UIView.setMaximumContentSizeCategory:', iOS: (false, (15, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMaximumContentSizeCategory_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setMinimumContentSizeCategory:
  set minimumContentSizeCategory(objc.NSString? value) {
  objc.checkOsVersionInternal('UIView.setMinimumContentSizeCategory:', iOS: (false, (15, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMinimumContentSizeCategory_, value?.ref.pointer ?? ffi.nullptr);

  }

}


/// WARNING: UITraitChangeObservable is a stub. To generate bindings for this class, include
/// UITraitChangeObservable in your config's objc-protocols list.
///
/// UITraitChangeObservable
extension type UITraitChangeObservable._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [UITraitChangeObservable] that points to the same underlying object as [other].
  UITraitChangeObservable.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITraitChangeObservable] that wraps the given raw object pointer.
  UITraitChangeObservable.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// 
extension unnamed on UIView {

}


/// WARNING: UIViewLayoutRegion is a stub. To generate bindings for this class, include
/// UIViewLayoutRegion in your config's objc-interfaces list.
///
/// UIViewLayoutRegion
extension type UIViewLayoutRegion._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UIViewLayoutRegion] that points to the same underlying object as [other].
  UIViewLayoutRegion.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIViewLayoutRegion', iOS: (false, (26, 0, 0)));
  }

  /// Constructs a [UIViewLayoutRegion] that wraps the given raw object pointer.
  UIViewLayoutRegion.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewLayoutRegion', iOS: (false, (26, 0, 0)));
  }


}

late final _sel_layoutGuideForLayoutRegion_ = objc.registerName("layoutGuideForLayoutRegion:");
late final _sel_edgeInsetsForLayoutRegion_ = objc.registerName("edgeInsetsForLayoutRegion:");
final _objc_msgSend_16w06qx = objc.msgSendPointer.cast<ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_16w06qxStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<UIEdgeInsets> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<UIEdgeInsets> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_directionalEdgeInsetsForLayoutRegion_ = objc.registerName("directionalEdgeInsetsForLayoutRegion:");
final _objc_msgSend_wk01t0 = objc.msgSendPointer.cast<ffi.NativeFunction<NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_wk01t0Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NSDirectionalEdgeInsets> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<NSDirectionalEdgeInsets> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// LayoutRegions
extension LayoutRegions on UIView {

  /// directionalEdgeInsetsForLayoutRegion:
  NSDirectionalEdgeInsets directionalEdgeInsetsForLayoutRegion(UIViewLayoutRegion layoutRegion) {
  objc.checkOsVersionInternal('UIView.directionalEdgeInsetsForLayoutRegion:', iOS: (false, (26, 0, 0)));
    final $ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_wk01t0Stret($ptr, object$.ref.pointer, _sel_directionalEdgeInsetsForLayoutRegion_, layoutRegion.ref.pointer) : $ptr.ref = _objc_msgSend_wk01t0(object$.ref.pointer, _sel_directionalEdgeInsetsForLayoutRegion_, layoutRegion.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSDirectionalEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSDirectionalEdgeInsets>(
        $finalizable);

  }


  /// edgeInsetsForLayoutRegion:
  UIEdgeInsets edgeInsetsForLayoutRegion(UIViewLayoutRegion layoutRegion) {
  objc.checkOsVersionInternal('UIView.edgeInsetsForLayoutRegion:', iOS: (false, (26, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_16w06qxStret($ptr, object$.ref.pointer, _sel_edgeInsetsForLayoutRegion_, layoutRegion.ref.pointer) : $ptr.ref = _objc_msgSend_16w06qx(object$.ref.pointer, _sel_edgeInsetsForLayoutRegion_, layoutRegion.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// layoutGuideForLayoutRegion:
  UILayoutGuide layoutGuideForLayoutRegion(UIViewLayoutRegion layoutRegion) {
  objc.checkOsVersionInternal('UIView.layoutGuideForLayoutRegion:', iOS: (false, (26, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_layoutGuideForLayoutRegion_, layoutRegion.ref.pointer);
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }

}


/// WARNING: UICornerConfiguration is a stub. To generate bindings for this class, include
/// UICornerConfiguration in your config's objc-interfaces list.
///
/// UICornerConfiguration
extension type UICornerConfiguration._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying {
  /// Constructs a [UICornerConfiguration] that points to the same underlying object as [other].
  UICornerConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UICornerConfiguration', iOS: (false, (26, 0, 0)));
  }

  /// Constructs a [UICornerConfiguration] that wraps the given raw object pointer.
  UICornerConfiguration.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UICornerConfiguration', iOS: (false, (26, 0, 0)));
  }


}

late final _sel_cornerConfiguration = objc.registerName("cornerConfiguration");
late final _sel_setCornerConfiguration_ = objc.registerName("setCornerConfiguration:");
late final _sel_effectiveRadiusForCorner_ = objc.registerName("effectiveRadiusForCorner:");
final _objc_msgSend_8ud30b = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
final _objc_msgSend_8ud30bFpret = objc.msgSendFpretPointer.cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// CornerConfiguration
extension CornerConfiguration on UIView {

  /// cornerConfiguration
  UICornerConfiguration get cornerConfiguration {
  objc.checkOsVersionInternal('UIView.cornerConfiguration', iOS: (false, (26, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_cornerConfiguration);
    return UICornerConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// effectiveRadiusForCorner:
  double effectiveRadiusForCorner(int corner) {
  objc.checkOsVersionInternal('UIView.effectiveRadiusForCorner:', iOS: (false, (26, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_8ud30bFpret(object$.ref.pointer, _sel_effectiveRadiusForCorner_, corner) : _objc_msgSend_8ud30b(object$.ref.pointer, _sel_effectiveRadiusForCorner_, corner);

  }


  /// setCornerConfiguration:
  set cornerConfiguration(UICornerConfiguration value) {
  objc.checkOsVersionInternal('UIView.setCornerConfiguration:', iOS: (false, (26, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCornerConfiguration_, value.ref.pointer);

  }

}


/// WARNING: UIInteraction is a stub. To generate bindings for this class, include
/// UIInteraction in your config's objc-protocols list.
///
/// UIInteraction
extension type UIInteraction._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIInteraction] that points to the same underlying object as [other].
  UIInteraction.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIInteraction] that wraps the given raw object pointer.
  UIInteraction.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_addInteraction_ = objc.registerName("addInteraction:");
late final _sel_removeInteraction_ = objc.registerName("removeInteraction:");
late final _sel_interactions = objc.registerName("interactions");
late final _sel_setInteractions_ = objc.registerName("setInteractions:");

/// Interactions
extension Interactions on UIView {

  /// addInteraction:
  void addInteraction(UIInteraction interaction) {
  objc.checkOsVersionInternal('UIView.addInteraction:', iOS: (false, (11, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addInteraction_, interaction.ref.pointer);

  }


  /// interactions
  objc.NSArray get interactions {
  objc.checkOsVersionInternal('UIView.interactions', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_interactions);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// removeInteraction:
  void removeInteraction(UIInteraction interaction) {
  objc.checkOsVersionInternal('UIView.removeInteraction:', iOS: (false, (11, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeInteraction_, interaction.ref.pointer);

  }


  /// setInteractions:
  set interactions(objc.NSArray value) {
  objc.checkOsVersionInternal('UIView.setInteractions:', iOS: (false, (11, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setInteractions_, value.ref.pointer);

  }

}

late final _sel_accessibilityIgnoresInvertColors = objc.registerName("accessibilityIgnoresInvertColors");
late final _sel_setAccessibilityIgnoresInvertColors_ = objc.registerName("setAccessibilityIgnoresInvertColors:");

/// UIAccessibilityInvertColors
extension UIAccessibilityInvertColors on UIView {

  /// accessibilityIgnoresInvertColors
  bool get accessibilityIgnoresInvertColors {
  objc.checkOsVersionInternal('UIView.accessibilityIgnoresInvertColors', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_accessibilityIgnoresInvertColors);

  }


  /// setAccessibilityIgnoresInvertColors:
  set accessibilityIgnoresInvertColors(bool value) {
  objc.checkOsVersionInternal('UIView.setAccessibilityIgnoresInvertColors:', iOS: (false, (11, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAccessibilityIgnoresInvertColors_, value);

  }

}

late final _sel_endEditing_ = objc.registerName("endEditing:");
final _objc_msgSend_41h7k3 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Bool )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , bool )>();

/// UITextField
extension UITextField on UIView {

  /// endEditing:
  bool endEditing(bool force) {
  objc.checkOsVersionInternal('UIView.endEditing:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_41h7k3(object$.ref.pointer, _sel_endEditing_, force);

  }

}


/// UIAccessibility
extension UIAccessibility$2 on UIView {

  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
  objc.checkOsVersionInternal('UIView.accessibilityIdentifier', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_accessibilityIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
  objc.checkOsVersionInternal('UIView.setAccessibilityIdentifier:', iOS: (false, (5, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAccessibilityIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _sel_showsLargeContentViewer = objc.registerName("showsLargeContentViewer");
late final _sel_setShowsLargeContentViewer_ = objc.registerName("setShowsLargeContentViewer:");
late final _sel_largeContentTitle = objc.registerName("largeContentTitle");
late final _sel_setLargeContentTitle_ = objc.registerName("setLargeContentTitle:");
late final _sel_largeContentImage = objc.registerName("largeContentImage");

/// Construction methods for `objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIImage_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromFunction(UIImage? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIImage_ffiVoid$CallExtension on objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> {
  UIImage? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : UIImage.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_setLargeContentImage_ = objc.registerName("setLargeContentImage:");
late final _sel_scalesLargeContentImage = objc.registerName("scalesLargeContentImage");
late final _sel_setScalesLargeContentImage_ = objc.registerName("setScalesLargeContentImage:");
late final _sel_largeContentImageInsets = objc.registerName("largeContentImageInsets");

/// Construction methods for `objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIEdgeInsets_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)> fromFunction(UIEdgeInsets Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static UIEdgeInsets _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      UIEdgeInsets Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static UIEdgeInsets _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as UIEdgeInsets Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      UIEdgeInsets Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIEdgeInsets_ffiVoid$CallExtension on objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)> {
  UIEdgeInsets call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_setLargeContentImageInsets_ = objc.registerName("setLargeContentImageInsets:");

/// WARNING: UILargeContentViewerItem is a stub. To generate bindings for this class, include
/// UILargeContentViewerItem in your config's objc-protocols list.
///
/// UILargeContentViewerItem
extension type UILargeContentViewerItem._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UILargeContentViewerItem] that points to the same underlying object as [other].
  UILargeContentViewerItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UILargeContentViewerItem] that wraps the given raw object pointer.
  UILargeContentViewerItem.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// UILargeContentViewer
extension UILargeContentViewer on UIView {

  /// largeContentImage
  UIImage? get largeContentImage {
  objc.checkOsVersionInternal('UIView.largeContentImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_largeContentImage);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// largeContentImageInsets
  UIEdgeInsets get largeContentImageInsets {
  objc.checkOsVersionInternal('UIView.largeContentImageInsets', iOS: (false, (13, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_largeContentImageInsets) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_largeContentImageInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// largeContentTitle
  objc.NSString? get largeContentTitle {
  objc.checkOsVersionInternal('UIView.largeContentTitle', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_largeContentTitle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// scalesLargeContentImage
  bool get scalesLargeContentImage {
  objc.checkOsVersionInternal('UIView.scalesLargeContentImage', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_scalesLargeContentImage);

  }


  /// setLargeContentImage:
  set largeContentImage$1(UIImage? value) {
  objc.checkOsVersionInternal('UIView.setLargeContentImage:', iOS: (false, (13, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLargeContentImage_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setLargeContentImageInsets:
  set largeContentImageInsets$1(UIEdgeInsets value) {
  objc.checkOsVersionInternal('UIView.setLargeContentImageInsets:', iOS: (false, (13, 0, 0)));
_objc_msgSend_1g8fos5(object$.ref.pointer, _sel_setLargeContentImageInsets_, value);

  }


  /// setLargeContentTitle:
  set largeContentTitle$1(objc.NSString? value) {
  objc.checkOsVersionInternal('UIView.setLargeContentTitle:', iOS: (false, (13, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLargeContentTitle_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setScalesLargeContentImage:
  set scalesLargeContentImage$1(bool value) {
  objc.checkOsVersionInternal('UIView.setScalesLargeContentImage:', iOS: (false, (13, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setScalesLargeContentImage_, value);

  }


  /// setShowsLargeContentViewer:
  set showsLargeContentViewer(bool value) {
  objc.checkOsVersionInternal('UIView.setShowsLargeContentViewer:', iOS: (false, (13, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsLargeContentViewer_, value);

  }


  /// showsLargeContentViewer
  bool get showsLargeContentViewer$1 {
  objc.checkOsVersionInternal('UIView.showsLargeContentViewer', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsLargeContentViewer);

  }

}

late final _class_UIHoverStyle = objc.getClass("UIHoverStyle");

/// WARNING: UIHoverEffect is a stub. To generate bindings for this class, include
/// UIHoverEffect in your config's objc-protocols list.
///
/// UIHoverEffect
extension type UIHoverEffect._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol, objc.NSCopying {
  /// Constructs a [UIHoverEffect] that points to the same underlying object as [other].
  UIHoverEffect.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIHoverEffect] that wraps the given raw object pointer.
  UIHoverEffect.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_effect = objc.registerName("effect");
late final _sel_setEffect_ = objc.registerName("setEffect:");

/// WARNING: UIShape is a stub. To generate bindings for this class, include
/// UIShape in your config's objc-interfaces list.
///
/// UIShape
extension type UIShape._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,UIShapeProvider,objc.NSCopying {
  /// Constructs a [UIShape] that points to the same underlying object as [other].
  UIShape.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIShape', iOS: (false, (17, 0, 0)));
  }

  /// Constructs a [UIShape] that wraps the given raw object pointer.
  UIShape.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIShape', iOS: (false, (17, 0, 0)));
  }


}

late final _sel_shape = objc.registerName("shape");
late final _sel_setShape_ = objc.registerName("setShape:");
late final _sel_isEnabled = objc.registerName("isEnabled");
late final _sel_setEnabled_ = objc.registerName("setEnabled:");
late final _sel_styleWithEffect_shape_ = objc.registerName("styleWithEffect:shape:");
late final _sel_styleWithShape_ = objc.registerName("styleWithShape:");
late final _sel_automaticStyle = objc.registerName("automaticStyle");

/// UIHoverStyle
extension type UIHoverStyle$1._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying {
  /// Constructs a [UIHoverStyle$1] that points to the same underlying object as [other].
  UIHoverStyle$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIHoverStyle', iOS: (false, (17, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIHoverStyle$1] that wraps the given raw object pointer.
  UIHoverStyle$1.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIHoverStyle', iOS: (false, (17, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIHoverStyle$1].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIHoverStyle);

  /// alloc
  static UIHoverStyle$1 alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIHoverStyle, _sel_alloc);
    return UIHoverStyle$1.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIHoverStyle$1 allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIHoverStyle, _sel_allocWithZone_, zone);
    return UIHoverStyle$1.fromPointer($ret, retain: false, release: true);
  }


  /// automaticStyle
  static UIHoverStyle$1 automaticStyle() {
  objc.checkOsVersionInternal('UIHoverStyle.automaticStyle', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIHoverStyle, _sel_automaticStyle);
    return UIHoverStyle$1.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static UIHoverStyle$1 new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIHoverStyle, _sel_new);
    return UIHoverStyle$1.fromPointer($ret, retain: false, release: true);
  }


  /// styleWithEffect:shape:
  static UIHoverStyle$1 styleWithEffect(UIHoverEffect effect, {UIShape? shape}) {
  objc.checkOsVersionInternal('UIHoverStyle.styleWithEffect:shape:', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIHoverStyle, _sel_styleWithEffect_shape_, effect.ref.pointer, shape?.ref.pointer ?? ffi.nullptr);
    return UIHoverStyle$1.fromPointer($ret, retain: true, release: true);
  }


  /// styleWithShape:
  static UIHoverStyle$1 styleWithShape(UIShape? shape) {
  objc.checkOsVersionInternal('UIHoverStyle.styleWithShape:', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIHoverStyle, _sel_styleWithShape_, shape?.ref.pointer ?? ffi.nullptr);
    return UIHoverStyle$1.fromPointer($ret, retain: true, release: true);
  }
  /// Returns a new instance of UIHoverStyle$1 constructed with the default `new` method.
  UIHoverStyle$1() : this.as(new$().object$);

}

extension UIHoverStyle$1$Methods on UIHoverStyle$1 {

  /// effect
  UIHoverEffect get effect {
  objc.checkOsVersionInternal('UIHoverStyle.effect', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_effect);
    return UIHoverEffect.fromPointer($ret, retain: true, release: true);
  }


  /// init
  UIHoverStyle$1 init() {
  objc.checkOsVersionInternal('UIHoverStyle.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIHoverStyle$1.fromPointer($ret, retain: false, release: true);
  }


  /// isEnabled
  bool get isEnabled {
  objc.checkOsVersionInternal('UIHoverStyle.isEnabled', iOS: (false, (17, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isEnabled);

  }


  /// setEffect:
  set effect(UIHoverEffect value) {
  objc.checkOsVersionInternal('UIHoverStyle.setEffect:', iOS: (false, (17, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setEffect_, value.ref.pointer);

  }


  /// setEnabled:
  set isEnabled(bool value) {
  objc.checkOsVersionInternal('UIHoverStyle.setEnabled:', iOS: (false, (17, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setEnabled_, value);

  }


  /// setShape:
  set shape(UIShape? value) {
  objc.checkOsVersionInternal('UIHoverStyle.setShape:', iOS: (false, (17, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setShape_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// shape
  UIShape? get shape {
  objc.checkOsVersionInternal('UIHoverStyle.shape', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_shape);
    return $ret.address == 0 ? null : UIShape.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_hoverStyle = objc.registerName("hoverStyle");
late final _sel_setHoverStyle_ = objc.registerName("setHoverStyle:");

/// UIHoverStyle
extension UIHoverStyle on UIView {

  /// hoverStyle
  UIHoverStyle$1? get hoverStyle {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hoverStyle);
    return $ret.address == 0 ? null : UIHoverStyle$1.fromPointer($ret, retain: true, release: true);
  }


  /// setHoverStyle:
  set hoverStyle(UIHoverStyle$1? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHoverStyle_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _sel_frameInView_ = objc.registerName("frameInView:");
final _objc_msgSend_qrtfce = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_qrtfceStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_UIView {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)> fromFunction(objc.CGRect Function(ffi.Pointer<ffi.Void> , UIView ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UIView.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static objc.CGRect _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static objc.CGRect _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as objc.CGRect Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>`.
extension ObjCBlock_CGRect_ffiVoid_UIView$CallExtension on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, UIView arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}


/// WARNING: UIPopoverPresentationControllerSourceItem$1 is a stub. To generate bindings for this class, include
/// UIPopoverPresentationControllerSourceItem in your config's objc-protocols list.
///
/// UIPopoverPresentationControllerSourceItem
extension type UIPopoverPresentationControllerSourceItem$1._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIPopoverPresentationControllerSourceItem$1] that points to the same underlying object as [other].
  UIPopoverPresentationControllerSourceItem$1.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIPopoverPresentationControllerSourceItem$1] that wraps the given raw object pointer.
  UIPopoverPresentationControllerSourceItem$1.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// UIPopoverPresentationControllerSourceItem
extension UIPopoverPresentationControllerSourceItem on UIView {

  /// frameInView:
  objc.CGRect frameInView(UIView referenceView) {
  objc.checkOsVersionInternal('UIView.frameInView:', iOS: (false, (17, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_qrtfceStret($ptr, object$.ref.pointer, _sel_frameInView_, referenceView.ref.pointer) : $ptr.ref = _objc_msgSend_qrtfce(object$.ref.pointer, _sel_frameInView_, referenceView.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }

}


/// WARNING: UIViewPrintFormatter is a stub. To generate bindings for this class, include
/// UIViewPrintFormatter in your config's objc-interfaces list.
///
/// UIViewPrintFormatter
extension type UIViewPrintFormatter._(objc.ObjCObject object$) implements objc.ObjCObject,UIPrintFormatter$1 {
  /// Constructs a [UIViewPrintFormatter] that points to the same underlying object as [other].
  UIViewPrintFormatter.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIViewPrintFormatter', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UIViewPrintFormatter] that wraps the given raw object pointer.
  UIViewPrintFormatter.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewPrintFormatter', iOS: (false, (4, 2, 0)));
  }


}

late final _sel_viewPrintFormatter = objc.registerName("viewPrintFormatter");
late final _sel_drawRect_forViewPrintFormatter_ = objc.registerName("drawRect:forViewPrintFormatter:");

/// UIPrintFormatter
extension UIPrintFormatter on UIView {

  /// drawRect:forViewPrintFormatter:
  void drawRect(objc.CGRect rect, {required UIViewPrintFormatter forViewPrintFormatter}) {
_objc_msgSend_f227js(object$.ref.pointer, _sel_drawRect_forViewPrintFormatter_, rect, forViewPrintFormatter.ref.pointer);

  }


  /// viewPrintFormatter
  UIViewPrintFormatter viewPrintFormatter() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_viewPrintFormatter);
    return UIViewPrintFormatter.fromPointer($ret, retain: true, release: true);
  }

}


/// WARNING: UIAppearance is a stub. To generate bindings for this class, include
/// UIAppearance in your config's objc-protocols list.
///
/// UIAppearance
extension type UIAppearance._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAppearance] that points to the same underlying object as [other].
  UIAppearance.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAppearance] that wraps the given raw object pointer.
  UIAppearance.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// WARNING: UIDynamicItem is a stub. To generate bindings for this class, include
/// UIDynamicItem in your config's objc-protocols list.
///
/// UIDynamicItem
extension type UIDynamicItem._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIDynamicItem] that points to the same underlying object as [other].
  UIDynamicItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIDynamicItem] that wraps the given raw object pointer.
  UIDynamicItem.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// WARNING: UITraitEnvironment is a stub. To generate bindings for this class, include
/// UITraitEnvironment in your config's objc-protocols list.
///
/// UITraitEnvironment
extension type UITraitEnvironment._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UITraitEnvironment] that points to the same underlying object as [other].
  UITraitEnvironment.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITraitEnvironment] that wraps the given raw object pointer.
  UITraitEnvironment.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// WARNING: UIFocusItem is a stub. To generate bindings for this class, include
/// UIFocusItem in your config's objc-protocols list.
///
/// UIFocusItem
extension type UIFocusItem._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, UIFocusEnvironment {
  /// Constructs a [UIFocusItem] that points to the same underlying object as [other].
  UIFocusItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusItem] that wraps the given raw object pointer.
  UIFocusItem.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// UIView
extension type UIView._(objc.ObjCObject object$) implements objc.ObjCObject,UIResponder,objc.NSCoding,UIAppearance,UIAppearanceContainer,UIDynamicItem,UITraitEnvironment,UICoordinateSpace,UIFocusItem,UIFocusItemContainer,CALayerDelegate {
  /// Constructs a [UIView] that points to the same underlying object as [other].
  UIView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIView] that wraps the given raw object pointer.
  UIView.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIView);

  /// alloc
  static UIView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_alloc);
    return UIView.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIView, _sel_allocWithZone_, zone);
    return UIView.fromPointer($ret, retain: false, release: true);
  }


  /// appearance
  static UIView appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_appearance);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:
  static UIView appearanceForTraitCollection(UITraitCollection trait) {
  objc.checkOsVersionInternal('UIView.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIView, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedIn:
  static UIView appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
  objc.checkOsVersionInternal('UIView.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIView, _sel_appearanceForTraitCollection_whenContainedIn_, trait.ref.pointer, whenContainedIn?.ref.pointer ?? ffi.nullptr);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIView appearanceForTraitCollection$2(UITraitCollection trait, {required objc.NSArray whenContainedInInstancesOfClasses}) {
  objc.checkOsVersionInternal('UIView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIView, _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_, trait.ref.pointer, whenContainedInInstancesOfClasses.ref.pointer);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedIn:
  static UIView appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
  objc.checkOsVersionInternal('UIView.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIView, _sel_appearanceWhenContainedIn_, ContainerClass?.ref.pointer ?? ffi.nullptr);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedInInstancesOfClasses:
  static UIView appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
  objc.checkOsVersionInternal('UIView.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIView, _sel_appearanceWhenContainedInInstancesOfClasses_, containerTypes.ref.pointer);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// layerClass
  static objc.ObjCObject getLayerClass() {
  objc.checkOsVersionInternal('UIView.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// new
  static UIView new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_new);
    return UIView.fromPointer($ret, retain: false, release: true);
  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute(int attribute) {
  objc.checkOsVersionInternal('UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_racczx(_class_UIView, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_, attribute);

  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute$1(int semanticContentAttribute, {required int relativeToLayoutDirection}) {
  objc.checkOsVersionInternal('UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_tz4p54(_class_UIView, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_, semanticContentAttribute, relativeToLayoutDirection);

  }
  /// Returns a new instance of UIView constructed with the default `new` method.
  UIView() : this.as(new$().object$);

}

extension UIView$Methods on UIView {

  /// actionForLayer:forKey:
  CAAction? actionForLayer(CALayer layer, {required objc.NSString forKey}) {
  objc.checkOsVersionInternal('UIView.actionForLayer:forKey:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_actionForLayer_forKey_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'actionForLayer:forKey:');
    }
    final $ret = _objc_msgSend_15qeuct(object$.ref.pointer, _sel_actionForLayer_forKey_, layer.ref.pointer, forKey.ref.pointer);
    return $ret.address == 0 ? null : CAAction.fromPointer($ret, retain: true, release: true);
  }


  /// bounds
  objc.CGRect get bounds {
  objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_bounds) : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// canBecomeFocused
  bool get canBecomeFocused {
  objc.checkOsVersionInternal('UIView.canBecomeFocused', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canBecomeFocused);

  }


  /// center
  objc.CGPoint get center {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_center) : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_center);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// collisionBoundingPath
  UIBezierPath get collisionBoundingPath {
  objc.checkOsVersionInternal('UIView.collisionBoundingPath', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_collisionBoundingPath)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'collisionBoundingPath');
    }
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_collisionBoundingPath);
    return UIBezierPath.fromPointer($ret, retain: true, release: true);
  }


  /// collisionBoundsType
  int get collisionBoundsType {
  objc.checkOsVersionInternal('UIView.collisionBoundsType', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_collisionBoundsType)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'collisionBoundsType');
    }
    return _objc_msgSend_k9iunc(object$.ref.pointer, _sel_collisionBoundsType);

  }


  /// convertPoint:fromCoordinateSpace:
  objc.CGPoint convertPoint(objc.CGPoint point, {required UICoordinateSpace fromCoordinateSpace}) {
  objc.checkOsVersionInternal('UIView.convertPoint:fromCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_3l1tu1Stret($ptr, object$.ref.pointer, _sel_convertPoint_fromCoordinateSpace_, point, fromCoordinateSpace.ref.pointer) : $ptr.ref = _objc_msgSend_3l1tu1(object$.ref.pointer, _sel_convertPoint_fromCoordinateSpace_, point, fromCoordinateSpace.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// convertPoint:toCoordinateSpace:
  objc.CGPoint convertPoint$1(objc.CGPoint point, {required UICoordinateSpace toCoordinateSpace}) {
  objc.checkOsVersionInternal('UIView.convertPoint:toCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_3l1tu1Stret($ptr, object$.ref.pointer, _sel_convertPoint_toCoordinateSpace_, point, toCoordinateSpace.ref.pointer) : $ptr.ref = _objc_msgSend_3l1tu1(object$.ref.pointer, _sel_convertPoint_toCoordinateSpace_, point, toCoordinateSpace.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// convertRect:fromCoordinateSpace:
  objc.CGRect convertRect(objc.CGRect rect, {required UICoordinateSpace fromCoordinateSpace}) {
  objc.checkOsVersionInternal('UIView.convertRect:fromCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_2olghrStret($ptr, object$.ref.pointer, _sel_convertRect_fromCoordinateSpace_, rect, fromCoordinateSpace.ref.pointer) : $ptr.ref = _objc_msgSend_2olghr(object$.ref.pointer, _sel_convertRect_fromCoordinateSpace_, rect, fromCoordinateSpace.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// convertRect:toCoordinateSpace:
  objc.CGRect convertRect$1(objc.CGRect rect, {required UICoordinateSpace toCoordinateSpace}) {
  objc.checkOsVersionInternal('UIView.convertRect:toCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_2olghrStret($ptr, object$.ref.pointer, _sel_convertRect_toCoordinateSpace_, rect, toCoordinateSpace.ref.pointer) : $ptr.ref = _objc_msgSend_2olghr(object$.ref.pointer, _sel_convertRect_toCoordinateSpace_, rect, toCoordinateSpace.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// coordinateSpace
  UICoordinateSpace get coordinateSpace {
  objc.checkOsVersionInternal('UIView.coordinateSpace', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_coordinateSpace);
    return UICoordinateSpace.fromPointer($ret, retain: true, release: true);
  }


  /// didHintFocusMovement:
  void didHintFocusMovement(UIFocusMovementHint hint) {
  objc.checkOsVersionInternal('UIView.didHintFocusMovement:', iOS: (false, (12, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_didHintFocusMovement_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'didHintFocusMovement:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_didHintFocusMovement_, hint.ref.pointer);

  }


  /// didUpdateFocusInContext:withAnimationCoordinator:
  void didUpdateFocusInContext(UIFocusUpdateContext context, {required UIFocusAnimationCoordinator withAnimationCoordinator}) {
  objc.checkOsVersionInternal('UIView.didUpdateFocusInContext:withAnimationCoordinator:', iOS: (false, (9, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_didUpdateFocusInContext_withAnimationCoordinator_, context.ref.pointer, withAnimationCoordinator.ref.pointer);

  }


  /// displayLayer:
  void displayLayer(CALayer layer) {
  objc.checkOsVersionInternal('UIView.displayLayer:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_displayLayer_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'displayLayer:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_displayLayer_, layer.ref.pointer);

  }


  /// drawLayer:inContext:
  void drawLayer(CALayer layer, {required ffi.Pointer<CGContext> inContext}) {
  objc.checkOsVersionInternal('UIView.drawLayer:inContext:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_drawLayer_inContext_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'drawLayer:inContext:');
    }
_objc_msgSend_a4xp11(object$.ref.pointer, _sel_drawLayer_inContext_, layer.ref.pointer, inContext);

  }


  /// effectiveUserInterfaceLayoutDirection
  int get effectiveUserInterfaceLayoutDirection {
  objc.checkOsVersionInternal('UIView.effectiveUserInterfaceLayoutDirection', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_qj4fey(object$.ref.pointer, _sel_effectiveUserInterfaceLayoutDirection);

  }


  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// focusEffect
  UIFocusEffect? get focusEffect {
  objc.checkOsVersionInternal('UIView.focusEffect', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_focusEffect);
    return $ret.address == 0 ? null : UIFocusEffect.fromPointer($ret, retain: true, release: true);
  }


  /// focusGroupIdentifier
  objc.NSString? get focusGroupIdentifier {
  objc.checkOsVersionInternal('UIView.focusGroupIdentifier', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_focusGroupIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// focusGroupPriority
  int get focusGroupPriority {
  objc.checkOsVersionInternal('UIView.focusGroupPriority', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_focusGroupPriority);

  }


  /// focusItemContainer
  UIFocusItemContainer? get focusItemContainer {
  objc.checkOsVersionInternal('UIView.focusItemContainer', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_focusItemContainer);
    return $ret.address == 0 ? null : UIFocusItemContainer.fromPointer($ret, retain: true, release: true);
  }


  /// focusItemDeferralMode
  int get focusItemDeferralMode {
  objc.checkOsVersionInternal('UIView.focusItemDeferralMode', iOS: (false, (10, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_focusItemDeferralMode)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'focusItemDeferralMode');
    }
    return _objc_msgSend_1lv2zxu(object$.ref.pointer, _sel_focusItemDeferralMode);

  }


  /// focusItemsInRect:
  objc.NSArray focusItemsInRect(objc.CGRect rect) {
  objc.checkOsVersionInternal('UIView.focusItemsInRect:', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(object$.ref.pointer, _sel_focusItemsInRect_, rect);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// frame
  objc.CGRect get frame {
  objc.checkOsVersionInternal('UIView.frame', iOS: (false, (12, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame) : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// init
  UIView init() {
  objc.checkOsVersionInternal('UIView.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UIView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithFrame:
  UIView initWithFrame(objc.CGRect frame) {
  objc.checkOsVersionInternal('UIView.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIView.fromPointer($ret, retain: false, release: true);
  }


  /// isFocused
  bool get isFocused {
  objc.checkOsVersionInternal('UIView.isFocused', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFocused);

  }


  /// isTransparentFocusItem
  bool get isTransparentFocusItem {
  objc.checkOsVersionInternal('UIView.isTransparentFocusItem', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_isTransparentFocusItem)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'isTransparentFocusItem');
    }
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isTransparentFocusItem);

  }


  /// isUserInteractionEnabled
  bool get isUserInteractionEnabled {
  objc.checkOsVersionInternal('UIView.isUserInteractionEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isUserInteractionEnabled);

  }


  /// layer
  CALayer get layer {
  objc.checkOsVersionInternal('UIView.layer', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layer);
    return CALayer.fromPointer($ret, retain: true, release: true);
  }


  /// layerWillDraw:
  void layerWillDraw(CALayer layer) {
  objc.checkOsVersionInternal('UIView.layerWillDraw:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_layerWillDraw_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'layerWillDraw:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_layerWillDraw_, layer.ref.pointer);

  }


  /// layoutSublayersOfLayer:
  void layoutSublayersOfLayer(CALayer layer) {
  objc.checkOsVersionInternal('UIView.layoutSublayersOfLayer:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_layoutSublayersOfLayer_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'layoutSublayersOfLayer:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_layoutSublayersOfLayer_, layer.ref.pointer);

  }


  /// parentFocusEnvironment
  UIFocusEnvironment? get parentFocusEnvironment {
  objc.checkOsVersionInternal('UIView.parentFocusEnvironment', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_parentFocusEnvironment);
    return $ret.address == 0 ? null : UIFocusEnvironment.fromPointer($ret, retain: true, release: true);
  }


  /// preferredFocusEnvironments
  objc.NSArray get preferredFocusEnvironments {
  objc.checkOsVersionInternal('UIView.preferredFocusEnvironments', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_preferredFocusEnvironments);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// preferredFocusedView
  UIView? get preferredFocusedView {
  objc.checkOsVersionInternal('UIView.preferredFocusedView', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_preferredFocusedView)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'preferredFocusedView');
    }
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_preferredFocusedView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// semanticContentAttribute
  int get semanticContentAttribute {
  objc.checkOsVersionInternal('UIView.semanticContentAttribute', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_i2u4x4(object$.ref.pointer, _sel_semanticContentAttribute);

  }


  /// setCenter:
  set center(objc.CGPoint value) {
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setCenter_, value);

  }


  /// setFocusEffect:
  set focusEffect(UIFocusEffect? value) {
  objc.checkOsVersionInternal('UIView.setFocusEffect:', iOS: (false, (15, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFocusEffect_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setFocusGroupIdentifier:
  set focusGroupIdentifier(objc.NSString? value) {
  objc.checkOsVersionInternal('UIView.setFocusGroupIdentifier:', iOS: (false, (14, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFocusGroupIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setFocusGroupPriority:
  set focusGroupPriority(int value) {
  objc.checkOsVersionInternal('UIView.setFocusGroupPriority:', iOS: (false, (15, 0, 0)));
_objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setFocusGroupPriority_, value);

  }


  /// setNeedsFocusUpdate
  void setNeedsFocusUpdate() {
  objc.checkOsVersionInternal('UIView.setNeedsFocusUpdate', iOS: (false, (9, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsFocusUpdate);

  }


  /// setSemanticContentAttribute:
  set semanticContentAttribute(int value) {
  objc.checkOsVersionInternal('UIView.setSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
_objc_msgSend_162qwxu(object$.ref.pointer, _sel_setSemanticContentAttribute_, value);

  }


  /// setTag:
  set tag(int value) {
  objc.checkOsVersionInternal('UIView.setTag:', iOS: (false, (2, 0, 0)));
_objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setTag_, value);

  }


  /// setTransform:
  set transform(CGAffineTransform value) {
_objc_msgSend_qgt66z(object$.ref.pointer, _sel_setTransform_, value);

  }


  /// setUserInteractionEnabled:
  set isUserInteractionEnabled(bool value) {
  objc.checkOsVersionInternal('UIView.setUserInteractionEnabled:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setUserInteractionEnabled_, value);

  }


  /// shouldUpdateFocusInContext:
  bool shouldUpdateFocusInContext(UIFocusUpdateContext context) {
  objc.checkOsVersionInternal('UIView.shouldUpdateFocusInContext:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_shouldUpdateFocusInContext_, context.ref.pointer);

  }


  /// soundIdentifierForFocusUpdateInContext:
  objc.NSString? soundIdentifierForFocusUpdateInContext(UIFocusUpdateContext context) {
  objc.checkOsVersionInternal('UIView.soundIdentifierForFocusUpdateInContext:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_soundIdentifierForFocusUpdateInContext_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'soundIdentifierForFocusUpdateInContext:');
    }
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_soundIdentifierForFocusUpdateInContext_, context.ref.pointer);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// tag
  int get tag {
  objc.checkOsVersionInternal('UIView.tag', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_tag);

  }


  /// traitCollection
  UITraitCollection get traitCollection {
  objc.checkOsVersionInternal('UIView.traitCollection', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_traitCollection);
    return UITraitCollection.fromPointer($ret, retain: true, release: true);
  }


  /// traitCollectionDidChange:
  void traitCollectionDidChange(UITraitCollection? previousTraitCollection) {
  objc.checkOsVersionInternal('UIView.traitCollectionDidChange:', iOS: (false, (8, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_traitCollectionDidChange_, previousTraitCollection?.ref.pointer ?? ffi.nullptr);

  }


  /// traitOverrides
  UITraitOverrides get traitOverrides {
  objc.checkOsVersionInternal('UIView.traitOverrides', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_traitOverrides);
    return UITraitOverrides.fromPointer($ret, retain: true, release: true);
  }


  /// transform
  CGAffineTransform get transform {
    final $ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants ? _objc_msgSend_5qswvjStret($ptr, object$.ref.pointer, _sel_transform) : $ptr.ref = _objc_msgSend_5qswvj(object$.ref.pointer, _sel_transform);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGAffineTransform>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGAffineTransform>(
        $finalizable);

  }


  /// updateFocusIfNeeded
  void updateFocusIfNeeded() {
  objc.checkOsVersionInternal('UIView.updateFocusIfNeeded', iOS: (false, (9, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateFocusIfNeeded);

  }


  /// updateTraitsIfNeeded
  void updateTraitsIfNeeded() {
  objc.checkOsVersionInternal('UIView.updateTraitsIfNeeded', iOS: (false, (17, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateTraitsIfNeeded);

  }

}

late final _sel_inputView = objc.registerName("inputView");
late final _sel_inputAccessoryView = objc.registerName("inputAccessoryView");

/// WARNING: UITextInputAssistantItem is a stub. To generate bindings for this class, include
/// UITextInputAssistantItem in your config's objc-interfaces list.
///
/// UITextInputAssistantItem
extension type UITextInputAssistantItem._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UITextInputAssistantItem] that points to the same underlying object as [other].
  UITextInputAssistantItem.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITextInputAssistantItem', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UITextInputAssistantItem] that wraps the given raw object pointer.
  UITextInputAssistantItem.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputAssistantItem', iOS: (false, (9, 0, 0)));
  }


}

late final _sel_inputAssistantItem = objc.registerName("inputAssistantItem");

/// WARNING: UIInputViewController is a stub. To generate bindings for this class, include
/// UIInputViewController in your config's objc-interfaces list.
///
/// UIInputViewController
extension type UIInputViewController._(objc.ObjCObject object$) implements objc.ObjCObject,UIViewController,UITextInputDelegate {
  /// Constructs a [UIInputViewController] that points to the same underlying object as [other].
  UIInputViewController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIInputViewController', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UIInputViewController] that wraps the given raw object pointer.
  UIInputViewController.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIInputViewController', iOS: (false, (8, 0, 0)));
  }


}

late final _sel_inputViewController = objc.registerName("inputViewController");
late final _sel_inputAccessoryViewController = objc.registerName("inputAccessoryViewController");

/// WARNING: UITextInputMode is a stub. To generate bindings for this class, include
/// UITextInputMode in your config's objc-interfaces list.
///
/// UITextInputMode
extension type UITextInputMode._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding {
  /// Constructs a [UITextInputMode] that points to the same underlying object as [other].
  UITextInputMode.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UITextInputMode] that wraps the given raw object pointer.
  UITextInputMode.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }


}

late final _sel_textInputMode = objc.registerName("textInputMode");
late final _sel_textInputContextIdentifier = objc.registerName("textInputContextIdentifier");
late final _sel_clearTextInputContextIdentifier_ = objc.registerName("clearTextInputContextIdentifier:");
late final _sel_reloadInputViews = objc.registerName("reloadInputViews");

/// UIResponderInputViewAdditions
extension UIResponderInputViewAdditions on UIResponder {

  /// inputAccessoryView
  UIView? get inputAccessoryView {
  objc.checkOsVersionInternal('UIResponder.inputAccessoryView', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_inputAccessoryView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// inputAccessoryViewController
  UIInputViewController? get inputAccessoryViewController {
  objc.checkOsVersionInternal('UIResponder.inputAccessoryViewController', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_inputAccessoryViewController);
    return $ret.address == 0 ? null : UIInputViewController.fromPointer($ret, retain: true, release: true);
  }


  /// inputAssistantItem
  UITextInputAssistantItem get inputAssistantItem {
  objc.checkOsVersionInternal('UIResponder.inputAssistantItem', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_inputAssistantItem);
    return UITextInputAssistantItem.fromPointer($ret, retain: true, release: true);
  }


  /// inputView
  UIView? get inputView {
  objc.checkOsVersionInternal('UIResponder.inputView', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_inputView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// inputViewController
  UIInputViewController? get inputViewController {
  objc.checkOsVersionInternal('UIResponder.inputViewController', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_inputViewController);
    return $ret.address == 0 ? null : UIInputViewController.fromPointer($ret, retain: true, release: true);
  }


  /// reloadInputViews
  void reloadInputViews() {
  objc.checkOsVersionInternal('UIResponder.reloadInputViews', iOS: (false, (3, 2, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_reloadInputViews);

  }


  /// textInputContextIdentifier
  objc.NSString? get textInputContextIdentifier {
  objc.checkOsVersionInternal('UIResponder.textInputContextIdentifier', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textInputContextIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// textInputMode
  UITextInputMode? get textInputMode {
  objc.checkOsVersionInternal('UIResponder.textInputMode', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textInputMode);
    return $ret.address == 0 ? null : UITextInputMode.fromPointer($ret, retain: true, release: true);
  }


  /// clearTextInputContextIdentifier:
  static void clearTextInputContextIdentifier(objc.NSString identifier) {
  objc.checkOsVersionInternal('UIResponder.clearTextInputContextIdentifier:', iOS: (false, (7, 0, 0)));
_objc_msgSend_xtuoz7(_class_UIResponder, _sel_clearTextInputContextIdentifier_, identifier.ref.pointer);

  }

}

late final _sel_userActivity = objc.registerName("userActivity");
late final _sel_setUserActivity_ = objc.registerName("setUserActivity:");
late final _sel_updateUserActivityState_ = objc.registerName("updateUserActivityState:");
late final _sel_restoreUserActivityState_ = objc.registerName("restoreUserActivityState:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUserActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromFunction(void Function(ffi.Pointer<ffi.Void> , NSUserActivity ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, NSUserActivity.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> listener(void Function(ffi.Pointer<ffi.Void> , NSUserActivity ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, NSUserActivity.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> blocking(void Function(ffi.Pointer<ffi.Void> , NSUserActivity ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, NSUserActivity.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, NSUserActivity.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUserActivity$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSUserActivity arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}


/// ActivityContinuation
extension ActivityContinuation on UIResponder {

  /// restoreUserActivityState:
  void restoreUserActivityState(NSUserActivity userActivity) {
  objc.checkOsVersionInternal('UIResponder.restoreUserActivityState:', iOS: (false, (8, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_restoreUserActivityState_, userActivity.ref.pointer);

  }


  /// setUserActivity:
  set userActivity(NSUserActivity? value) {
  objc.checkOsVersionInternal('UIResponder.setUserActivity:', iOS: (false, (8, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setUserActivity_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// updateUserActivityState:
  void updateUserActivityState(NSUserActivity activity) {
  objc.checkOsVersionInternal('UIResponder.updateUserActivityState:', iOS: (false, (8, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_updateUserActivityState_, activity.ref.pointer);

  }


  /// userActivity
  NSUserActivity? get userActivity {
  objc.checkOsVersionInternal('UIResponder.userActivity', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_userActivity);
    return $ret.address == 0 ? null : NSUserActivity.fromPointer($ret, retain: true, release: true);
  }

}


/// WARNING: UIPasteConfiguration is a stub. To generate bindings for this class, include
/// UIPasteConfiguration in your config's objc-interfaces list.
///
/// UIPasteConfiguration
extension type UIPasteConfiguration._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [UIPasteConfiguration] that points to the same underlying object as [other].
  UIPasteConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPasteConfiguration', iOS: (false, (11, 0, 0)));
  }

  /// Constructs a [UIPasteConfiguration] that wraps the given raw object pointer.
  UIPasteConfiguration.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPasteConfiguration', iOS: (false, (11, 0, 0)));
  }


}

late final _sel_pasteConfiguration = objc.registerName("pasteConfiguration");

/// Construction methods for `objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIPasteConfiguration_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)> fromFunction(UIPasteConfiguration? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIPasteConfiguration_ffiVoid$CallExtension on objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)> {
  UIPasteConfiguration? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : UIPasteConfiguration.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_setPasteConfiguration_ = objc.registerName("setPasteConfiguration:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)> fromFunction(void Function(ffi.Pointer<ffi.Void> , UIPasteConfiguration? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIPasteConfiguration.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)> listener(void Function(ffi.Pointer<ffi.Void> , UIPasteConfiguration? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIPasteConfiguration.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)> blocking(void Function(ffi.Pointer<ffi.Void> , UIPasteConfiguration? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIPasteConfiguration.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIPasteConfiguration.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIPasteConfiguration? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_pasteItemProviders_ = objc.registerName("pasteItemProviders:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.NSArray ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSArray.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> listener(void Function(ffi.Pointer<ffi.Void> , objc.NSArray ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSArray.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.NSArray ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSArray.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSArray.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSArray$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_canPasteItemProviders_ = objc.registerName("canPasteItemProviders:");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunction(bool Function(ffi.Pointer<ffi.Void> , objc.NSArray ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSArray.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_bool_ffiVoid_NSArray$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  bool call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}


/// UIPasteConfigurationSupporting
extension UIPasteConfigurationSupporting on UIResponder {

  /// canPasteItemProviders:
  bool canPasteItemProviders(objc.NSArray itemProviders) {
  objc.checkOsVersionInternal('UIResponder.canPasteItemProviders:', iOS: (false, (11, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_canPasteItemProviders_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'canPasteItemProviders:');
    }
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_canPasteItemProviders_, itemProviders.ref.pointer);

  }


  /// pasteConfiguration
  UIPasteConfiguration? get pasteConfiguration {
  objc.checkOsVersionInternal('UIResponder.pasteConfiguration', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_pasteConfiguration);
    return $ret.address == 0 ? null : UIPasteConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// pasteItemProviders:
  void pasteItemProviders(objc.NSArray itemProviders) {
  objc.checkOsVersionInternal('UIResponder.pasteItemProviders:', iOS: (false, (11, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_pasteItemProviders_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteItemProviders:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_pasteItemProviders_, itemProviders.ref.pointer);

  }


  /// setPasteConfiguration:
  set pasteConfiguration(UIPasteConfiguration? value) {
  objc.checkOsVersionInternal('UIResponder.setPasteConfiguration:', iOS: (false, (11, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setPasteConfiguration_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _sel_captureTextFromCamera_ = objc.registerName("captureTextFromCamera:");

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting on UIResponder {

  /// captureTextFromCamera:
  void captureTextFromCamera(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.captureTextFromCamera:', iOS: (false, (15, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_captureTextFromCamera_, sender?.ref.pointer ?? ffi.nullptr);

  }

}


/// WARNING: UIActivityItemsConfigurationReading is a stub. To generate bindings for this class, include
/// UIActivityItemsConfigurationReading in your config's objc-protocols list.
///
/// UIActivityItemsConfigurationReading
extension type UIActivityItemsConfigurationReading._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIActivityItemsConfigurationReading] that points to the same underlying object as [other].
  UIActivityItemsConfigurationReading.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIActivityItemsConfigurationReading] that wraps the given raw object pointer.
  UIActivityItemsConfigurationReading.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_activityItemsConfiguration = objc.registerName("activityItemsConfiguration");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunction(UIActivityItemsConfigurationReading? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> {
  UIActivityItemsConfigurationReading? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : UIActivityItemsConfigurationReading.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_setActivityItemsConfiguration_ = objc.registerName("setActivityItemsConfiguration:");

/// WARNING: UIActivityItemsConfigurationProviding is a stub. To generate bindings for this class, include
/// UIActivityItemsConfigurationProviding in your config's objc-protocols list.
///
/// UIActivityItemsConfigurationProviding
extension type UIActivityItemsConfigurationProviding._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIActivityItemsConfigurationProviding] that points to the same underlying object as [other].
  UIActivityItemsConfigurationProviding.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIActivityItemsConfigurationProviding] that wraps the given raw object pointer.
  UIActivityItemsConfigurationProviding.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// UIActivityItemsConfiguration
extension UIActivityItemsConfiguration on UIResponder {

  /// activityItemsConfiguration
  UIActivityItemsConfigurationReading? get activityItemsConfiguration {
  objc.checkOsVersionInternal('UIResponder.activityItemsConfiguration', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_activityItemsConfiguration);
    return $ret.address == 0 ? null : UIActivityItemsConfigurationReading.fromPointer($ret, retain: true, release: true);
  }


  /// setActivityItemsConfiguration:
  set activityItemsConfiguration$1(UIActivityItemsConfigurationReading? value) {
  objc.checkOsVersionInternal('UIResponder.setActivityItemsConfiguration:', iOS: (false, (13, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setActivityItemsConfiguration_, value?.ref.pointer ?? ffi.nullptr);

  }

}


/// UIResponder
extension type UIResponder._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,UIResponderStandardEditActions {
  /// Constructs a [UIResponder] that points to the same underlying object as [other].
  UIResponder.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIResponder] that wraps the given raw object pointer.
  UIResponder.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIResponder].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIResponder);

  /// alloc
  static UIResponder alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_alloc);
    return UIResponder.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIResponder allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIResponder, _sel_allocWithZone_, zone);
    return UIResponder.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static UIResponder new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_new);
    return UIResponder.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of UIResponder constructed with the default `new` method.
  UIResponder() : this.as(new$().object$);

}

extension UIResponder$Methods on UIResponder {

  /// alignCenter:
  void alignCenter(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.alignCenter:', iOS: (false, (26, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_alignCenter_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'alignCenter:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_alignCenter_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// alignJustified:
  void alignJustified(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.alignJustified:', iOS: (false, (26, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_alignJustified_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'alignJustified:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_alignJustified_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// alignLeft:
  void alignLeft(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.alignLeft:', iOS: (false, (26, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_alignLeft_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'alignLeft:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_alignLeft_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// alignRight:
  void alignRight(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.alignRight:', iOS: (false, (26, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_alignRight_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'alignRight:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_alignRight_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// becomeFirstResponder
  bool becomeFirstResponder() {
  objc.checkOsVersionInternal('UIResponder.becomeFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_becomeFirstResponder);

  }


  /// buildMenuWithBuilder:
  void buildMenuWithBuilder(UIMenuBuilder builder) {
  objc.checkOsVersionInternal('UIResponder.buildMenuWithBuilder:', iOS: (false, (13, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_buildMenuWithBuilder_, builder.ref.pointer);

  }


  /// canBecomeFirstResponder
  bool get canBecomeFirstResponder {
  objc.checkOsVersionInternal('UIResponder.canBecomeFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canBecomeFirstResponder);

  }


  /// canPerformAction:withSender:
  bool canPerformAction(ffi.Pointer<objc.ObjCSelector> action, {objc.ObjCObject? withSender}) {
  objc.checkOsVersionInternal('UIResponder.canPerformAction:withSender:', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_1f04296(object$.ref.pointer, _sel_canPerformAction_withSender_, action, withSender?.ref.pointer ?? ffi.nullptr);

  }


  /// canResignFirstResponder
  bool get canResignFirstResponder {
  objc.checkOsVersionInternal('UIResponder.canResignFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canResignFirstResponder);

  }


  /// copy:
  void copy$1(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.copy:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_copy_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'copy:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_copy_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// cut:
  void cut(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.cut:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_cut_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'cut:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_cut_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// decreaseSize:
  void decreaseSize(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.decreaseSize:', iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_decreaseSize_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'decreaseSize:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_decreaseSize_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// delete:
  void delete(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.delete:', iOS: (false, (3, 2, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_delete_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'delete:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_delete_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// duplicate:
  void duplicate(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.duplicate:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_duplicate_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'duplicate:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_duplicate_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// editingInteractionConfiguration
  int get editingInteractionConfiguration {
  objc.checkOsVersionInternal('UIResponder.editingInteractionConfiguration', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_15pfzxv(object$.ref.pointer, _sel_editingInteractionConfiguration);

  }


  /// export:
  void export(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.export:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_export_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'export:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_export_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// find:
  void find(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.find:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_find_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'find:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_find_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// findAndReplace:
  void findAndReplace(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.findAndReplace:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_findAndReplace_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'findAndReplace:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_findAndReplace_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// findNext:
  void findNext(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.findNext:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_findNext_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'findNext:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_findNext_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// findPrevious:
  void findPrevious(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.findPrevious:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_findPrevious_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'findPrevious:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_findPrevious_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// increaseSize:
  void increaseSize(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.increaseSize:', iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_increaseSize_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'increaseSize:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_increaseSize_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// init
  UIResponder init() {
  objc.checkOsVersionInternal('UIResponder.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIResponder.fromPointer($ret, retain: false, release: true);
  }


  /// isFirstResponder
  bool get isFirstResponder {
  objc.checkOsVersionInternal('UIResponder.isFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFirstResponder);

  }


  /// makeTextWritingDirectionLeftToRight:
  void makeTextWritingDirectionLeftToRight(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.makeTextWritingDirectionLeftToRight:', iOS: (false, (5, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_makeTextWritingDirectionLeftToRight_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'makeTextWritingDirectionLeftToRight:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_makeTextWritingDirectionLeftToRight_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// makeTextWritingDirectionRightToLeft:
  void makeTextWritingDirectionRightToLeft(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.makeTextWritingDirectionRightToLeft:', iOS: (false, (5, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_makeTextWritingDirectionRightToLeft_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'makeTextWritingDirectionRightToLeft:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_makeTextWritingDirectionRightToLeft_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// motionBegan:withEvent:
  void motionBegan(int motion, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.motionBegan:withEvent:', iOS: (false, (3, 0, 0)));
_objc_msgSend_pov02z(object$.ref.pointer, _sel_motionBegan_withEvent_, motion, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// motionCancelled:withEvent:
  void motionCancelled(int motion, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.motionCancelled:withEvent:', iOS: (false, (3, 0, 0)));
_objc_msgSend_pov02z(object$.ref.pointer, _sel_motionCancelled_withEvent_, motion, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// motionEnded:withEvent:
  void motionEnded(int motion, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.motionEnded:withEvent:', iOS: (false, (3, 0, 0)));
_objc_msgSend_pov02z(object$.ref.pointer, _sel_motionEnded_withEvent_, motion, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// move:
  void move(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.move:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_move_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'move:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_move_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// newFromPasteboard:
  void newFromPasteboard(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.newFromPasteboard:', iOS: (false, (26, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_newFromPasteboard_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'newFromPasteboard:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_newFromPasteboard_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// nextResponder
  UIResponder? get nextResponder {
  objc.checkOsVersionInternal('UIResponder.nextResponder', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_nextResponder);
    return $ret.address == 0 ? null : UIResponder.fromPointer($ret, retain: true, release: true);
  }


  /// paste:
  void paste(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.paste:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_paste_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'paste:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_paste_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// pasteAndGo:
  void pasteAndGo(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.pasteAndGo:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_pasteAndGo_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndGo:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_pasteAndGo_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// pasteAndMatchStyle:
  void pasteAndMatchStyle(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.pasteAndMatchStyle:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_pasteAndMatchStyle_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndMatchStyle:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_pasteAndMatchStyle_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// pasteAndSearch:
  void pasteAndSearch(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.pasteAndSearch:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_pasteAndSearch_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndSearch:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_pasteAndSearch_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// performClose:
  void performClose(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.performClose:', iOS: (false, (26, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_performClose_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'performClose:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_performClose_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// pressesBegan:withEvent:
  void pressesBegan(objc.NSSet presses, {UIPressesEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.pressesBegan:withEvent:', iOS: (false, (9, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_pressesBegan_withEvent_, presses.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// pressesCancelled:withEvent:
  void pressesCancelled(objc.NSSet presses, {UIPressesEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.pressesCancelled:withEvent:', iOS: (false, (9, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_pressesCancelled_withEvent_, presses.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// pressesChanged:withEvent:
  void pressesChanged(objc.NSSet presses, {UIPressesEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.pressesChanged:withEvent:', iOS: (false, (9, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_pressesChanged_withEvent_, presses.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// pressesEnded:withEvent:
  void pressesEnded(objc.NSSet presses, {UIPressesEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.pressesEnded:withEvent:', iOS: (false, (9, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_pressesEnded_withEvent_, presses.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// print:
  void print(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.print:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_print_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'print:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_print_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// providerForDeferredMenuElement:
  UIDeferredMenuElementProvider? providerForDeferredMenuElement(UIDeferredMenuElement deferredElement) {
  objc.checkOsVersionInternal('UIResponder.providerForDeferredMenuElement:', iOS: (false, (26, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_providerForDeferredMenuElement_, deferredElement.ref.pointer);
    return $ret.address == 0 ? null : UIDeferredMenuElementProvider.fromPointer($ret, retain: true, release: true);
  }


  /// remoteControlReceivedWithEvent:
  void remoteControlReceivedWithEvent(UIEvent? event) {
  objc.checkOsVersionInternal('UIResponder.remoteControlReceivedWithEvent:', iOS: (false, (4, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_remoteControlReceivedWithEvent_, event?.ref.pointer ?? ffi.nullptr);

  }


  /// rename:
  void rename(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.rename:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_rename_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'rename:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_rename_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// resignFirstResponder
  bool resignFirstResponder() {
  objc.checkOsVersionInternal('UIResponder.resignFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_resignFirstResponder);

  }


  /// select:
  void select(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.select:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_select_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'select:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_select_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// selectAll:
  void selectAll(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.selectAll:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_selectAll_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'selectAll:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_selectAll_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// showWritingTools:
  void showWritingTools(objc.ObjCObject sender) {
  objc.checkOsVersionInternal('UIResponder.showWritingTools:', iOS: (false, (18, 2, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_showWritingTools_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'showWritingTools:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_showWritingTools_, sender.ref.pointer);

  }


  /// targetForAction:withSender:
  objc.ObjCObject? targetForAction(ffi.Pointer<objc.ObjCSelector> action, {objc.ObjCObject? withSender}) {
  objc.checkOsVersionInternal('UIResponder.targetForAction:withSender:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_gx50so(object$.ref.pointer, _sel_targetForAction_withSender_, action, withSender?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// toggleBoldface:
  void toggleBoldface(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.toggleBoldface:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleBoldface_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleBoldface:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_toggleBoldface_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// toggleInspector:
  void toggleInspector(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.toggleInspector:', iOS: (false, (26, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleInspector_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleInspector:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_toggleInspector_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// toggleItalics:
  void toggleItalics(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.toggleItalics:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleItalics_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleItalics:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_toggleItalics_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// toggleSidebar:
  void toggleSidebar(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.toggleSidebar:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleSidebar_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleSidebar:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_toggleSidebar_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// toggleUnderline:
  void toggleUnderline(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.toggleUnderline:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleUnderline_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleUnderline:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_toggleUnderline_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// touchesBegan:withEvent:
  void touchesBegan(objc.NSSet touches, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.touchesBegan:withEvent:', iOS: (false, (2, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_touchesBegan_withEvent_, touches.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// touchesCancelled:withEvent:
  void touchesCancelled(objc.NSSet touches, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.touchesCancelled:withEvent:', iOS: (false, (2, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_touchesCancelled_withEvent_, touches.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// touchesEnded:withEvent:
  void touchesEnded(objc.NSSet touches, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.touchesEnded:withEvent:', iOS: (false, (2, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_touchesEnded_withEvent_, touches.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// touchesEstimatedPropertiesUpdated:
  void touchesEstimatedPropertiesUpdated(objc.NSSet touches) {
  objc.checkOsVersionInternal('UIResponder.touchesEstimatedPropertiesUpdated:', iOS: (false, (9, 1, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_touchesEstimatedPropertiesUpdated_, touches.ref.pointer);

  }


  /// touchesMoved:withEvent:
  void touchesMoved(objc.NSSet touches, {UIEvent? withEvent}) {
  objc.checkOsVersionInternal('UIResponder.touchesMoved:withEvent:', iOS: (false, (2, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_touchesMoved_withEvent_, touches.ref.pointer, withEvent?.ref.pointer ?? ffi.nullptr);

  }


  /// undoManager
  NSUndoManager? get undoManager {
  objc.checkOsVersionInternal('UIResponder.undoManager', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_undoManager);
    return $ret.address == 0 ? null : NSUndoManager.fromPointer($ret, retain: true, release: true);
  }


  /// updateTextAttributesWithConversionHandler:
  void updateTextAttributesWithConversionHandler(objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> conversionHandler) {
  objc.checkOsVersionInternal('UIResponder.updateTextAttributesWithConversionHandler:', iOS: (false, (13, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_updateTextAttributesWithConversionHandler_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'updateTextAttributesWithConversionHandler:');
    }
_objc_msgSend_f167m6(object$.ref.pointer, _sel_updateTextAttributesWithConversionHandler_, conversionHandler.ref.pointer);

  }


  /// useSelectionForFind:
  void useSelectionForFind(objc.ObjCObject? sender) {
  objc.checkOsVersionInternal('UIResponder.useSelectionForFind:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_useSelectionForFind_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'useSelectionForFind:');
    }
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_useSelectionForFind_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// validateCommand:
  void validateCommand(UICommand command) {
  objc.checkOsVersionInternal('UIResponder.validateCommand:', iOS: (false, (13, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_validateCommand_, command.ref.pointer);

  }

}

sealed class UIBarStyle {
  static const UIBarStyleDefault = 0;
  static const UIBarStyleBlack = 1;
  static const UIBarStyleBlackOpaque = 1;
  static const UIBarStyleBlackTranslucent = 2;}

sealed class UIUserInterfaceSizeClass {
  static const UIUserInterfaceSizeClassUnspecified = 0;
  static const UIUserInterfaceSizeClassCompact = 1;
  static const UIUserInterfaceSizeClassRegular = 2;}

sealed class UITraitEnvironmentLayoutDirection {
  static const UITraitEnvironmentLayoutDirectionUnspecified = -1;
  static const UITraitEnvironmentLayoutDirectionLeftToRight = 0;
  static const UITraitEnvironmentLayoutDirectionRightToLeft = 1;}

sealed class UIDisplayGamut {
  static const UIDisplayGamutUnspecified = -1;
  static const UIDisplayGamutSRGB = 0;
  static const UIDisplayGamutP3 = 1;}

sealed class UIAccessibilityContrast {
  static const UIAccessibilityContrastUnspecified = -1;
  static const UIAccessibilityContrastNormal = 0;
  static const UIAccessibilityContrastHigh = 1;}

sealed class UILegibilityWeight {
  static const UILegibilityWeightUnspecified = -1;
  static const UILegibilityWeightRegular = 0;
  static const UILegibilityWeightBold = 1;}

sealed class UIUserInterfaceLevel {
  static const UIUserInterfaceLevelUnspecified = -1;
  static const UIUserInterfaceLevelBase = 0;
  static const UIUserInterfaceLevelElevated = 1;}

sealed class UIUserInterfaceActiveAppearance {
  static const UIUserInterfaceActiveAppearanceUnspecified = -1;
  static const UIUserInterfaceActiveAppearanceInactive = 0;
  static const UIUserInterfaceActiveAppearanceActive = 1;}

sealed class UINSToolbarItemPresentationSize {
  static const UINSToolbarItemPresentationSizeUnspecified = -1;
  static const UINSToolbarItemPresentationSizeRegular = 0;
  static const UINSToolbarItemPresentationSizeSmall = 1;
  static const UINSToolbarItemPresentationSizeLarge = 3;}

sealed class UIImageDynamicRange {
  static const UIImageDynamicRangeUnspecified = -1;
  static const UIImageDynamicRangeStandard = 0;
  static const UIImageDynamicRangeConstrainedHigh = 1;
  static const UIImageDynamicRangeHigh = 2;}

sealed class UIHDRHeadroomUsageLimit {
  static const UIHDRHeadroomUsageLimitUnspecified = -1;
  static const UIHDRHeadroomUsageLimitActive = 0;
  static const UIHDRHeadroomUsageLimitInactive = 1;}

sealed class NSLayoutRelation {
  static const NSLayoutRelationLessThanOrEqual = -1;
  static const NSLayoutRelationEqual = 0;
  static const NSLayoutRelationGreaterThanOrEqual = 1;}

sealed class NSLayoutAttribute {
  static const NSLayoutAttributeLeft = 1;
  static const NSLayoutAttributeRight = 2;
  static const NSLayoutAttributeTop = 3;
  static const NSLayoutAttributeBottom = 4;
  static const NSLayoutAttributeLeading = 5;
  static const NSLayoutAttributeTrailing = 6;
  static const NSLayoutAttributeWidth = 7;
  static const NSLayoutAttributeHeight = 8;
  static const NSLayoutAttributeCenterX = 9;
  static const NSLayoutAttributeCenterY = 10;
  static const NSLayoutAttributeLastBaseline = 11;
  static const NSLayoutAttributeBaseline = 11;
  static const NSLayoutAttributeFirstBaseline = 12;
  static const NSLayoutAttributeLeftMargin = 13;
  static const NSLayoutAttributeRightMargin = 14;
  static const NSLayoutAttributeTopMargin = 15;
  static const NSLayoutAttributeBottomMargin = 16;
  static const NSLayoutAttributeLeadingMargin = 17;
  static const NSLayoutAttributeTrailingMargin = 18;
  static const NSLayoutAttributeCenterXWithinMargins = 19;
  static const NSLayoutAttributeCenterYWithinMargins = 20;
  static const NSLayoutAttributeNotAnAttribute = 0;}

sealed class NSLayoutFormatOptions {
  static const NSLayoutFormatAlignAllLeft = 2;
  static const NSLayoutFormatAlignAllRight = 4;
  static const NSLayoutFormatAlignAllTop = 8;
  static const NSLayoutFormatAlignAllBottom = 16;
  static const NSLayoutFormatAlignAllLeading = 32;
  static const NSLayoutFormatAlignAllTrailing = 64;
  static const NSLayoutFormatAlignAllCenterX = 512;
  static const NSLayoutFormatAlignAllCenterY = 1024;
  static const NSLayoutFormatAlignAllLastBaseline = 2048;
  static const NSLayoutFormatAlignAllFirstBaseline = 4096;
  static const NSLayoutFormatAlignAllBaseline = 2048;
  static const NSLayoutFormatAlignmentMask = 65535;
  static const NSLayoutFormatDirectionLeadingToTrailing = 0;
  static const NSLayoutFormatDirectionLeftToRight = 65536;
  static const NSLayoutFormatDirectionRightToLeft = 131072;
  static const NSLayoutFormatDirectionMask = 196608;
  static const NSLayoutFormatSpacingEdgeToEdge = 0;
  static const NSLayoutFormatSpacingBaselineToBaseline = 524288;
  static const NSLayoutFormatSpacingMask = 524288;}

sealed class UIInterfaceOrientation {
  static const UIInterfaceOrientationUnknown = 0;
  static const UIInterfaceOrientationPortrait = 1;
  static const UIInterfaceOrientationPortraitUpsideDown = 2;
  static const UIInterfaceOrientationLandscapeLeft = 4;
  static const UIInterfaceOrientationLandscapeRight = 3;}

sealed class UIInterfaceOrientationMask {
  static const UIInterfaceOrientationMaskPortrait = 2;
  static const UIInterfaceOrientationMaskLandscapeLeft = 16;
  static const UIInterfaceOrientationMaskLandscapeRight = 8;
  static const UIInterfaceOrientationMaskPortraitUpsideDown = 4;
  static const UIInterfaceOrientationMaskLandscape = 24;
  static const UIInterfaceOrientationMaskAll = 30;
  static const UIInterfaceOrientationMaskAllButUpsideDown = 26;}

sealed class UIUserInterfaceIdiom {
  static const UIUserInterfaceIdiomUnspecified = -1;
  static const UIUserInterfaceIdiomPhone = 0;
  static const UIUserInterfaceIdiomPad = 1;
  static const UIUserInterfaceIdiomTV = 2;
  static const UIUserInterfaceIdiomCarPlay = 3;
  static const UIUserInterfaceIdiomMac = 5;
  static const UIUserInterfaceIdiomVision = 6;}

sealed class UITouchPhase {
  static const UITouchPhaseBegan = 0;
  static const UITouchPhaseMoved = 1;
  static const UITouchPhaseStationary = 2;
  static const UITouchPhaseEnded = 3;
  static const UITouchPhaseCancelled = 4;
  static const UITouchPhaseRegionEntered = 5;
  static const UITouchPhaseRegionMoved = 6;
  static const UITouchPhaseRegionExited = 7;}

sealed class UIForceTouchCapability {
  static const UIForceTouchCapabilityUnknown = 0;
  static const UIForceTouchCapabilityUnavailable = 1;
  static const UIForceTouchCapabilityAvailable = 2;}

sealed class UITouchType {
  static const UITouchTypeDirect = 0;
  static const UITouchTypeIndirect = 1;
  static const UITouchTypePencil = 2;
  static const UITouchTypeStylus = 2;
  static const UITouchTypeIndirectPointer = 3;}

sealed class UITouchProperties {
  static const UITouchPropertyForce = 1;
  static const UITouchPropertyAzimuth = 2;
  static const UITouchPropertyAltitude = 4;
  static const UITouchPropertyLocation = 8;
  static const UITouchPropertyRoll = 16;}


/// WARNING: UITouch is a stub. To generate bindings for this class, include
/// UITouch in your config's objc-interfaces list.
///
/// UITouch
extension type UITouch._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UITouch] that points to the same underlying object as [other].
  UITouch.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITouch', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITouch] that wraps the given raw object pointer.
  UITouch.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITouch', iOS: (false, (2, 0, 0)));
  }


}

sealed class UISceneActivationState {
  static const UISceneActivationStateUnattached = -1;
  static const UISceneActivationStateForegroundActive = 0;
  static const UISceneActivationStateForegroundInactive = 1;
  static const UISceneActivationStateBackground = 2;}

sealed class UISceneCaptureState {
  static const UISceneCaptureStateUnspecified = -1;
  static const UISceneCaptureStateInactive = 0;
  static const UISceneCaptureStateActive = 1;}

sealed class UIListEnvironment {
  static const UIListEnvironmentUnspecified = 0;
  static const UIListEnvironmentNone = 1;
  static const UIListEnvironmentPlain = 2;
  static const UIListEnvironmentGrouped = 3;
  static const UIListEnvironmentInsetGrouped = 4;
  static const UIListEnvironmentSidebar = 5;
  static const UIListEnvironmentSidebarPlain = 6;}

sealed class UITabAccessoryEnvironment {
  static const UITabAccessoryEnvironmentUnspecified = 0;
  static const UITabAccessoryEnvironmentNone = 1;
  static const UITabAccessoryEnvironmentRegular = 2;
  static const UITabAccessoryEnvironmentInline = 3;}

sealed class UISplitViewControllerLayoutEnvironment {
  static const UISplitViewControllerLayoutEnvironmentNone = 0;
  static const UISplitViewControllerLayoutEnvironmentExpanded = 1;
  static const UISplitViewControllerLayoutEnvironmentCollapsed = 2;}


/// WARNING: UIMutableTraits is a stub. To generate bindings for this class, include
/// UIMutableTraits in your config's objc-protocols list.
///
/// UIMutableTraits
extension type UIMutableTraits._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIMutableTraits] that points to the same underlying object as [other].
  UIMutableTraits.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIMutableTraits] that wraps the given raw object pointer.
  UIMutableTraits.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_ffiVoid_idUIMutableTraits {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)> fromFunction(void Function(UIMutableTraits ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIMutableTraits.fromPointer(arg0, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)> listener(void Function(UIMutableTraits ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIMutableTraits.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)> blocking(void Function(UIMutableTraits ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIMutableTraits.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIMutableTraits.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_ffiVoid_idUIMutableTraits$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)> {
  void call(UIMutableTraits arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>`.
abstract final class ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)> fromFunction(void Function(UITraitEnvironment , UITraitCollection ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITraitEnvironment.fromPointer(arg0, retain: true, release: true), UITraitCollection.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)> listener(void Function(UITraitEnvironment , UITraitCollection ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITraitEnvironment.fromPointer(arg0, retain: false, release: true), UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)> blocking(void Function(UITraitEnvironment , UITraitCollection ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITraitEnvironment.fromPointer(arg0, retain: false, release: true), UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITraitEnvironment.fromPointer(arg0, retain: false, release: true), UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>`.
extension ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)> {
  void call(UITraitEnvironment arg0, UITraitCollection arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

sealed class UIFocusHeading {
  static const UIFocusHeadingNone = 0;
  static const UIFocusHeadingUp = 1;
  static const UIFocusHeadingDown = 2;
  static const UIFocusHeadingLeft = 4;
  static const UIFocusHeadingRight = 8;
  static const UIFocusHeadingNext = 16;
  static const UIFocusHeadingPrevious = 32;
  static const UIFocusHeadingFirst = 256;
  static const UIFocusHeadingLast = 512;}

sealed class UIViewLayoutRegionAdaptivityAxis {
  static const UIViewLayoutRegionAdaptivityAxisNone = 0;
  static const UIViewLayoutRegionAdaptivityAxisHorizontal = 1;
  static const UIViewLayoutRegionAdaptivityAxisVertical = 2;}

late final _class_UIAction = objc.getClass("UIAction");

/// Construction methods for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.NSString Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid$CallExtension on objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString call(ffi.Pointer<ffi.Void> arg0) =>objc.NSString.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_setTitle_ = objc.registerName("setTitle:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSString.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> listener(void Function(ffi.Pointer<ffi.Void> , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSString.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSString.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSString.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_setImage_ = objc.registerName("setImage:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIImage {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)> fromFunction(void Function(ffi.Pointer<ffi.Void> , UIImage? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIImage.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)> listener(void Function(ffi.Pointer<ffi.Void> , UIImage? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIImage.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)> blocking(void Function(ffi.Pointer<ffi.Void> , UIImage? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIImage.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, arg1.address == 0 ? null : UIImage.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIImage$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIImage? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_discoverabilityTitle = objc.registerName("discoverabilityTitle");
late final _sel_setDiscoverabilityTitle_ = objc.registerName("setDiscoverabilityTitle:");
late final _sel_attributes = objc.registerName("attributes");
final _objc_msgSend_kzdfm1 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIMenuElementAttributes_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunction(int Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static int _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<int Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline , 0).cast();
  static int _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline , 0).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIMenuElementAttributes_ffiVoid$CallExtension on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_setAttributes_ = objc.registerName("setAttributes:");
final _objc_msgSend_18kcki9 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> fromFunction(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> listener(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1lmpkp(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> blocking(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1lmpkp(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, int arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , int )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.UnsignedLong )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> {
  void call(ffi.Pointer<ffi.Void> arg0, int arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , int )>()(
    ref.pointer, arg0, arg1);
}

late final _sel_state = objc.registerName("state");
final _objc_msgSend_13oxpc5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIMenuElementState_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(int Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static int _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<int Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline , 0).cast();
  static int _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline , 0).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIMenuElementState_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_setState_ = objc.registerName("setState:");
final _objc_msgSend_1qgnjih = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> fromFunction(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> listener(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1mm4s9d(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> blocking(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1mm4s9d(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Long )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Long )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, int arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Long )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Long )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Long )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Long )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , int )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Long )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Long )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, int arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , int )>()(
    ref.pointer, arg0, arg1);
}

late final _sel_sender = objc.registerName("sender");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.ObjCObject? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid$1$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObject? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_actionWithHandler_ = objc.registerName("actionWithHandler:");
final _objc_msgSend_nnxkei = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_actionWithTitle_image_identifier_handler_ = objc.registerName("actionWithTitle:image:identifier:handler:");
final _objc_msgSend_bpwlds = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_selectedImage = objc.registerName("selectedImage");
late final _sel_setSelectedImage_ = objc.registerName("setSelectedImage:");
late final _sel_repeatBehavior = objc.registerName("repeatBehavior");
final _objc_msgSend_16il6gh = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIMenuElementRepeatBehavior_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(int Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static int _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<int Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline , 0).cast();
  static int _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline , 0).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIMenuElementRepeatBehavior_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_setRepeatBehavior_ = objc.registerName("setRepeatBehavior:");
final _objc_msgSend_bhswox = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIMenuElementRepeatBehavior {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> fromFunction(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> listener(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1wqrf61(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> blocking(void Function(ffi.Pointer<ffi.Void> , int ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1wqrf61(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Long )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Long )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, int arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Long )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Long )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Long )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Long )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , int )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Long )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, int arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , int ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Long )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIMenuElementRepeatBehavior$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, int arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , int )>()(
    ref.pointer, arg0, arg1);
}

late final _sel_presentationSourceItem = objc.registerName("presentationSourceItem");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> fromFunction(UIPopoverPresentationControllerSourceItem$1? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)> {
  UIPopoverPresentationControllerSourceItem$1? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : UIPopoverPresentationControllerSourceItem$1.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

late final _sel_performWithSender_target_ = objc.registerName("performWithSender:target:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl_objcObjCObjectImpl {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: true, release: true), arg2.address == 0 ? null : objc.ObjCObject(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)> listener(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true), arg2.address == 0 ? null : objc.ObjCObject(arg2, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? , objc.ObjCObject? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true), arg2.address == 0 ? null : objc.ObjCObject(arg2, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true), arg2.address == 0 ? null : objc.ObjCObject(arg2, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl_objcObjCObjectImpl$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject? arg1, objc.ObjCObject? arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr, arg2?.ref.pointer ?? ffi.nullptr);
}

late final _sel_captureTextFromCameraActionForResponder_identifier_ = objc.registerName("captureTextFromCameraActionForResponder:identifier:");

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting$1 on UIAction {

}


/// UIAction
extension type UIAction._(objc.ObjCObject object$) implements objc.ObjCObject,UIMenuElement,UIMenuLeaf {
  /// Constructs a [UIAction] that points to the same underlying object as [other].
  UIAction.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIAction', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIAction] that wraps the given raw object pointer.
  UIAction.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAction', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIAction].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIAction);

  /// actionWithHandler:
  static UIAction actionWithHandler(objc.ObjCBlock<ffi.Void Function(UIAction)> handler) {
  objc.checkOsVersionInternal('UIAction.actionWithHandler:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_nnxkei(_class_UIAction, _sel_actionWithHandler_, handler.ref.pointer);
    return UIAction.fromPointer($ret, retain: true, release: true);
  }


  /// actionWithTitle:image:identifier:handler:
  static UIAction actionWithTitle(objc.NSString title, {UIImage? image,objc.NSString? identifier,required objc.ObjCBlock<ffi.Void Function(UIAction)> handler}) {
    final $ret = _objc_msgSend_bpwlds(_class_UIAction, _sel_actionWithTitle_image_identifier_handler_, title.ref.pointer, image?.ref.pointer ?? ffi.nullptr, identifier?.ref.pointer ?? ffi.nullptr, handler.ref.pointer);
    return UIAction.fromPointer($ret, retain: true, release: true);
  }


  /// alloc
  static UIAction alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIAction, _sel_alloc);
    return UIAction.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIAction allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIAction, _sel_allocWithZone_, zone);
    return UIAction.fromPointer($ret, retain: false, release: true);
  }


  /// captureTextFromCameraActionForResponder:identifier:
  static UIAction captureTextFromCameraActionForResponder(UIResponder responder, {objc.NSString? identifier}) {
  objc.checkOsVersionInternal('UIAction.captureTextFromCameraActionForResponder:identifier:', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIAction, _sel_captureTextFromCameraActionForResponder_identifier_, responder.ref.pointer, identifier?.ref.pointer ?? ffi.nullptr);
    return UIAction.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static UIAction new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIAction, _sel_new);
    return UIAction.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIAction, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of UIAction constructed with the default `new` method.
  UIAction() : this.as(new$().object$);

}

extension UIAction$Methods on UIAction {

  /// attributes
  int get attributes {
  objc.checkOsVersionInternal('UIAction.attributes', iOS: (false, (16, 0, 0)));
    return _objc_msgSend_kzdfm1(object$.ref.pointer, _sel_attributes);

  }


  /// discoverabilityTitle
  objc.NSString? get discoverabilityTitle {
  objc.checkOsVersionInternal('UIAction.discoverabilityTitle', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_discoverabilityTitle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// identifier
  objc.NSString get identifier {
  objc.checkOsVersionInternal('UIAction.identifier', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// image
  UIImage? get image {
  objc.checkOsVersionInternal('UIAction.image', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_image);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// init
  UIAction init() {
  objc.checkOsVersionInternal('UIAction.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIAction.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UIAction? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIAction.fromPointer($ret, retain: false, release: true);
  }


  /// performWithSender:target:
  void performWithSender(objc.ObjCObject? sender, {objc.ObjCObject? target}) {
  objc.checkOsVersionInternal('UIAction.performWithSender:target:', iOS: (false, (16, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_performWithSender_target_, sender?.ref.pointer ?? ffi.nullptr, target?.ref.pointer ?? ffi.nullptr);

  }


  /// presentationSourceItem
  UIPopoverPresentationControllerSourceItem$1? get presentationSourceItem {
  objc.checkOsVersionInternal('UIAction.presentationSourceItem', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_presentationSourceItem);
    return $ret.address == 0 ? null : UIPopoverPresentationControllerSourceItem$1.fromPointer($ret, retain: true, release: true);
  }


  /// repeatBehavior
  int get repeatBehavior {
  objc.checkOsVersionInternal('UIAction.repeatBehavior', iOS: (false, (16, 0, 0)));
    return _objc_msgSend_16il6gh(object$.ref.pointer, _sel_repeatBehavior);

  }


  /// selectedImage
  UIImage? get selectedImage {
  objc.checkOsVersionInternal('UIAction.selectedImage', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_selectedImage);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// sender
  objc.ObjCObject? get sender {
  objc.checkOsVersionInternal('UIAction.sender', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sender);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// setAttributes:
  set attributes(int value) {
  objc.checkOsVersionInternal('UIAction.setAttributes:', iOS: (false, (16, 0, 0)));
_objc_msgSend_18kcki9(object$.ref.pointer, _sel_setAttributes_, value);

  }


  /// setDiscoverabilityTitle:
  set discoverabilityTitle(objc.NSString? value) {
  objc.checkOsVersionInternal('UIAction.setDiscoverabilityTitle:', iOS: (false, (16, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setDiscoverabilityTitle_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setImage:
  set image$1(UIImage? value) {
  objc.checkOsVersionInternal('UIAction.setImage:', iOS: (false, (16, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setRepeatBehavior:
  set repeatBehavior(int value) {
  objc.checkOsVersionInternal('UIAction.setRepeatBehavior:', iOS: (false, (16, 0, 0)));
_objc_msgSend_bhswox(object$.ref.pointer, _sel_setRepeatBehavior_, value);

  }


  /// setSelectedImage:
  set selectedImage(UIImage? value) {
  objc.checkOsVersionInternal('UIAction.setSelectedImage:', iOS: (false, (17, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSelectedImage_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setState:
  set state(int value) {
  objc.checkOsVersionInternal('UIAction.setState:', iOS: (false, (16, 0, 0)));
_objc_msgSend_1qgnjih(object$.ref.pointer, _sel_setState_, value);

  }


  /// setTitle:
  set title$1(objc.NSString value) {
  objc.checkOsVersionInternal('UIAction.setTitle:', iOS: (false, (16, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTitle_, value.ref.pointer);

  }


  /// state
  int get state {
  objc.checkOsVersionInternal('UIAction.state', iOS: (false, (16, 0, 0)));
    return _objc_msgSend_13oxpc5(object$.ref.pointer, _sel_state);

  }


  /// title
  objc.NSString get title {
  objc.checkOsVersionInternal('UIAction.title', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIAction)>`.
abstract final class ObjCBlock_ffiVoid_UIAction {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(UIAction)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(UIAction)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> fromFunction(void Function(UIAction ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UIAction)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIAction.fromPointer(arg0, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> listener(void Function(UIAction ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIAction.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAction)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> blocking(void Function(UIAction ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIAction.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIAction.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAction)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIAction)>`.
extension ObjCBlock_ffiVoid_UIAction$CallExtension on objc.ObjCBlock<ffi.Void Function(UIAction)> {
  void call(UIAction arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer);
}

sealed class UIContextMenuConfigurationElementOrder {
  static const UIContextMenuConfigurationElementOrderAutomatic = 0;
  static const UIContextMenuConfigurationElementOrderPriority = 1;
  static const UIContextMenuConfigurationElementOrderFixed = 2;}


/// Construction methods for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
abstract final class ObjCBlock_UIMenu_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunction(UIMenu? Function(objc.NSArray ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(objc.NSArray.fromPointer(arg0, retain: true, release: true))?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
extension ObjCBlock_UIMenu_NSArray$CallExtension on objc.ObjCBlock<UIMenu? Function(objc.NSArray)> {
  UIMenu? call(objc.NSArray arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer).address == 0 ? null : UIMenu.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer), retain: true, release: true);
}


/// WARNING: UIViewController is a stub. To generate bindings for this class, include
/// UIViewController in your config's objc-interfaces list.
///
/// UIViewController
extension type UIViewController._(objc.ObjCObject object$) implements objc.ObjCObject,UIResponder,objc.NSCoding,UIAppearanceContainer,UITraitEnvironment,UIContentContainer,UIFocusEnvironment {
  /// Constructs a [UIViewController] that points to the same underlying object as [other].
  UIViewController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIViewController', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIViewController] that wraps the given raw object pointer.
  UIViewController.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewController', iOS: (false, (2, 0, 0)));
  }


}


/// Construction methods for `objc.ObjCBlock<UIViewController? Function()>`.
abstract final class ObjCBlock_UIViewController {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIViewController? Function()> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIViewController? Function()>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIViewController? Function()> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function()>> ptr) =>
      objc.ObjCBlock<UIViewController? Function()>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIViewController? Function()> fromFunction(UIViewController? Function() fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIViewController? Function()>(objc.newClosureBlock(_closureCallable, () => fn()?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function()>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function())();
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIViewController? Function()>`.
extension ObjCBlock_UIViewController$CallExtension on objc.ObjCBlock<UIViewController? Function()> {
  UIViewController? call() =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>()(
    ref.pointer, ).address == 0 ? null : UIViewController.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>()(
    ref.pointer, ), retain: true, release: true);
}

sealed class UIContextMenuInteractionCommitStyle {
  static const UIContextMenuInteractionCommitStyleDismiss = 0;
  static const UIContextMenuInteractionCommitStylePop = 1;}

sealed class UIContextMenuInteractionAppearance {
  static const UIContextMenuInteractionAppearanceUnknown = 0;
  static const UIContextMenuInteractionAppearanceRich = 1;
  static const UIContextMenuInteractionAppearanceCompact = 2;}

sealed class UIControlEvents {
  static const UIControlEventTouchDown = 1;
  static const UIControlEventTouchDownRepeat = 2;
  static const UIControlEventTouchDragInside = 4;
  static const UIControlEventTouchDragOutside = 8;
  static const UIControlEventTouchDragEnter = 16;
  static const UIControlEventTouchDragExit = 32;
  static const UIControlEventTouchUpInside = 64;
  static const UIControlEventTouchUpOutside = 128;
  static const UIControlEventTouchCancel = 256;
  static const UIControlEventValueChanged = 4096;
  static const UIControlEventPrimaryActionTriggered = 8192;
  static const UIControlEventMenuActionTriggered = 16384;
  static const UIControlEventEditingDidBegin = 65536;
  static const UIControlEventEditingChanged = 131072;
  static const UIControlEventEditingDidEnd = 262144;
  static const UIControlEventEditingDidEndOnExit = 524288;
  static const UIControlEventAllTouchEvents = 4095;
  static const UIControlEventAllEditingEvents = 983040;
  static const UIControlEventApplicationReserved = 251658240;
  static const UIControlEventSystemReserved = 4026531840;
  static const UIControlEventAllEvents = 4294967295;}

sealed class UIControlContentVerticalAlignment {
  static const UIControlContentVerticalAlignmentCenter = 0;
  static const UIControlContentVerticalAlignmentTop = 1;
  static const UIControlContentVerticalAlignmentBottom = 2;
  static const UIControlContentVerticalAlignmentFill = 3;}

sealed class UIControlContentHorizontalAlignment {
  static const UIControlContentHorizontalAlignmentCenter = 0;
  static const UIControlContentHorizontalAlignmentLeft = 1;
  static const UIControlContentHorizontalAlignmentRight = 2;
  static const UIControlContentHorizontalAlignmentFill = 3;
  static const UIControlContentHorizontalAlignmentLeading = 4;
  static const UIControlContentHorizontalAlignmentTrailing = 5;}

sealed class UIControlState {
  static const UIControlStateNormal = 0;
  static const UIControlStateHighlighted = 1;
  static const UIControlStateDisabled = 2;
  static const UIControlStateSelected = 4;
  static const UIControlStateFocused = 8;
  static const UIControlStateApplication = 16711680;
  static const UIControlStateReserved = 4278190080;}


/// WARNING: UIControl is a stub. To generate bindings for this class, include
/// UIControl in your config's objc-interfaces list.
///
/// UIControl
extension type UIControl._(objc.ObjCObject object$) implements objc.ObjCObject,UIView {
  /// Constructs a [UIControl] that points to the same underlying object as [other].
  UIControl.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIControl', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIControl] that wraps the given raw object pointer.
  UIControl.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIControl', iOS: (false, (2, 0, 0)));
  }


}

sealed class UIScrollViewIndicatorStyle {
  static const UIScrollViewIndicatorStyleDefault = 0;
  static const UIScrollViewIndicatorStyleBlack = 1;
  static const UIScrollViewIndicatorStyleWhite = 2;}

sealed class UIScrollViewKeyboardDismissMode {
  static const UIScrollViewKeyboardDismissModeNone = 0;
  static const UIScrollViewKeyboardDismissModeOnDrag = 1;
  static const UIScrollViewKeyboardDismissModeInteractive = 2;
  static const UIScrollViewKeyboardDismissModeOnDragWithAccessory = 3;
  static const UIScrollViewKeyboardDismissModeInteractiveWithAccessory = 4;}

sealed class UIScrollViewIndexDisplayMode {
  static const UIScrollViewIndexDisplayModeAutomatic = 0;
  static const UIScrollViewIndexDisplayModeAlwaysHidden = 1;}

sealed class UIScrollViewContentInsetAdjustmentBehavior {
  static const UIScrollViewContentInsetAdjustmentAutomatic = 0;
  static const UIScrollViewContentInsetAdjustmentScrollableAxes = 1;
  static const UIScrollViewContentInsetAdjustmentNever = 2;
  static const UIScrollViewContentInsetAdjustmentAlways = 3;}

sealed class UITextAutocapitalizationType {
  static const UITextAutocapitalizationTypeNone = 0;
  static const UITextAutocapitalizationTypeWords = 1;
  static const UITextAutocapitalizationTypeSentences = 2;
  static const UITextAutocapitalizationTypeAllCharacters = 3;}

sealed class UITextAutocorrectionType {
  static const UITextAutocorrectionTypeDefault = 0;
  static const UITextAutocorrectionTypeNo = 1;
  static const UITextAutocorrectionTypeYes = 2;}

sealed class UITextSpellCheckingType {
  static const UITextSpellCheckingTypeDefault = 0;
  static const UITextSpellCheckingTypeNo = 1;
  static const UITextSpellCheckingTypeYes = 2;}

sealed class UITextSmartQuotesType {
  static const UITextSmartQuotesTypeDefault = 0;
  static const UITextSmartQuotesTypeNo = 1;
  static const UITextSmartQuotesTypeYes = 2;}

sealed class UITextSmartDashesType {
  static const UITextSmartDashesTypeDefault = 0;
  static const UITextSmartDashesTypeNo = 1;
  static const UITextSmartDashesTypeYes = 2;}

sealed class UITextSmartInsertDeleteType {
  static const UITextSmartInsertDeleteTypeDefault = 0;
  static const UITextSmartInsertDeleteTypeNo = 1;
  static const UITextSmartInsertDeleteTypeYes = 2;}

sealed class UITextInlinePredictionType {
  static const UITextInlinePredictionTypeDefault = 0;
  static const UITextInlinePredictionTypeNo = 1;
  static const UITextInlinePredictionTypeYes = 2;}

sealed class UITextMathExpressionCompletionType {
  static const UITextMathExpressionCompletionTypeDefault = 0;
  static const UITextMathExpressionCompletionTypeNo = 1;
  static const UITextMathExpressionCompletionTypeYes = 2;}

sealed class UIKeyboardType {
  static const UIKeyboardTypeDefault = 0;
  static const UIKeyboardTypeASCIICapable = 1;
  static const UIKeyboardTypeNumbersAndPunctuation = 2;
  static const UIKeyboardTypeURL = 3;
  static const UIKeyboardTypeNumberPad = 4;
  static const UIKeyboardTypePhonePad = 5;
  static const UIKeyboardTypeNamePhonePad = 6;
  static const UIKeyboardTypeEmailAddress = 7;
  static const UIKeyboardTypeDecimalPad = 8;
  static const UIKeyboardTypeTwitter = 9;
  static const UIKeyboardTypeWebSearch = 10;
  static const UIKeyboardTypeASCIICapableNumberPad = 11;
  static const UIKeyboardTypeAlphabet = 1;}

sealed class UIKeyboardAppearance {
  static const UIKeyboardAppearanceDefault = 0;
  static const UIKeyboardAppearanceDark = 1;
  static const UIKeyboardAppearanceLight = 2;
  static const UIKeyboardAppearanceAlert = 1;}

sealed class UIReturnKeyType {
  static const UIReturnKeyDefault = 0;
  static const UIReturnKeyGo = 1;
  static const UIReturnKeyGoogle = 2;
  static const UIReturnKeyJoin = 3;
  static const UIReturnKeyNext = 4;
  static const UIReturnKeyRoute = 5;
  static const UIReturnKeySearch = 6;
  static const UIReturnKeySend = 7;
  static const UIReturnKeyYahoo = 8;
  static const UIReturnKeyDone = 9;
  static const UIReturnKeyEmergencyCall = 10;
  static const UIReturnKeyContinue = 11;}

sealed class UIWritingToolsBehavior {
  static const UIWritingToolsBehaviorNone = -1;
  static const UIWritingToolsBehaviorDefault = 0;
  static const UIWritingToolsBehaviorComplete = 1;
  static const UIWritingToolsBehaviorLimited = 2;}

sealed class UIWritingToolsResultOptions {
  static const UIWritingToolsResultDefault = 0;
  static const UIWritingToolsResultPlainText = 1;
  static const UIWritingToolsResultRichText = 2;
  static const UIWritingToolsResultList = 4;
  static const UIWritingToolsResultTable = 8;
  static const UIWritingToolsResultPresentationIntent = 16;}

sealed class UITextStorageDirection {
  static const UITextStorageDirectionForward = 0;
  static const UITextStorageDirectionBackward = 1;}

sealed class UITextLayoutDirection {
  static const UITextLayoutDirectionRight = 2;
  static const UITextLayoutDirectionLeft = 3;
  static const UITextLayoutDirectionUp = 4;
  static const UITextLayoutDirectionDown = 5;}

sealed class UITextGranularity {
  static const UITextGranularityCharacter = 0;
  static const UITextGranularityWord = 1;
  static const UITextGranularitySentence = 2;
  static const UITextGranularityParagraph = 3;
  static const UITextGranularityLine = 4;
  static const UITextGranularityDocument = 5;}

sealed class UITextAlternativeStyle {
  static const UITextAlternativeStyleNone = 0;
  static const UITextAlternativeStyleLowConfidence = 1;}


/// WARNING: UITextInputDelegate is a stub. To generate bindings for this class, include
/// UITextInputDelegate in your config's objc-protocols list.
///
/// UITextInputDelegate
extension type UITextInputDelegate._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UITextInputDelegate] that points to the same underlying object as [other].
  UITextInputDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITextInputDelegate] that wraps the given raw object pointer.
  UITextInputDelegate.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class UIBaselineAdjustment {
  static const UIBaselineAdjustmentAlignBaselines = 0;
  static const UIBaselineAdjustmentAlignCenters = 1;
  static const UIBaselineAdjustmentNone = 2;}

late final _sel_sizeWithFont_ = objc.registerName("sizeWithFont:");
late final _sel_sizeWithFont_forWidth_lineBreakMode_ = objc.registerName("sizeWithFont:forWidth:lineBreakMode:");
final _objc_msgSend_kuoegl = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Long )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , int )>();
final _objc_msgSend_kuoeglStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , int )>();
late final _sel_drawAtPoint_withFont_ = objc.registerName("drawAtPoint:withFont:");
final _objc_msgSend_17ogua4 = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_17ogua4Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_drawAtPoint_forWidth_withFont_lineBreakMode_ = objc.registerName("drawAtPoint:forWidth:withFont:lineBreakMode:");
final _objc_msgSend_vv6w34 = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Long )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , double , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
final _objc_msgSend_vv6w34Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , double , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
late final _sel_sizeWithFont_constrainedToSize_ = objc.registerName("sizeWithFont:constrainedToSize:");
final _objc_msgSend_xq5db9 = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.CGSize )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.CGSize )>();
final _objc_msgSend_xq5db9Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.CGSize )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.CGSize )>();
late final _sel_sizeWithFont_constrainedToSize_lineBreakMode_ = objc.registerName("sizeWithFont:constrainedToSize:lineBreakMode:");
final _objc_msgSend_ryab2 = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.CGSize , ffi.Long )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.CGSize , int )>();
final _objc_msgSend_ryab2Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.CGSize , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.CGSize , int )>();
late final _sel_drawInRect_withFont_ = objc.registerName("drawInRect:withFont:");
final _objc_msgSend_1cqcuuc = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_1cqcuucStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_drawInRect_withFont_lineBreakMode_ = objc.registerName("drawInRect:withFont:lineBreakMode:");
final _objc_msgSend_7bdf8d = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Long )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
final _objc_msgSend_7bdf8dStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
late final _sel_drawInRect_withFont_lineBreakMode_alignment_ = objc.registerName("drawInRect:withFont:lineBreakMode:alignment:");
final _objc_msgSend_1p7713g = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Long , ffi.Long )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , int , int )>();
final _objc_msgSend_1p7713gStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Long , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , int , int )>();
late final _sel_sizeWithFont_minFontSize_actualFontSize_forWidth_lineBreakMode_ = objc.registerName("sizeWithFont:minFontSize:actualFontSize:forWidth:lineBreakMode:");
final _objc_msgSend_15ap4e3 = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<ffi.Double> , ffi.Double , ffi.Long )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<ffi.Double> , double , int )>();
final _objc_msgSend_15ap4e3Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<ffi.Double> , ffi.Double , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<ffi.Double> , double , int )>();
late final _sel_drawAtPoint_forWidth_withFont_fontSize_lineBreakMode_baselineAdjustment_ = objc.registerName("drawAtPoint:forWidth:withFont:fontSize:lineBreakMode:baselineAdjustment:");
final _objc_msgSend_rzrv5j = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Long , ffi.Long )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , double , ffi.Pointer<objc.ObjCObjectImpl> , double , int , int )>();
final _objc_msgSend_rzrv5jStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Long , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , double , ffi.Pointer<objc.ObjCObjectImpl> , double , int , int )>();
late final _sel_drawAtPoint_forWidth_withFont_minFontSize_actualFontSize_lineBreakMode_baselineAdjustment_ = objc.registerName("drawAtPoint:forWidth:withFont:minFontSize:actualFontSize:lineBreakMode:baselineAdjustment:");
final _objc_msgSend_1hcmz6k = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<ffi.Double> , ffi.Long , ffi.Long )>>().asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , double , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<ffi.Double> , int , int )>();
final _objc_msgSend_1hcmz6kStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<ffi.Double> , ffi.Long , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.CGSize> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , double , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<ffi.Double> , int , int )>();

/// UIStringDrawing
extension UIStringDrawing on objc.NSString {

  /// drawAtPoint:forWidth:withFont:fontSize:lineBreakMode:baselineAdjustment:
  objc.CGSize drawAtPoint(objc.CGPoint point, {required double forWidth,required UIFont withFont,required double fontSize,required int lineBreakMode,required int baselineAdjustment}) {
  objc.checkOsVersionInternal('NSString.drawAtPoint:forWidth:withFont:fontSize:lineBreakMode:baselineAdjustment:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_rzrv5jStret($ptr, object$.ref.pointer, _sel_drawAtPoint_forWidth_withFont_fontSize_lineBreakMode_baselineAdjustment_, point, forWidth, withFont.ref.pointer, fontSize, lineBreakMode, baselineAdjustment) : $ptr.ref = _objc_msgSend_rzrv5j(object$.ref.pointer, _sel_drawAtPoint_forWidth_withFont_fontSize_lineBreakMode_baselineAdjustment_, point, forWidth, withFont.ref.pointer, fontSize, lineBreakMode, baselineAdjustment);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// drawAtPoint:forWidth:withFont:lineBreakMode:
  objc.CGSize drawAtPoint$1(objc.CGPoint point, {required double forWidth,required UIFont withFont,required int lineBreakMode}) {
  objc.checkOsVersionInternal('NSString.drawAtPoint:forWidth:withFont:lineBreakMode:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_vv6w34Stret($ptr, object$.ref.pointer, _sel_drawAtPoint_forWidth_withFont_lineBreakMode_, point, forWidth, withFont.ref.pointer, lineBreakMode) : $ptr.ref = _objc_msgSend_vv6w34(object$.ref.pointer, _sel_drawAtPoint_forWidth_withFont_lineBreakMode_, point, forWidth, withFont.ref.pointer, lineBreakMode);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// drawAtPoint:forWidth:withFont:minFontSize:actualFontSize:lineBreakMode:baselineAdjustment:
  objc.CGSize drawAtPoint$2(objc.CGPoint point, {required double forWidth,required UIFont withFont,required double minFontSize,required ffi.Pointer<ffi.Double> actualFontSize,required int lineBreakMode,required int baselineAdjustment}) {
  objc.checkOsVersionInternal('NSString.drawAtPoint:forWidth:withFont:minFontSize:actualFontSize:lineBreakMode:baselineAdjustment:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1hcmz6kStret($ptr, object$.ref.pointer, _sel_drawAtPoint_forWidth_withFont_minFontSize_actualFontSize_lineBreakMode_baselineAdjustment_, point, forWidth, withFont.ref.pointer, minFontSize, actualFontSize, lineBreakMode, baselineAdjustment) : $ptr.ref = _objc_msgSend_1hcmz6k(object$.ref.pointer, _sel_drawAtPoint_forWidth_withFont_minFontSize_actualFontSize_lineBreakMode_baselineAdjustment_, point, forWidth, withFont.ref.pointer, minFontSize, actualFontSize, lineBreakMode, baselineAdjustment);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// drawAtPoint:withFont:
  objc.CGSize drawAtPoint$3(objc.CGPoint point, {required UIFont withFont}) {
  objc.checkOsVersionInternal('NSString.drawAtPoint:withFont:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_17ogua4Stret($ptr, object$.ref.pointer, _sel_drawAtPoint_withFont_, point, withFont.ref.pointer) : $ptr.ref = _objc_msgSend_17ogua4(object$.ref.pointer, _sel_drawAtPoint_withFont_, point, withFont.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// drawInRect:withFont:
  objc.CGSize drawInRect(objc.CGRect rect, {required UIFont withFont}) {
  objc.checkOsVersionInternal('NSString.drawInRect:withFont:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1cqcuucStret($ptr, object$.ref.pointer, _sel_drawInRect_withFont_, rect, withFont.ref.pointer) : $ptr.ref = _objc_msgSend_1cqcuuc(object$.ref.pointer, _sel_drawInRect_withFont_, rect, withFont.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// drawInRect:withFont:lineBreakMode:
  objc.CGSize drawInRect$1(objc.CGRect rect, {required UIFont withFont,required int lineBreakMode}) {
  objc.checkOsVersionInternal('NSString.drawInRect:withFont:lineBreakMode:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_7bdf8dStret($ptr, object$.ref.pointer, _sel_drawInRect_withFont_lineBreakMode_, rect, withFont.ref.pointer, lineBreakMode) : $ptr.ref = _objc_msgSend_7bdf8d(object$.ref.pointer, _sel_drawInRect_withFont_lineBreakMode_, rect, withFont.ref.pointer, lineBreakMode);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// drawInRect:withFont:lineBreakMode:alignment:
  objc.CGSize drawInRect$2(objc.CGRect rect, {required UIFont withFont,required int lineBreakMode,required int alignment}) {
  objc.checkOsVersionInternal('NSString.drawInRect:withFont:lineBreakMode:alignment:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_1p7713gStret($ptr, object$.ref.pointer, _sel_drawInRect_withFont_lineBreakMode_alignment_, rect, withFont.ref.pointer, lineBreakMode, alignment) : $ptr.ref = _objc_msgSend_1p7713g(object$.ref.pointer, _sel_drawInRect_withFont_lineBreakMode_alignment_, rect, withFont.ref.pointer, lineBreakMode, alignment);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// sizeWithFont:
  objc.CGSize sizeWithFont(UIFont font) {
  objc.checkOsVersionInternal('NSString.sizeWithFont:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_18r320vStret($ptr, object$.ref.pointer, _sel_sizeWithFont_, font.ref.pointer) : $ptr.ref = _objc_msgSend_18r320v(object$.ref.pointer, _sel_sizeWithFont_, font.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// sizeWithFont:constrainedToSize:
  objc.CGSize sizeWithFont$1(UIFont font, {required objc.CGSize constrainedToSize}) {
  objc.checkOsVersionInternal('NSString.sizeWithFont:constrainedToSize:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_xq5db9Stret($ptr, object$.ref.pointer, _sel_sizeWithFont_constrainedToSize_, font.ref.pointer, constrainedToSize) : $ptr.ref = _objc_msgSend_xq5db9(object$.ref.pointer, _sel_sizeWithFont_constrainedToSize_, font.ref.pointer, constrainedToSize);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// sizeWithFont:constrainedToSize:lineBreakMode:
  objc.CGSize sizeWithFont$2(UIFont font, {required objc.CGSize constrainedToSize,required int lineBreakMode}) {
  objc.checkOsVersionInternal('NSString.sizeWithFont:constrainedToSize:lineBreakMode:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_ryab2Stret($ptr, object$.ref.pointer, _sel_sizeWithFont_constrainedToSize_lineBreakMode_, font.ref.pointer, constrainedToSize, lineBreakMode) : $ptr.ref = _objc_msgSend_ryab2(object$.ref.pointer, _sel_sizeWithFont_constrainedToSize_lineBreakMode_, font.ref.pointer, constrainedToSize, lineBreakMode);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// sizeWithFont:forWidth:lineBreakMode:
  objc.CGSize sizeWithFont$3(UIFont font, {required double forWidth,required int lineBreakMode}) {
  objc.checkOsVersionInternal('NSString.sizeWithFont:forWidth:lineBreakMode:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_kuoeglStret($ptr, object$.ref.pointer, _sel_sizeWithFont_forWidth_lineBreakMode_, font.ref.pointer, forWidth, lineBreakMode) : $ptr.ref = _objc_msgSend_kuoegl(object$.ref.pointer, _sel_sizeWithFont_forWidth_lineBreakMode_, font.ref.pointer, forWidth, lineBreakMode);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }


  /// sizeWithFont:minFontSize:actualFontSize:forWidth:lineBreakMode:
  objc.CGSize sizeWithFont$4(UIFont font, {required double minFontSize,required ffi.Pointer<ffi.Double> actualFontSize,required double forWidth,required int lineBreakMode}) {
  objc.checkOsVersionInternal('NSString.sizeWithFont:minFontSize:actualFontSize:forWidth:lineBreakMode:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants ? _objc_msgSend_15ap4e3Stret($ptr, object$.ref.pointer, _sel_sizeWithFont_minFontSize_actualFontSize_forWidth_lineBreakMode_, font.ref.pointer, minFontSize, actualFontSize, forWidth, lineBreakMode) : $ptr.ref = _objc_msgSend_15ap4e3(object$.ref.pointer, _sel_sizeWithFont_minFontSize_actualFontSize_forWidth_lineBreakMode_, font.ref.pointer, minFontSize, actualFontSize, forWidth, lineBreakMode);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGSize>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGSize>(
        $finalizable);

  }

}

sealed class UIDropOperation {
  static const UIDropOperationCancel = 0;
  static const UIDropOperationForbidden = 1;
  static const UIDropOperationCopy = 2;
  static const UIDropOperationMove = 3;}

sealed class UIViewAnimatingState {
  static const UIViewAnimatingStateInactive = 0;
  static const UIViewAnimatingStateActive = 1;
  static const UIViewAnimatingStateStopped = 2;}

sealed class UIViewAnimatingPosition {
  static const UIViewAnimatingPositionEnd = 0;
  static const UIViewAnimatingPositionStart = 1;
  static const UIViewAnimatingPositionCurrent = 2;}

sealed class UITextDragOptions {
  static const UITextDragOptionsNone = 0;
  static const UITextDragOptionStripTextColorFromPreviews = 1;}

sealed class UITextDropAction {
  static const UITextDropActionInsert = 0;
  static const UITextDropActionReplaceSelection = 1;
  static const UITextDropActionReplaceAll = 2;}

sealed class UITextDropProgressMode {
  static const UITextDropProgressModeSystem = 0;
  static const UITextDropProgressModeCustom = 1;}

sealed class UITextDropPerformer {
  static const UITextDropPerformerView = 0;
  static const UITextDropPerformerDelegate = 1;}

sealed class UITextDropEditability {
  static const UITextDropEditabilityNo = 0;
  static const UITextDropEditabilityTemporary = 1;
  static const UITextDropEditabilityYes = 2;}


/// WARNING: UIContentSizeCategoryAdjusting is a stub. To generate bindings for this class, include
/// UIContentSizeCategoryAdjusting in your config's objc-protocols list.
///
/// UIContentSizeCategoryAdjusting
extension type UIContentSizeCategoryAdjusting._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIContentSizeCategoryAdjusting] that points to the same underlying object as [other].
  UIContentSizeCategoryAdjusting.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIContentSizeCategoryAdjusting] that wraps the given raw object pointer.
  UIContentSizeCategoryAdjusting.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class UILetterformAwareSizingRule {
  static const UILetterformAwareSizingRuleTypographic = 0;
  static const UILetterformAwareSizingRuleOversize = 1;}


/// WARNING: UILetterformAwareAdjusting is a stub. To generate bindings for this class, include
/// UILetterformAwareAdjusting in your config's objc-protocols list.
///
/// UILetterformAwareAdjusting
extension type UILetterformAwareAdjusting._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UILetterformAwareAdjusting] that points to the same underlying object as [other].
  UILetterformAwareAdjusting.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UILetterformAwareAdjusting] that wraps the given raw object pointer.
  UILetterformAwareAdjusting.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class UITextBorderStyle {
  static const UITextBorderStyleNone = 0;
  static const UITextBorderStyleLine = 1;
  static const UITextBorderStyleBezel = 2;
  static const UITextBorderStyleRoundedRect = 3;}

sealed class UITextFieldViewMode {
  static const UITextFieldViewModeNever = 0;
  static const UITextFieldViewModeWhileEditing = 1;
  static const UITextFieldViewModeUnlessEditing = 2;
  static const UITextFieldViewModeAlways = 3;}

sealed class UITextFieldDidEndEditingReason {
  static const UITextFieldDidEndEditingReasonCommitted = 0;
  static const UITextFieldDidEndEditingReasonCancelled = 1;}

sealed class UIStatusBarStyle {
  static const UIStatusBarStyleDefault = 0;
  static const UIStatusBarStyleLightContent = 1;
  static const UIStatusBarStyleDarkContent = 3;
  static const UIStatusBarStyleBlackTranslucent = 1;
  static const UIStatusBarStyleBlackOpaque = 2;}

sealed class UIStatusBarAnimation {
  static const UIStatusBarAnimationNone = 0;
  static const UIStatusBarAnimationFade = 1;
  static const UIStatusBarAnimationSlide = 2;}

sealed class UIModalTransitionStyle {
  static const UIModalTransitionStyleCoverVertical = 0;
  static const UIModalTransitionStyleFlipHorizontal = 1;
  static const UIModalTransitionStyleCrossDissolve = 2;
  static const UIModalTransitionStylePartialCurl = 3;}

sealed class UIModalPresentationStyle {
  static const UIModalPresentationFullScreen = 0;
  static const UIModalPresentationPageSheet = 1;
  static const UIModalPresentationFormSheet = 2;
  static const UIModalPresentationCurrentContext = 3;
  static const UIModalPresentationCustom = 4;
  static const UIModalPresentationOverFullScreen = 5;
  static const UIModalPresentationOverCurrentContext = 6;
  static const UIModalPresentationPopover = 7;
  static const UIModalPresentationBlurOverFullScreen = 8;
  static const UIModalPresentationNone = -1;
  static const UIModalPresentationAutomatic = -2;}


/// WARNING: UIContentContainer is a stub. To generate bindings for this class, include
/// UIContentContainer in your config's objc-protocols list.
///
/// UIContentContainer
extension type UIContentContainer._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIContentContainer] that points to the same underlying object as [other].
  UIContentContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIContentContainer] that wraps the given raw object pointer.
  UIContentContainer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class UIContainerBackgroundStyle {
  static const UIContainerBackgroundStyleAutomatic = 0;
  static const UIContainerBackgroundStyleGlass = 1;
  static const UIContainerBackgroundStyleHidden = 2;}


/// WARNING: UISymbolEffectCompletionContext is a stub. To generate bindings for this class, include
/// UISymbolEffectCompletionContext in your config's objc-interfaces list.
///
/// UISymbolEffectCompletionContext
extension type UISymbolEffectCompletionContext._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UISymbolEffectCompletionContext] that points to the same underlying object as [other].
  UISymbolEffectCompletionContext.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UISymbolEffectCompletionContext', iOS: (false, (17, 0, 0)));
  }

  /// Constructs a [UISymbolEffectCompletionContext] that wraps the given raw object pointer.
  UISymbolEffectCompletionContext.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UISymbolEffectCompletionContext', iOS: (false, (17, 0, 0)));
  }


}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>`.
abstract final class ObjCBlock_ffiVoid_UISymbolEffectCompletionContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)> fromFunction(void Function(UISymbolEffectCompletionContext ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UISymbolEffectCompletionContext.fromPointer(arg0, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)> listener(void Function(UISymbolEffectCompletionContext ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UISymbolEffectCompletionContext.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)> blocking(void Function(UISymbolEffectCompletionContext ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UISymbolEffectCompletionContext.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UISymbolEffectCompletionContext.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>`.
extension ObjCBlock_ffiVoid_UISymbolEffectCompletionContext$CallExtension on objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)> {
  void call(UISymbolEffectCompletionContext arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer);
}


/// WARNING: NSSymbolEffectOptions is a stub. To generate bindings for this class, include
/// NSSymbolEffectOptions in your config's objc-interfaces list.
///
/// NSSymbolEffectOptions
extension type NSSymbolEffectOptions._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [NSSymbolEffectOptions] that points to the same underlying object as [other].
  NSSymbolEffectOptions.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSSymbolEffectOptions', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }

  /// Constructs a [NSSymbolEffectOptions] that wraps the given raw object pointer.
  NSSymbolEffectOptions.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSSymbolEffectOptions', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }


}


/// WARNING: NSSymbolEffect is a stub. To generate bindings for this class, include
/// NSSymbolEffect in your config's objc-interfaces list.
///
/// NSSymbolEffect
extension type NSSymbolEffect._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [NSSymbolEffect] that points to the same underlying object as [other].
  NSSymbolEffect.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSSymbolEffect', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }

  /// Constructs a [NSSymbolEffect] that wraps the given raw object pointer.
  NSSymbolEffect.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSSymbolEffect', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }


}


/// WARNING: NSSymbolContentTransition is a stub. To generate bindings for this class, include
/// NSSymbolContentTransition in your config's objc-interfaces list.
///
/// NSSymbolContentTransition
extension type NSSymbolContentTransition._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [NSSymbolContentTransition] that points to the same underlying object as [other].
  NSSymbolContentTransition.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSSymbolContentTransition', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }

  /// Constructs a [NSSymbolContentTransition] that wraps the given raw object pointer.
  NSSymbolContentTransition.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSSymbolContentTransition', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
  }


}

late final _class_UIImageView = objc.getClass("UIImageView");
late final _sel_initWithImage_ = objc.registerName("initWithImage:");
late final _sel_initWithImage_highlightedImage_ = objc.registerName("initWithImage:highlightedImage:");
late final _sel_highlightedImage = objc.registerName("highlightedImage");
late final _sel_setHighlightedImage_ = objc.registerName("setHighlightedImage:");
late final _sel_preferredSymbolConfiguration = objc.registerName("preferredSymbolConfiguration");
late final _sel_setPreferredSymbolConfiguration_ = objc.registerName("setPreferredSymbolConfiguration:");
late final _sel_isHighlighted = objc.registerName("isHighlighted");
late final _sel_setHighlighted_ = objc.registerName("setHighlighted:");
late final _sel_animationImages = objc.registerName("animationImages");
late final _sel_setAnimationImages_ = objc.registerName("setAnimationImages:");
late final _sel_highlightedAnimationImages = objc.registerName("highlightedAnimationImages");
late final _sel_setHighlightedAnimationImages_ = objc.registerName("setHighlightedAnimationImages:");
late final _sel_animationDuration = objc.registerName("animationDuration");
late final _sel_animationRepeatCount = objc.registerName("animationRepeatCount");
late final _sel_startAnimating = objc.registerName("startAnimating");
late final _sel_stopAnimating = objc.registerName("stopAnimating");
late final _sel_isAnimating = objc.registerName("isAnimating");
late final _sel_preferredImageDynamicRange = objc.registerName("preferredImageDynamicRange");
final _objc_msgSend_xfd0s2 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setPreferredImageDynamicRange_ = objc.registerName("setPreferredImageDynamicRange:");
final _objc_msgSend_141mpu0 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_imageDynamicRange = objc.registerName("imageDynamicRange");
late final _sel_adjustsImageWhenAncestorFocused = objc.registerName("adjustsImageWhenAncestorFocused");
late final _sel_setAdjustsImageWhenAncestorFocused_ = objc.registerName("setAdjustsImageWhenAncestorFocused:");
late final _sel_focusedFrameGuide = objc.registerName("focusedFrameGuide");
late final _sel_overlayContentView = objc.registerName("overlayContentView");
late final _sel_masksFocusEffectToContents = objc.registerName("masksFocusEffectToContents");
late final _sel_setMasksFocusEffectToContents_ = objc.registerName("setMasksFocusEffectToContents:");
late final _sel_addSymbolEffect_ = objc.registerName("addSymbolEffect:");
late final _sel_addSymbolEffect_options_ = objc.registerName("addSymbolEffect:options:");
late final _sel_addSymbolEffect_options_animated_ = objc.registerName("addSymbolEffect:options:animated:");
final _objc_msgSend_1lhy15d = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , bool )>();
late final _sel_addSymbolEffect_options_animated_completion_ = objc.registerName("addSymbolEffect:options:animated:completion:");
final _objc_msgSend_1imhooq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_removeSymbolEffectOfType_ = objc.registerName("removeSymbolEffectOfType:");
late final _sel_removeSymbolEffectOfType_options_ = objc.registerName("removeSymbolEffectOfType:options:");
late final _sel_removeSymbolEffectOfType_options_animated_ = objc.registerName("removeSymbolEffectOfType:options:animated:");
late final _sel_removeSymbolEffectOfType_options_animated_completion_ = objc.registerName("removeSymbolEffectOfType:options:animated:completion:");
late final _sel_removeAllSymbolEffects = objc.registerName("removeAllSymbolEffects");
late final _sel_removeAllSymbolEffectsWithOptions_ = objc.registerName("removeAllSymbolEffectsWithOptions:");
late final _sel_removeAllSymbolEffectsWithOptions_animated_ = objc.registerName("removeAllSymbolEffectsWithOptions:animated:");
final _objc_msgSend_6p7ndb = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , bool )>();
late final _sel_setSymbolImage_withContentTransition_ = objc.registerName("setSymbolImage:withContentTransition:");
late final _sel_setSymbolImage_withContentTransition_options_ = objc.registerName("setSymbolImage:withContentTransition:options:");
late final _sel_setSymbolImage_withContentTransition_options_completion_ = objc.registerName("setSymbolImage:withContentTransition:options:completion:");
final _objc_msgSend_m7tls4 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// 
extension unnamed$1 on UIImageView {

}

late final _sel_adjustsImageSizeForAccessibilityContentSizeCategory = objc.registerName("adjustsImageSizeForAccessibilityContentSizeCategory");
late final _sel_setAdjustsImageSizeForAccessibilityContentSizeCategory_ = objc.registerName("setAdjustsImageSizeForAccessibilityContentSizeCategory:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> fromFunction(void Function(ffi.Pointer<ffi.Void> , bool ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> listener(void Function(ffi.Pointer<ffi.Void> , bool ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_10lndml(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> blocking(void Function(ffi.Pointer<ffi.Void> , bool ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_10lndml(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, bool arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , bool ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, bool arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , bool ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Bool )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Bool )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Bool )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Bool )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, bool arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , bool )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, bool arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , bool ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Bool )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_ffiVoid_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> {
  void call(ffi.Pointer<ffi.Void> arg0, bool arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , bool )>()(
    ref.pointer, arg0, arg1);
}


/// WARNING: UIAccessibilityContentSizeCategoryImageAdjusting$1 is a stub. To generate bindings for this class, include
/// UIAccessibilityContentSizeCategoryImageAdjusting in your config's objc-protocols list.
///
/// UIAccessibilityContentSizeCategoryImageAdjusting
extension type UIAccessibilityContentSizeCategoryImageAdjusting$1._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAccessibilityContentSizeCategoryImageAdjusting$1] that points to the same underlying object as [other].
  UIAccessibilityContentSizeCategoryImageAdjusting$1.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAccessibilityContentSizeCategoryImageAdjusting$1] that wraps the given raw object pointer.
  UIAccessibilityContentSizeCategoryImageAdjusting$1.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// UIAccessibilityContentSizeCategoryImageAdjusting
extension UIAccessibilityContentSizeCategoryImageAdjusting on UIImageView {

  /// adjustsImageSizeForAccessibilityContentSizeCategory
  bool get adjustsImageSizeForAccessibilityContentSizeCategory {
  objc.checkOsVersionInternal('UIImageView.adjustsImageSizeForAccessibilityContentSizeCategory', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_adjustsImageSizeForAccessibilityContentSizeCategory);

  }


  /// setAdjustsImageSizeForAccessibilityContentSizeCategory:
  set adjustsImageSizeForAccessibilityContentSizeCategory(bool value) {
  objc.checkOsVersionInternal('UIImageView.setAdjustsImageSizeForAccessibilityContentSizeCategory:', iOS: (false, (11, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAdjustsImageSizeForAccessibilityContentSizeCategory_, value);

  }

}


/// UIImageView
extension type UIImageView._(objc.ObjCObject object$) implements objc.ObjCObject,UIView {
  /// Constructs a [UIImageView] that points to the same underlying object as [other].
  UIImageView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIImageView', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIImageView] that wraps the given raw object pointer.
  UIImageView.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImageView', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIImageView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIImageView);

  /// alloc
  static UIImageView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIImageView, _sel_alloc);
    return UIImageView.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIImageView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIImageView, _sel_allocWithZone_, zone);
    return UIImageView.fromPointer($ret, retain: false, release: true);
  }


  /// appearance
  static UIImageView appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UIImageView, _sel_appearance);
    return UIImageView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:
  static UIImageView appearanceForTraitCollection(UITraitCollection trait) {
  objc.checkOsVersionInternal('UIImageView.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIImageView, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIImageView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedIn:
  static UIImageView appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
  objc.checkOsVersionInternal('UIImageView.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIImageView, _sel_appearanceForTraitCollection_whenContainedIn_, trait.ref.pointer, whenContainedIn?.ref.pointer ?? ffi.nullptr);
    return UIImageView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIImageView appearanceForTraitCollection$2(UITraitCollection trait, {required objc.NSArray whenContainedInInstancesOfClasses}) {
  objc.checkOsVersionInternal('UIImageView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIImageView, _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_, trait.ref.pointer, whenContainedInInstancesOfClasses.ref.pointer);
    return UIImageView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedIn:
  static UIImageView appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
  objc.checkOsVersionInternal('UIImageView.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIImageView, _sel_appearanceWhenContainedIn_, ContainerClass?.ref.pointer ?? ffi.nullptr);
    return UIImageView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedInInstancesOfClasses:
  static UIImageView appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
  objc.checkOsVersionInternal('UIImageView.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIImageView, _sel_appearanceWhenContainedInInstancesOfClasses_, containerTypes.ref.pointer);
    return UIImageView.fromPointer($ret, retain: true, release: true);
  }


  /// layerClass
  static objc.ObjCObject getLayerClass() {
  objc.checkOsVersionInternal('UIImageView.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIImageView, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// new
  static UIImageView new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIImageView, _sel_new);
    return UIImageView.fromPointer($ret, retain: false, release: true);
  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute(int attribute) {
  objc.checkOsVersionInternal('UIImageView.userInterfaceLayoutDirectionForSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_racczx(_class_UIImageView, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_, attribute);

  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute$1(int semanticContentAttribute, {required int relativeToLayoutDirection}) {
  objc.checkOsVersionInternal('UIImageView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_tz4p54(_class_UIImageView, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_, semanticContentAttribute, relativeToLayoutDirection);

  }
  /// Returns a new instance of UIImageView constructed with the default `new` method.
  UIImageView() : this.as(new$().object$);

}

extension UIImageView$Methods on UIImageView {

  /// addSymbolEffect:
  void addSymbolEffect(NSSymbolEffect symbolEffect) {
  objc.checkOsVersionInternal('UIImageView.addSymbolEffect:', iOS: (false, (17, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addSymbolEffect_, symbolEffect.ref.pointer);

  }


  /// addSymbolEffect:options:
  void addSymbolEffect$1(NSSymbolEffect symbolEffect, {required NSSymbolEffectOptions options}) {
  objc.checkOsVersionInternal('UIImageView.addSymbolEffect:options:', iOS: (false, (17, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_addSymbolEffect_options_, symbolEffect.ref.pointer, options.ref.pointer);

  }


  /// addSymbolEffect:options:animated:
  void addSymbolEffect$2(NSSymbolEffect symbolEffect, {required NSSymbolEffectOptions options,required bool animated}) {
  objc.checkOsVersionInternal('UIImageView.addSymbolEffect:options:animated:', iOS: (false, (17, 0, 0)));
_objc_msgSend_1lhy15d(object$.ref.pointer, _sel_addSymbolEffect_options_animated_, symbolEffect.ref.pointer, options.ref.pointer, animated);

  }


  /// addSymbolEffect:options:animated:completion:
  void addSymbolEffect$3(NSSymbolEffect symbolEffect, {required NSSymbolEffectOptions options,required bool animated,objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>? completion}) {
  objc.checkOsVersionInternal('UIImageView.addSymbolEffect:options:animated:completion:', iOS: (false, (17, 0, 0)));
_objc_msgSend_1imhooq(object$.ref.pointer, _sel_addSymbolEffect_options_animated_completion_, symbolEffect.ref.pointer, options.ref.pointer, animated, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// adjustsImageWhenAncestorFocused
  bool get adjustsImageWhenAncestorFocused {
  objc.checkOsVersionInternal('UIImageView.adjustsImageWhenAncestorFocused', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_adjustsImageWhenAncestorFocused);

  }


  /// animationDuration
  double get animationDuration {
  objc.checkOsVersionInternal('UIImageView.animationDuration', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_animationDuration) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_animationDuration);

  }


  /// animationImages
  objc.NSArray? get animationImages {
  objc.checkOsVersionInternal('UIImageView.animationImages', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_animationImages);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// animationRepeatCount
  int get animationRepeatCount {
  objc.checkOsVersionInternal('UIImageView.animationRepeatCount', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_animationRepeatCount);

  }


  /// focusedFrameGuide
  UILayoutGuide get focusedFrameGuide {
  objc.checkOsVersionInternal('UIImageView.focusedFrameGuide', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_focusedFrameGuide);
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }


  /// highlightedAnimationImages
  objc.NSArray? get highlightedAnimationImages {
  objc.checkOsVersionInternal('UIImageView.highlightedAnimationImages', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_highlightedAnimationImages);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// highlightedImage
  UIImage? get highlightedImage {
  objc.checkOsVersionInternal('UIImageView.highlightedImage', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_highlightedImage);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// image
  UIImage? get image {
  objc.checkOsVersionInternal('UIImageView.image', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_image);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// imageDynamicRange
  int get imageDynamicRange {
  objc.checkOsVersionInternal('UIImageView.imageDynamicRange', iOS: (false, (17, 0, 0)));
    return _objc_msgSend_xfd0s2(object$.ref.pointer, _sel_imageDynamicRange);

  }


  /// init
  UIImageView init() {
  objc.checkOsVersionInternal('UIImageView.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIImageView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UIImageView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIImageView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithFrame:
  UIImageView initWithFrame(objc.CGRect frame) {
  objc.checkOsVersionInternal('UIImageView.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIImageView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithImage:
  UIImageView initWithImage(UIImage? image) {
  objc.checkOsVersionInternal('UIImageView.initWithImage:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithImage_, image?.ref.pointer ?? ffi.nullptr);
    return UIImageView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithImage:highlightedImage:
  UIImageView initWithImage$1(UIImage? image, {UIImage? highlightedImage}) {
  objc.checkOsVersionInternal('UIImageView.initWithImage:highlightedImage:', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithImage_highlightedImage_, image?.ref.pointer ?? ffi.nullptr, highlightedImage?.ref.pointer ?? ffi.nullptr);
    return UIImageView.fromPointer($ret, retain: false, release: true);
  }


  /// isAnimating
  bool get isAnimating {
  objc.checkOsVersionInternal('UIImageView.isAnimating', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isAnimating);

  }


  /// isHighlighted
  bool get isHighlighted {
  objc.checkOsVersionInternal('UIImageView.isHighlighted', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHighlighted);

  }


  /// isUserInteractionEnabled
  bool get isUserInteractionEnabled {
  objc.checkOsVersionInternal('UIImageView.isUserInteractionEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isUserInteractionEnabled);

  }


  /// masksFocusEffectToContents
  bool get masksFocusEffectToContents {
  objc.checkOsVersionInternal('UIImageView.masksFocusEffectToContents', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_masksFocusEffectToContents);

  }


  /// overlayContentView
  UIView get overlayContentView {
  objc.checkOsVersionInternal('UIImageView.overlayContentView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_overlayContentView);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// preferredImageDynamicRange
  int get preferredImageDynamicRange {
  objc.checkOsVersionInternal('UIImageView.preferredImageDynamicRange', iOS: (false, (17, 0, 0)));
    return _objc_msgSend_xfd0s2(object$.ref.pointer, _sel_preferredImageDynamicRange);

  }


  /// preferredSymbolConfiguration
  UIImageSymbolConfiguration? get preferredSymbolConfiguration {
  objc.checkOsVersionInternal('UIImageView.preferredSymbolConfiguration', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_preferredSymbolConfiguration);
    return $ret.address == 0 ? null : UIImageSymbolConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// removeAllSymbolEffects
  void removeAllSymbolEffects() {
  objc.checkOsVersionInternal('UIImageView.removeAllSymbolEffects', iOS: (false, (17, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_removeAllSymbolEffects);

  }


  /// removeAllSymbolEffectsWithOptions:
  void removeAllSymbolEffectsWithOptions(NSSymbolEffectOptions options) {
  objc.checkOsVersionInternal('UIImageView.removeAllSymbolEffectsWithOptions:', iOS: (false, (17, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeAllSymbolEffectsWithOptions_, options.ref.pointer);

  }


  /// removeAllSymbolEffectsWithOptions:animated:
  void removeAllSymbolEffectsWithOptions$1(NSSymbolEffectOptions options, {required bool animated}) {
  objc.checkOsVersionInternal('UIImageView.removeAllSymbolEffectsWithOptions:animated:', iOS: (false, (17, 0, 0)));
_objc_msgSend_6p7ndb(object$.ref.pointer, _sel_removeAllSymbolEffectsWithOptions_animated_, options.ref.pointer, animated);

  }


  /// removeSymbolEffectOfType:
  void removeSymbolEffectOfType(NSSymbolEffect symbolEffect) {
  objc.checkOsVersionInternal('UIImageView.removeSymbolEffectOfType:', iOS: (false, (17, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeSymbolEffectOfType_, symbolEffect.ref.pointer);

  }


  /// removeSymbolEffectOfType:options:
  void removeSymbolEffectOfType$1(NSSymbolEffect symbolEffect, {required NSSymbolEffectOptions options}) {
  objc.checkOsVersionInternal('UIImageView.removeSymbolEffectOfType:options:', iOS: (false, (17, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_removeSymbolEffectOfType_options_, symbolEffect.ref.pointer, options.ref.pointer);

  }


  /// removeSymbolEffectOfType:options:animated:
  void removeSymbolEffectOfType$2(NSSymbolEffect symbolEffect, {required NSSymbolEffectOptions options,required bool animated}) {
  objc.checkOsVersionInternal('UIImageView.removeSymbolEffectOfType:options:animated:', iOS: (false, (17, 0, 0)));
_objc_msgSend_1lhy15d(object$.ref.pointer, _sel_removeSymbolEffectOfType_options_animated_, symbolEffect.ref.pointer, options.ref.pointer, animated);

  }


  /// removeSymbolEffectOfType:options:animated:completion:
  void removeSymbolEffectOfType$3(NSSymbolEffect symbolEffect, {required NSSymbolEffectOptions options,required bool animated,objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>? completion}) {
  objc.checkOsVersionInternal('UIImageView.removeSymbolEffectOfType:options:animated:completion:', iOS: (false, (17, 0, 0)));
_objc_msgSend_1imhooq(object$.ref.pointer, _sel_removeSymbolEffectOfType_options_animated_completion_, symbolEffect.ref.pointer, options.ref.pointer, animated, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// setAdjustsImageWhenAncestorFocused:
  set adjustsImageWhenAncestorFocused(bool value) {
  objc.checkOsVersionInternal('UIImageView.setAdjustsImageWhenAncestorFocused:', iOS: (true, null));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAdjustsImageWhenAncestorFocused_, value);

  }


  /// setAnimationDuration:
  set animationDuration(double value) {
  objc.checkOsVersionInternal('UIImageView.setAnimationDuration:', iOS: (false, (2, 0, 0)));
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setAnimationDuration_, value);

  }


  /// setAnimationImages:
  set animationImages(objc.NSArray? value) {
  objc.checkOsVersionInternal('UIImageView.setAnimationImages:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAnimationImages_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setAnimationRepeatCount:
  set animationRepeatCount(int value) {
  objc.checkOsVersionInternal('UIImageView.setAnimationRepeatCount:', iOS: (false, (2, 0, 0)));
_objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setAnimationRepeatCount_, value);

  }


  /// setHighlighted:
  set isHighlighted(bool value) {
  objc.checkOsVersionInternal('UIImageView.setHighlighted:', iOS: (false, (3, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHighlighted_, value);

  }


  /// setHighlightedAnimationImages:
  set highlightedAnimationImages(objc.NSArray? value) {
  objc.checkOsVersionInternal('UIImageView.setHighlightedAnimationImages:', iOS: (false, (3, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHighlightedAnimationImages_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setHighlightedImage:
  set highlightedImage(UIImage? value) {
  objc.checkOsVersionInternal('UIImageView.setHighlightedImage:', iOS: (false, (3, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHighlightedImage_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setImage:
  set image(UIImage? value) {
  objc.checkOsVersionInternal('UIImageView.setImage:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setMasksFocusEffectToContents:
  set masksFocusEffectToContents(bool value) {
  objc.checkOsVersionInternal('UIImageView.setMasksFocusEffectToContents:', iOS: (true, null));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setMasksFocusEffectToContents_, value);

  }


  /// setPreferredImageDynamicRange:
  set preferredImageDynamicRange(int value) {
  objc.checkOsVersionInternal('UIImageView.setPreferredImageDynamicRange:', iOS: (false, (17, 0, 0)));
_objc_msgSend_141mpu0(object$.ref.pointer, _sel_setPreferredImageDynamicRange_, value);

  }


  /// setPreferredSymbolConfiguration:
  set preferredSymbolConfiguration(UIImageSymbolConfiguration? value) {
  objc.checkOsVersionInternal('UIImageView.setPreferredSymbolConfiguration:', iOS: (false, (13, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setPreferredSymbolConfiguration_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setSymbolImage:withContentTransition:
  void setSymbolImage(UIImage symbolImage, {required NSSymbolContentTransition withContentTransition}) {
  objc.checkOsVersionInternal('UIImageView.setSymbolImage:withContentTransition:', iOS: (false, (17, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_setSymbolImage_withContentTransition_, symbolImage.ref.pointer, withContentTransition.ref.pointer);

  }


  /// setSymbolImage:withContentTransition:options:
  void setSymbolImage$1(UIImage symbolImage, {required NSSymbolContentTransition withContentTransition,required NSSymbolEffectOptions options}) {
  objc.checkOsVersionInternal('UIImageView.setSymbolImage:withContentTransition:options:', iOS: (false, (17, 0, 0)));
_objc_msgSend_r8gdi7(object$.ref.pointer, _sel_setSymbolImage_withContentTransition_options_, symbolImage.ref.pointer, withContentTransition.ref.pointer, options.ref.pointer);

  }


  /// setSymbolImage:withContentTransition:options:completion:
  void setSymbolImage$2(UIImage symbolImage, {required NSSymbolContentTransition withContentTransition,required NSSymbolEffectOptions options,objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>? completion}) {
  objc.checkOsVersionInternal('UIImageView.setSymbolImage:withContentTransition:options:completion:', iOS: (false, (17, 0, 0)));
_objc_msgSend_m7tls4(object$.ref.pointer, _sel_setSymbolImage_withContentTransition_options_completion_, symbolImage.ref.pointer, withContentTransition.ref.pointer, options.ref.pointer, completion?.ref.pointer ?? ffi.nullptr);

  }


  /// setTintColor:
  set tintColor(UIColor value) {
  objc.checkOsVersionInternal('UIImageView.setTintColor:', iOS: (false, (7, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTintColor_, value.ref.pointer);

  }


  /// setUserInteractionEnabled:
  set isUserInteractionEnabled(bool value) {
  objc.checkOsVersionInternal('UIImageView.setUserInteractionEnabled:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setUserInteractionEnabled_, value);

  }


  /// startAnimating
  void startAnimating() {
  objc.checkOsVersionInternal('UIImageView.startAnimating', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_startAnimating);

  }


  /// stopAnimating
  void stopAnimating() {
  objc.checkOsVersionInternal('UIImageView.stopAnimating', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_stopAnimating);

  }


  /// tintColor
  UIColor get tintColor {
  objc.checkOsVersionInternal('UIImageView.tintColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tintColor);
    return UIColor.fromPointer($ret, retain: true, release: true);
  }

}


/// Construction methods for `objc.ObjCBlock<UIColor Function(UIColor)>`.
abstract final class ObjCBlock_UIColor_UIColor {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIColor Function(UIColor)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIColor Function(UIColor)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIColor Function(UIColor)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<UIColor Function(UIColor)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIColor Function(UIColor)> fromFunction(UIColor Function(UIColor ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIColor Function(UIColor)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIColor.fromPointer(arg0, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIColor Function(UIColor)>`.
extension ObjCBlock_UIColor_UIColor$CallExtension on objc.ObjCBlock<UIColor Function(UIColor)> {
  UIColor call(UIColor arg0) =>UIColor.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer), retain: true, release: true);
}


/// WARNING: UIBackgroundConfiguration is a stub. To generate bindings for this class, include
/// UIBackgroundConfiguration in your config's objc-interfaces list.
///
/// UIBackgroundConfiguration
extension type UIBackgroundConfiguration._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [UIBackgroundConfiguration] that points to the same underlying object as [other].
  UIBackgroundConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIBackgroundConfiguration', iOS: (false, (14, 0, 0)));
  }

  /// Constructs a [UIBackgroundConfiguration] that wraps the given raw object pointer.
  UIBackgroundConfiguration.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBackgroundConfiguration', iOS: (false, (14, 0, 0)));
  }


}

sealed class UIButtonConfigurationSize {
  static const UIButtonConfigurationSizeMedium = 0;
  static const UIButtonConfigurationSizeSmall = 1;
  static const UIButtonConfigurationSizeMini = 2;
  static const UIButtonConfigurationSizeLarge = 3;}

sealed class UIButtonConfigurationTitleAlignment {
  static const UIButtonConfigurationTitleAlignmentAutomatic = 0;
  static const UIButtonConfigurationTitleAlignmentLeading = 1;
  static const UIButtonConfigurationTitleAlignmentCenter = 2;
  static const UIButtonConfigurationTitleAlignmentTrailing = 3;}

sealed class UIButtonConfigurationCornerStyle {
  static const UIButtonConfigurationCornerStyleFixed = -1;
  static const UIButtonConfigurationCornerStyleDynamic = 0;
  static const UIButtonConfigurationCornerStyleSmall = 1;
  static const UIButtonConfigurationCornerStyleMedium = 2;
  static const UIButtonConfigurationCornerStyleLarge = 3;
  static const UIButtonConfigurationCornerStyleCapsule = 4;}

sealed class UIButtonConfigurationMacIdiomStyle {
  static const UIButtonConfigurationMacIdiomStyleAutomatic = 0;
  static const UIButtonConfigurationMacIdiomStyleBordered = 1;
  static const UIButtonConfigurationMacIdiomStyleBorderless = 2;
  static const UIButtonConfigurationMacIdiomStyleBorderlessTinted = 3;}

sealed class UIButtonConfigurationIndicator {
  static const UIButtonConfigurationIndicatorAutomatic = 0;
  static const UIButtonConfigurationIndicatorNone = 1;
  static const UIButtonConfigurationIndicatorPopup = 2;}

sealed class UIButtonType {
  static const UIButtonTypeCustom = 0;
  static const UIButtonTypeSystem = 1;
  static const UIButtonTypeDetailDisclosure = 2;
  static const UIButtonTypeInfoLight = 3;
  static const UIButtonTypeInfoDark = 4;
  static const UIButtonTypeContactAdd = 5;
  static const UIButtonTypePlain = 6;
  static const UIButtonTypeClose = 7;
  static const UIButtonTypeRoundedRect = 1;}

sealed class UIButtonRole {
  static const UIButtonRoleNormal = 0;
  static const UIButtonRolePrimary = 1;
  static const UIButtonRoleCancel = 2;
  static const UIButtonRoleDestructive = 3;}

late final _class_UIPointerStyle = objc.getClass("UIPointerStyle");
late final _sel_accessories = objc.registerName("accessories");
late final _sel_setAccessories_ = objc.registerName("setAccessories:");
late final _class_UIPointerShape = objc.getClass("UIPointerShape");
late final _sel_shapeWithPath_ = objc.registerName("shapeWithPath:");
late final _sel_shapeWithRoundedRect_ = objc.registerName("shapeWithRoundedRect:");
late final _sel_shapeWithRoundedRect_cornerRadius_ = objc.registerName("shapeWithRoundedRect:cornerRadius:");
final _objc_msgSend_1k439hd = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , double )>();
late final _sel_beamWithPreferredLength_axis_ = objc.registerName("beamWithPreferredLength:axis:");
final _objc_msgSend_h14qyr = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , int )>();

/// UIPointerShape
extension type UIPointerShape._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying {
  /// Constructs a [UIPointerShape] that points to the same underlying object as [other].
  UIPointerShape.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPointerShape', iOS: (false, (13, 4, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIPointerShape] that wraps the given raw object pointer.
  UIPointerShape.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPointerShape', iOS: (false, (13, 4, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIPointerShape].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIPointerShape);

  /// alloc
  static UIPointerShape alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIPointerShape, _sel_alloc);
    return UIPointerShape.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIPointerShape allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIPointerShape, _sel_allocWithZone_, zone);
    return UIPointerShape.fromPointer($ret, retain: false, release: true);
  }


  /// beamWithPreferredLength:axis:
  static UIPointerShape beamWithPreferredLength(double length, {required int axis}) {
  objc.checkOsVersionInternal('UIPointerShape.beamWithPreferredLength:axis:', iOS: (false, (13, 4, 0)));
    final $ret = _objc_msgSend_h14qyr(_class_UIPointerShape, _sel_beamWithPreferredLength_axis_, length, axis);
    return UIPointerShape.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static UIPointerShape new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIPointerShape, _sel_new);
    return UIPointerShape.fromPointer($ret, retain: false, release: true);
  }


  /// shapeWithPath:
  static UIPointerShape shapeWithPath(UIBezierPath path) {
  objc.checkOsVersionInternal('UIPointerShape.shapeWithPath:', iOS: (false, (13, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIPointerShape, _sel_shapeWithPath_, path.ref.pointer);
    return UIPointerShape.fromPointer($ret, retain: true, release: true);
  }


  /// shapeWithRoundedRect:
  static UIPointerShape shapeWithRoundedRect(objc.CGRect rect) {
  objc.checkOsVersionInternal('UIPointerShape.shapeWithRoundedRect:', iOS: (false, (13, 4, 0)));
    final $ret = _objc_msgSend_15yz4e6(_class_UIPointerShape, _sel_shapeWithRoundedRect_, rect);
    return UIPointerShape.fromPointer($ret, retain: true, release: true);
  }


  /// shapeWithRoundedRect:cornerRadius:
  static UIPointerShape shapeWithRoundedRect$1(objc.CGRect rect, {required double cornerRadius}) {
  objc.checkOsVersionInternal('UIPointerShape.shapeWithRoundedRect:cornerRadius:', iOS: (false, (13, 4, 0)));
    final $ret = _objc_msgSend_1k439hd(_class_UIPointerShape, _sel_shapeWithRoundedRect_cornerRadius_, rect, cornerRadius);
    return UIPointerShape.fromPointer($ret, retain: true, release: true);
  }
  /// Returns a new instance of UIPointerShape constructed with the default `new` method.
  UIPointerShape() : this.as(new$().object$);

}

extension UIPointerShape$Methods on UIPointerShape {

  /// init
  UIPointerShape init() {
  objc.checkOsVersionInternal('UIPointerShape.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIPointerShape.fromPointer($ret, retain: false, release: true);
  }

}

late final _sel_styleWithShape_constrainedAxes_ = objc.registerName("styleWithShape:constrainedAxes:");
final _objc_msgSend_tuvlta = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
late final _sel_hiddenPointerStyle = objc.registerName("hiddenPointerStyle");
late final _sel_systemPointerStyle = objc.registerName("systemPointerStyle");

/// UIPointerStyle
extension type UIPointerStyle._(objc.ObjCObject object$) implements objc.ObjCObject,UIHoverStyle$1,objc.NSCopying {
  /// Constructs a [UIPointerStyle] that points to the same underlying object as [other].
  UIPointerStyle.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPointerStyle', iOS: (false, (13, 4, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIPointerStyle] that wraps the given raw object pointer.
  UIPointerStyle.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPointerStyle', iOS: (false, (13, 4, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIPointerStyle].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIPointerStyle);

  /// alloc
  static UIPointerStyle alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_alloc);
    return UIPointerStyle.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIPointerStyle allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIPointerStyle, _sel_allocWithZone_, zone);
    return UIPointerStyle.fromPointer($ret, retain: false, release: true);
  }


  /// automaticStyle
  static UIPointerStyle automaticStyle() {
  objc.checkOsVersionInternal('UIPointerStyle.automaticStyle', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_automaticStyle);
    return UIPointerStyle.fromPointer($ret, retain: true, release: true);
  }


  /// hiddenPointerStyle
  static UIPointerStyle hiddenPointerStyle() {
  objc.checkOsVersionInternal('UIPointerStyle.hiddenPointerStyle', iOS: (false, (13, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_hiddenPointerStyle);
    return UIPointerStyle.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static UIPointerStyle new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_new);
    return UIPointerStyle.fromPointer($ret, retain: false, release: true);
  }


  /// styleWithEffect:shape:
  static UIPointerStyle styleWithEffect(UIHoverEffect effect, {UIShape? shape}) {
  objc.checkOsVersionInternal('UIPointerStyle.styleWithEffect:shape:', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UIPointerStyle, _sel_styleWithEffect_shape_, effect.ref.pointer, shape?.ref.pointer ?? ffi.nullptr);
    return UIPointerStyle.fromPointer($ret, retain: true, release: true);
  }


  /// styleWithShape:
  static UIPointerStyle styleWithShape(UIShape? shape) {
  objc.checkOsVersionInternal('UIPointerStyle.styleWithShape:', iOS: (false, (17, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIPointerStyle, _sel_styleWithShape_, shape?.ref.pointer ?? ffi.nullptr);
    return UIPointerStyle.fromPointer($ret, retain: true, release: true);
  }


  /// styleWithShape:constrainedAxes:
  static UIPointerStyle styleWithShape$1(UIPointerShape shape, {required int constrainedAxes}) {
  objc.checkOsVersionInternal('UIPointerStyle.styleWithShape:constrainedAxes:', iOS: (false, (13, 4, 0)));
    final $ret = _objc_msgSend_tuvlta(_class_UIPointerStyle, _sel_styleWithShape_constrainedAxes_, shape.ref.pointer, constrainedAxes);
    return UIPointerStyle.fromPointer($ret, retain: true, release: true);
  }


  /// systemPointerStyle
  static UIPointerStyle systemPointerStyle() {
  objc.checkOsVersionInternal('UIPointerStyle.systemPointerStyle', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIPointerStyle, _sel_systemPointerStyle);
    return UIPointerStyle.fromPointer($ret, retain: true, release: true);
  }
  /// Returns a new instance of UIPointerStyle constructed with the default `new` method.
  UIPointerStyle() : this.as(new$().object$);

}

extension UIPointerStyle$Methods on UIPointerStyle {

  /// accessories
  objc.NSArray get accessories {
  objc.checkOsVersionInternal('UIPointerStyle.accessories', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_accessories);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// init
  UIPointerStyle init() {
  objc.checkOsVersionInternal('UIPointerStyle.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIPointerStyle.fromPointer($ret, retain: false, release: true);
  }


  /// setAccessories:
  set accessories(objc.NSArray value) {
  objc.checkOsVersionInternal('UIPointerStyle.setAccessories:', iOS: (false, (15, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAccessories_, value.ref.pointer);

  }

}


/// WARNING: UIButton is a stub. To generate bindings for this class, include
/// UIButton in your config's objc-interfaces list.
///
/// UIButton
extension type UIButton._(objc.ObjCObject object$) implements objc.ObjCObject,UIControl,objc.NSCoding {
  /// Constructs a [UIButton] that points to the same underlying object as [other].
  UIButton.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIButton', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIButton] that wraps the given raw object pointer.
  UIButton.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIButton', iOS: (false, (2, 0, 0)));
  }


}

late final _class_UIPointerEffect = objc.getClass("UIPointerEffect");

/// WARNING: UITargetedPreview is a stub. To generate bindings for this class, include
/// UITargetedPreview in your config's objc-interfaces list.
///
/// UITargetedPreview
extension type UITargetedPreview._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying {
  /// Constructs a [UITargetedPreview] that points to the same underlying object as [other].
  UITargetedPreview.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITargetedPreview', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UITargetedPreview] that wraps the given raw object pointer.
  UITargetedPreview.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITargetedPreview', iOS: (false, (13, 0, 0)));
  }


}

late final _sel_preview = objc.registerName("preview");
late final _sel_effectWithPreview_ = objc.registerName("effectWithPreview:");

/// UIPointerEffect
extension type UIPointerEffect._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,UIHoverEffect {
  /// Constructs a [UIPointerEffect] that points to the same underlying object as [other].
  UIPointerEffect.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPointerEffect', iOS: (false, (13, 4, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIPointerEffect] that wraps the given raw object pointer.
  UIPointerEffect.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPointerEffect', iOS: (false, (13, 4, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIPointerEffect].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIPointerEffect);

  /// alloc
  static UIPointerEffect alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIPointerEffect, _sel_alloc);
    return UIPointerEffect.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIPointerEffect allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIPointerEffect, _sel_allocWithZone_, zone);
    return UIPointerEffect.fromPointer($ret, retain: false, release: true);
  }


  /// effectWithPreview:
  static UIPointerEffect effectWithPreview(UITargetedPreview preview) {
  objc.checkOsVersionInternal('UIPointerEffect.effectWithPreview:', iOS: (false, (13, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIPointerEffect, _sel_effectWithPreview_, preview.ref.pointer);
    return UIPointerEffect.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static UIPointerEffect new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIPointerEffect, _sel_new);
    return UIPointerEffect.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of UIPointerEffect constructed with the default `new` method.
  UIPointerEffect() : this.as(new$().object$);

}

extension UIPointerEffect$Methods on UIPointerEffect {

  /// init
  UIPointerEffect init() {
  objc.checkOsVersionInternal('UIPointerEffect.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIPointerEffect.fromPointer($ret, retain: false, release: true);
  }


  /// preview
  UITargetedPreview get preview {
  objc.checkOsVersionInternal('UIPointerEffect.preview', iOS: (false, (13, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_preview);
    return UITargetedPreview.fromPointer($ret, retain: true, release: true);
  }

}


/// Construction methods for `objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>`.
abstract final class ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)> fromFunction(UIPointerStyle? Function(UIButton , UIPointerEffect , UIPointerShape ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(UIButton.fromPointer(arg0, retain: true, release: true), UIPointerEffect.fromPointer(arg1, retain: true, release: true), UIPointerShape.fromPointer(arg2, retain: true, release: true))?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)>`.
extension ObjCBlock_UIPointerStyle_UIButton_UIPointerEffect_UIPointerShape$CallExtension on objc.ObjCBlock<UIPointerStyle? Function(UIButton, UIPointerEffect, UIPointerShape)> {
  UIPointerStyle? call(UIButton arg0, UIPointerEffect arg1, UIPointerShape arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer).address == 0 ? null : UIPointerStyle.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer), retain: true, release: true);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIButton)>`.
abstract final class ObjCBlock_ffiVoid_UIButton {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(UIButton)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(UIButton)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> fromFunction(void Function(UIButton ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UIButton)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIButton.fromPointer(arg0, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> listener(void Function(UIButton ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIButton.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIButton)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIButton)> blocking(void Function(UIButton ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIButton.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(UIButton.fromPointer(arg0, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIButton)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIButton)>`.
extension ObjCBlock_ffiVoid_UIButton$CallExtension on objc.ObjCBlock<ffi.Void Function(UIButton)> {
  void call(UIButton arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer);
}

sealed class UIBarMetrics {
  static const UIBarMetricsDefault = 0;
  static const UIBarMetricsCompact = 1;
  static const UIBarMetricsDefaultPrompt = 101;
  static const UIBarMetricsCompactPrompt = 102;
  static const UIBarMetricsLandscapePhone = 1;
  static const UIBarMetricsLandscapePhonePrompt = 102;}

sealed class UIBarPosition {
  static const UIBarPositionAny = 0;
  static const UIBarPositionBottom = 1;
  static const UIBarPositionTop = 2;
  static const UIBarPositionTopAttached = 3;}

sealed class UIBarButtonItemStyle {
  static const UIBarButtonItemStylePlain = 0;
  static const UIBarButtonItemStyleProminent = 2;
  static const UIBarButtonItemStyleBordered = 1;
  static const UIBarButtonItemStyleDone = 2;}

sealed class UIBarButtonSystemItem {
  static const UIBarButtonSystemItemDone = 0;
  static const UIBarButtonSystemItemCancel = 1;
  static const UIBarButtonSystemItemEdit = 2;
  static const UIBarButtonSystemItemSave = 3;
  static const UIBarButtonSystemItemAdd = 4;
  static const UIBarButtonSystemItemFlexibleSpace = 5;
  static const UIBarButtonSystemItemFixedSpace = 6;
  static const UIBarButtonSystemItemCompose = 7;
  static const UIBarButtonSystemItemReply = 8;
  static const UIBarButtonSystemItemAction = 9;
  static const UIBarButtonSystemItemOrganize = 10;
  static const UIBarButtonSystemItemBookmarks = 11;
  static const UIBarButtonSystemItemSearch = 12;
  static const UIBarButtonSystemItemRefresh = 13;
  static const UIBarButtonSystemItemStop = 14;
  static const UIBarButtonSystemItemCamera = 15;
  static const UIBarButtonSystemItemTrash = 16;
  static const UIBarButtonSystemItemPlay = 17;
  static const UIBarButtonSystemItemPause = 18;
  static const UIBarButtonSystemItemRewind = 19;
  static const UIBarButtonSystemItemFastForward = 20;
  static const UIBarButtonSystemItemUndo = 21;
  static const UIBarButtonSystemItemRedo = 22;
  static const UIBarButtonSystemItemPageCurl = 23;
  static const UIBarButtonSystemItemClose = 24;
  static const UIBarButtonSystemItemWritingTools = 25;}

sealed class UIGestureRecognizerState {
  static const UIGestureRecognizerStatePossible = 0;
  static const UIGestureRecognizerStateBegan = 1;
  static const UIGestureRecognizerStateChanged = 2;
  static const UIGestureRecognizerStateEnded = 3;
  static const UIGestureRecognizerStateCancelled = 4;
  static const UIGestureRecognizerStateFailed = 5;
  static const UIGestureRecognizerStateRecognized = 3;}


/// WARNING: UIGestureRecognizerDelegate is a stub. To generate bindings for this class, include
/// UIGestureRecognizerDelegate in your config's objc-protocols list.
///
/// UIGestureRecognizerDelegate
extension type UIGestureRecognizerDelegate._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIGestureRecognizerDelegate] that points to the same underlying object as [other].
  UIGestureRecognizerDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIGestureRecognizerDelegate] that wraps the given raw object pointer.
  UIGestureRecognizerDelegate.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class UITableViewCellStyle {
  static const UITableViewCellStyleDefault = 0;
  static const UITableViewCellStyleValue1 = 1;
  static const UITableViewCellStyleValue2 = 2;
  static const UITableViewCellStyleSubtitle = 3;}

sealed class UITableViewCellSeparatorStyle {
  static const UITableViewCellSeparatorStyleNone = 0;
  static const UITableViewCellSeparatorStyleSingleLine = 1;
  static const UITableViewCellSeparatorStyleSingleLineEtched = 2;}

sealed class UITableViewCellSelectionStyle {
  static const UITableViewCellSelectionStyleNone = 0;
  static const UITableViewCellSelectionStyleBlue = 1;
  static const UITableViewCellSelectionStyleGray = 2;
  static const UITableViewCellSelectionStyleDefault = 3;}

sealed class UITableViewCellFocusStyle {
  static const UITableViewCellFocusStyleDefault = 0;
  static const UITableViewCellFocusStyleCustom = 1;}

sealed class UITableViewCellEditingStyle {
  static const UITableViewCellEditingStyleNone = 0;
  static const UITableViewCellEditingStyleDelete = 1;
  static const UITableViewCellEditingStyleInsert = 2;}

sealed class UITableViewCellAccessoryType {
  static const UITableViewCellAccessoryNone = 0;
  static const UITableViewCellAccessoryDisclosureIndicator = 1;
  static const UITableViewCellAccessoryDetailDisclosureButton = 2;
  static const UITableViewCellAccessoryCheckmark = 3;
  static const UITableViewCellAccessoryDetailButton = 4;}

sealed class UITableViewCellStateMask {
  static const UITableViewCellStateDefaultMask = 0;
  static const UITableViewCellStateShowingEditControlMask = 1;
  static const UITableViewCellStateShowingDeleteConfirmationMask = 2;}

sealed class UITableViewCellDragState {
  static const UITableViewCellDragStateNone = 0;
  static const UITableViewCellDragStateLifting = 1;
  static const UITableViewCellDragStateDragging = 2;}

late final _class_UITableViewCell = objc.getClass("UITableViewCell");
late final _sel_initWithStyle_reuseIdentifier_ = objc.registerName("initWithStyle:reuseIdentifier:");
final _objc_msgSend_96u4vv = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _class_UICellConfigurationState = objc.getClass("UICellConfigurationState");
late final _sel_isEditing = objc.registerName("isEditing");
late final _sel_setEditing_ = objc.registerName("setEditing:");
late final _sel_isExpanded = objc.registerName("isExpanded");
late final _sel_setExpanded_ = objc.registerName("setExpanded:");
late final _sel_isSwiped = objc.registerName("isSwiped");
late final _sel_setSwiped_ = objc.registerName("setSwiped:");
late final _sel_isReordering = objc.registerName("isReordering");
late final _sel_setReordering_ = objc.registerName("setReordering:");
sealed class UICellConfigurationDragState {
  static const UICellConfigurationDragStateNone = 0;
  static const UICellConfigurationDragStateLifting = 1;
  static const UICellConfigurationDragStateDragging = 2;}

late final _sel_cellDragState = objc.registerName("cellDragState");
final _objc_msgSend_10i7aka = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setCellDragState_ = objc.registerName("setCellDragState:");
final _objc_msgSend_1murqn0 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
sealed class UICellConfigurationDropState {
  static const UICellConfigurationDropStateNone = 0;
  static const UICellConfigurationDropStateNotTargeted = 1;
  static const UICellConfigurationDropStateTargeted = 2;}

late final _sel_cellDropState = objc.registerName("cellDropState");
final _objc_msgSend_1g9qrcf = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setCellDropState_ = objc.registerName("setCellDropState:");
final _objc_msgSend_9t0hj7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_initWithTraitCollection_ = objc.registerName("initWithTraitCollection:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void> , UITraitCollection ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UITraitCollection.fromPointer(arg1, retain: true, release: true)).ref.retainAndReturnPointer(), keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection$1$CallExtension on objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer), retain: false, release: true);
}

late final _class_UIViewConfigurationState = objc.getClass("UIViewConfigurationState");
late final _sel_setTraitCollection_ = objc.registerName("setTraitCollection:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunction(void Function(ffi.Pointer<ffi.Void> , UITraitCollection ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UITraitCollection.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)> listener(void Function(ffi.Pointer<ffi.Void> , UITraitCollection ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)> blocking(void Function(ffi.Pointer<ffi.Void> , UITraitCollection ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UITraitCollection.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_isDisabled = objc.registerName("isDisabled");
late final _sel_setDisabled_ = objc.registerName("setDisabled:");
late final _sel_isSelected = objc.registerName("isSelected");
late final _sel_setSelected_ = objc.registerName("setSelected:");
late final _sel_setFocused_ = objc.registerName("setFocused:");
late final _sel_isPinned = objc.registerName("isPinned");
late final _sel_setPinned_ = objc.registerName("setPinned:");
late final _sel_customStateForKey_ = objc.registerName("customStateForKey:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid_UIActivityItemsConfigurationMetadataKey {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(objc.ObjCObject? Function(ffi.Pointer<ffi.Void> , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSString.fromPointer(arg1, retain: true, release: true))?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid_UIActivityItemsConfigurationMetadataKey$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.ObjCObject? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer).address == 0 ? null : objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer), retain: true, release: true);
}

late final _sel_setCustomState_forKey_ = objc.registerName("setCustomState:forKey:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl_UIConfigurationStateCustomKey {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: true, release: true), objc.NSString.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)> listener(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true), objc.NSString.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.ObjCObject? , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true), objc.NSString.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, arg1.address == 0 ? null : objc.ObjCObject(arg1, retain: false, release: true), objc.NSString.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl_UIConfigurationStateCustomKey$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject? arg1, objc.NSString arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr, arg2.ref.pointer);
}

late final _sel_objectForKeyedSubscript_ = objc.registerName("objectForKeyedSubscript:");
late final _sel_setObject_forKeyedSubscript_ = objc.registerName("setObject:forKeyedSubscript:");

/// WARNING: UIConfigurationState is a stub. To generate bindings for this class, include
/// UIConfigurationState in your config's objc-protocols list.
///
/// UIConfigurationState
extension type UIConfigurationState._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol, objc.NSCopying, objc.NSSecureCoding {
  /// Constructs a [UIConfigurationState] that points to the same underlying object as [other].
  UIConfigurationState.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIConfigurationState] that wraps the given raw object pointer.
  UIConfigurationState.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// UIViewConfigurationState
extension type UIViewConfigurationState._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,UIConfigurationState {
  /// Constructs a [UIViewConfigurationState] that points to the same underlying object as [other].
  UIViewConfigurationState.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIViewConfigurationState', iOS: (false, (14, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIViewConfigurationState] that wraps the given raw object pointer.
  UIViewConfigurationState.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewConfigurationState', iOS: (false, (14, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIViewConfigurationState].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIViewConfigurationState);

  /// alloc
  static UIViewConfigurationState alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIViewConfigurationState, _sel_alloc);
    return UIViewConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIViewConfigurationState allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIViewConfigurationState, _sel_allocWithZone_, zone);
    return UIViewConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static UIViewConfigurationState new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIViewConfigurationState, _sel_new);
    return UIViewConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIViewConfigurationState, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of UIViewConfigurationState constructed with the default `new` method.
  UIViewConfigurationState() : this.as(new$().object$);

}

extension UIViewConfigurationState$Methods on UIViewConfigurationState {

  /// customStateForKey:
  objc.ObjCObject? customStateForKey(objc.NSString key) {
  objc.checkOsVersionInternal('UIViewConfigurationState.customStateForKey:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_customStateForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// init
  UIViewConfigurationState init() {
  objc.checkOsVersionInternal('UIViewConfigurationState.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIViewConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UIViewConfigurationState? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIViewConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// initWithTraitCollection:
  UIViewConfigurationState initWithTraitCollection(UITraitCollection traitCollection) {
  objc.checkOsVersionInternal('UIViewConfigurationState.initWithTraitCollection:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithTraitCollection_, traitCollection.ref.pointer);
    return UIViewConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// isDisabled
  bool get isDisabled {
  objc.checkOsVersionInternal('UIViewConfigurationState.isDisabled', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isDisabled);

  }


  /// isFocused
  bool get isFocused {
  objc.checkOsVersionInternal('UIViewConfigurationState.isFocused', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFocused);

  }


  /// isHighlighted
  bool get isHighlighted {
  objc.checkOsVersionInternal('UIViewConfigurationState.isHighlighted', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHighlighted);

  }


  /// isPinned
  bool get isPinned {
  objc.checkOsVersionInternal('UIViewConfigurationState.isPinned', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isPinned);

  }


  /// isSelected
  bool get isSelected {
  objc.checkOsVersionInternal('UIViewConfigurationState.isSelected', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSelected);

  }


  /// objectForKeyedSubscript:
  objc.ObjCObject? objectForKeyedSubscript(objc.NSString key) {
  objc.checkOsVersionInternal('UIViewConfigurationState.objectForKeyedSubscript:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_objectForKeyedSubscript_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// setCustomState:forKey:
  void setCustomState(objc.ObjCObject? customState, {required objc.NSString forKey}) {
  objc.checkOsVersionInternal('UIViewConfigurationState.setCustomState:forKey:', iOS: (false, (14, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_setCustomState_forKey_, customState?.ref.pointer ?? ffi.nullptr, forKey.ref.pointer);

  }


  /// setDisabled:
  set isDisabled(bool value) {
  objc.checkOsVersionInternal('UIViewConfigurationState.setDisabled:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setDisabled_, value);

  }


  /// setFocused:
  set isFocused(bool value) {
  objc.checkOsVersionInternal('UIViewConfigurationState.setFocused:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setFocused_, value);

  }


  /// setHighlighted:
  set isHighlighted(bool value) {
  objc.checkOsVersionInternal('UIViewConfigurationState.setHighlighted:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHighlighted_, value);

  }


  /// setObject:forKeyedSubscript:
  void setObject(objc.ObjCObject? obj, {required objc.NSString forKeyedSubscript}) {
  objc.checkOsVersionInternal('UIViewConfigurationState.setObject:forKeyedSubscript:', iOS: (false, (14, 0, 0)));
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_setObject_forKeyedSubscript_, obj?.ref.pointer ?? ffi.nullptr, forKeyedSubscript.ref.pointer);

  }


  /// setPinned:
  set isPinned(bool value) {
  objc.checkOsVersionInternal('UIViewConfigurationState.setPinned:', iOS: (false, (15, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setPinned_, value);

  }


  /// setSelected:
  set isSelected(bool value) {
  objc.checkOsVersionInternal('UIViewConfigurationState.setSelected:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setSelected_, value);

  }


  /// setTraitCollection:
  set traitCollection(UITraitCollection value) {
  objc.checkOsVersionInternal('UIViewConfigurationState.setTraitCollection:', iOS: (false, (14, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTraitCollection_, value.ref.pointer);

  }


  /// traitCollection
  UITraitCollection get traitCollection {
  objc.checkOsVersionInternal('UIViewConfigurationState.traitCollection', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_traitCollection);
    return UITraitCollection.fromPointer($ret, retain: true, release: true);
  }

}


/// UICellConfigurationState
extension type UICellConfigurationState._(objc.ObjCObject object$) implements objc.ObjCObject,UIViewConfigurationState {
  /// Constructs a [UICellConfigurationState] that points to the same underlying object as [other].
  UICellConfigurationState.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UICellConfigurationState', iOS: (false, (14, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UICellConfigurationState] that wraps the given raw object pointer.
  UICellConfigurationState.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UICellConfigurationState', iOS: (false, (14, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UICellConfigurationState].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UICellConfigurationState);

  /// alloc
  static UICellConfigurationState alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UICellConfigurationState, _sel_alloc);
    return UICellConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UICellConfigurationState allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UICellConfigurationState, _sel_allocWithZone_, zone);
    return UICellConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static UICellConfigurationState new$() {
    final $ret = _objc_msgSend_151sglz(_class_UICellConfigurationState, _sel_new);
    return UICellConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UICellConfigurationState, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of UICellConfigurationState constructed with the default `new` method.
  UICellConfigurationState() : this.as(new$().object$);

}

extension UICellConfigurationState$Methods on UICellConfigurationState {

  /// cellDragState
  int get cellDragState {
    return _objc_msgSend_10i7aka(object$.ref.pointer, _sel_cellDragState);

  }


  /// cellDropState
  int get cellDropState {
    return _objc_msgSend_1g9qrcf(object$.ref.pointer, _sel_cellDropState);

  }


  /// init
  UICellConfigurationState init() {
  objc.checkOsVersionInternal('UICellConfigurationState.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UICellConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UICellConfigurationState? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UICellConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// initWithTraitCollection:
  UICellConfigurationState initWithTraitCollection(UITraitCollection traitCollection) {
  objc.checkOsVersionInternal('UICellConfigurationState.initWithTraitCollection:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithTraitCollection_, traitCollection.ref.pointer);
    return UICellConfigurationState.fromPointer($ret, retain: false, release: true);
  }


  /// isEditing
  bool get isEditing {
  objc.checkOsVersionInternal('UICellConfigurationState.isEditing', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isEditing);

  }


  /// isExpanded
  bool get isExpanded {
  objc.checkOsVersionInternal('UICellConfigurationState.isExpanded', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isExpanded);

  }


  /// isReordering
  bool get isReordering {
  objc.checkOsVersionInternal('UICellConfigurationState.isReordering', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isReordering);

  }


  /// isSwiped
  bool get isSwiped {
  objc.checkOsVersionInternal('UICellConfigurationState.isSwiped', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSwiped);

  }


  /// setCellDragState:
  set cellDragState(int value) {
_objc_msgSend_1murqn0(object$.ref.pointer, _sel_setCellDragState_, value);

  }


  /// setCellDropState:
  set cellDropState(int value) {
_objc_msgSend_9t0hj7(object$.ref.pointer, _sel_setCellDropState_, value);

  }


  /// setEditing:
  set isEditing(bool value) {
  objc.checkOsVersionInternal('UICellConfigurationState.setEditing:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setEditing_, value);

  }


  /// setExpanded:
  set isExpanded(bool value) {
  objc.checkOsVersionInternal('UICellConfigurationState.setExpanded:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setExpanded_, value);

  }


  /// setReordering:
  set isReordering(bool value) {
  objc.checkOsVersionInternal('UICellConfigurationState.setReordering:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setReordering_, value);

  }


  /// setSwiped:
  set isSwiped(bool value) {
  objc.checkOsVersionInternal('UICellConfigurationState.setSwiped:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setSwiped_, value);

  }

}

late final _sel_configurationState = objc.registerName("configurationState");
late final _sel_setNeedsUpdateConfiguration = objc.registerName("setNeedsUpdateConfiguration");
late final _sel_updateConfigurationUsingState_ = objc.registerName("updateConfigurationUsingState:");
late final _sel_configurationUpdateHandler = objc.registerName("configurationUpdateHandler");
late final _sel_setConfigurationUpdateHandler_ = objc.registerName("setConfigurationUpdateHandler:");

/// WARNING: UIListContentConfiguration is a stub. To generate bindings for this class, include
/// UIListContentConfiguration in your config's objc-interfaces list.
///
/// UIListContentConfiguration
extension type UIListContentConfiguration._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,UIContentConfiguration,objc.NSSecureCoding {
  /// Constructs a [UIListContentConfiguration] that points to the same underlying object as [other].
  UIListContentConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIListContentConfiguration', iOS: (false, (14, 0, 0)));
  }

  /// Constructs a [UIListContentConfiguration] that wraps the given raw object pointer.
  UIListContentConfiguration.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIListContentConfiguration', iOS: (false, (14, 0, 0)));
  }


}

late final _sel_defaultContentConfiguration = objc.registerName("defaultContentConfiguration");

/// WARNING: UIContentConfiguration is a stub. To generate bindings for this class, include
/// UIContentConfiguration in your config's objc-protocols list.
///
/// UIContentConfiguration
extension type UIContentConfiguration._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol, objc.NSCopying {
  /// Constructs a [UIContentConfiguration] that points to the same underlying object as [other].
  UIContentConfiguration.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIContentConfiguration] that wraps the given raw object pointer.
  UIContentConfiguration.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_contentConfiguration = objc.registerName("contentConfiguration");
late final _sel_setContentConfiguration_ = objc.registerName("setContentConfiguration:");
late final _sel_automaticallyUpdatesContentConfiguration = objc.registerName("automaticallyUpdatesContentConfiguration");
late final _sel_setAutomaticallyUpdatesContentConfiguration_ = objc.registerName("setAutomaticallyUpdatesContentConfiguration:");
late final _sel_contentView = objc.registerName("contentView");
late final _sel_imageView = objc.registerName("imageView");

/// WARNING: UILabel is a stub. To generate bindings for this class, include
/// UILabel in your config's objc-interfaces list.
///
/// UILabel
extension type UILabel._(objc.ObjCObject object$) implements objc.ObjCObject,UIView,objc.NSCoding,UIContentSizeCategoryAdjusting,UILetterformAwareAdjusting {
  /// Constructs a [UILabel] that points to the same underlying object as [other].
  UILabel.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UILabel', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UILabel] that wraps the given raw object pointer.
  UILabel.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILabel', iOS: (false, (2, 0, 0)));
  }


}

late final _sel_textLabel = objc.registerName("textLabel");
late final _sel_detailTextLabel = objc.registerName("detailTextLabel");
late final _sel_defaultBackgroundConfiguration = objc.registerName("defaultBackgroundConfiguration");
late final _sel_backgroundConfiguration = objc.registerName("backgroundConfiguration");
late final _sel_setBackgroundConfiguration_ = objc.registerName("setBackgroundConfiguration:");
late final _sel_automaticallyUpdatesBackgroundConfiguration = objc.registerName("automaticallyUpdatesBackgroundConfiguration");
late final _sel_setAutomaticallyUpdatesBackgroundConfiguration_ = objc.registerName("setAutomaticallyUpdatesBackgroundConfiguration:");
late final _sel_backgroundView = objc.registerName("backgroundView");
late final _sel_setBackgroundView_ = objc.registerName("setBackgroundView:");
late final _sel_selectedBackgroundView = objc.registerName("selectedBackgroundView");
late final _sel_setSelectedBackgroundView_ = objc.registerName("setSelectedBackgroundView:");
late final _sel_multipleSelectionBackgroundView = objc.registerName("multipleSelectionBackgroundView");
late final _sel_setMultipleSelectionBackgroundView_ = objc.registerName("setMultipleSelectionBackgroundView:");
late final _sel_reuseIdentifier = objc.registerName("reuseIdentifier");
late final _sel_prepareForReuse = objc.registerName("prepareForReuse");
late final _sel_selectionStyle = objc.registerName("selectionStyle");
final _objc_msgSend_1d2lxkb = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setSelectionStyle_ = objc.registerName("setSelectionStyle:");
final _objc_msgSend_1uwq2nz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_setSelected_animated_ = objc.registerName("setSelected:animated:");
final _objc_msgSend_14iqu8t = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Bool , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , bool , bool )>();
late final _sel_setHighlighted_animated_ = objc.registerName("setHighlighted:animated:");
late final _sel_editingStyle = objc.registerName("editingStyle");
final _objc_msgSend_rz99rt = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_showsReorderControl = objc.registerName("showsReorderControl");
late final _sel_setShowsReorderControl_ = objc.registerName("setShowsReorderControl:");
late final _sel_shouldIndentWhileEditing = objc.registerName("shouldIndentWhileEditing");
late final _sel_setShouldIndentWhileEditing_ = objc.registerName("setShouldIndentWhileEditing:");
late final _sel_accessoryType = objc.registerName("accessoryType");
final _objc_msgSend_1vg5j0q = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setAccessoryType_ = objc.registerName("setAccessoryType:");
final _objc_msgSend_c8nyto = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_accessoryView = objc.registerName("accessoryView");
late final _sel_setAccessoryView_ = objc.registerName("setAccessoryView:");
late final _sel_editingAccessoryType = objc.registerName("editingAccessoryType");
late final _sel_setEditingAccessoryType_ = objc.registerName("setEditingAccessoryType:");
late final _sel_editingAccessoryView = objc.registerName("editingAccessoryView");
late final _sel_setEditingAccessoryView_ = objc.registerName("setEditingAccessoryView:");
late final _sel_indentationLevel = objc.registerName("indentationLevel");
late final _sel_setIndentationLevel_ = objc.registerName("setIndentationLevel:");
late final _sel_indentationWidth = objc.registerName("indentationWidth");
late final _sel_setIndentationWidth_ = objc.registerName("setIndentationWidth:");
late final _sel_separatorInset = objc.registerName("separatorInset");
late final _sel_setSeparatorInset_ = objc.registerName("setSeparatorInset:");
late final _sel_setEditing_animated_ = objc.registerName("setEditing:animated:");
late final _sel_showingDeleteConfirmation = objc.registerName("showingDeleteConfirmation");
late final _sel_focusStyle = objc.registerName("focusStyle");
final _objc_msgSend_1o6ymet = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setFocusStyle_ = objc.registerName("setFocusStyle:");
final _objc_msgSend_tbdrv1 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_willTransitionToState_ = objc.registerName("willTransitionToState:");
final _objc_msgSend_ipxvh9 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_didTransitionToState_ = objc.registerName("didTransitionToState:");
late final _sel_dragStateDidChange_ = objc.registerName("dragStateDidChange:");
final _objc_msgSend_c54vyn = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_userInteractionEnabledWhileDragging = objc.registerName("userInteractionEnabledWhileDragging");
late final _sel_setUserInteractionEnabledWhileDragging_ = objc.registerName("setUserInteractionEnabledWhileDragging:");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)> fromFunction(bool Function(ffi.Pointer<ffi.Void> , UIGestureRecognizer ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, UIGestureRecognizer.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_ = objc.registerName("gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:");
final _objc_msgSend_1lsax7n = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)> fromFunction(bool Function(ffi.Pointer<ffi.Void> , UIGestureRecognizer , UIGestureRecognizer ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UIGestureRecognizer.fromPointer(arg1, retain: true, release: true), UIGestureRecognizer.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1, UIGestureRecognizer arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_ = objc.registerName("gestureRecognizer:shouldRequireFailureOfGestureRecognizer:");
late final _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_ = objc.registerName("gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:");
late final _sel_gestureRecognizer_shouldReceiveTouch_ = objc.registerName("gestureRecognizer:shouldReceiveTouch:");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)> fromFunction(bool Function(ffi.Pointer<ffi.Void> , UIGestureRecognizer , UITouch ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UIGestureRecognizer.fromPointer(arg1, retain: true, release: true), UITouch.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1, UITouch arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}


/// WARNING: UIPress is a stub. To generate bindings for this class, include
/// UIPress in your config's objc-interfaces list.
///
/// UIPress
extension type UIPress._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UIPress] that points to the same underlying object as [other].
  UIPress.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPress', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIPress] that wraps the given raw object pointer.
  UIPress.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPress', iOS: (false, (9, 0, 0)));
  }


}

late final _sel_gestureRecognizer_shouldReceivePress_ = objc.registerName("gestureRecognizer:shouldReceivePress:");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)> fromFunction(bool Function(ffi.Pointer<ffi.Void> , UIGestureRecognizer , UIPress ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UIGestureRecognizer.fromPointer(arg1, retain: true, release: true), UIPress.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1, UIPress arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_gestureRecognizer_shouldReceiveEvent_ = objc.registerName("gestureRecognizer:shouldReceiveEvent:");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)> fromFunction(bool Function(ffi.Pointer<ffi.Void> , UIGestureRecognizer , UIEvent ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0, UIGestureRecognizer.fromPointer(arg1, retain: true, release: true), UIEvent.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1, UIEvent arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_initWithFrame_reuseIdentifier_ = objc.registerName("initWithFrame:reuseIdentifier:");
final _objc_msgSend_gxusyk = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_text = objc.registerName("text");
late final _sel_setText_ = objc.registerName("setText:");
late final _sel_font = objc.registerName("font");
late final _sel_setFont_ = objc.registerName("setFont:");
late final _sel_textAlignment = objc.registerName("textAlignment");
final _objc_msgSend_buxwfm = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setTextAlignment_ = objc.registerName("setTextAlignment:");
final _objc_msgSend_12huos = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_lineBreakMode = objc.registerName("lineBreakMode");
final _objc_msgSend_ybsdio = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setLineBreakMode_ = objc.registerName("setLineBreakMode:");
final _objc_msgSend_1kdet46 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_textColor = objc.registerName("textColor");
late final _sel_setTextColor_ = objc.registerName("setTextColor:");
late final _sel_selectedTextColor = objc.registerName("selectedTextColor");
late final _sel_setSelectedTextColor_ = objc.registerName("setSelectedTextColor:");
late final _sel_hidesAccessoryWhenEditing = objc.registerName("hidesAccessoryWhenEditing");
late final _sel_setHidesAccessoryWhenEditing_ = objc.registerName("setHidesAccessoryWhenEditing:");
late final _sel_target = objc.registerName("target");
late final _sel_setTarget_ = objc.registerName("setTarget:");
late final _sel_editAction = objc.registerName("editAction");
final _objc_msgSend_1ovaulg = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setEditAction_ = objc.registerName("setEditAction:");
late final _sel_accessoryAction = objc.registerName("accessoryAction");
late final _sel_setAccessoryAction_ = objc.registerName("setAccessoryAction:");

/// UIDeprecated
extension UIDeprecated on UITableViewCell {

  /// accessoryAction
  ffi.Pointer<objc.ObjCSelector> get accessoryAction {
  objc.checkOsVersionInternal('UITableViewCell.accessoryAction', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1ovaulg(object$.ref.pointer, _sel_accessoryAction);

  }


  /// editAction
  ffi.Pointer<objc.ObjCSelector> get editAction {
  objc.checkOsVersionInternal('UITableViewCell.editAction', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1ovaulg(object$.ref.pointer, _sel_editAction);

  }


  /// font
  UIFont? get font {
  objc.checkOsVersionInternal('UITableViewCell.font', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_font);
    return $ret.address == 0 ? null : UIFont.fromPointer($ret, retain: true, release: true);
  }


  /// hidesAccessoryWhenEditing
  bool get hidesAccessoryWhenEditing {
  objc.checkOsVersionInternal('UITableViewCell.hidesAccessoryWhenEditing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_hidesAccessoryWhenEditing);

  }


  /// image
  UIImage? get image {
  objc.checkOsVersionInternal('UITableViewCell.image', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_image);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// initWithFrame:reuseIdentifier:
  objc.ObjCObject initWithFrame$1(objc.CGRect frame, {objc.NSString? reuseIdentifier}) {
  objc.checkOsVersionInternal('UITableViewCell.initWithFrame:reuseIdentifier:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_gxusyk(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_reuseIdentifier_, frame, reuseIdentifier?.ref.pointer ?? ffi.nullptr);
    return objc.ObjCObject($ret, retain: false, release: true);
  }


  /// lineBreakMode
  int get lineBreakMode {
  objc.checkOsVersionInternal('UITableViewCell.lineBreakMode', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_ybsdio(object$.ref.pointer, _sel_lineBreakMode);

  }


  /// selectedImage
  UIImage? get selectedImage {
  objc.checkOsVersionInternal('UITableViewCell.selectedImage', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_selectedImage);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// selectedTextColor
  UIColor? get selectedTextColor {
  objc.checkOsVersionInternal('UITableViewCell.selectedTextColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_selectedTextColor);
    return $ret.address == 0 ? null : UIColor.fromPointer($ret, retain: true, release: true);
  }


  /// setAccessoryAction:
  set accessoryAction(ffi.Pointer<objc.ObjCSelector> value) {
  objc.checkOsVersionInternal('UITableViewCell.setAccessoryAction:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1d9e4oe(object$.ref.pointer, _sel_setAccessoryAction_, value);

  }


  /// setEditAction:
  set editAction(ffi.Pointer<objc.ObjCSelector> value) {
  objc.checkOsVersionInternal('UITableViewCell.setEditAction:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1d9e4oe(object$.ref.pointer, _sel_setEditAction_, value);

  }


  /// setFont:
  set font(UIFont? value) {
  objc.checkOsVersionInternal('UITableViewCell.setFont:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFont_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setHidesAccessoryWhenEditing:
  set hidesAccessoryWhenEditing(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setHidesAccessoryWhenEditing:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHidesAccessoryWhenEditing_, value);

  }


  /// setImage:
  set image(UIImage? value) {
  objc.checkOsVersionInternal('UITableViewCell.setImage:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setLineBreakMode:
  set lineBreakMode(int value) {
  objc.checkOsVersionInternal('UITableViewCell.setLineBreakMode:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1kdet46(object$.ref.pointer, _sel_setLineBreakMode_, value);

  }


  /// setSelectedImage:
  set selectedImage(UIImage? value) {
  objc.checkOsVersionInternal('UITableViewCell.setSelectedImage:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSelectedImage_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setSelectedTextColor:
  set selectedTextColor(UIColor? value) {
  objc.checkOsVersionInternal('UITableViewCell.setSelectedTextColor:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSelectedTextColor_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setTarget:
  set target(objc.ObjCObject? value) {
  objc.checkOsVersionInternal('UITableViewCell.setTarget:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTarget_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setText:
  set text(objc.NSString? value) {
  objc.checkOsVersionInternal('UITableViewCell.setText:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setText_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setTextAlignment:
  set textAlignment(int value) {
  objc.checkOsVersionInternal('UITableViewCell.setTextAlignment:', iOS: (false, (2, 0, 0)));
_objc_msgSend_12huos(object$.ref.pointer, _sel_setTextAlignment_, value);

  }


  /// setTextColor:
  set textColor(UIColor? value) {
  objc.checkOsVersionInternal('UITableViewCell.setTextColor:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextColor_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// target
  objc.ObjCObject? get target {
  objc.checkOsVersionInternal('UITableViewCell.target', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_target);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// text
  objc.NSString? get text {
  objc.checkOsVersionInternal('UITableViewCell.text', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_text);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// textAlignment
  int get textAlignment {
  objc.checkOsVersionInternal('UITableViewCell.textAlignment', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_buxwfm(object$.ref.pointer, _sel_textAlignment);

  }


  /// textColor
  UIColor? get textColor {
  objc.checkOsVersionInternal('UITableViewCell.textColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textColor);
    return $ret.address == 0 ? null : UIColor.fromPointer($ret, retain: true, release: true);
  }

}


/// UITableViewCell
extension type UITableViewCell._(objc.ObjCObject object$) implements objc.ObjCObject,UIView,objc.NSCoding,UIGestureRecognizerDelegate {
  /// Constructs a [UITableViewCell] that points to the same underlying object as [other].
  UITableViewCell.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITableViewCell', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UITableViewCell] that wraps the given raw object pointer.
  UITableViewCell.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITableViewCell', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UITableViewCell].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UITableViewCell);

  /// alloc
  static UITableViewCell alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_alloc);
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UITableViewCell allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UITableViewCell, _sel_allocWithZone_, zone);
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }


  /// appearance
  static UITableViewCell appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_appearance);
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:
  static UITableViewCell appearanceForTraitCollection(UITraitCollection trait) {
  objc.checkOsVersionInternal('UITableViewCell.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UITableViewCell, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedIn:
  static UITableViewCell appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
  objc.checkOsVersionInternal('UITableViewCell.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UITableViewCell, _sel_appearanceForTraitCollection_whenContainedIn_, trait.ref.pointer, whenContainedIn?.ref.pointer ?? ffi.nullptr);
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UITableViewCell appearanceForTraitCollection$2(UITraitCollection trait, {required objc.NSArray whenContainedInInstancesOfClasses}) {
  objc.checkOsVersionInternal('UITableViewCell.appearanceForTraitCollection:whenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UITableViewCell, _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_, trait.ref.pointer, whenContainedInInstancesOfClasses.ref.pointer);
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedIn:
  static UITableViewCell appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
  objc.checkOsVersionInternal('UITableViewCell.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UITableViewCell, _sel_appearanceWhenContainedIn_, ContainerClass?.ref.pointer ?? ffi.nullptr);
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedInInstancesOfClasses:
  static UITableViewCell appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
  objc.checkOsVersionInternal('UITableViewCell.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UITableViewCell, _sel_appearanceWhenContainedInInstancesOfClasses_, containerTypes.ref.pointer);
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }


  /// layerClass
  static objc.ObjCObject getLayerClass() {
  objc.checkOsVersionInternal('UITableViewCell.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// new
  static UITableViewCell new$() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_new);
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute(int attribute) {
  objc.checkOsVersionInternal('UITableViewCell.userInterfaceLayoutDirectionForSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_racczx(_class_UITableViewCell, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_, attribute);

  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute$1(int semanticContentAttribute, {required int relativeToLayoutDirection}) {
  objc.checkOsVersionInternal('UITableViewCell.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_tz4p54(_class_UITableViewCell, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_, semanticContentAttribute, relativeToLayoutDirection);

  }
  /// Returns a new instance of UITableViewCell constructed with the default `new` method.
  UITableViewCell() : this.as(new$().object$);

}

extension UITableViewCell$Methods on UITableViewCell {

  /// accessoryType
  int get accessoryType {
  objc.checkOsVersionInternal('UITableViewCell.accessoryType', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1vg5j0q(object$.ref.pointer, _sel_accessoryType);

  }


  /// accessoryView
  UIView? get accessoryView {
  objc.checkOsVersionInternal('UITableViewCell.accessoryView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_accessoryView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// automaticallyUpdatesBackgroundConfiguration
  bool get automaticallyUpdatesBackgroundConfiguration {
  objc.checkOsVersionInternal('UITableViewCell.automaticallyUpdatesBackgroundConfiguration', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_automaticallyUpdatesBackgroundConfiguration);

  }


  /// automaticallyUpdatesContentConfiguration
  bool get automaticallyUpdatesContentConfiguration {
  objc.checkOsVersionInternal('UITableViewCell.automaticallyUpdatesContentConfiguration', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_automaticallyUpdatesContentConfiguration);

  }


  /// backgroundConfiguration
  UIBackgroundConfiguration? get backgroundConfiguration {
  objc.checkOsVersionInternal('UITableViewCell.backgroundConfiguration', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_backgroundConfiguration);
    return $ret.address == 0 ? null : UIBackgroundConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// backgroundView
  UIView? get backgroundView {
  objc.checkOsVersionInternal('UITableViewCell.backgroundView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_backgroundView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// configurationState
  UICellConfigurationState get configurationState {
  objc.checkOsVersionInternal('UITableViewCell.configurationState', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_configurationState);
    return UICellConfigurationState.fromPointer($ret, retain: true, release: true);
  }


  /// configurationUpdateHandler
  objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>? get configurationUpdateHandler {
  objc.checkOsVersionInternal('UITableViewCell.configurationUpdateHandler', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_uwvaik(object$.ref.pointer, _sel_configurationUpdateHandler);
    return $ret.address == 0 ? null : ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState.fromPointer($ret, retain: true, release: true);
  }


  /// contentConfiguration
  UIContentConfiguration? get contentConfiguration {
  objc.checkOsVersionInternal('UITableViewCell.contentConfiguration', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentConfiguration);
    return $ret.address == 0 ? null : UIContentConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// contentView
  UIView get contentView {
  objc.checkOsVersionInternal('UITableViewCell.contentView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentView);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// defaultBackgroundConfiguration
  UIBackgroundConfiguration defaultBackgroundConfiguration() {
  objc.checkOsVersionInternal('UITableViewCell.defaultBackgroundConfiguration', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_defaultBackgroundConfiguration);
    return UIBackgroundConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// defaultContentConfiguration
  UIListContentConfiguration defaultContentConfiguration() {
  objc.checkOsVersionInternal('UITableViewCell.defaultContentConfiguration', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_defaultContentConfiguration);
    return UIListContentConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// detailTextLabel
  UILabel? get detailTextLabel {
  objc.checkOsVersionInternal('UITableViewCell.detailTextLabel', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_detailTextLabel);
    return $ret.address == 0 ? null : UILabel.fromPointer($ret, retain: true, release: true);
  }


  /// didTransitionToState:
  void didTransitionToState(int state) {
  objc.checkOsVersionInternal('UITableViewCell.didTransitionToState:', iOS: (false, (3, 0, 0)));
_objc_msgSend_ipxvh9(object$.ref.pointer, _sel_didTransitionToState_, state);

  }


  /// dragStateDidChange:
  void dragStateDidChange(int dragState) {
  objc.checkOsVersionInternal('UITableViewCell.dragStateDidChange:', iOS: (false, (11, 0, 0)));
_objc_msgSend_c54vyn(object$.ref.pointer, _sel_dragStateDidChange_, dragState);

  }


  /// editingAccessoryType
  int get editingAccessoryType {
  objc.checkOsVersionInternal('UITableViewCell.editingAccessoryType', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1vg5j0q(object$.ref.pointer, _sel_editingAccessoryType);

  }


  /// editingAccessoryView
  UIView? get editingAccessoryView {
  objc.checkOsVersionInternal('UITableViewCell.editingAccessoryView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_editingAccessoryView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// editingStyle
  int get editingStyle {
  objc.checkOsVersionInternal('UITableViewCell.editingStyle', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_rz99rt(object$.ref.pointer, _sel_editingStyle);

  }


  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// focusStyle
  int get focusStyle {
  objc.checkOsVersionInternal('UITableViewCell.focusStyle', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_1o6ymet(object$.ref.pointer, _sel_focusStyle);

  }


  /// gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:
  bool gestureRecognizer(UIGestureRecognizer gestureRecognizer, {required UIGestureRecognizer shouldBeRequiredToFailByGestureRecognizer}) {
  objc.checkOsVersionInternal('UITableViewCell.gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:', iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell', 'gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:');
    }
    return _objc_msgSend_1lsax7n(object$.ref.pointer, _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_, gestureRecognizer.ref.pointer, shouldBeRequiredToFailByGestureRecognizer.ref.pointer);

  }


  /// gestureRecognizer:shouldReceiveEvent:
  bool gestureRecognizer$1(UIGestureRecognizer gestureRecognizer, {required UIEvent shouldReceiveEvent}) {
  objc.checkOsVersionInternal('UITableViewCell.gestureRecognizer:shouldReceiveEvent:', iOS: (false, (13, 4, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_gestureRecognizer_shouldReceiveEvent_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell', 'gestureRecognizer:shouldReceiveEvent:');
    }
    return _objc_msgSend_1lsax7n(object$.ref.pointer, _sel_gestureRecognizer_shouldReceiveEvent_, gestureRecognizer.ref.pointer, shouldReceiveEvent.ref.pointer);

  }


  /// gestureRecognizer:shouldReceivePress:
  bool gestureRecognizer$2(UIGestureRecognizer gestureRecognizer, {required UIPress shouldReceivePress}) {
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_gestureRecognizer_shouldReceivePress_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell', 'gestureRecognizer:shouldReceivePress:');
    }
    return _objc_msgSend_1lsax7n(object$.ref.pointer, _sel_gestureRecognizer_shouldReceivePress_, gestureRecognizer.ref.pointer, shouldReceivePress.ref.pointer);

  }


  /// gestureRecognizer:shouldReceiveTouch:
  bool gestureRecognizer$3(UIGestureRecognizer gestureRecognizer, {required UITouch shouldReceiveTouch}) {
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_gestureRecognizer_shouldReceiveTouch_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell', 'gestureRecognizer:shouldReceiveTouch:');
    }
    return _objc_msgSend_1lsax7n(object$.ref.pointer, _sel_gestureRecognizer_shouldReceiveTouch_, gestureRecognizer.ref.pointer, shouldReceiveTouch.ref.pointer);

  }


  /// gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:
  bool gestureRecognizer$4(UIGestureRecognizer gestureRecognizer, {required UIGestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer}) {
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell', 'gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:');
    }
    return _objc_msgSend_1lsax7n(object$.ref.pointer, _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_, gestureRecognizer.ref.pointer, shouldRecognizeSimultaneouslyWithGestureRecognizer.ref.pointer);

  }


  /// gestureRecognizer:shouldRequireFailureOfGestureRecognizer:
  bool gestureRecognizer$5(UIGestureRecognizer gestureRecognizer, {required UIGestureRecognizer shouldRequireFailureOfGestureRecognizer}) {
  objc.checkOsVersionInternal('UITableViewCell.gestureRecognizer:shouldRequireFailureOfGestureRecognizer:', iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell', 'gestureRecognizer:shouldRequireFailureOfGestureRecognizer:');
    }
    return _objc_msgSend_1lsax7n(object$.ref.pointer, _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_, gestureRecognizer.ref.pointer, shouldRequireFailureOfGestureRecognizer.ref.pointer);

  }


  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_gestureRecognizerShouldBegin_)) {
      throw objc.UnimplementedOptionalMethodException('UITableViewCell', 'gestureRecognizerShouldBegin:');
    }
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_gestureRecognizerShouldBegin_, gestureRecognizer.ref.pointer);

  }


  /// imageView
  UIImageView? get imageView {
  objc.checkOsVersionInternal('UITableViewCell.imageView', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageView);
    return $ret.address == 0 ? null : UIImageView.fromPointer($ret, retain: true, release: true);
  }


  /// indentationLevel
  int get indentationLevel {
  objc.checkOsVersionInternal('UITableViewCell.indentationLevel', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_indentationLevel);

  }


  /// indentationWidth
  double get indentationWidth {
  objc.checkOsVersionInternal('UITableViewCell.indentationWidth', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_indentationWidth) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_indentationWidth);

  }


  /// init
  UITableViewCell init() {
  objc.checkOsVersionInternal('UITableViewCell.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UITableViewCell? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UITableViewCell.fromPointer($ret, retain: false, release: true);
  }


  /// initWithFrame:
  UITableViewCell initWithFrame(objc.CGRect frame) {
  objc.checkOsVersionInternal('UITableViewCell.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }


  /// initWithStyle:reuseIdentifier:
  UITableViewCell initWithStyle(int style, {objc.NSString? reuseIdentifier}) {
  objc.checkOsVersionInternal('UITableViewCell.initWithStyle:reuseIdentifier:', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_96u4vv(object$.ref.retainAndReturnPointer(), _sel_initWithStyle_reuseIdentifier_, style, reuseIdentifier?.ref.pointer ?? ffi.nullptr);
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }


  /// isEditing
  bool get isEditing {
  objc.checkOsVersionInternal('UITableViewCell.isEditing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isEditing);

  }


  /// isHighlighted
  bool get isHighlighted {
  objc.checkOsVersionInternal('UITableViewCell.isHighlighted', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHighlighted);

  }


  /// isSelected
  bool get isSelected {
  objc.checkOsVersionInternal('UITableViewCell.isSelected', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSelected);

  }


  /// multipleSelectionBackgroundView
  UIView? get multipleSelectionBackgroundView {
  objc.checkOsVersionInternal('UITableViewCell.multipleSelectionBackgroundView', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_multipleSelectionBackgroundView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// prepareForReuse
  void prepareForReuse() {
  objc.checkOsVersionInternal('UITableViewCell.prepareForReuse', iOS: (false, (2, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_prepareForReuse);

  }


  /// reuseIdentifier
  objc.NSString? get reuseIdentifier {
  objc.checkOsVersionInternal('UITableViewCell.reuseIdentifier', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_reuseIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// selectedBackgroundView
  UIView? get selectedBackgroundView {
  objc.checkOsVersionInternal('UITableViewCell.selectedBackgroundView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_selectedBackgroundView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// selectionStyle
  int get selectionStyle {
  objc.checkOsVersionInternal('UITableViewCell.selectionStyle', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1d2lxkb(object$.ref.pointer, _sel_selectionStyle);

  }


  /// separatorInset
  UIEdgeInsets get separatorInset {
  objc.checkOsVersionInternal('UITableViewCell.separatorInset', iOS: (false, (7, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_separatorInset) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_separatorInset);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// setAccessoryType:
  set accessoryType(int value) {
  objc.checkOsVersionInternal('UITableViewCell.setAccessoryType:', iOS: (false, (2, 0, 0)));
_objc_msgSend_c8nyto(object$.ref.pointer, _sel_setAccessoryType_, value);

  }


  /// setAccessoryView:
  set accessoryView(UIView? value) {
  objc.checkOsVersionInternal('UITableViewCell.setAccessoryView:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAccessoryView_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setAutomaticallyUpdatesBackgroundConfiguration:
  set automaticallyUpdatesBackgroundConfiguration(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setAutomaticallyUpdatesBackgroundConfiguration:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAutomaticallyUpdatesBackgroundConfiguration_, value);

  }


  /// setAutomaticallyUpdatesContentConfiguration:
  set automaticallyUpdatesContentConfiguration(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setAutomaticallyUpdatesContentConfiguration:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAutomaticallyUpdatesContentConfiguration_, value);

  }


  /// setBackgroundConfiguration:
  set backgroundConfiguration(UIBackgroundConfiguration? value) {
  objc.checkOsVersionInternal('UITableViewCell.setBackgroundConfiguration:', iOS: (false, (14, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBackgroundConfiguration_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setBackgroundView:
  set backgroundView(UIView? value) {
  objc.checkOsVersionInternal('UITableViewCell.setBackgroundView:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBackgroundView_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setConfigurationUpdateHandler:
  set configurationUpdateHandler(objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>? value) {
  objc.checkOsVersionInternal('UITableViewCell.setConfigurationUpdateHandler:', iOS: (false, (15, 0, 0)));
_objc_msgSend_f167m6(object$.ref.pointer, _sel_setConfigurationUpdateHandler_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setContentConfiguration:
  set contentConfiguration(UIContentConfiguration? value) {
  objc.checkOsVersionInternal('UITableViewCell.setContentConfiguration:', iOS: (false, (14, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setContentConfiguration_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setEditing:
  set isEditing(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setEditing:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setEditing_, value);

  }


  /// setEditing:animated:
  void setEditing(bool editing, {required bool animated}) {
  objc.checkOsVersionInternal('UITableViewCell.setEditing:animated:', iOS: (false, (2, 0, 0)));
_objc_msgSend_14iqu8t(object$.ref.pointer, _sel_setEditing_animated_, editing, animated);

  }


  /// setEditingAccessoryType:
  set editingAccessoryType(int value) {
  objc.checkOsVersionInternal('UITableViewCell.setEditingAccessoryType:', iOS: (false, (2, 0, 0)));
_objc_msgSend_c8nyto(object$.ref.pointer, _sel_setEditingAccessoryType_, value);

  }


  /// setEditingAccessoryView:
  set editingAccessoryView(UIView? value) {
  objc.checkOsVersionInternal('UITableViewCell.setEditingAccessoryView:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setEditingAccessoryView_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setFocusStyle:
  set focusStyle(int value) {
  objc.checkOsVersionInternal('UITableViewCell.setFocusStyle:', iOS: (false, (9, 0, 0)));
_objc_msgSend_tbdrv1(object$.ref.pointer, _sel_setFocusStyle_, value);

  }


  /// setHighlighted:
  set isHighlighted(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setHighlighted:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHighlighted_, value);

  }


  /// setHighlighted:animated:
  void setHighlighted(bool highlighted, {required bool animated}) {
  objc.checkOsVersionInternal('UITableViewCell.setHighlighted:animated:', iOS: (false, (2, 0, 0)));
_objc_msgSend_14iqu8t(object$.ref.pointer, _sel_setHighlighted_animated_, highlighted, animated);

  }


  /// setIndentationLevel:
  set indentationLevel(int value) {
  objc.checkOsVersionInternal('UITableViewCell.setIndentationLevel:', iOS: (false, (2, 0, 0)));
_objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setIndentationLevel_, value);

  }


  /// setIndentationWidth:
  set indentationWidth(double value) {
  objc.checkOsVersionInternal('UITableViewCell.setIndentationWidth:', iOS: (false, (2, 0, 0)));
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setIndentationWidth_, value);

  }


  /// setMultipleSelectionBackgroundView:
  set multipleSelectionBackgroundView(UIView? value) {
  objc.checkOsVersionInternal('UITableViewCell.setMultipleSelectionBackgroundView:', iOS: (false, (5, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMultipleSelectionBackgroundView_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setNeedsUpdateConfiguration
  void setNeedsUpdateConfiguration() {
  objc.checkOsVersionInternal('UITableViewCell.setNeedsUpdateConfiguration', iOS: (false, (14, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsUpdateConfiguration);

  }


  /// setSelected:
  set isSelected(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setSelected:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setSelected_, value);

  }


  /// setSelected:animated:
  void setSelected(bool selected, {required bool animated}) {
  objc.checkOsVersionInternal('UITableViewCell.setSelected:animated:', iOS: (false, (2, 0, 0)));
_objc_msgSend_14iqu8t(object$.ref.pointer, _sel_setSelected_animated_, selected, animated);

  }


  /// setSelectedBackgroundView:
  set selectedBackgroundView(UIView? value) {
  objc.checkOsVersionInternal('UITableViewCell.setSelectedBackgroundView:', iOS: (false, (2, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSelectedBackgroundView_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setSelectionStyle:
  set selectionStyle(int value) {
  objc.checkOsVersionInternal('UITableViewCell.setSelectionStyle:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1uwq2nz(object$.ref.pointer, _sel_setSelectionStyle_, value);

  }


  /// setSeparatorInset:
  set separatorInset(UIEdgeInsets value) {
  objc.checkOsVersionInternal('UITableViewCell.setSeparatorInset:', iOS: (false, (7, 0, 0)));
_objc_msgSend_1g8fos5(object$.ref.pointer, _sel_setSeparatorInset_, value);

  }


  /// setShouldIndentWhileEditing:
  set shouldIndentWhileEditing(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setShouldIndentWhileEditing:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShouldIndentWhileEditing_, value);

  }


  /// setShowsReorderControl:
  set showsReorderControl(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setShowsReorderControl:', iOS: (false, (2, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsReorderControl_, value);

  }


  /// setUserInteractionEnabledWhileDragging:
  set userInteractionEnabledWhileDragging(bool value) {
  objc.checkOsVersionInternal('UITableViewCell.setUserInteractionEnabledWhileDragging:', iOS: (false, (11, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setUserInteractionEnabledWhileDragging_, value);

  }


  /// shouldIndentWhileEditing
  bool get shouldIndentWhileEditing {
  objc.checkOsVersionInternal('UITableViewCell.shouldIndentWhileEditing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_shouldIndentWhileEditing);

  }


  /// showingDeleteConfirmation
  bool get showingDeleteConfirmation {
  objc.checkOsVersionInternal('UITableViewCell.showingDeleteConfirmation', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showingDeleteConfirmation);

  }


  /// showsReorderControl
  bool get showsReorderControl {
  objc.checkOsVersionInternal('UITableViewCell.showsReorderControl', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsReorderControl);

  }


  /// textLabel
  UILabel? get textLabel {
  objc.checkOsVersionInternal('UITableViewCell.textLabel', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textLabel);
    return $ret.address == 0 ? null : UILabel.fromPointer($ret, retain: true, release: true);
  }


  /// updateConfigurationUsingState:
  void updateConfigurationUsingState(UICellConfigurationState state) {
  objc.checkOsVersionInternal('UITableViewCell.updateConfigurationUsingState:', iOS: (false, (14, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_updateConfigurationUsingState_, state.ref.pointer);

  }


  /// userInteractionEnabledWhileDragging
  bool get userInteractionEnabledWhileDragging {
  objc.checkOsVersionInternal('UITableViewCell.userInteractionEnabledWhileDragging', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_userInteractionEnabledWhileDragging);

  }


  /// willTransitionToState:
  void willTransitionToState(int state) {
  objc.checkOsVersionInternal('UITableViewCell.willTransitionToState:', iOS: (false, (3, 0, 0)));
_objc_msgSend_ipxvh9(object$.ref.pointer, _sel_willTransitionToState_, state);

  }

}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>`.
abstract final class ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> fromFunction(void Function(UITableViewCell , UICellConfigurationState ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITableViewCell.fromPointer(arg0, retain: true, release: true), UICellConfigurationState.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> listener(void Function(UITableViewCell , UICellConfigurationState ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITableViewCell.fromPointer(arg0, retain: false, release: true), UICellConfigurationState.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> blocking(void Function(UITableViewCell , UICellConfigurationState ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITableViewCell.fromPointer(arg0, retain: false, release: true), UICellConfigurationState.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITableViewCell.fromPointer(arg0, retain: false, release: true), UICellConfigurationState.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>`.
extension ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState$CallExtension on objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)> {
  void call(UITableViewCell arg0, UICellConfigurationState arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

sealed class UITableViewStyle {
  static const UITableViewStylePlain = 0;
  static const UITableViewStyleGrouped = 1;
  static const UITableViewStyleInsetGrouped = 2;}

sealed class UITableViewScrollPosition {
  static const UITableViewScrollPositionNone = 0;
  static const UITableViewScrollPositionTop = 1;
  static const UITableViewScrollPositionMiddle = 2;
  static const UITableViewScrollPositionBottom = 3;}

sealed class UITableViewRowAnimation {
  static const UITableViewRowAnimationFade = 0;
  static const UITableViewRowAnimationRight = 1;
  static const UITableViewRowAnimationLeft = 2;
  static const UITableViewRowAnimationTop = 3;
  static const UITableViewRowAnimationBottom = 4;
  static const UITableViewRowAnimationNone = 5;
  static const UITableViewRowAnimationMiddle = 6;
  static const UITableViewRowAnimationAutomatic = 100;}

sealed class UITableViewContentHuggingElements {
  static const UITableViewContentHuggingElementsNone = 0;
  static const UITableViewContentHuggingElementsSectionHeaders = 1;}

sealed class UITableViewSeparatorInsetReference {
  static const UITableViewSeparatorInsetFromCellEdges = 0;
  static const UITableViewSeparatorInsetFromAutomaticInsets = 1;}

sealed class UITableViewSelfSizingInvalidation {
  static const UITableViewSelfSizingInvalidationDisabled = 0;
  static const UITableViewSelfSizingInvalidationEnabled = 1;
  static const UITableViewSelfSizingInvalidationEnabledIncludingConstraints = 2;}

sealed class UITableViewDropIntent {
  static const UITableViewDropIntentUnspecified = 0;
  static const UITableViewDropIntentInsertAtDestinationIndexPath = 1;
  static const UITableViewDropIntentInsertIntoDestinationIndexPath = 2;
  static const UITableViewDropIntentAutomatic = 3;}

sealed class UIListContentTextAlignment {
  static const UIListContentTextAlignmentNatural = 0;
  static const UIListContentTextAlignmentCenter = 1;
  static const UIListContentTextAlignmentJustified = 2;}

sealed class UIListContentTextTransform {
  static const UIListContentTextTransformNone = 0;
  static const UIListContentTextTransformUppercase = 1;
  static const UIListContentTextTransformLowercase = 2;
  static const UIListContentTextTransformCapitalized = 3;}

sealed class UIKeyboardHIDUsage {
  static const UIKeyboardHIDUsageKeyboardErrorRollOver = 1;
  static const UIKeyboardHIDUsageKeyboardPOSTFail = 2;
  static const UIKeyboardHIDUsageKeyboardErrorUndefined = 3;
  static const UIKeyboardHIDUsageKeyboardA = 4;
  static const UIKeyboardHIDUsageKeyboardB = 5;
  static const UIKeyboardHIDUsageKeyboardC = 6;
  static const UIKeyboardHIDUsageKeyboardD = 7;
  static const UIKeyboardHIDUsageKeyboardE = 8;
  static const UIKeyboardHIDUsageKeyboardF = 9;
  static const UIKeyboardHIDUsageKeyboardG = 10;
  static const UIKeyboardHIDUsageKeyboardH = 11;
  static const UIKeyboardHIDUsageKeyboardI = 12;
  static const UIKeyboardHIDUsageKeyboardJ = 13;
  static const UIKeyboardHIDUsageKeyboardK = 14;
  static const UIKeyboardHIDUsageKeyboardL = 15;
  static const UIKeyboardHIDUsageKeyboardM = 16;
  static const UIKeyboardHIDUsageKeyboardN = 17;
  static const UIKeyboardHIDUsageKeyboardO = 18;
  static const UIKeyboardHIDUsageKeyboardP = 19;
  static const UIKeyboardHIDUsageKeyboardQ = 20;
  static const UIKeyboardHIDUsageKeyboardR = 21;
  static const UIKeyboardHIDUsageKeyboardS = 22;
  static const UIKeyboardHIDUsageKeyboardT = 23;
  static const UIKeyboardHIDUsageKeyboardU = 24;
  static const UIKeyboardHIDUsageKeyboardV = 25;
  static const UIKeyboardHIDUsageKeyboardW = 26;
  static const UIKeyboardHIDUsageKeyboardX = 27;
  static const UIKeyboardHIDUsageKeyboardY = 28;
  static const UIKeyboardHIDUsageKeyboardZ = 29;
  static const UIKeyboardHIDUsageKeyboard1 = 30;
  static const UIKeyboardHIDUsageKeyboard2 = 31;
  static const UIKeyboardHIDUsageKeyboard3 = 32;
  static const UIKeyboardHIDUsageKeyboard4 = 33;
  static const UIKeyboardHIDUsageKeyboard5 = 34;
  static const UIKeyboardHIDUsageKeyboard6 = 35;
  static const UIKeyboardHIDUsageKeyboard7 = 36;
  static const UIKeyboardHIDUsageKeyboard8 = 37;
  static const UIKeyboardHIDUsageKeyboard9 = 38;
  static const UIKeyboardHIDUsageKeyboard0 = 39;
  static const UIKeyboardHIDUsageKeyboardReturnOrEnter = 40;
  static const UIKeyboardHIDUsageKeyboardEscape = 41;
  static const UIKeyboardHIDUsageKeyboardDeleteOrBackspace = 42;
  static const UIKeyboardHIDUsageKeyboardTab = 43;
  static const UIKeyboardHIDUsageKeyboardSpacebar = 44;
  static const UIKeyboardHIDUsageKeyboardHyphen = 45;
  static const UIKeyboardHIDUsageKeyboardEqualSign = 46;
  static const UIKeyboardHIDUsageKeyboardOpenBracket = 47;
  static const UIKeyboardHIDUsageKeyboardCloseBracket = 48;
  static const UIKeyboardHIDUsageKeyboardBackslash = 49;
  static const UIKeyboardHIDUsageKeyboardNonUSPound = 50;
  static const UIKeyboardHIDUsageKeyboardSemicolon = 51;
  static const UIKeyboardHIDUsageKeyboardQuote = 52;
  static const UIKeyboardHIDUsageKeyboardGraveAccentAndTilde = 53;
  static const UIKeyboardHIDUsageKeyboardComma = 54;
  static const UIKeyboardHIDUsageKeyboardPeriod = 55;
  static const UIKeyboardHIDUsageKeyboardSlash = 56;
  static const UIKeyboardHIDUsageKeyboardCapsLock = 57;
  static const UIKeyboardHIDUsageKeyboardF1 = 58;
  static const UIKeyboardHIDUsageKeyboardF2 = 59;
  static const UIKeyboardHIDUsageKeyboardF3 = 60;
  static const UIKeyboardHIDUsageKeyboardF4 = 61;
  static const UIKeyboardHIDUsageKeyboardF5 = 62;
  static const UIKeyboardHIDUsageKeyboardF6 = 63;
  static const UIKeyboardHIDUsageKeyboardF7 = 64;
  static const UIKeyboardHIDUsageKeyboardF8 = 65;
  static const UIKeyboardHIDUsageKeyboardF9 = 66;
  static const UIKeyboardHIDUsageKeyboardF10 = 67;
  static const UIKeyboardHIDUsageKeyboardF11 = 68;
  static const UIKeyboardHIDUsageKeyboardF12 = 69;
  static const UIKeyboardHIDUsageKeyboardPrintScreen = 70;
  static const UIKeyboardHIDUsageKeyboardScrollLock = 71;
  static const UIKeyboardHIDUsageKeyboardPause = 72;
  static const UIKeyboardHIDUsageKeyboardInsert = 73;
  static const UIKeyboardHIDUsageKeyboardHome = 74;
  static const UIKeyboardHIDUsageKeyboardPageUp = 75;
  static const UIKeyboardHIDUsageKeyboardDeleteForward = 76;
  static const UIKeyboardHIDUsageKeyboardEnd = 77;
  static const UIKeyboardHIDUsageKeyboardPageDown = 78;
  static const UIKeyboardHIDUsageKeyboardRightArrow = 79;
  static const UIKeyboardHIDUsageKeyboardLeftArrow = 80;
  static const UIKeyboardHIDUsageKeyboardDownArrow = 81;
  static const UIKeyboardHIDUsageKeyboardUpArrow = 82;
  static const UIKeyboardHIDUsageKeypadNumLock = 83;
  static const UIKeyboardHIDUsageKeypadSlash = 84;
  static const UIKeyboardHIDUsageKeypadAsterisk = 85;
  static const UIKeyboardHIDUsageKeypadHyphen = 86;
  static const UIKeyboardHIDUsageKeypadPlus = 87;
  static const UIKeyboardHIDUsageKeypadEnter = 88;
  static const UIKeyboardHIDUsageKeypad1 = 89;
  static const UIKeyboardHIDUsageKeypad2 = 90;
  static const UIKeyboardHIDUsageKeypad3 = 91;
  static const UIKeyboardHIDUsageKeypad4 = 92;
  static const UIKeyboardHIDUsageKeypad5 = 93;
  static const UIKeyboardHIDUsageKeypad6 = 94;
  static const UIKeyboardHIDUsageKeypad7 = 95;
  static const UIKeyboardHIDUsageKeypad8 = 96;
  static const UIKeyboardHIDUsageKeypad9 = 97;
  static const UIKeyboardHIDUsageKeypad0 = 98;
  static const UIKeyboardHIDUsageKeypadPeriod = 99;
  static const UIKeyboardHIDUsageKeyboardNonUSBackslash = 100;
  static const UIKeyboardHIDUsageKeyboardApplication = 101;
  static const UIKeyboardHIDUsageKeyboardPower = 102;
  static const UIKeyboardHIDUsageKeypadEqualSign = 103;
  static const UIKeyboardHIDUsageKeyboardF13 = 104;
  static const UIKeyboardHIDUsageKeyboardF14 = 105;
  static const UIKeyboardHIDUsageKeyboardF15 = 106;
  static const UIKeyboardHIDUsageKeyboardF16 = 107;
  static const UIKeyboardHIDUsageKeyboardF17 = 108;
  static const UIKeyboardHIDUsageKeyboardF18 = 109;
  static const UIKeyboardHIDUsageKeyboardF19 = 110;
  static const UIKeyboardHIDUsageKeyboardF20 = 111;
  static const UIKeyboardHIDUsageKeyboardF21 = 112;
  static const UIKeyboardHIDUsageKeyboardF22 = 113;
  static const UIKeyboardHIDUsageKeyboardF23 = 114;
  static const UIKeyboardHIDUsageKeyboardF24 = 115;
  static const UIKeyboardHIDUsageKeyboardExecute = 116;
  static const UIKeyboardHIDUsageKeyboardHelp = 117;
  static const UIKeyboardHIDUsageKeyboardMenu = 118;
  static const UIKeyboardHIDUsageKeyboardSelect = 119;
  static const UIKeyboardHIDUsageKeyboardStop = 120;
  static const UIKeyboardHIDUsageKeyboardAgain = 121;
  static const UIKeyboardHIDUsageKeyboardUndo = 122;
  static const UIKeyboardHIDUsageKeyboardCut = 123;
  static const UIKeyboardHIDUsageKeyboardCopy = 124;
  static const UIKeyboardHIDUsageKeyboardPaste = 125;
  static const UIKeyboardHIDUsageKeyboardFind = 126;
  static const UIKeyboardHIDUsageKeyboardMute = 127;
  static const UIKeyboardHIDUsageKeyboardVolumeUp = 128;
  static const UIKeyboardHIDUsageKeyboardVolumeDown = 129;
  static const UIKeyboardHIDUsageKeyboardLockingCapsLock = 130;
  static const UIKeyboardHIDUsageKeyboardLockingNumLock = 131;
  static const UIKeyboardHIDUsageKeyboardLockingScrollLock = 132;
  static const UIKeyboardHIDUsageKeypadComma = 133;
  static const UIKeyboardHIDUsageKeypadEqualSignAS400 = 134;
  static const UIKeyboardHIDUsageKeyboardInternational1 = 135;
  static const UIKeyboardHIDUsageKeyboardInternational2 = 136;
  static const UIKeyboardHIDUsageKeyboardInternational3 = 137;
  static const UIKeyboardHIDUsageKeyboardInternational4 = 138;
  static const UIKeyboardHIDUsageKeyboardInternational5 = 139;
  static const UIKeyboardHIDUsageKeyboardInternational6 = 140;
  static const UIKeyboardHIDUsageKeyboardInternational7 = 141;
  static const UIKeyboardHIDUsageKeyboardInternational8 = 142;
  static const UIKeyboardHIDUsageKeyboardInternational9 = 143;
  static const UIKeyboardHIDUsageKeyboardLANG1 = 144;
  static const UIKeyboardHIDUsageKeyboardLANG2 = 145;
  static const UIKeyboardHIDUsageKeyboardLANG3 = 146;
  static const UIKeyboardHIDUsageKeyboardLANG4 = 147;
  static const UIKeyboardHIDUsageKeyboardLANG5 = 148;
  static const UIKeyboardHIDUsageKeyboardLANG6 = 149;
  static const UIKeyboardHIDUsageKeyboardLANG7 = 150;
  static const UIKeyboardHIDUsageKeyboardLANG8 = 151;
  static const UIKeyboardHIDUsageKeyboardLANG9 = 152;
  static const UIKeyboardHIDUsageKeyboardAlternateErase = 153;
  static const UIKeyboardHIDUsageKeyboardSysReqOrAttention = 154;
  static const UIKeyboardHIDUsageKeyboardCancel = 155;
  static const UIKeyboardHIDUsageKeyboardClear = 156;
  static const UIKeyboardHIDUsageKeyboardPrior = 157;
  static const UIKeyboardHIDUsageKeyboardReturn = 158;
  static const UIKeyboardHIDUsageKeyboardSeparator = 159;
  static const UIKeyboardHIDUsageKeyboardOut = 160;
  static const UIKeyboardHIDUsageKeyboardOper = 161;
  static const UIKeyboardHIDUsageKeyboardClearOrAgain = 162;
  static const UIKeyboardHIDUsageKeyboardCrSelOrProps = 163;
  static const UIKeyboardHIDUsageKeyboardExSel = 164;
  static const UIKeyboardHIDUsageKeyboardLeftControl = 224;
  static const UIKeyboardHIDUsageKeyboardLeftShift = 225;
  static const UIKeyboardHIDUsageKeyboardLeftAlt = 226;
  static const UIKeyboardHIDUsageKeyboardLeftGUI = 227;
  static const UIKeyboardHIDUsageKeyboardRightControl = 228;
  static const UIKeyboardHIDUsageKeyboardRightShift = 229;
  static const UIKeyboardHIDUsageKeyboardRightAlt = 230;
  static const UIKeyboardHIDUsageKeyboardRightGUI = 231;
  static const UIKeyboardHIDUsageKeyboard_Reserved = 65535;
  static const UIKeyboardHIDUsageKeyboardHangul = 144;
  static const UIKeyboardHIDUsageKeyboardHanja = 145;
  static const UIKeyboardHIDUsageKeyboardKanaSwitch = 144;
  static const UIKeyboardHIDUsageKeyboardAlphanumericSwitch = 145;
  static const UIKeyboardHIDUsageKeyboardKatakana = 146;
  static const UIKeyboardHIDUsageKeyboardHiragana = 147;
  static const UIKeyboardHIDUsageKeyboardZenkakuHankakuKanji = 148;}

sealed class UINavigationItemLargeTitleDisplayMode {
  static const UINavigationItemLargeTitleDisplayModeAutomatic = 0;
  static const UINavigationItemLargeTitleDisplayModeAlways = 1;
  static const UINavigationItemLargeTitleDisplayModeNever = 2;
  static const UINavigationItemLargeTitleDisplayModeInline = 3;}

sealed class UINavigationItemBackButtonDisplayMode {
  static const UINavigationItemBackButtonDisplayModeDefault = 0;
  static const UINavigationItemBackButtonDisplayModeGeneric = 1;
  static const UINavigationItemBackButtonDisplayModeMinimal = 2;}

sealed class UINavigationItemSearchBarPlacement {
  static const UINavigationItemSearchBarPlacementAutomatic = 0;
  static const UINavigationItemSearchBarPlacementIntegrated = 1;
  static const UINavigationItemSearchBarPlacementStacked = 2;
  static const UINavigationItemSearchBarPlacementIntegratedCentered = 3;
  static const UINavigationItemSearchBarPlacementIntegratedButton = 4;
  static const UINavigationItemSearchBarPlacementInline = 1;}

sealed class UINavigationItemStyle {
  static const UINavigationItemStyleNavigator = 0;
  static const UINavigationItemStyleBrowser = 1;
  static const UINavigationItemStyleEditor = 2;}

sealed class UIBlurEffectStyle {
  static const UIBlurEffectStyleExtraLight = 0;
  static const UIBlurEffectStyleLight = 1;
  static const UIBlurEffectStyleDark = 2;
  static const UIBlurEffectStyleExtraDark = 3;
  static const UIBlurEffectStyleRegular = 4;
  static const UIBlurEffectStyleProminent = 5;
  static const UIBlurEffectStyleSystemUltraThinMaterial = 6;
  static const UIBlurEffectStyleSystemThinMaterial = 7;
  static const UIBlurEffectStyleSystemMaterial = 8;
  static const UIBlurEffectStyleSystemThickMaterial = 9;
  static const UIBlurEffectStyleSystemChromeMaterial = 10;
  static const UIBlurEffectStyleSystemUltraThinMaterialLight = 11;
  static const UIBlurEffectStyleSystemThinMaterialLight = 12;
  static const UIBlurEffectStyleSystemMaterialLight = 13;
  static const UIBlurEffectStyleSystemThickMaterialLight = 14;
  static const UIBlurEffectStyleSystemChromeMaterialLight = 15;
  static const UIBlurEffectStyleSystemUltraThinMaterialDark = 16;
  static const UIBlurEffectStyleSystemThinMaterialDark = 17;
  static const UIBlurEffectStyleSystemMaterialDark = 18;
  static const UIBlurEffectStyleSystemThickMaterialDark = 19;
  static const UIBlurEffectStyleSystemChromeMaterialDark = 20;}


/// WARNING: UIGraphicsRendererFormat is a stub. To generate bindings for this class, include
/// UIGraphicsRendererFormat in your config's objc-interfaces list.
///
/// UIGraphicsRendererFormat
extension type UIGraphicsRendererFormat._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying {
  /// Constructs a [UIGraphicsRendererFormat] that points to the same underlying object as [other].
  UIGraphicsRendererFormat.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIGraphicsRendererFormat', iOS: (false, (10, 0, 0)));
  }

  /// Constructs a [UIGraphicsRendererFormat] that wraps the given raw object pointer.
  UIGraphicsRendererFormat.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIGraphicsRendererFormat', iOS: (false, (10, 0, 0)));
  }


}

sealed class UIGraphicsImageRendererFormatRange {
  static const UIGraphicsImageRendererFormatRangeUnspecified = -1;
  static const UIGraphicsImageRendererFormatRangeAutomatic = 0;
  static const UIGraphicsImageRendererFormatRangeExtended = 1;
  static const UIGraphicsImageRendererFormatRangeStandard = 2;}

sealed class UIScrollTypeMask {
  static const UIScrollTypeMaskDiscrete = 1;
  static const UIScrollTypeMaskContinuous = 2;
  static const UIScrollTypeMaskAll = 3;}

sealed class UINavigationControllerOperation {
  static const UINavigationControllerOperationNone = 0;
  static const UINavigationControllerOperationPush = 1;
  static const UINavigationControllerOperationPop = 2;}

sealed class UIInputViewStyle {
  static const UIInputViewStyleDefault = 0;
  static const UIInputViewStyleKeyboard = 1;}

sealed class UILabelVibrancy {
  static const UILabelVibrancyNone = 0;
  static const UILabelVibrancyAutomatic = 1;}

sealed class UIApplicationShortcutIconType {
  static const UIApplicationShortcutIconTypeCompose = 0;
  static const UIApplicationShortcutIconTypePlay = 1;
  static const UIApplicationShortcutIconTypePause = 2;
  static const UIApplicationShortcutIconTypeAdd = 3;
  static const UIApplicationShortcutIconTypeLocation = 4;
  static const UIApplicationShortcutIconTypeSearch = 5;
  static const UIApplicationShortcutIconTypeShare = 6;
  static const UIApplicationShortcutIconTypeProhibit = 7;
  static const UIApplicationShortcutIconTypeContact = 8;
  static const UIApplicationShortcutIconTypeHome = 9;
  static const UIApplicationShortcutIconTypeMarkLocation = 10;
  static const UIApplicationShortcutIconTypeFavorite = 11;
  static const UIApplicationShortcutIconTypeLove = 12;
  static const UIApplicationShortcutIconTypeCloud = 13;
  static const UIApplicationShortcutIconTypeInvitation = 14;
  static const UIApplicationShortcutIconTypeConfirmation = 15;
  static const UIApplicationShortcutIconTypeMail = 16;
  static const UIApplicationShortcutIconTypeMessage = 17;
  static const UIApplicationShortcutIconTypeDate = 18;
  static const UIApplicationShortcutIconTypeTime = 19;
  static const UIApplicationShortcutIconTypeCapturePhoto = 20;
  static const UIApplicationShortcutIconTypeCaptureVideo = 21;
  static const UIApplicationShortcutIconTypeTask = 22;
  static const UIApplicationShortcutIconTypeTaskCompleted = 23;
  static const UIApplicationShortcutIconTypeAlarm = 24;
  static const UIApplicationShortcutIconTypeBookmark = 25;
  static const UIApplicationShortcutIconTypeShuffle = 26;
  static const UIApplicationShortcutIconTypeAudio = 27;
  static const UIApplicationShortcutIconTypeUpdate = 28;}

sealed class UICornerCurve {
  static const UICornerCurveAutomatic = 0;
  static const UICornerCurveCircular = 1;
  static const UICornerCurveContinuous = 2;}


/// WARNING: UIShapeProvider is a stub. To generate bindings for this class, include
/// UIShapeProvider in your config's objc-protocols list.
///
/// UIShapeProvider
extension type UIShapeProvider._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIShapeProvider] that points to the same underlying object as [other].
  UIShapeProvider.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIShapeProvider] that wraps the given raw object pointer.
  UIShapeProvider.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class UIBehavioralStyle {
  static const UIBehavioralStyleAutomatic = 0;
  static const UIBehavioralStylePad = 1;
  static const UIBehavioralStyleMac = 2;}

sealed class UINavigationBarNSToolbarSection {
  static const UINavigationBarNSToolbarSectionNone = 0;
  static const UINavigationBarNSToolbarSectionSidebar = 1;
  static const UINavigationBarNSToolbarSectionSupplementary = 2;
  static const UINavigationBarNSToolbarSectionContent = 3;}

sealed class UIPopoverArrowDirection {
  static const UIPopoverArrowDirectionUp = 1;
  static const UIPopoverArrowDirectionDown = 2;
  static const UIPopoverArrowDirectionLeft = 4;
  static const UIPopoverArrowDirectionRight = 8;
  static const UIPopoverArrowDirectionAny = 15;
  static const UIPopoverArrowDirectionUnknown = -1;}

sealed class UIPressPhase {
  static const UIPressPhaseBegan = 0;
  static const UIPressPhaseChanged = 1;
  static const UIPressPhaseStationary = 2;
  static const UIPressPhaseEnded = 3;
  static const UIPressPhaseCancelled = 4;}

sealed class UIPressType {
  static const UIPressTypeUpArrow = 0;
  static const UIPressTypeDownArrow = 1;
  static const UIPressTypeLeftArrow = 2;
  static const UIPressTypeRightArrow = 3;
  static const UIPressTypeSelect = 4;
  static const UIPressTypeMenu = 5;
  static const UIPressTypePlayPause = 6;
  static const UIPressTypePageUp = 30;
  static const UIPressTypePageDown = 31;
  static const UIPressTypeTVRemoteOneTwoThree = 32;
  static const UIPressTypeTVRemoteFourColors = 33;}

sealed class UIScreenOverscanCompensation {
  static const UIScreenOverscanCompensationScale = 0;
  static const UIScreenOverscanCompensationInsetBounds = 1;
  static const UIScreenOverscanCompensationNone = 2;
  static const UIScreenOverscanCompensationInsetApplicationFrame = 2;}

sealed class UIScreenReferenceDisplayModeStatus {
  static const UIScreenReferenceDisplayModeStatusNotSupported = 0;
  static const UIScreenReferenceDisplayModeStatusNotEnabled = 1;
  static const UIScreenReferenceDisplayModeStatusLimited = 2;
  static const UIScreenReferenceDisplayModeStatusEnabled = 3;}

late final _class_UIScreen = objc.getClass("UIScreen");
late final _sel_screens = objc.registerName("screens");
late final _sel_mainScreen = objc.registerName("mainScreen");
late final _sel_availableModes = objc.registerName("availableModes");

/// WARNING: UIScreenMode is a stub. To generate bindings for this class, include
/// UIScreenMode in your config's objc-interfaces list.
///
/// UIScreenMode
extension type UIScreenMode._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [UIScreenMode] that points to the same underlying object as [other].
  UIScreenMode.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIScreenMode', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIScreenMode] that wraps the given raw object pointer.
  UIScreenMode.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIScreenMode', iOS: (false, (3, 2, 0)));
  }


}

late final _sel_preferredMode = objc.registerName("preferredMode");
late final _sel_currentMode = objc.registerName("currentMode");
late final _sel_setCurrentMode_ = objc.registerName("setCurrentMode:");
late final _sel_overscanCompensation = objc.registerName("overscanCompensation");
final _objc_msgSend_8mvtpi = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setOverscanCompensation_ = objc.registerName("setOverscanCompensation:");
final _objc_msgSend_1mz4wgw = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_overscanCompensationInsets = objc.registerName("overscanCompensationInsets");
late final _sel_mirroredScreen = objc.registerName("mirroredScreen");
late final _sel_isCaptured = objc.registerName("isCaptured");
late final _sel_brightness = objc.registerName("brightness");
late final _sel_setBrightness_ = objc.registerName("setBrightness:");
late final _sel_wantsSoftwareDimming = objc.registerName("wantsSoftwareDimming");
late final _sel_setWantsSoftwareDimming_ = objc.registerName("setWantsSoftwareDimming:");
late final _sel_fixedCoordinateSpace = objc.registerName("fixedCoordinateSpace");
late final _sel_nativeBounds = objc.registerName("nativeBounds");
late final _sel_nativeScale = objc.registerName("nativeScale");
late final _sel_displayLinkWithTarget_selector_ = objc.registerName("displayLinkWithTarget:selector:");
final _objc_msgSend_836y90 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_maximumFramesPerSecond = objc.registerName("maximumFramesPerSecond");
late final _sel_calibratedLatency = objc.registerName("calibratedLatency");
late final _sel_referenceDisplayModeStatus = objc.registerName("referenceDisplayModeStatus");
final _objc_msgSend_1wd735b = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_currentEDRHeadroom = objc.registerName("currentEDRHeadroom");
late final _sel_potentialEDRHeadroom = objc.registerName("potentialEDRHeadroom");
late final _sel_focusedItem = objc.registerName("focusedItem");
late final _sel_focusedView = objc.registerName("focusedView");
late final _sel_supportsFocus = objc.registerName("supportsFocus");
late final _sel_applicationFrame = objc.registerName("applicationFrame");

/// UISnapshotting
extension UISnapshotting$1 on UIScreen {

  /// snapshotViewAfterScreenUpdates:
  UIView snapshotViewAfterScreenUpdates(bool afterUpdates) {
  objc.checkOsVersionInternal('UIScreen.snapshotViewAfterScreenUpdates:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1t6aok9(object$.ref.pointer, _sel_snapshotViewAfterScreenUpdates_, afterUpdates);
    return UIView.fromPointer($ret, retain: true, release: true);
  }

}


/// UIScreen
extension type UIScreen._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,UITraitEnvironment {
  /// Constructs a [UIScreen] that points to the same underlying object as [other].
  UIScreen.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIScreen', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIScreen] that wraps the given raw object pointer.
  UIScreen.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIScreen', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIScreen].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIScreen);

  /// alloc
  static UIScreen alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIScreen, _sel_alloc);
    return UIScreen.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UIScreen allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIScreen, _sel_allocWithZone_, zone);
    return UIScreen.fromPointer($ret, retain: false, release: true);
  }


  /// mainScreen
  static UIScreen getMainScreen() {
  objc.checkOsVersionInternal('UIScreen.mainScreen', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIScreen, _sel_mainScreen);
    return UIScreen.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static UIScreen new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIScreen, _sel_new);
    return UIScreen.fromPointer($ret, retain: false, release: true);
  }


  /// screens
  static objc.NSArray getScreens() {
  objc.checkOsVersionInternal('UIScreen.screens', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIScreen, _sel_screens);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
  /// Returns a new instance of UIScreen constructed with the default `new` method.
  UIScreen() : this.as(new$().object$);

}

extension UIScreen$Methods on UIScreen {

  /// applicationFrame
  objc.CGRect get applicationFrame {
  objc.checkOsVersionInternal('UIScreen.applicationFrame', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_applicationFrame) : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_applicationFrame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// availableModes
  objc.NSArray get availableModes {
  objc.checkOsVersionInternal('UIScreen.availableModes', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_availableModes);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// bounds
  objc.CGRect get bounds {
  objc.checkOsVersionInternal('UIScreen.bounds', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_bounds) : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// brightness
  double get brightness {
  objc.checkOsVersionInternal('UIScreen.brightness', iOS: (false, (5, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_brightness) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_brightness);

  }


  /// calibratedLatency
  double get calibratedLatency {
  objc.checkOsVersionInternal('UIScreen.calibratedLatency', iOS: (false, (13, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_calibratedLatency) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_calibratedLatency);

  }


  /// coordinateSpace
  UICoordinateSpace get coordinateSpace {
  objc.checkOsVersionInternal('UIScreen.coordinateSpace', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_coordinateSpace);
    return UICoordinateSpace.fromPointer($ret, retain: true, release: true);
  }


  /// currentEDRHeadroom
  double get currentEDRHeadroom {
  objc.checkOsVersionInternal('UIScreen.currentEDRHeadroom', iOS: (false, (16, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_currentEDRHeadroom) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_currentEDRHeadroom);

  }


  /// currentMode
  UIScreenMode? get currentMode {
  objc.checkOsVersionInternal('UIScreen.currentMode', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_currentMode);
    return $ret.address == 0 ? null : UIScreenMode.fromPointer($ret, retain: true, release: true);
  }


  /// displayLinkWithTarget:selector:
  CADisplayLink? displayLinkWithTarget(objc.ObjCObject target, {required ffi.Pointer<objc.ObjCSelector> selector}) {
  objc.checkOsVersionInternal('UIScreen.displayLinkWithTarget:selector:', iOS: (false, (4, 0, 0)));
    final $ret = _objc_msgSend_836y90(object$.ref.pointer, _sel_displayLinkWithTarget_selector_, target.ref.pointer, selector);
    return $ret.address == 0 ? null : CADisplayLink.fromPointer($ret, retain: true, release: true);
  }


  /// fixedCoordinateSpace
  UICoordinateSpace get fixedCoordinateSpace {
  objc.checkOsVersionInternal('UIScreen.fixedCoordinateSpace', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fixedCoordinateSpace);
    return UICoordinateSpace.fromPointer($ret, retain: true, release: true);
  }


  /// focusedItem
  UIFocusItem? get focusedItem {
  objc.checkOsVersionInternal('UIScreen.focusedItem', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_focusedItem);
    return $ret.address == 0 ? null : UIFocusItem.fromPointer($ret, retain: true, release: true);
  }


  /// focusedView
  UIView? get focusedView {
  objc.checkOsVersionInternal('UIScreen.focusedView', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_focusedView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// init
  UIScreen init() {
  objc.checkOsVersionInternal('UIScreen.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UIScreen.fromPointer($ret, retain: false, release: true);
  }


  /// isCaptured
  bool get isCaptured {
  objc.checkOsVersionInternal('UIScreen.isCaptured', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isCaptured);

  }


  /// maximumFramesPerSecond
  int get maximumFramesPerSecond {
  objc.checkOsVersionInternal('UIScreen.maximumFramesPerSecond', iOS: (false, (10, 3, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_maximumFramesPerSecond);

  }


  /// mirroredScreen
  UIScreen? get mirroredScreen {
  objc.checkOsVersionInternal('UIScreen.mirroredScreen', iOS: (false, (4, 3, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mirroredScreen);
    return $ret.address == 0 ? null : UIScreen.fromPointer($ret, retain: true, release: true);
  }


  /// nativeBounds
  objc.CGRect get nativeBounds {
  objc.checkOsVersionInternal('UIScreen.nativeBounds', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_nativeBounds) : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_nativeBounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// nativeScale
  double get nativeScale {
  objc.checkOsVersionInternal('UIScreen.nativeScale', iOS: (false, (8, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_nativeScale) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_nativeScale);

  }


  /// overscanCompensation
  int get overscanCompensation {
  objc.checkOsVersionInternal('UIScreen.overscanCompensation', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_8mvtpi(object$.ref.pointer, _sel_overscanCompensation);

  }


  /// overscanCompensationInsets
  UIEdgeInsets get overscanCompensationInsets {
  objc.checkOsVersionInternal('UIScreen.overscanCompensationInsets', iOS: (false, (9, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_overscanCompensationInsets) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_overscanCompensationInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// potentialEDRHeadroom
  double get potentialEDRHeadroom {
  objc.checkOsVersionInternal('UIScreen.potentialEDRHeadroom', iOS: (false, (16, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_potentialEDRHeadroom) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_potentialEDRHeadroom);

  }


  /// preferredMode
  UIScreenMode? get preferredMode {
  objc.checkOsVersionInternal('UIScreen.preferredMode', iOS: (false, (4, 3, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_preferredMode);
    return $ret.address == 0 ? null : UIScreenMode.fromPointer($ret, retain: true, release: true);
  }


  /// referenceDisplayModeStatus
  int get referenceDisplayModeStatus {
  objc.checkOsVersionInternal('UIScreen.referenceDisplayModeStatus', iOS: (false, (16, 0, 0)));
    return _objc_msgSend_1wd735b(object$.ref.pointer, _sel_referenceDisplayModeStatus);

  }


  /// scale
  double get scale {
  objc.checkOsVersionInternal('UIScreen.scale', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_scale) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_scale);

  }


  /// setBrightness:
  set brightness(double value) {
  objc.checkOsVersionInternal('UIScreen.setBrightness:', iOS: (false, (5, 0, 0)));
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setBrightness_, value);

  }


  /// setCurrentMode:
  set currentMode(UIScreenMode? value) {
  objc.checkOsVersionInternal('UIScreen.setCurrentMode:', iOS: (false, (3, 2, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCurrentMode_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setOverscanCompensation:
  set overscanCompensation(int value) {
  objc.checkOsVersionInternal('UIScreen.setOverscanCompensation:', iOS: (false, (5, 0, 0)));
_objc_msgSend_1mz4wgw(object$.ref.pointer, _sel_setOverscanCompensation_, value);

  }


  /// setWantsSoftwareDimming:
  set wantsSoftwareDimming(bool value) {
  objc.checkOsVersionInternal('UIScreen.setWantsSoftwareDimming:', iOS: (false, (5, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setWantsSoftwareDimming_, value);

  }


  /// supportsFocus
  bool get supportsFocus {
  objc.checkOsVersionInternal('UIScreen.supportsFocus', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_supportsFocus);

  }


  /// traitCollection
  UITraitCollection get traitCollection {
  objc.checkOsVersionInternal('UIScreen.traitCollection', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_traitCollection);
    return UITraitCollection.fromPointer($ret, retain: true, release: true);
  }


  /// traitCollectionDidChange:
  void traitCollectionDidChange(UITraitCollection? previousTraitCollection) {
  objc.checkOsVersionInternal('UIScreen.traitCollectionDidChange:', iOS: (false, (8, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_traitCollectionDidChange_, previousTraitCollection?.ref.pointer ?? ffi.nullptr);

  }


  /// wantsSoftwareDimming
  bool get wantsSoftwareDimming {
  objc.checkOsVersionInternal('UIScreen.wantsSoftwareDimming', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_wantsSoftwareDimming);

  }

}

sealed class UISearchBarIcon {
  static const UISearchBarIconSearch = 0;
  static const UISearchBarIconClear = 1;
  static const UISearchBarIconBookmark = 2;
  static const UISearchBarIconResultsList = 3;}

sealed class UISearchBarStyle {
  static const UISearchBarStyleDefault = 0;
  static const UISearchBarStyleProminent = 1;
  static const UISearchBarStyleMinimal = 2;}

sealed class UITimingCurveType {
  static const UITimingCurveTypeBuiltin = 0;
  static const UITimingCurveTypeCubic = 1;
  static const UITimingCurveTypeSpring = 2;
  static const UITimingCurveTypeComposed = 3;}

sealed class UISearchControllerScopeBarActivation {
  static const UISearchControllerScopeBarActivationAutomatic = 0;
  static const UISearchControllerScopeBarActivationManual = 1;
  static const UISearchControllerScopeBarActivationOnTextEntry = 2;
  static const UISearchControllerScopeBarActivationOnSearchActivation = 3;}

sealed class UISplitViewControllerDisplayMode {
  static const UISplitViewControllerDisplayModeAutomatic = 0;
  static const UISplitViewControllerDisplayModeSecondaryOnly = 1;
  static const UISplitViewControllerDisplayModeOneBesideSecondary = 2;
  static const UISplitViewControllerDisplayModeOneOverSecondary = 3;
  static const UISplitViewControllerDisplayModeTwoBesideSecondary = 4;
  static const UISplitViewControllerDisplayModeTwoOverSecondary = 5;
  static const UISplitViewControllerDisplayModeTwoDisplaceSecondary = 6;
  static const UISplitViewControllerDisplayModePrimaryHidden = 1;
  static const UISplitViewControllerDisplayModeAllVisible = 2;
  static const UISplitViewControllerDisplayModePrimaryOverlay = 3;}

sealed class UISplitViewControllerPrimaryEdge {
  static const UISplitViewControllerPrimaryEdgeLeading = 0;
  static const UISplitViewControllerPrimaryEdgeTrailing = 1;}

sealed class UISplitViewControllerBackgroundStyle {
  static const UISplitViewControllerBackgroundStyleNone = 0;
  static const UISplitViewControllerBackgroundStyleSidebar = 1;}

sealed class UISplitViewControllerStyle {
  static const UISplitViewControllerStyleUnspecified = 0;
  static const UISplitViewControllerStyleDoubleColumn = 1;
  static const UISplitViewControllerStyleTripleColumn = 2;}

sealed class UISplitViewControllerColumn {
  static const UISplitViewControllerColumnPrimary = 0;
  static const UISplitViewControllerColumnSupplementary = 1;
  static const UISplitViewControllerColumnSecondary = 2;
  static const UISplitViewControllerColumnCompact = 3;
  static const UISplitViewControllerColumnInspector = 4;}

sealed class UISplitViewControllerSplitBehavior {
  static const UISplitViewControllerSplitBehaviorAutomatic = 0;
  static const UISplitViewControllerSplitBehaviorTile = 1;
  static const UISplitViewControllerSplitBehaviorOverlay = 2;
  static const UISplitViewControllerSplitBehaviorDisplace = 3;}

sealed class UISplitViewControllerDisplayModeButtonVisibility {
  static const UISplitViewControllerDisplayModeButtonVisibilityAutomatic = 0;
  static const UISplitViewControllerDisplayModeButtonVisibilityNever = 1;
  static const UISplitViewControllerDisplayModeButtonVisibilityAlways = 2;}


/// Construction methods for `objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>`.
abstract final class ObjCBlock_UIViewController_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>> ptr) =>
      objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> fromFunction(UIViewController? Function(objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(objc.NSCoder.fromPointer(arg0, retain: true, release: true))?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>`.
extension ObjCBlock_UIViewController_NSCoder$CallExtension on objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> {
  UIViewController? call(objc.NSCoder arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer).address == 0 ? null : UIViewController.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer), retain: true, release: true);
}

sealed class UITabBarItemPositioning {
  static const UITabBarItemPositioningAutomatic = 0;
  static const UITabBarItemPositioningFill = 1;
  static const UITabBarItemPositioningCentered = 2;}

sealed class UITabBarControllerMode {
  static const UITabBarControllerModeAutomatic = 0;
  static const UITabBarControllerModeTabBar = 1;
  static const UITabBarControllerModeTabSidebar = 2;}

sealed class UITabBarMinimizeBehavior {
  static const UITabBarMinimizeBehaviorAutomatic = 0;
  static const UITabBarMinimizeBehaviorNever = 1;
  static const UITabBarMinimizeBehaviorOnScrollDown = 2;
  static const UITabBarMinimizeBehaviorOnScrollUp = 3;}

sealed class UITabBarSystemItem {
  static const UITabBarSystemItemMore = 0;
  static const UITabBarSystemItemFavorites = 1;
  static const UITabBarSystemItemFeatured = 2;
  static const UITabBarSystemItemTopRated = 3;
  static const UITabBarSystemItemRecents = 4;
  static const UITabBarSystemItemContacts = 5;
  static const UITabBarSystemItemHistory = 6;
  static const UITabBarSystemItemBookmarks = 7;
  static const UITabBarSystemItemSearch = 8;
  static const UITabBarSystemItemDownloads = 9;
  static const UITabBarSystemItemMostRecent = 10;
  static const UITabBarSystemItemMostViewed = 11;}

late final _class_UITableViewHeaderFooterView = objc.getClass("UITableViewHeaderFooterView");
late final _sel_initWithReuseIdentifier_ = objc.registerName("initWithReuseIdentifier:");

/// UITableViewHeaderFooterView
extension type UITableViewHeaderFooterView._(objc.ObjCObject object$) implements objc.ObjCObject,UIView {
  /// Constructs a [UITableViewHeaderFooterView] that points to the same underlying object as [other].
  UITableViewHeaderFooterView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView', iOS: (false, (6, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UITableViewHeaderFooterView] that wraps the given raw object pointer.
  UITableViewHeaderFooterView.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITableViewHeaderFooterView', iOS: (false, (6, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UITableViewHeaderFooterView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UITableViewHeaderFooterView);

  /// alloc
  static UITableViewHeaderFooterView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewHeaderFooterView, _sel_alloc);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static UITableViewHeaderFooterView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UITableViewHeaderFooterView, _sel_allocWithZone_, zone);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: false, release: true);
  }


  /// appearance
  static UITableViewHeaderFooterView appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewHeaderFooterView, _sel_appearance);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:
  static UITableViewHeaderFooterView appearanceForTraitCollection(UITraitCollection trait) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UITableViewHeaderFooterView, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedIn:
  static UITableViewHeaderFooterView appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UITableViewHeaderFooterView, _sel_appearanceForTraitCollection_whenContainedIn_, trait.ref.pointer, whenContainedIn?.ref.pointer ?? ffi.nullptr);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UITableViewHeaderFooterView appearanceForTraitCollection$2(UITraitCollection trait, {required objc.NSArray whenContainedInInstancesOfClasses}) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_UITableViewHeaderFooterView, _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_, trait.ref.pointer, whenContainedInInstancesOfClasses.ref.pointer);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedIn:
  static UITableViewHeaderFooterView appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UITableViewHeaderFooterView, _sel_appearanceWhenContainedIn_, ContainerClass?.ref.pointer ?? ffi.nullptr);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedInInstancesOfClasses:
  static UITableViewHeaderFooterView appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UITableViewHeaderFooterView, _sel_appearanceWhenContainedInInstancesOfClasses_, containerTypes.ref.pointer);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: true, release: true);
  }


  /// layerClass
  static objc.ObjCObject getLayerClass() {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UITableViewHeaderFooterView, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// new
  static UITableViewHeaderFooterView new$() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewHeaderFooterView, _sel_new);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: false, release: true);
  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute(int attribute) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.userInterfaceLayoutDirectionForSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_racczx(_class_UITableViewHeaderFooterView, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_, attribute);

  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute$1(int semanticContentAttribute, {required int relativeToLayoutDirection}) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_tz4p54(_class_UITableViewHeaderFooterView, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_, semanticContentAttribute, relativeToLayoutDirection);

  }
  /// Returns a new instance of UITableViewHeaderFooterView constructed with the default `new` method.
  UITableViewHeaderFooterView() : this.as(new$().object$);

}

extension UITableViewHeaderFooterView$Methods on UITableViewHeaderFooterView {

  /// automaticallyUpdatesBackgroundConfiguration
  bool get automaticallyUpdatesBackgroundConfiguration {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.automaticallyUpdatesBackgroundConfiguration', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_automaticallyUpdatesBackgroundConfiguration);

  }


  /// automaticallyUpdatesContentConfiguration
  bool get automaticallyUpdatesContentConfiguration {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.automaticallyUpdatesContentConfiguration', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_automaticallyUpdatesContentConfiguration);

  }


  /// backgroundConfiguration
  UIBackgroundConfiguration? get backgroundConfiguration {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.backgroundConfiguration', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_backgroundConfiguration);
    return $ret.address == 0 ? null : UIBackgroundConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// backgroundView
  UIView? get backgroundView {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.backgroundView', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_backgroundView);
    return $ret.address == 0 ? null : UIView.fromPointer($ret, retain: true, release: true);
  }


  /// configurationState
  UIViewConfigurationState get configurationState {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.configurationState', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_configurationState);
    return UIViewConfigurationState.fromPointer($ret, retain: true, release: true);
  }


  /// configurationUpdateHandler
  objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>? get configurationUpdateHandler {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.configurationUpdateHandler', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_uwvaik(object$.ref.pointer, _sel_configurationUpdateHandler);
    return $ret.address == 0 ? null : ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState.fromPointer($ret, retain: true, release: true);
  }


  /// contentConfiguration
  UIContentConfiguration? get contentConfiguration {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.contentConfiguration', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentConfiguration);
    return $ret.address == 0 ? null : UIContentConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// contentView
  UIView get contentView {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.contentView', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentView);
    return UIView.fromPointer($ret, retain: true, release: true);
  }


  /// defaultBackgroundConfiguration
  UIBackgroundConfiguration defaultBackgroundConfiguration() {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.defaultBackgroundConfiguration', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_defaultBackgroundConfiguration);
    return UIBackgroundConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// defaultContentConfiguration
  UIListContentConfiguration defaultContentConfiguration() {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.defaultContentConfiguration', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_defaultContentConfiguration);
    return UIListContentConfiguration.fromPointer($ret, retain: true, release: true);
  }


  /// detailTextLabel
  UILabel? get detailTextLabel {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.detailTextLabel', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_detailTextLabel);
    return $ret.address == 0 ? null : UILabel.fromPointer($ret, retain: true, release: true);
  }


  /// init
  UITableViewHeaderFooterView init() {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  UITableViewHeaderFooterView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UITableViewHeaderFooterView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithFrame:
  UITableViewHeaderFooterView initWithFrame(objc.CGRect frame) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithReuseIdentifier:
  UITableViewHeaderFooterView initWithReuseIdentifier(objc.NSString? reuseIdentifier) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.initWithReuseIdentifier:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithReuseIdentifier_, reuseIdentifier?.ref.pointer ?? ffi.nullptr);
    return UITableViewHeaderFooterView.fromPointer($ret, retain: false, release: true);
  }


  /// prepareForReuse
  void prepareForReuse() {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.prepareForReuse', iOS: (false, (6, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_prepareForReuse);

  }


  /// reuseIdentifier
  objc.NSString? get reuseIdentifier {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.reuseIdentifier', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_reuseIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// setAutomaticallyUpdatesBackgroundConfiguration:
  set automaticallyUpdatesBackgroundConfiguration(bool value) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.setAutomaticallyUpdatesBackgroundConfiguration:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAutomaticallyUpdatesBackgroundConfiguration_, value);

  }


  /// setAutomaticallyUpdatesContentConfiguration:
  set automaticallyUpdatesContentConfiguration(bool value) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.setAutomaticallyUpdatesContentConfiguration:', iOS: (false, (14, 0, 0)));
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAutomaticallyUpdatesContentConfiguration_, value);

  }


  /// setBackgroundConfiguration:
  set backgroundConfiguration(UIBackgroundConfiguration? value) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.setBackgroundConfiguration:', iOS: (false, (14, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBackgroundConfiguration_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setBackgroundView:
  set backgroundView(UIView? value) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.setBackgroundView:', iOS: (false, (6, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBackgroundView_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setConfigurationUpdateHandler:
  set configurationUpdateHandler(objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>? value) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.setConfigurationUpdateHandler:', iOS: (false, (15, 0, 0)));
_objc_msgSend_f167m6(object$.ref.pointer, _sel_setConfigurationUpdateHandler_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setContentConfiguration:
  set contentConfiguration(UIContentConfiguration? value) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.setContentConfiguration:', iOS: (false, (14, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setContentConfiguration_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setNeedsUpdateConfiguration
  void setNeedsUpdateConfiguration() {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.setNeedsUpdateConfiguration', iOS: (false, (14, 0, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsUpdateConfiguration);

  }


  /// textLabel
  UILabel? get textLabel {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.textLabel', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textLabel);
    return $ret.address == 0 ? null : UILabel.fromPointer($ret, retain: true, release: true);
  }


  /// updateConfigurationUsingState:
  void updateConfigurationUsingState(UIViewConfigurationState state) {
  objc.checkOsVersionInternal('UITableViewHeaderFooterView.updateConfigurationUsingState:', iOS: (false, (14, 0, 0)));
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_updateConfigurationUsingState_, state.ref.pointer);

  }

}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>`.
abstract final class ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)> fromFunction(void Function(UITableViewHeaderFooterView , UIViewConfigurationState ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITableViewHeaderFooterView.fromPointer(arg0, retain: true, release: true), UIViewConfigurationState.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)> listener(void Function(UITableViewHeaderFooterView , UIViewConfigurationState ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITableViewHeaderFooterView.fromPointer(arg0, retain: false, release: true), UIViewConfigurationState.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)> blocking(void Function(UITableViewHeaderFooterView , UIViewConfigurationState ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITableViewHeaderFooterView.fromPointer(arg0, retain: false, release: true), UIViewConfigurationState.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(UITableViewHeaderFooterView.fromPointer(arg0, retain: false, release: true), UIViewConfigurationState.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>`.
extension ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState$CallExtension on objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)> {
  void call(UITableViewHeaderFooterView arg0, UIViewConfigurationState arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

sealed class UIDropSessionProgressIndicatorStyle {
  static const UIDropSessionProgressIndicatorStyleNone = 0;
  static const UIDropSessionProgressIndicatorStyleDefault = 1;}

sealed class UISpringLoadedInteractionEffectState {
  static const UISpringLoadedInteractionEffectStateInactive = 0;
  static const UISpringLoadedInteractionEffectStatePossible = 1;
  static const UISpringLoadedInteractionEffectStateActivating = 2;
  static const UISpringLoadedInteractionEffectStateActivated = 3;}

sealed class UITabBarItemAppearanceStyle {
  static const UITabBarItemAppearanceStyleStacked = 0;
  static const UITabBarItemAppearanceStyleInline = 1;
  static const UITabBarItemAppearanceStyleCompactInline = 2;}


/// WARNING: NSLayoutAnchor is a stub. To generate bindings for this class, include
/// NSLayoutAnchor in your config's objc-interfaces list.
///
/// NSLayoutAnchor
extension type NSLayoutAnchor._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSCoding {
  /// Constructs a [NSLayoutAnchor] that points to the same underlying object as [other].
  NSLayoutAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSLayoutAnchor', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [NSLayoutAnchor] that wraps the given raw object pointer.
  NSLayoutAnchor.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutAnchor', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
  }


}


/// WARNING: UITrackingLayoutGuide is a stub. To generate bindings for this class, include
/// UITrackingLayoutGuide in your config's objc-interfaces list.
///
/// UITrackingLayoutGuide
extension type UITrackingLayoutGuide._(objc.ObjCObject object$) implements objc.ObjCObject,UILayoutGuide {
  /// Constructs a [UITrackingLayoutGuide] that points to the same underlying object as [other].
  UITrackingLayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITrackingLayoutGuide', iOS: (false, (15, 0, 0)));
  }

  /// Constructs a [UITrackingLayoutGuide] that wraps the given raw object pointer.
  UITrackingLayoutGuide.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITrackingLayoutGuide', iOS: (false, (15, 0, 0)));
  }


}

sealed class NSTextStorageEditActions {
  static const NSTextStorageEditedAttributes = 1;
  static const NSTextStorageEditedCharacters = 2;}

sealed class NSTextLayoutOrientation {
  static const NSTextLayoutOrientationHorizontal = 0;
  static const NSTextLayoutOrientationVertical = 1;}

sealed class NSGlyphProperty {
  static const NSGlyphPropertyNull = 1;
  static const NSGlyphPropertyControlCharacter = 2;
  static const NSGlyphPropertyElastic = 4;
  static const NSGlyphPropertyNonBaseCharacter = 8;}

sealed class NSControlCharacterAction {
  static const NSControlCharacterActionZeroAdvancement = 1;
  static const NSControlCharacterActionWhitespace = 2;
  static const NSControlCharacterActionHorizontalTab = 4;
  static const NSControlCharacterActionLineBreak = 8;
  static const NSControlCharacterActionParagraphBreak = 16;
  static const NSControlCharacterActionContainerBreak = 32;}

sealed class UIWindowSceneResizingRestrictions {
  static const UIWindowSceneResizingRestrictionsUnspecified = 0;
  static const UIWindowSceneResizingRestrictionsNone = 1;
  static const UIWindowSceneResizingRestrictionsUniform = 2;
  static const UIWindowSceneResizingRestrictionsFreeform = 3;}

sealed class UITabPlacement {
  static const UITabPlacementAutomatic = 0;
  static const UITabPlacementDefault = 1;
  static const UITabPlacementOptional = 2;
  static const UITabPlacementMovable = 3;
  static const UITabPlacementPinned = 4;
  static const UITabPlacementFixed = 5;
  static const UITabPlacementSidebarOnly = 6;}

sealed class UITabGroupSidebarAppearance {
  static const UITabGroupSidebarAppearanceAutomatic = 0;
  static const UITabGroupSidebarAppearanceInline = 1;
  static const UITabGroupSidebarAppearanceRootSection = 2;}

sealed class UITabBarControllerSidebarLayout {
  static const UITabBarControllerSidebarLayoutAutomatic = 0;
  static const UITabBarControllerSidebarLayoutOverlap = 1;
  static const UITabBarControllerSidebarLayoutTile = 2;}


/// WARNING: CTAdaptiveImageProviding is a stub. To generate bindings for this class, include
/// CTAdaptiveImageProviding in your config's objc-protocols list.
///
/// CTAdaptiveImageProviding
extension type CTAdaptiveImageProviding._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [CTAdaptiveImageProviding] that points to the same underlying object as [other].
  CTAdaptiveImageProviding.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CTAdaptiveImageProviding] that wraps the given raw object pointer.
  CTAdaptiveImageProviding.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}


/// WARNING: NSAdaptiveImageGlyph is a stub. To generate bindings for this class, include
/// NSAdaptiveImageGlyph in your config's objc-interfaces list.
///
/// NSAdaptiveImageGlyph
extension type NSAdaptiveImageGlyph._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding,CTAdaptiveImageProviding {
  /// Constructs a [NSAdaptiveImageGlyph] that points to the same underlying object as [other].
  NSAdaptiveImageGlyph.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSAdaptiveImageGlyph', iOS: (false, (18, 0, 0)), macOS: (false, (15, 0, 0)));
  }

  /// Constructs a [NSAdaptiveImageGlyph] that wraps the given raw object pointer.
  NSAdaptiveImageGlyph.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSAdaptiveImageGlyph', iOS: (false, (18, 0, 0)), macOS: (false, (15, 0, 0)));
  }


}

late final _sel_attributedStringWithAdaptiveImageGlyph_attributes_ = objc.registerName("attributedStringWithAdaptiveImageGlyph:attributes:");

/// NSAttributedStringAdaptiveImageGlyphConveniences
extension NSAttributedStringAdaptiveImageGlyphConveniences on objc.NSAttributedString {

  /// attributedStringWithAdaptiveImageGlyph:attributes:
  static objc.NSAttributedString attributedStringWithAdaptiveImageGlyph(NSAdaptiveImageGlyph adaptiveImageGlyph, {required objc.NSDictionary attributes}) {
  objc.checkOsVersionInternal('NSAttributedString.attributedStringWithAdaptiveImageGlyph:attributes:', iOS: (false, (18, 0, 0)), macOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSAttributedString, _sel_attributedStringWithAdaptiveImageGlyph_attributes_, adaptiveImageGlyph.ref.pointer, attributes.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }

}

sealed class NSTextSelectionGranularity {
  static const NSTextSelectionGranularityCharacter = 0;
  static const NSTextSelectionGranularityWord = 1;
  static const NSTextSelectionGranularityParagraph = 2;
  static const NSTextSelectionGranularityLine = 3;
  static const NSTextSelectionGranularitySentence = 4;}

sealed class NSTextSelectionAffinity {
  static const NSTextSelectionAffinityUpstream = 0;
  static const NSTextSelectionAffinityDownstream = 1;}

sealed class NSTextSelectionNavigationDirection {
  static const NSTextSelectionNavigationDirectionForward = 0;
  static const NSTextSelectionNavigationDirectionBackward = 1;
  static const NSTextSelectionNavigationDirectionRight = 2;
  static const NSTextSelectionNavigationDirectionLeft = 3;
  static const NSTextSelectionNavigationDirectionUp = 4;
  static const NSTextSelectionNavigationDirectionDown = 5;}

sealed class NSTextSelectionNavigationDestination {
  static const NSTextSelectionNavigationDestinationCharacter = 0;
  static const NSTextSelectionNavigationDestinationWord = 1;
  static const NSTextSelectionNavigationDestinationLine = 2;
  static const NSTextSelectionNavigationDestinationSentence = 3;
  static const NSTextSelectionNavigationDestinationParagraph = 4;
  static const NSTextSelectionNavigationDestinationContainer = 5;
  static const NSTextSelectionNavigationDestinationDocument = 6;}

sealed class NSTextSelectionNavigationModifier {
  static const NSTextSelectionNavigationModifierExtend = 1;
  static const NSTextSelectionNavigationModifierVisual = 2;
  static const NSTextSelectionNavigationModifierMultiple = 4;}

sealed class NSTextSelectionNavigationWritingDirection {
  static const NSTextSelectionNavigationWritingDirectionLeftToRight = 0;
  static const NSTextSelectionNavigationWritingDirectionRightToLeft = 1;}

sealed class NSTextSelectionNavigationLayoutOrientation {
  static const NSTextSelectionNavigationLayoutOrientationHorizontal = 0;
  static const NSTextSelectionNavigationLayoutOrientationVertical = 1;}

sealed class NSTextContentManagerEnumerationOptions {
  static const NSTextContentManagerEnumerationOptionsNone = 0;
  static const NSTextContentManagerEnumerationOptionsReverse = 1;}

sealed class NSTextLayoutFragmentEnumerationOptions {
  static const NSTextLayoutFragmentEnumerationOptionsNone = 0;
  static const NSTextLayoutFragmentEnumerationOptionsReverse = 1;
  static const NSTextLayoutFragmentEnumerationOptionsEstimatesSize = 2;
  static const NSTextLayoutFragmentEnumerationOptionsEnsuresLayout = 4;
  static const NSTextLayoutFragmentEnumerationOptionsEnsuresExtraLineFragment = 8;}

sealed class NSTextLayoutFragmentState {
  static const NSTextLayoutFragmentStateNone = 0;
  static const NSTextLayoutFragmentStateEstimatedUsageBounds = 1;
  static const NSTextLayoutFragmentStateCalculatedUsageBounds = 2;
  static const NSTextLayoutFragmentStateLayoutAvailable = 3;}

sealed class NSTextLayoutManagerSegmentType {
  static const NSTextLayoutManagerSegmentTypeStandard = 0;
  static const NSTextLayoutManagerSegmentTypeSelection = 1;
  static const NSTextLayoutManagerSegmentTypeHighlight = 2;}

sealed class NSTextLayoutManagerSegmentOptions {
  static const NSTextLayoutManagerSegmentOptionsNone = 0;
  static const NSTextLayoutManagerSegmentOptionsRangeNotRequired = 1;
  static const NSTextLayoutManagerSegmentOptionsMiddleFragmentsExcluded = 2;
  static const NSTextLayoutManagerSegmentOptionsHeadSegmentExtended = 4;
  static const NSTextLayoutManagerSegmentOptionsTailSegmentExtended = 8;
  static const NSTextLayoutManagerSegmentOptionsUpstreamAffinity = 16;}

sealed class UIActivitySectionTypes {
  static const UIActivitySectionTypesNone = 0;
  static const UIActivitySectionTypesPeopleSuggestions = 1;}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_UIActivityType_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Bool arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> fromFunction(void Function(objc.NSString? , bool ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: true, release: true), arg1), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> listener(void Function(objc.NSString? , bool ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_6p7ndb(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> blocking(void Function(objc.NSString? , bool ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_6p7ndb(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , bool ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , bool ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Bool arg1)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , bool )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , bool ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_UIActivityType_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> {
  void call(objc.NSString? arg0, bool arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Bool arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , bool )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> fromFunction(void Function(objc.NSString? , bool , objc.NSArray? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: true, release: true), arg1, arg2.address == 0 ? null : objc.NSArray.fromPointer(arg2, retain: true, release: true), arg3.address == 0 ? null : objc.NSError.fromPointer(arg3, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> listener(void Function(objc.NSString? , bool , objc.NSArray? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2.address == 0 ? null : objc.NSArray.fromPointer(arg2, retain: false, release: true), arg3.address == 0 ? null : objc.NSError.fromPointer(arg3, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_13x5jor(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> blocking(void Function(objc.NSString? , bool , objc.NSArray? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2.address == 0 ? null : objc.NSArray.fromPointer(arg2, retain: false, release: true), arg3.address == 0 ? null : objc.NSError.fromPointer(arg3, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2.address == 0 ? null : objc.NSArray.fromPointer(arg2, retain: false, release: true), arg3.address == 0 ? null : objc.NSError.fromPointer(arg3, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_13x5jor(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)> {
  void call(objc.NSString? arg0, bool arg1, objc.NSArray? arg2, objc.NSError? arg3) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Bool arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , bool , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2?.ref.pointer ?? ffi.nullptr, arg3?.ref.pointer ?? ffi.nullptr);
}


/// WARNING: UIPrintFormatter$1 is a stub. To generate bindings for this class, include
/// UIPrintFormatter in your config's objc-interfaces list.
///
/// UIPrintFormatter
extension type UIPrintFormatter$1._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying {
  /// Constructs a [UIPrintFormatter$1] that points to the same underlying object as [other].
  UIPrintFormatter$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPrintFormatter', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UIPrintFormatter$1] that wraps the given raw object pointer.
  UIPrintFormatter$1.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPrintFormatter', iOS: (false, (4, 2, 0)));
  }


}

sealed class UIPrintRenderingQuality {
  static const UIPrintRenderingQualityBest = 0;
  static const UIPrintRenderingQualityResponsive = 1;}

late final _class_MLNBackendResource = objc.getClass("MLNBackendResource");

/// MLNBackendResource
extension type MLNBackendResource._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNBackendResource] that points to the same underlying object as [other].
  MLNBackendResource.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNBackendResource] that wraps the given raw object pointer.
  MLNBackendResource.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNBackendResource].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNBackendResource);

  /// alloc
  static MLNBackendResource alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNBackendResource, _sel_alloc);
    return MLNBackendResource.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNBackendResource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNBackendResource, _sel_allocWithZone_, zone);
    return MLNBackendResource.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNBackendResource new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNBackendResource, _sel_new);
    return MLNBackendResource.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNBackendResource constructed with the default `new` method.
  MLNBackendResource() : this.as(new$().object$);

}

extension MLNBackendResource$Methods on MLNBackendResource {

  /// init
  MLNBackendResource init() {
  objc.checkOsVersionInternal('MLNBackendResource.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNBackendResource.fromPointer($ret, retain: false, release: true);
  }

}

/// Options for enabling debugging features in an ``MLNMapView`` instance.
sealed class MLNMapDebugMaskOptions {
  /// Edges of tile boundaries are shown as thick, red lines to help diagnose
  /// tile clipping issues.
  static const MLNMapDebugTileBoundariesMask = 2;
  /// Each tile shows its tile coordinate (x/y/z) in the upper-left corner.
  static const MLNMapDebugTileInfoMask = 4;
  /// Each tile shows a timestamp indicating when it was loaded.
  static const MLNMapDebugTimestampsMask = 8;
  /// Edges of glyphs and symbols are shown as faint, green lines to help
  /// diagnose collision and label placement issues.
  static const MLNMapDebugCollisionBoxesMask = 16;
  /// Each drawing operation is replaced by a translucent fill. Overlapping
  /// drawing operations appear more prominent to help diagnose overdrawing.
  /// > Note: This option does nothing in Release builds of the SDK.
  static const MLNMapDebugOverdrawVisualizationMask = 32;}

/// A structure containing information about a transition.
final class MLNTransition extends ffi.Struct{
  /// The amount of time the animation should take, not including the delay.
  @ffi.Double()
  external double duration;

  /// The amount of time in seconds to wait before beginning the animation.
  @ffi.Double()
  external double delay;

}

/// Constants indicating the visibility of different map ornaments.
sealed class MLNOrnamentVisibility {
  /// A constant indicating that the ornament adapts to the current map state.
  static const MLNOrnamentVisibilityAdaptive = 0;
  /// A constant indicating that the ornament is always hidden.
  static const MLNOrnamentVisibilityHidden = 1;
  /// A constant indicating that the ornament is always visible.
  static const MLNOrnamentVisibilityVisible = 2;}

late final _class_MLNCompassButton = objc.getClass("MLNCompassButton");
late final _sel_compassVisibility = objc.registerName("compassVisibility");
final _objc_msgSend_1hoz5da = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setCompassVisibility_ = objc.registerName("setCompassVisibility:");
final _objc_msgSend_1khwzis = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// A specialized view that displays the current compass heading for its associated map.
extension type MLNCompassButton._(objc.ObjCObject object$) implements objc.ObjCObject,UIImageView {
  /// Constructs a [MLNCompassButton] that points to the same underlying object as [other].
  MLNCompassButton.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNCompassButton] that wraps the given raw object pointer.
  MLNCompassButton.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNCompassButton].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNCompassButton);

  /// alloc
  static MLNCompassButton alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNCompassButton, _sel_alloc);
    return MLNCompassButton.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNCompassButton allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNCompassButton, _sel_allocWithZone_, zone);
    return MLNCompassButton.fromPointer($ret, retain: false, release: true);
  }


  /// appearance
  static MLNCompassButton appearance() {
    final $ret = _objc_msgSend_151sglz(_class_MLNCompassButton, _sel_appearance);
    return MLNCompassButton.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:
  static MLNCompassButton appearanceForTraitCollection(UITraitCollection trait) {
  objc.checkOsVersionInternal('MLNCompassButton.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_MLNCompassButton, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return MLNCompassButton.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedIn:
  static MLNCompassButton appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
  objc.checkOsVersionInternal('MLNCompassButton.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_MLNCompassButton, _sel_appearanceForTraitCollection_whenContainedIn_, trait.ref.pointer, whenContainedIn?.ref.pointer ?? ffi.nullptr);
    return MLNCompassButton.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static MLNCompassButton appearanceForTraitCollection$2(UITraitCollection trait, {required objc.NSArray whenContainedInInstancesOfClasses}) {
  objc.checkOsVersionInternal('MLNCompassButton.appearanceForTraitCollection:whenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_MLNCompassButton, _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_, trait.ref.pointer, whenContainedInInstancesOfClasses.ref.pointer);
    return MLNCompassButton.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedIn:
  static MLNCompassButton appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
  objc.checkOsVersionInternal('MLNCompassButton.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_MLNCompassButton, _sel_appearanceWhenContainedIn_, ContainerClass?.ref.pointer ?? ffi.nullptr);
    return MLNCompassButton.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedInInstancesOfClasses:
  static MLNCompassButton appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
  objc.checkOsVersionInternal('MLNCompassButton.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_MLNCompassButton, _sel_appearanceWhenContainedInInstancesOfClasses_, containerTypes.ref.pointer);
    return MLNCompassButton.fromPointer($ret, retain: true, release: true);
  }


  /// layerClass
  static objc.ObjCObject getLayerClass() {
  objc.checkOsVersionInternal('MLNCompassButton.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_MLNCompassButton, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// new
  static MLNCompassButton new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNCompassButton, _sel_new);
    return MLNCompassButton.fromPointer($ret, retain: false, release: true);
  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute(int attribute) {
  objc.checkOsVersionInternal('MLNCompassButton.userInterfaceLayoutDirectionForSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_racczx(_class_MLNCompassButton, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_, attribute);

  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute$1(int semanticContentAttribute, {required int relativeToLayoutDirection}) {
  objc.checkOsVersionInternal('MLNCompassButton.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_tz4p54(_class_MLNCompassButton, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_, semanticContentAttribute, relativeToLayoutDirection);

  }
  /// Returns a new instance of MLNCompassButton constructed with the default `new` method.
  MLNCompassButton() : this.as(new$().object$);

}

extension MLNCompassButton$Methods on MLNCompassButton {

  /// The visibility of the compass button.
/// 
/// You can configure a compass button to be visible all the time or only when the compass heading
/// changes.
  int get compassVisibility {
    return _objc_msgSend_1hoz5da(object$.ref.pointer, _sel_compassVisibility);

  }


  /// init
  MLNCompassButton init() {
  objc.checkOsVersionInternal('MLNCompassButton.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNCompassButton.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNCompassButton? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNCompassButton.fromPointer($ret, retain: false, release: true);
  }


  /// initWithFrame:
  MLNCompassButton initWithFrame(objc.CGRect frame) {
  objc.checkOsVersionInternal('MLNCompassButton.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return MLNCompassButton.fromPointer($ret, retain: false, release: true);
  }


  /// initWithImage:
  MLNCompassButton initWithImage(UIImage? image) {
  objc.checkOsVersionInternal('MLNCompassButton.initWithImage:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithImage_, image?.ref.pointer ?? ffi.nullptr);
    return MLNCompassButton.fromPointer($ret, retain: false, release: true);
  }


  /// initWithImage:highlightedImage:
  MLNCompassButton initWithImage$1(UIImage? image, {UIImage? highlightedImage}) {
  objc.checkOsVersionInternal('MLNCompassButton.initWithImage:highlightedImage:', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithImage_highlightedImage_, image?.ref.pointer ?? ffi.nullptr, highlightedImage?.ref.pointer ?? ffi.nullptr);
    return MLNCompassButton.fromPointer($ret, retain: false, release: true);
  }


  /// The visibility of the compass button.
/// 
/// You can configure a compass button to be visible all the time or only when the compass heading
/// changes.
  set compassVisibility(int value) {
_objc_msgSend_1khwzis(object$.ref.pointer, _sel_setCompassVisibility_, value);

  }

}

final class CLLocationCoordinate2D extends ffi.Struct{
  @ffi.Double()
  external double latitude;

  @ffi.Double()
  external double longitude;

}

/// A rectangular area as measured on a two-dimensional map projection.
final class MLNCoordinateBounds extends ffi.Struct{
  /// Coordinate at the southwest corner.
  external CLLocationCoordinate2D sw;

  /// Coordinate at the northeast corner.
  external CLLocationCoordinate2D ne;

}

/// A quadrilateral area as measured on a two-dimensional map projection.
/// ``MLNCoordinateQuad`` differs from ``MLNCoordinateQuad`` in that it allows
/// representation of non-axis aligned bounds and non-rectangular quadrilaterals.
/// The coordinates are described in counter clockwise order from top left.
final class MLNCoordinateQuad extends ffi.Struct{
  /// Coordinate at the top left corner.
  external CLLocationCoordinate2D topLeft;

  /// Coordinate at the bottom left corner.
  external CLLocationCoordinate2D bottomLeft;

  /// Coordinate at the bottom right corner.
  external CLLocationCoordinate2D bottomRight;

  /// Coordinate at the top right corner.
  external CLLocationCoordinate2D topRight;

}

late final _class_MLNMapCamera = objc.getClass("MLNMapCamera");
late final _sel_centerCoordinate = objc.registerName("centerCoordinate");
final _objc_msgSend_18o5nok = objc.msgSendPointer.cast<ffi.NativeFunction<CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_18o5nokStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CLLocationCoordinate2D> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<CLLocationCoordinate2D> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setCenterCoordinate_ = objc.registerName("setCenterCoordinate:");
final _objc_msgSend_1zv0am = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D )>();
late final _sel_heading = objc.registerName("heading");
late final _sel_setHeading_ = objc.registerName("setHeading:");
late final _sel_pitch = objc.registerName("pitch");
late final _sel_setPitch_ = objc.registerName("setPitch:");
late final _sel_altitude = objc.registerName("altitude");
late final _sel_setAltitude_ = objc.registerName("setAltitude:");
late final _sel_viewingDistance = objc.registerName("viewingDistance");
late final _sel_setViewingDistance_ = objc.registerName("setViewingDistance:");
late final _sel_camera = objc.registerName("camera");
late final _sel_cameraLookingAtCenterCoordinate_fromEyeCoordinate_eyeAltitude_ = objc.registerName("cameraLookingAtCenterCoordinate:fromEyeCoordinate:eyeAltitude:");
final _objc_msgSend_2d68z4 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , CLLocationCoordinate2D , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , CLLocationCoordinate2D , double )>();
late final _sel_cameraLookingAtCenterCoordinate_acrossDistance_pitch_heading_ = objc.registerName("cameraLookingAtCenterCoordinate:acrossDistance:pitch:heading:");
final _objc_msgSend_x3m0f9 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Double , ffi.Double , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , double , double , double )>();
late final _sel_cameraLookingAtCenterCoordinate_altitude_pitch_heading_ = objc.registerName("cameraLookingAtCenterCoordinate:altitude:pitch:heading:");
late final _sel_cameraLookingAtCenterCoordinate_fromDistance_pitch_heading_ = objc.registerName("cameraLookingAtCenterCoordinate:fromDistance:pitch:heading:");
late final _sel_isEqualToMapCamera_ = objc.registerName("isEqualToMapCamera:");

/// An ``MLNMapCamera`` object represents a viewpoint from which the user observes
/// some point on an ``MLNMapView``.
/// 
/// #### Related examples
/// - <doc:BlockingGesturesExample>: learn how to use the
/// ``MLNMapViewDelegate/mapView:shouldChangeFromCamera:toCamera:`` method of ``MLNMapViewDelegate`` to
/// restrict panning.
/// - *TODO:* Camera animation, learn how to create a camera that rotates
/// around a central point.
extension type MLNMapCamera._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [MLNMapCamera] that points to the same underlying object as [other].
  MLNMapCamera.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMapCamera] that wraps the given raw object pointer.
  MLNMapCamera.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMapCamera].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapCamera);

  /// alloc
  static MLNMapCamera alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapCamera, _sel_alloc);
    return MLNMapCamera.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMapCamera allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMapCamera, _sel_allocWithZone_, zone);
    return MLNMapCamera.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a new camera with all properties set to 0.
  static MLNMapCamera camera() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapCamera, _sel_camera);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a new camera with the given distance, pitch, and heading.
/// 
/// This method interprets the distance as a straight-line distance from the
/// viewpoint to the center coordinate. To specify the altitude of the viewpoint,
/// use the ``cameraLookingAtCenterCoordinate:altitude:pitch:heading:`` method.
/// 
/// @param centerCoordinate The geographic coordinate on which the map should be
/// centered.
/// @param distance The straight-line distance from the viewpoint to the
/// ``centerCoordinate``.
/// @param pitch The viewing angle of the camera, measured in degrees. A value of
/// `0` results in a camera pointed straight down at the map. Angles greater
/// than `0` result in a camera angled toward the horizon.
/// @param heading The cameras heading, measured in degrees clockwise from true
/// north. A value of `0` means that the top edge of the map view corresponds to
/// true north. The value `90` means the top of the map is pointing due east.
/// The value `180` means the top of the map points due south, and so on.
  static MLNMapCamera cameraLookingAtCenterCoordinate(CLLocationCoordinate2D centerCoordinate, {required double acrossDistance,required double pitch,required double heading}) {
    final $ret = _objc_msgSend_x3m0f9(_class_MLNMapCamera, _sel_cameraLookingAtCenterCoordinate_acrossDistance_pitch_heading_, centerCoordinate, acrossDistance, pitch, heading);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a new camera with the given altitude, pitch, and heading.
/// 
/// @param centerCoordinate The geographic coordinate on which the map should be
/// centered.
/// @param altitude The altitude (measured in meters) above the map at which the
/// camera should be situated. The altitude may be less than the distance from
/// the cameras viewpoint to the cameras focus point.
/// @param pitch The viewing angle of the camera, measured in degrees. A value of
/// `0` results in a camera pointed straight down at the map. Angles greater
/// than `0` result in a camera angled toward the horizon.
/// @param heading The cameras heading, measured in degrees clockwise from true
/// north. A value of `0` means that the top edge of the map view corresponds to
/// true north. The value `90` means the top of the map is pointing due east.
/// The value `180` means the top of the map points due south, and so on.
  static MLNMapCamera cameraLookingAtCenterCoordinate$1(CLLocationCoordinate2D centerCoordinate, {required double altitude,required double pitch,required double heading}) {
    final $ret = _objc_msgSend_x3m0f9(_class_MLNMapCamera, _sel_cameraLookingAtCenterCoordinate_altitude_pitch_heading_, centerCoordinate, altitude, pitch, heading);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// > This initializer incorrectly interprets the `distance` parameter. To
/// specify the straight-line distance from the viewpoint to ``centerCoordinate``,
/// use the ``cameraLookingAtCenterCoordinate:acrossDistance:pitch:heading:``
/// method. To specify the altitude of the viewpoint, use the
/// ``cameraLookingAtCenterCoordinate:altitude:pitch:heading:`` method, which has
/// the same behavior as this initializer.
  static MLNMapCamera cameraLookingAtCenterCoordinate$2(CLLocationCoordinate2D centerCoordinate, {required double fromDistance,required double pitch,required double heading}) {
    final $ret = _objc_msgSend_x3m0f9(_class_MLNMapCamera, _sel_cameraLookingAtCenterCoordinate_fromDistance_pitch_heading_, centerCoordinate, fromDistance, pitch, heading);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a new camera based on information about the cameras viewpoint
/// and focus point.
/// 
/// @param centerCoordinate The geographic coordinate on which the map should be
/// centered.
/// @param eyeCoordinate The geometric coordinate at which the camera should be
/// situated.
/// @param eyeAltitude The altitude (measured in meters) above the map at which the
/// camera should be situated. The altitude may be less than the distance from
/// the cameras viewpoint to the cameras focus point.
  static MLNMapCamera cameraLookingAtCenterCoordinate$3(CLLocationCoordinate2D centerCoordinate, {required CLLocationCoordinate2D fromEyeCoordinate,required double eyeAltitude}) {
    final $ret = _objc_msgSend_2d68z4(_class_MLNMapCamera, _sel_cameraLookingAtCenterCoordinate_fromEyeCoordinate_eyeAltitude_, centerCoordinate, fromEyeCoordinate, eyeAltitude);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static MLNMapCamera new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapCamera, _sel_new);
    return MLNMapCamera.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNMapCamera, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNMapCamera constructed with the default `new` method.
  MLNMapCamera() : this.as(new$().object$);

}

extension MLNMapCamera$Methods on MLNMapCamera {

  /// The altitude (measured in meters) above the map at which the camera is
/// situated.
/// 
/// The altitude is the distance from the viewpoint to the map, perpendicular to
/// the map plane. This property does not account for physical elevation.
/// 
/// This propertys value may be less than that of the ``viewingDistance`` property.
/// Setting this property automatically updates the ``viewingDistance`` property
/// based on the ``pitch`` propertys current value.
  double get altitude {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_altitude) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_altitude);

  }


  /// Coordinate at the center of the map view.
  CLLocationCoordinate2D get centerCoordinate {
    final $ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants ? _objc_msgSend_18o5nokStret($ptr, object$.ref.pointer, _sel_centerCoordinate) : $ptr.ref = _objc_msgSend_18o5nok(object$.ref.pointer, _sel_centerCoordinate);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(
        $finalizable);

  }


  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// Heading measured in degrees clockwise from true north.
  double get heading {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_heading) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_heading);

  }


  /// init
  MLNMapCamera init() {
  objc.checkOsVersionInternal('MLNMapCamera.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapCamera.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNMapCamera? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNMapCamera.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a Boolean value indicating whether the given camera is functionally
/// equivalent to the receiver.
/// 
/// Unlike `isEqual:`, this method returns `YES` if the difference between the
/// coordinates, altitudes, pitches, or headings of the two camera objects is
/// negligible.
/// 
/// @param otherCamera The camera with which to compare the receiver.
/// @return A Boolean value indicating whether the two cameras are functionally
/// equivalent.
  bool isEqualToMapCamera(MLNMapCamera otherCamera) {
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_isEqualToMapCamera_, otherCamera.ref.pointer);

  }


  /// Pitch toward the horizon measured in degrees, with 0 degrees resulting in a
/// two-dimensional map.
  double get pitch {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_pitch) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_pitch);

  }


  /// The altitude (measured in meters) above the map at which the camera is
/// situated.
/// 
/// The altitude is the distance from the viewpoint to the map, perpendicular to
/// the map plane. This property does not account for physical elevation.
/// 
/// This propertys value may be less than that of the ``viewingDistance`` property.
/// Setting this property automatically updates the ``viewingDistance`` property
/// based on the ``pitch`` propertys current value.
  set altitude(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setAltitude_, value);

  }


  /// Coordinate at the center of the map view.
  set centerCoordinate(CLLocationCoordinate2D value) {
_objc_msgSend_1zv0am(object$.ref.pointer, _sel_setCenterCoordinate_, value);

  }


  /// Heading measured in degrees clockwise from true north.
  set heading(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setHeading_, value);

  }


  /// Pitch toward the horizon measured in degrees, with 0 degrees resulting in a
/// two-dimensional map.
  set pitch(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setPitch_, value);

  }


  /// The straight-line distance from the viewpoint to the ``centerCoordinate``.
/// 
/// Setting this property automatically updates the ``altitude`` property based on
/// the ``pitch`` propertys current value.
  set viewingDistance(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setViewingDistance_, value);

  }


  /// The straight-line distance from the viewpoint to the ``centerCoordinate``.
/// 
/// Setting this property automatically updates the ``altitude`` property based on
/// the ``pitch`` propertys current value.
  double get viewingDistance {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_viewingDistance) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_viewingDistance);

  }

}

late final _class_MLNActionJournalOptions = objc.getClass("MLNActionJournalOptions");
late final _sel_enabled = objc.registerName("enabled");
late final _sel_path = objc.registerName("path");
late final _sel_setPath_ = objc.registerName("setPath:");
late final _sel_logFileSize = objc.registerName("logFileSize");
late final _sel_setLogFileSize_ = objc.registerName("setLogFileSize:");
late final _sel_logFileCount = objc.registerName("logFileCount");
late final _sel_setLogFileCount_ = objc.registerName("setLogFileCount:");
late final _sel_renderingStatsReportInterval = objc.registerName("renderingStatsReportInterval");
late final _sel_setRenderingStatsReportInterval_ = objc.registerName("setRenderingStatsReportInterval:");

/// The ``MLNActionJournalOptions`` defines action journal properties such as path, log size, etc...
extension type MLNActionJournalOptions._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNActionJournalOptions] that points to the same underlying object as [other].
  MLNActionJournalOptions.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNActionJournalOptions] that wraps the given raw object pointer.
  MLNActionJournalOptions.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNActionJournalOptions].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNActionJournalOptions);

  /// alloc
  static MLNActionJournalOptions alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNActionJournalOptions, _sel_alloc);
    return MLNActionJournalOptions.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNActionJournalOptions allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNActionJournalOptions, _sel_allocWithZone_, zone);
    return MLNActionJournalOptions.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNActionJournalOptions new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNActionJournalOptions, _sel_new);
    return MLNActionJournalOptions.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNActionJournalOptions constructed with the default `new` method.
  MLNActionJournalOptions() : this.as(new$().object$);

}

extension MLNActionJournalOptions$Methods on MLNActionJournalOptions {

  /// Enable/disable journal logging
  bool get enabled {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_enabled);

  }


  /// init
  MLNActionJournalOptions init() {
  objc.checkOsVersionInternal('MLNActionJournalOptions.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNActionJournalOptions.fromPointer($ret, retain: false, release: true);
  }


  /// Maximum number of log files
  int get logFileCount {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_logFileCount);

  }


  /// Log file size (total journal size is equal to `logFileSize * logFileCount`)
  int get logFileSize {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_logFileSize);

  }


  /// Local file path.
  objc.NSString get path {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_path);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// The wait time (seconds) between rendering reports
  int get renderingStatsReportInterval {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_renderingStatsReportInterval);

  }


  /// Enable/disable journal logging
  set enabled(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setEnabled_, value);

  }


  /// Maximum number of log files
  set logFileCount(int value) {
_objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setLogFileCount_, value);

  }


  /// Log file size (total journal size is equal to `logFileSize * logFileCount`)
  set logFileSize(int value) {
_objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setLogFileSize_, value);

  }


  /// Local file path.
  set path(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setPath_, value.ref.pointer);

  }


  /// The wait time (seconds) between rendering reports
  set renderingStatsReportInterval(int value) {
_objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setRenderingStatsReportInterval_, value);

  }

}

late final _class_MLNMapOptions = objc.getClass("MLNMapOptions");
late final _sel_styleURL = objc.registerName("styleURL");
late final _sel_setStyleURL_ = objc.registerName("setStyleURL:");
late final _sel_styleJSON = objc.registerName("styleJSON");
late final _sel_setStyleJSON_ = objc.registerName("setStyleJSON:");
late final _sel_actionJournalOptions = objc.registerName("actionJournalOptions");
late final _sel_setActionJournalOptions_ = objc.registerName("setActionJournalOptions:");
late final _sel_pluginLayers = objc.registerName("pluginLayers");
late final _sel_setPluginLayers_ = objc.registerName("setPluginLayers:");

/// The ``MLNMapOptions`` object provides a way to set map properties for each instance
extension type MLNMapOptions._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNMapOptions] that points to the same underlying object as [other].
  MLNMapOptions.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMapOptions] that wraps the given raw object pointer.
  MLNMapOptions.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMapOptions].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapOptions);

  /// alloc
  static MLNMapOptions alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapOptions, _sel_alloc);
    return MLNMapOptions.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMapOptions allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMapOptions, _sel_allocWithZone_, zone);
    return MLNMapOptions.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNMapOptions new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapOptions, _sel_new);
    return MLNMapOptions.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNMapOptions constructed with the default `new` method.
  MLNMapOptions() : this.as(new$().object$);

}

extension MLNMapOptions$Methods on MLNMapOptions {

  /// Action journal  options
  MLNActionJournalOptions get actionJournalOptions {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_actionJournalOptions);
    return MLNActionJournalOptions.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNMapOptions init() {
  objc.checkOsVersionInternal('MLNMapOptions.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapOptions.fromPointer($ret, retain: false, release: true);
  }


  /// List of plugin classes
  objc.NSArray get pluginLayers {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_pluginLayers);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Action journal  options
  set actionJournalOptions(MLNActionJournalOptions value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setActionJournalOptions_, value.ref.pointer);

  }


  /// List of plugin classes
  set pluginLayers(objc.NSArray value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setPluginLayers_, value.ref.pointer);

  }


  /// JSON string of the map style to display. The JSON must conform to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
/// Specify `nil` for the default style.
/// Ignored if `styleURL` is set to a non-nil value.
  set styleJSON(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setStyleJSON_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// URL of the map style to display. The URL may be a full HTTP
/// or HTTPS URL, a canonical URL or a path to a local file relative
/// to the applications resource path. Specify `nil` for the default style.
  set styleURL(objc.NSURL? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setStyleURL_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// JSON string of the map style to display. The JSON must conform to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
/// Specify `nil` for the default style.
/// Ignored if `styleURL` is set to a non-nil value.
  objc.NSString? get styleJSON {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_styleJSON);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// URL of the map style to display. The URL may be a full HTTP
/// or HTTPS URL, a canonical URL or a path to a local file relative
/// to the applications resource path. Specify `nil` for the default style.
  objc.NSURL? get styleURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_styleURL);
    return $ret.address == 0 ? null : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNStyleLayer = objc.getClass("MLNStyleLayer");
late final _sel_isVisible = objc.registerName("isVisible");
late final _sel_setVisible_ = objc.registerName("setVisible:");
late final _sel_maximumZoomLevel = objc.registerName("maximumZoomLevel");
final _objc_msgSend_2cgrxl = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer.cast<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setMaximumZoomLevel_ = objc.registerName("setMaximumZoomLevel:");
late final _sel_minimumZoomLevel = objc.registerName("minimumZoomLevel");
late final _sel_setMinimumZoomLevel_ = objc.registerName("setMinimumZoomLevel:");

/// ``MLNStyleLayer`` is an abstract base class for style layers. A style layer
/// manages the layout and appearance of content at a specific z-index in a style.
/// An ``MLNStyle`` object consists of one or more ``MLNStyle`` objects.
/// 
/// Each style layer defined by the style JSON file is represented at runtime by an
/// ``MLNStyleLayer`` object, which you can use to refine the maps appearance. You
/// can also add and remove style layers dynamically.
/// 
/// Create instances of ``MLNBackgroundStyleLayer`` and the concrete subclasses of
/// ``MLNForegroundStyleLayer`` in order to use ``MLNForegroundStyleLayer``'s properties and methods.
/// You do not create instances of ``MLNStyleLayer`` directly, and do not
/// create your own subclasses of this class.
/// 
/// Do not add ``MLNStyleLayer`` objects to the `style` property of a ``MLNStyleLayer`` before
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` is called.
extension type MLNStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNStyleLayer] that points to the same underlying object as [other].
  MLNStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNStyleLayer] that wraps the given raw object pointer.
  MLNStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNStyleLayer);

  /// alloc
  static MLNStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNStyleLayer, _sel_alloc);
    return MLNStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNStyleLayer, _sel_allocWithZone_, zone);
    return MLNStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNStyleLayer, _sel_new);
    return MLNStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNStyleLayer constructed with the default `new` method.
  MLNStyleLayer() : this.as(new$().object$);

}

extension MLNStyleLayer$Methods on MLNStyleLayer {

  /// A string that uniquely identifies the style layer in the style to which it is
/// added.
  objc.NSString get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNStyleLayer init() {
  objc.checkOsVersionInternal('MLNStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Whether this layer is displayed. A value of `NO` hides the layer.
/// 
/// #### Related examples
/// TODO: Show and hide a layer, learn how to toggle an ``MLNStyleLayer``
/// object's visibility.
  bool get isVisible {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isVisible);

  }


  /// The maximum zoom level at which the layer gets parsed and appears. This value is a floating-point
/// number.
  double get maximumZoomLevel {
    return objc.useMsgSendVariants ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_maximumZoomLevel) : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_maximumZoomLevel);

  }


  /// The minimum zoom level at which the layer gets parsed and appears. This value is a floating-point
/// number.
  double get minimumZoomLevel {
    return objc.useMsgSendVariants ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_minimumZoomLevel) : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_minimumZoomLevel);

  }


  /// The maximum zoom level at which the layer gets parsed and appears. This value is a floating-point
/// number.
  set maximumZoomLevel(double value) {
_objc_msgSend_v5hmet(object$.ref.pointer, _sel_setMaximumZoomLevel_, value);

  }


  /// The minimum zoom level at which the layer gets parsed and appears. This value is a floating-point
/// number.
  set minimumZoomLevel(double value) {
_objc_msgSend_v5hmet(object$.ref.pointer, _sel_setMinimumZoomLevel_, value);

  }


  /// Whether this layer is displayed. A value of `NO` hides the layer.
/// 
/// #### Related examples
/// TODO: Show and hide a layer, learn how to toggle an ``MLNStyleLayer``
/// object's visibility.
  set isVisible(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setVisible_, value);

  }

}

late final _class_MLNDefaultStyle = objc.getClass("MLNDefaultStyle");
late final _sel_url = objc.registerName("url");
late final _sel_setUrl_ = objc.registerName("setUrl:");
late final _sel_name = objc.registerName("name");
late final _sel_setName_ = objc.registerName("setName:");
late final _sel_version = objc.registerName("version");
final _objc_msgSend_13yqbb6 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setVersion_ = objc.registerName("setVersion:");
final _objc_msgSend_9o8504 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Int )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// The ``MLNDefaultStyle`` defines the predefined vendor style
extension type MLNDefaultStyle._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNDefaultStyle] that points to the same underlying object as [other].
  MLNDefaultStyle.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNDefaultStyle] that wraps the given raw object pointer.
  MLNDefaultStyle.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNDefaultStyle].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNDefaultStyle);

  /// alloc
  static MLNDefaultStyle alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNDefaultStyle, _sel_alloc);
    return MLNDefaultStyle.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNDefaultStyle allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNDefaultStyle, _sel_allocWithZone_, zone);
    return MLNDefaultStyle.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNDefaultStyle new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNDefaultStyle, _sel_new);
    return MLNDefaultStyle.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNDefaultStyle constructed with the default `new` method.
  MLNDefaultStyle() : this.as(new$().object$);

}

extension MLNDefaultStyle$Methods on MLNDefaultStyle {

  /// init
  MLNDefaultStyle init() {
  objc.checkOsVersionInternal('MLNDefaultStyle.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNDefaultStyle.fromPointer($ret, retain: false, release: true);
  }


  /// The style name
  objc.NSString get name {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_name);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// The style name
  set name(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setName_, value.ref.pointer);

  }


  /// The style URL
  set url(objc.NSURL value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setUrl_, value.ref.pointer);

  }


  /// The style version
  set version(int value) {
_objc_msgSend_9o8504(object$.ref.pointer, _sel_setVersion_, value);

  }


  /// The style URL
  objc.NSURL get url {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_url);
    return objc.NSURL.fromPointer($ret, retain: true, release: true);
  }


  /// The style version
  int get version {
    return _objc_msgSend_13yqbb6(object$.ref.pointer, _sel_version);

  }

}

late final _class_MLNTileServerOptions = objc.getClass("MLNTileServerOptions");
late final _sel_baseURL = objc.registerName("baseURL");
late final _sel_setBaseURL_ = objc.registerName("setBaseURL:");
late final _sel_uriSchemeAlias = objc.registerName("uriSchemeAlias");
late final _sel_setUriSchemeAlias_ = objc.registerName("setUriSchemeAlias:");
late final _sel_sourceTemplate = objc.registerName("sourceTemplate");
late final _sel_setSourceTemplate_ = objc.registerName("setSourceTemplate:");
late final _sel_sourceDomainName = objc.registerName("sourceDomainName");
late final _sel_setSourceDomainName_ = objc.registerName("setSourceDomainName:");
late final _sel_sourceVersionPrefix = objc.registerName("sourceVersionPrefix");
late final _sel_setSourceVersionPrefix_ = objc.registerName("setSourceVersionPrefix:");
late final _sel_styleTemplate = objc.registerName("styleTemplate");
late final _sel_setStyleTemplate_ = objc.registerName("setStyleTemplate:");
late final _sel_styleDomainName = objc.registerName("styleDomainName");
late final _sel_setStyleDomainName_ = objc.registerName("setStyleDomainName:");
late final _sel_styleVersionPrefix = objc.registerName("styleVersionPrefix");
late final _sel_setStyleVersionPrefix_ = objc.registerName("setStyleVersionPrefix:");
late final _sel_spritesTemplate = objc.registerName("spritesTemplate");
late final _sel_setSpritesTemplate_ = objc.registerName("setSpritesTemplate:");
late final _sel_spritesDomainName = objc.registerName("spritesDomainName");
late final _sel_setSpritesDomainName_ = objc.registerName("setSpritesDomainName:");
late final _sel_spritesVersionPrefix = objc.registerName("spritesVersionPrefix");
late final _sel_setSpritesVersionPrefix_ = objc.registerName("setSpritesVersionPrefix:");
late final _sel_glyphsTemplate = objc.registerName("glyphsTemplate");
late final _sel_setGlyphsTemplate_ = objc.registerName("setGlyphsTemplate:");
late final _sel_glyphsDomainName = objc.registerName("glyphsDomainName");
late final _sel_setGlyphsDomainName_ = objc.registerName("setGlyphsDomainName:");
late final _sel_glyphsVersionPrefix = objc.registerName("glyphsVersionPrefix");
late final _sel_setGlyphsVersionPrefix_ = objc.registerName("setGlyphsVersionPrefix:");
late final _sel_tileTemplate = objc.registerName("tileTemplate");
late final _sel_setTileTemplate_ = objc.registerName("setTileTemplate:");
late final _sel_tileDomainName = objc.registerName("tileDomainName");
late final _sel_setTileDomainName_ = objc.registerName("setTileDomainName:");
late final _sel_tileVersionPrefix = objc.registerName("tileVersionPrefix");
late final _sel_setTileVersionPrefix_ = objc.registerName("setTileVersionPrefix:");
late final _sel_apiKeyParameterName = objc.registerName("apiKeyParameterName");
late final _sel_setApiKeyParameterName_ = objc.registerName("setApiKeyParameterName:");
late final _sel_defaultStyles = objc.registerName("defaultStyles");
late final _sel_setDefaultStyles_ = objc.registerName("setDefaultStyles:");
late final _sel_defaultStyle = objc.registerName("defaultStyle");
late final _sel_setDefaultStyle_ = objc.registerName("setDefaultStyle:");

/// The ``MLNTileServerOptions`` defines server properties such as URL etc...
extension type MLNTileServerOptions._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNTileServerOptions] that points to the same underlying object as [other].
  MLNTileServerOptions.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNTileServerOptions] that wraps the given raw object pointer.
  MLNTileServerOptions.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNTileServerOptions].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNTileServerOptions);

  /// alloc
  static MLNTileServerOptions alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNTileServerOptions, _sel_alloc);
    return MLNTileServerOptions.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNTileServerOptions allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNTileServerOptions, _sel_allocWithZone_, zone);
    return MLNTileServerOptions.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNTileServerOptions new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNTileServerOptions, _sel_new);
    return MLNTileServerOptions.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNTileServerOptions constructed with the default `new` method.
  MLNTileServerOptions() : this.as(new$().object$);

}

extension MLNTileServerOptions$Methods on MLNTileServerOptions {

  /// API key parameter name.
  objc.NSString get apiKeyParameterName {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_apiKeyParameterName);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// API base URL.
  objc.NSString get baseURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_baseURL);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// Default style
  MLNDefaultStyle get defaultStyle {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_defaultStyle);
    return MLNDefaultStyle.fromPointer($ret, retain: true, release: true);
  }


  /// Default styles.
  objc.NSArray get defaultStyles {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_defaultStyles);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// glyphs domain name.
  objc.NSString get glyphsDomainName {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_glyphsDomainName);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// URL template for glyphs.
  objc.NSString get glyphsTemplate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_glyphsTemplate);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// Glyphs version prefix
  objc.NSString? get glyphsVersionPrefix {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_glyphsVersionPrefix);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNTileServerOptions init() {
  objc.checkOsVersionInternal('MLNTileServerOptions.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNTileServerOptions.fromPointer($ret, retain: false, release: true);
  }


  /// API key parameter name.
  set apiKeyParameterName(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setApiKeyParameterName_, value.ref.pointer);

  }


  /// API base URL.
  set baseURL(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBaseURL_, value.ref.pointer);

  }


  /// Default style
  set defaultStyle(MLNDefaultStyle value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setDefaultStyle_, value.ref.pointer);

  }


  /// Default styles.
  set defaultStyles(objc.NSArray value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setDefaultStyles_, value.ref.pointer);

  }


  /// glyphs domain name.
  set glyphsDomainName(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setGlyphsDomainName_, value.ref.pointer);

  }


  /// URL template for glyphs.
  set glyphsTemplate(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setGlyphsTemplate_, value.ref.pointer);

  }


  /// Glyphs version prefix
  set glyphsVersionPrefix(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setGlyphsVersionPrefix_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// source domain name.
  set sourceDomainName(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSourceDomainName_, value.ref.pointer);

  }


  /// URL template for sources.
  set sourceTemplate(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSourceTemplate_, value.ref.pointer);

  }


  /// source version prefix
  set sourceVersionPrefix(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSourceVersionPrefix_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// sprites domain name.
  set spritesDomainName(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSpritesDomainName_, value.ref.pointer);

  }


  /// URL template for sprites.
  set spritesTemplate(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSpritesTemplate_, value.ref.pointer);

  }


  /// version prefix
  set spritesVersionPrefix(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSpritesVersionPrefix_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// style domain name.
  set styleDomainName(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setStyleDomainName_, value.ref.pointer);

  }


  /// URL template for style.
  set styleTemplate(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setStyleTemplate_, value.ref.pointer);

  }


  /// style version prefix
  set styleVersionPrefix(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setStyleVersionPrefix_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// tile domain name.
  set tileDomainName(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTileDomainName_, value.ref.pointer);

  }


  /// URL template for tiles.
  set tileTemplate(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTileTemplate_, value.ref.pointer);

  }


  /// tile version prefix
  set tileVersionPrefix(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTileVersionPrefix_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// Tile server URI alias.
  set uriSchemeAlias(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setUriSchemeAlias_, value.ref.pointer);

  }


  /// source domain name.
  objc.NSString get sourceDomainName {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sourceDomainName);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// URL template for sources.
  objc.NSString get sourceTemplate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sourceTemplate);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// source version prefix
  objc.NSString? get sourceVersionPrefix {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sourceVersionPrefix);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// sprites domain name.
  objc.NSString get spritesDomainName {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_spritesDomainName);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// URL template for sprites.
  objc.NSString get spritesTemplate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_spritesTemplate);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// version prefix
  objc.NSString? get spritesVersionPrefix {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_spritesVersionPrefix);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// style domain name.
  objc.NSString get styleDomainName {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_styleDomainName);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// URL template for style.
  objc.NSString get styleTemplate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_styleTemplate);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// style version prefix
  objc.NSString? get styleVersionPrefix {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_styleVersionPrefix);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// tile domain name.
  objc.NSString get tileDomainName {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tileDomainName);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// URL template for tiles.
  objc.NSString get tileTemplate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tileTemplate);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// tile version prefix
  objc.NSString? get tileVersionPrefix {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tileVersionPrefix);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// Tile server URI alias.
  objc.NSString get uriSchemeAlias {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_uriSchemeAlias);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

/// Well-known tile servers
sealed class MLNWellKnownTileServer {
  /// Maptiler
  static const MLNMapTiler = 0;
  /// MapLibre
  static const MLNMapLibre = 1;
  /// Mapbox
  static const MLNMapbox = 2;}

late final _class_MLNSettings = objc.getClass("MLNSettings");
late final _sel_tileServerOptions = objc.registerName("tileServerOptions");
late final _sel_setTileServerOptions_ = objc.registerName("setTileServerOptions:");
late final _sel_apiKey = objc.registerName("apiKey");
late final _sel_setApiKey_ = objc.registerName("setApiKey:");
late final _sel_useWellKnownTileServer_ = objc.registerName("useWellKnownTileServer:");
final _objc_msgSend_1vrforg = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// The ``MLNSettings`` object provides a global way to set SDK properties such
/// as apiKey, backend URL, etc.
extension type MLNSettings._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNSettings] that points to the same underlying object as [other].
  MLNSettings.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNSettings] that wraps the given raw object pointer.
  MLNSettings.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNSettings].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNSettings);

  /// alloc
  static MLNSettings alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNSettings, _sel_alloc);
    return MLNSettings.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNSettings allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNSettings, _sel_allocWithZone_, zone);
    return MLNSettings.fromPointer($ret, retain: false, release: true);
  }


  /// The API Key used by all instances of ``MLNMapView`` in the current application.
/// Setting this property to a value of `nil` has no effect.
/// 
/// > Note: You must set the API key before attempting to load any style which
/// requires the token. Therefore, you should generally set it before creating an instance of
/// ``MLNMapView``. The recommended way to set an api key is to add an entry
/// to your applications Info.plist file with the key `MLNApiKey``
/// and the type `String`. Alternatively, you may call this method from your
/// application delegates `-applicationDidFinishLaunching:` method.
  static objc.NSString? getApiKey() {
    final $ret = _objc_msgSend_151sglz(_class_MLNSettings, _sel_apiKey);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static MLNSettings new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNSettings, _sel_new);
    return MLNSettings.fromPointer($ret, retain: false, release: true);
  }


  /// The API Key used by all instances of ``MLNMapView`` in the current application.
/// Setting this property to a value of `nil` has no effect.
/// 
/// > Note: You must set the API key before attempting to load any style which
/// requires the token. Therefore, you should generally set it before creating an instance of
/// ``MLNMapView``. The recommended way to set an api key is to add an entry
/// to your applications Info.plist file with the key `MLNApiKey``
/// and the type `String`. Alternatively, you may call this method from your
/// application delegates `-applicationDidFinishLaunching:` method.
  static void setApiKey(objc.NSString? value) {
_objc_msgSend_xtuoz7(_class_MLNSettings, _sel_setApiKey_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// Tile server options
  static void setTileServerOptions(MLNTileServerOptions? value) {
_objc_msgSend_xtuoz7(_class_MLNSettings, _sel_setTileServerOptions_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// Tile server options
  static MLNTileServerOptions? getTileServerOptions() {
    final $ret = _objc_msgSend_151sglz(_class_MLNSettings, _sel_tileServerOptions);
    return $ret.address == 0 ? null : MLNTileServerOptions.fromPointer($ret, retain: true, release: true);
  }


  /// Instructs the SDk to use the give tile server
  static void useWellKnownTileServer(int tileServer) {
_objc_msgSend_1vrforg(_class_MLNSettings, _sel_useWellKnownTileServer_, tileServer);

  }
  /// Returns a new instance of MLNSettings constructed with the default `new` method.
  MLNSettings() : this.as(new$().object$);

}

extension MLNSettings$Methods on MLNSettings {

  /// init
  MLNSettings init() {
  objc.checkOsVersionInternal('MLNSettings.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNSettings.fromPointer($ret, retain: false, release: true);
  }

}

late final _class_MLNStyle = objc.getClass("MLNStyle");
late final _sel_predefinedStyles = objc.registerName("predefinedStyles");
late final _sel_defaultStyleURL = objc.registerName("defaultStyleURL");
late final _sel_predefinedStyle_ = objc.registerName("predefinedStyle:");
late final _sel_sources = objc.registerName("sources");
late final _sel_setSources_ = objc.registerName("setSources:");
late final _sel_transition = objc.registerName("transition");
final _objc_msgSend_1i0p3hy = objc.msgSendPointer.cast<ffi.NativeFunction<MLNTransition Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<MLNTransition Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_1i0p3hyStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MLNTransition> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<MLNTransition> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setTransition_ = objc.registerName("setTransition:");
final _objc_msgSend_z7lywk = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNTransition )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNTransition )>();
late final _sel_performsPlacementTransitions = objc.registerName("performsPlacementTransitions");
late final _sel_setPerformsPlacementTransitions_ = objc.registerName("setPerformsPlacementTransitions:");
late final _class_MLNSource = objc.getClass("MLNSource");
late final _sel_initWithIdentifier_ = objc.registerName("initWithIdentifier:");
late final _sel_setIdentifier_ = objc.registerName("setIdentifier:");

/// MLNSource
extension type MLNSource._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNSource] that points to the same underlying object as [other].
  MLNSource.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNSource] that wraps the given raw object pointer.
  MLNSource.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNSource].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNSource);

  /// alloc
  static MLNSource alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNSource, _sel_alloc);
    return MLNSource.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNSource, _sel_allocWithZone_, zone);
    return MLNSource.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNSource new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNSource, _sel_new);
    return MLNSource.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNSource constructed with the default `new` method.
  MLNSource() : this.as(new$().object$);

}

extension MLNSource$Methods on MLNSource {

  /// A string that uniquely identifies the source in the style to which it is added.
  objc.NSString get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNSource init() {
  objc.checkOsVersionInternal('MLNSource.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a source initialized with an identifier.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @return An initialized source.
  MLNSource initWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNSource.fromPointer($ret, retain: false, release: true);
  }


  /// A string that uniquely identifies the source in the style to which it is added.
  set identifier(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value.ref.pointer);

  }

}

late final _sel_sourceWithIdentifier_ = objc.registerName("sourceWithIdentifier:");
late final _sel_addSource_ = objc.registerName("addSource:");
late final _sel_removeSource_ = objc.registerName("removeSource:");
late final _sel_removeSource_error_ = objc.registerName("removeSource:error:");
final _objc_msgSend_l9p60w = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();
late final _sel_layers = objc.registerName("layers");
late final _sel_setLayers_ = objc.registerName("setLayers:");
late final _sel_layerWithIdentifier_ = objc.registerName("layerWithIdentifier:");
late final _sel_addLayer_ = objc.registerName("addLayer:");
late final _sel_insertLayer_atIndex_ = objc.registerName("insertLayer:atIndex:");
final _objc_msgSend_djsa9o = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
late final _sel_insertLayer_belowLayer_ = objc.registerName("insertLayer:belowLayer:");
late final _sel_insertLayer_aboveLayer_ = objc.registerName("insertLayer:aboveLayer:");
late final _sel_removeLayer_ = objc.registerName("removeLayer:");
late final _sel_imageForName_ = objc.registerName("imageForName:");
late final _sel_setImage_forName_ = objc.registerName("setImage:forName:");
late final _sel_removeImageForName_ = objc.registerName("removeImageForName:");
late final _class_MLNLight = objc.getClass("MLNLight");

/// MLNLight
extension type MLNLight._(objc.ObjCObject object$) implements objc.ObjCObject {
  /// Constructs a [MLNLight] that points to the same underlying object as [other].
  MLNLight.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNLight] that wraps the given raw object pointer.
  MLNLight.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNLight].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNLight);

}

extension MLNLight$Methods on MLNLight {

}

late final _sel_light = objc.registerName("light");
late final _sel_setLight_ = objc.registerName("setLight:");
late final _sel_localizeLabelsIntoLocale_ = objc.registerName("localizeLabelsIntoLocale:");

/// The proxy object for the current map style.
/// 
/// MLNStyle provides a set of convenience methods for changing default styles included
/// with MapLibre.
/// 
/// It is also possible to directly manipulate the current map style
/// via ``MLNMapView/style`` by updating the style's data sources or layers.
/// 
/// > Note: Wait until the map style has finished loading before modifying a map's
/// style via any of the ``MLNStyle`` instance methods below. You can use the
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
/// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` methods as indicators
/// that it's safe to modify the map's style.
extension type MLNStyle._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNStyle] that points to the same underlying object as [other].
  MLNStyle.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNStyle] that wraps the given raw object pointer.
  MLNStyle.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNStyle].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNStyle);

  /// alloc
  static MLNStyle alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_alloc);
    return MLNStyle.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNStyle allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNStyle, _sel_allocWithZone_, zone);
    return MLNStyle.fromPointer($ret, retain: false, release: true);
  }


  /// Returns default style
  static MLNDefaultStyle defaultStyle() {
    final $ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_defaultStyle);
    return MLNDefaultStyle.fromPointer($ret, retain: true, release: true);
  }


  /// Returns default style as NSURL
  static objc.NSURL? defaultStyleURL() {
    final $ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_defaultStyleURL);
    return $ret.address == 0 ? null : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static MLNStyle new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_new);
    return MLNStyle.fromPointer($ret, retain: false, release: true);
  }


  /// Get predefined style by name
/// 
/// @param withStyleName style name.
  static MLNDefaultStyle? predefinedStyle(objc.NSString withStyleName) {
    final $ret = _objc_msgSend_1sotr3r(_class_MLNStyle, _sel_predefinedStyle_, withStyleName.ref.pointer);
    return $ret.address == 0 ? null : MLNDefaultStyle.fromPointer($ret, retain: true, release: true);
  }


  /// Returns list of predefined styles
  static objc.NSArray predefinedStyles() {
    final $ret = _objc_msgSend_151sglz(_class_MLNStyle, _sel_predefinedStyles);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
  /// Returns a new instance of MLNStyle constructed with the default `new` method.
  MLNStyle() : this.as(new$().object$);

}

extension MLNStyle$Methods on MLNStyle {

  /// Adds a new layer on top of existing layers.
/// 
/// > Note: Adding the same layer instance more than once will result in a
/// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
/// different layer instances, will also result in an exception.
/// 
/// > Note: Layers should be added in
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
/// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
/// has loaded the style and is ready to accept a new layer.
/// 
/// @param layer The layer object to add to the map view. This object must be an
/// instance of a concrete subclass of ``MLNStyleLayer``.
  void addLayer(MLNStyleLayer layer) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addLayer_, layer.ref.pointer);

  }


  /// Adds a new source to the current style.
/// 
/// > Note: Adding the same source instance more than once will result in a
/// ``MLNRedundantSourceException``. Reusing the same source identifier, even with
/// different source instances, will result in a
/// ``MLNRedundantSourceIdentifierException``.
/// 
/// > Note: Sources should be added in
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
/// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
/// has loaded the style and is ready to accept a new source.
/// 
/// @param source The source to add to the current style.
  void addSource(MLNSource source) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addSource_, source.ref.pointer);

  }


  /// Returns the image associated with the given name in the style.
/// 
/// @param name The name associated with the image you want to obtain.
/// @return The image associated with the given name, or `nil` if no image is
/// associated with that name.
  UIImage? imageForName(objc.NSString name) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_imageForName_, name.ref.pointer);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNStyle init() {
  objc.checkOsVersionInternal('MLNStyle.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNStyle.fromPointer($ret, retain: false, release: true);
  }


  /// Inserts a new layer above another layer.
/// 
/// > Note: Inserting the same layer instance more than once will result in a
/// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
/// different layer instances, will also result in an exception.
/// 
/// @param layer The layer to insert.
/// @param sibling An existing layer in the style.
/// 
/// #### Related examples
/// TODO: Add an image, learn how to add a layer to your map above an
/// existing layer.
  void insertLayer(MLNStyleLayer layer, {required MLNStyleLayer aboveLayer}) {
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_insertLayer_aboveLayer_, layer.ref.pointer, aboveLayer.ref.pointer);

  }


  /// Inserts a new layer into the style at the given index.
/// 
/// > Note: Adding the same layer instance more than once will result in a
/// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
/// different layer instances, will also result in an exception.
/// 
/// > Note: Layers should be added in
/// ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` or
/// ``MLNMapViewDelegate/mapViewDidFinishLoadingMap:`` to ensure that the map
/// has loaded the style and is ready to accept a new layer.
/// 
/// @param layer The layer to insert.
/// @param index The index at which to insert the layer. An index of 0 would send
/// the layer to the back; an index equal to the number of objects in the
/// `layers` property would bring the layer to the front.
  void insertLayer$1(MLNStyleLayer layer, {required int atIndex}) {
_objc_msgSend_djsa9o(object$.ref.pointer, _sel_insertLayer_atIndex_, layer.ref.pointer, atIndex);

  }


  /// Inserts a new layer below another layer.
/// 
/// > Note: Inserting the same layer instance more than once will result in a
/// ``MLNRedundantLayerException``. Reusing the same layer identifer, even with
/// different layer instances, will also result in an exception.
/// 
/// @param layer The layer to insert.
/// @param sibling An existing layer in the style.
/// 
/// #### Related examples
/// TODO: Add multiple shapes from a single shape source, learn how to
/// add a layer to your map below an existing layer.
  void insertLayer$2(MLNStyleLayer layer, {required MLNStyleLayer belowLayer}) {
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_insertLayer_belowLayer_, layer.ref.pointer, belowLayer.ref.pointer);

  }


  /// Returns a style layer with the given identifier in the current style.
/// 
/// @return An instance of a concrete subclass of ``MLNStyleLayer`` associated with
/// the given identifier, or `nil` if the current style contains no such style
/// layer.
  MLNStyleLayer? layerWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_layerWithIdentifier_, identifier.ref.pointer);
    return $ret.address == 0 ? null : MLNStyleLayer.fromPointer($ret, retain: true, release: true);
  }


  /// The layers included in the style, arranged according to their back-to-front
/// ordering on the screen.
  objc.NSArray get layers {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layers);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Provides global light source for the style.
  MLNLight get light {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_light);
    return MLNLight.fromPointer($ret, retain: true, release: true);
  }


  /// Attempts to localize labels in the style into the given locale.
/// 
/// This method automatically modifies the text property of any symbol style layer
/// in the style whose source is the
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets-v8/#overview">Mapbox Streets
/// source</a>. On iOS, the user can set the systems preferred language in Settings, General Settings,
/// Language & Region. On macOS, the user can set the systems preferred language in the Language &
/// Region pane of System Preferences.
/// 
/// @param locale The locale into which labels should be localized. To use the
/// systems preferred language, if supported, specify `nil`. To use the local
/// language, specify a locale with the identifier `mul`.
  void localizeLabelsIntoLocale(objc.NSLocale? locale) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_localizeLabelsIntoLocale_, locale?.ref.pointer ?? ffi.nullptr);

  }


  /// The name of the style.
/// 
/// You can customize the styles name in Mapbox Studio.
  objc.NSString? get name {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_name);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// A boolean value indicating whether label placement transitions are enabled.
/// 
/// The default value of this property is `YES`.
  bool get performsPlacementTransitions {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_performsPlacementTransitions);

  }


  /// Removes a name and its associated image from the style.
/// 
/// @param name The name of the image to remove.
  void removeImageForName(objc.NSString name) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeImageForName_, name.ref.pointer);

  }


  /// Removes a layer from the map view.
/// 
/// @param layer The layer object to remove from the map view. This object
/// must conform to the ``MLNStyleLayer`` protocol.
  void removeLayer(MLNStyleLayer layer) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeLayer_, layer.ref.pointer);

  }


  /// Removes a source from the current style.
/// 
/// @param source The source to remove from the current style.
  void removeSource(MLNSource source) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeSource_, source.ref.pointer);

  }


  /// Removes a source from the current style.
/// 
/// @param source The source to remove from the current style.
/// @param outError Upon return, if an error has occurred, a pointer to an `NSError`
/// object describing the error. Pass in `NULL` to ignore any error.
/// 
/// @return `YES` if `source` was removed successfully. If `NO`, `outError` contains
/// an `NSError` object describing the problem.
  bool removeSource$1(MLNSource source) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_l9p60w(object$.ref.pointer, _sel_removeSource_error_, source.ref.pointer, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret;    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// Adds or overrides an image used by the styles layers.
/// 
/// To use an image in a style layer, give it a unique name using this method, then
/// set the `iconImageName` property of an ``MLNSymbolStyleLayer`` object to that
/// name.
/// 
/// @param image The image for the name.
/// @param name The name of the image to set to the style.
/// 
/// #### Related examples
/// TODO: Use images to cluster point data
/// TODO: Cluster point data
/// Learn how to add images to your map using an ``MLNStyle`` object.
  void setImage(UIImage image, {required objc.NSString forName}) {
_objc_msgSend_pfv6jd(object$.ref.pointer, _sel_setImage_forName_, image.ref.pointer, forName.ref.pointer);

  }


  /// The layers included in the style, arranged according to their back-to-front
/// ordering on the screen.
  set layers(objc.NSArray value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLayers_, value.ref.pointer);

  }


  /// Provides global light source for the style.
  set light(MLNLight value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLight_, value.ref.pointer);

  }


  /// A boolean value indicating whether label placement transitions are enabled.
/// 
/// The default value of this property is `YES`.
  set performsPlacementTransitions(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setPerformsPlacementTransitions_, value);

  }


  /// A set containing the styles sources.
  set sources(objc.NSSet value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSources_, value.ref.pointer);

  }


  /// The style JSON representation of the map.
/// 
/// Setting this property results in an asynchronous style change. If you wish to know when the style
/// change is complete, observe the ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` method
/// on ``MLNMapViewDelegate``.
/// 
/// The JSON must conform to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
/// 
/// @throws NSInvalidArgumentException if styleJSON is nil or invalid JSON
  set styleJSON(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setStyleJSON_, value.ref.pointer);

  }


  /// Values describing animated transitions to changes on a style's individual
/// paint properties.
  set transition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setTransition_, value);

  }


  /// Returns a source with the given identifier in the current style.
/// 
/// @return An instance of a concrete subclass of ``MLNSource`` associated with the
/// given identifier, or `nil` if the current style contains no such source.
  MLNSource? sourceWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_sourceWithIdentifier_, identifier.ref.pointer);
    return $ret.address == 0 ? null : MLNSource.fromPointer($ret, retain: true, release: true);
  }


  /// A set containing the styles sources.
  objc.NSSet get sources {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sources);
    return objc.NSSet.fromPointer($ret, retain: true, release: true);
  }


  /// The style JSON representation of the map.
/// 
/// Setting this property results in an asynchronous style change. If you wish to know when the style
/// change is complete, observe the ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` method
/// on ``MLNMapViewDelegate``.
/// 
/// The JSON must conform to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
/// 
/// @throws NSInvalidArgumentException if styleJSON is nil or invalid JSON
  objc.NSString get styleJSON {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_styleJSON);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// Values describing animated transitions to changes on a style's individual
/// paint properties.
  MLNTransition get transition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_transition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_transition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }

}

late final _protocol_MLNStylable = objc.getProtocol("MLNStylable");
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCProtocolImpl> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCProtocolImpl> )>();
late final _sel_style = objc.registerName("style");

/// Construction methods for `objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_MLNStyle_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> fromFunction(MLNStyle? Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_MLNStyle_ffiVoid$CallExtension on objc.ObjCBlock<MLNStyle? Function(ffi.Pointer<ffi.Void>)> {
  MLNStyle? call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0).address == 0 ? null : MLNStyle.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}


/// An object whose contents are represented by an ``MLNStyle`` object that you
/// configure.
extension type MLNStylable._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [MLNStylable] that points to the same underlying object as [other].
  MLNStylable.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNStylable] that wraps the given raw object pointer.
  MLNStylable.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNStylable].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNStylable);
  }
}

extension MLNStylable$Methods on MLNStylable {

  /// The style currently displayed in the receiver.
  MLNStyle? get style {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_style);
    return $ret.address == 0 ? null : MLNStyle.fromPointer($ret, retain: true, release: true);
  }

}

  interface class MLNStylable$Builder {
  
    /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_MLNStylable.cast());

  /// Builds an object that implements the MLNStylable protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNStylable implement({required MLNStyle? Function() style, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNStylable');
        MLNStylable$Builder.style.implement(builder, style);
    builder.addProtocol($protocol);
    return MLNStylable.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNStylable protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder, {required MLNStyle? Function() style, bool $keepIsolateAlive = true}) {
        MLNStylable$Builder.style.implement(builder, style);
    builder.addProtocol($protocol);
  }

  
  /// The style currently displayed in the receiver.
static final style = objc.ObjCProtocolMethod<MLNStyle? Function()>(
      _protocol_MLNStylable,
      _sel_style,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1mbt9g9).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNStylable,
          _sel_style,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (MLNStyle? Function() func) => ObjCBlock_MLNStyle_ffiVoid.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );

}
/// The vertical alignment of an annotation within a map view. Used with
/// ``MLNMapView/userLocationVerticalAlignment``.
sealed class MLNAnnotationVerticalAlignment {
  /// Aligns the annotation vertically in the center of the map view.
  static const MLNAnnotationVerticalAlignmentCenter = 0;
  /// Aligns the annotation vertically at the top of the map view.
  static const MLNAnnotationVerticalAlignmentTop = 1;
  /// Aligns the annotation vertically at the bottom of the map view.
  static const MLNAnnotationVerticalAlignmentBottom = 2;}

/// The position of scale bar, compass, logo and attribution in a map view. Used with
/// ``MLNMapView/scaleBarPosition``,
/// ``MLNMapView/compassViewPosition``,
/// ``MLNMapView/logoViewPosition``,
/// ``MLNMapView/attributionButtonPosition``.
sealed class MLNOrnamentPosition {
  /// Place the ornament in the top left of the map view.
  static const MLNOrnamentPositionTopLeft = 0;
  /// Place the ornament in the top right of the map view.
  static const MLNOrnamentPositionTopRight = 1;
  /// Place the ornament in the bottom left of the map view.
  static const MLNOrnamentPositionBottomLeft = 2;
  /// Place the ornament in the bottom right of the map view.
  static const MLNOrnamentPositionBottomRight = 3;}

/// The mode used to track the user location on the map. Used with
/// ``MLNMapView/userTrackingMode``.
/// 
/// #### Related examples
/// - TODO: Switch between user tracking modes</a> example to learn how to toggle modes and
/// how each mode behaves.
sealed class MLNUserTrackingMode {
  /// The map does not follow the user location.
  static const MLNUserTrackingModeNone = 0;
  /// The map follows the user location. This tracking mode falls back
  /// to ``MLNUserTrackingMode/MLNUserTrackingModeNone`` if the user pans the map view.
  static const MLNUserTrackingModeFollow = 1;
  /// The map follows the user location and rotates when the heading changes.
  /// The default user location annotation displays a fan-shaped indicator with
  /// the current heading. The heading indicator represents the direction the
  /// device is facing, which is sized according to the reported accuracy.
  /// 
  /// This tracking mode is disabled if the user pans the map view, but
  /// remains enabled if the user zooms in. If the user rotates the map
  /// view, this tracking mode will fall back to ``MLNUserTrackingModeFollow``.
  static const MLNUserTrackingModeFollowWithHeading = 2;
  /// The map follows the user location and rotates when the course changes.
  /// Course represents the direction in which the device is traveling.
  /// The default user location annotation shows a puck-shaped indicator
  /// that rotates as the course changes.
  /// 
  /// This tracking mode is disabled if the user pans the map view, but
  /// remains enabled if the user zooms in. If the user rotates the map view,
  /// this tracking mode will fall back to ``MLNUserTrackingModeFollow``.
  static const MLNUserTrackingModeFollowWithCourse = 3;}

sealed class MLNPanScrollingMode {
  /// The map allows the user to only scroll horizontally.
  static const MLNPanScrollingModeHorizontal = 0;
  /// The map allows the user to only scroll vertically.
  static const MLNPanScrollingModeVertical = 1;
  /// The map allows the user to scroll both horizontally and vertically.
  static const MLNPanScrollingModeDefault = 2;}

late final _class_MLNMapView = objc.getClass("MLNMapView");
late final _sel_initWithFrame_styleURL_ = objc.registerName("initWithFrame:styleURL:");
late final _sel_initWithFrame_styleJSON_ = objc.registerName("initWithFrame:styleJSON:");
late final _sel_initWithFrame_options_ = objc.registerName("initWithFrame:options:");

/// WARNING: MLNMapViewDelegate is a stub. To generate bindings for this class, include
/// MLNMapViewDelegate in your config's objc-protocols list.
///
/// MLNMapViewDelegate
extension type MLNMapViewDelegate._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [MLNMapViewDelegate] that points to the same underlying object as [other].
  MLNMapViewDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNMapViewDelegate] that wraps the given raw object pointer.
  MLNMapViewDelegate.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
late final _sel_reloadStyle_ = objc.registerName("reloadStyle:");
late final _sel_automaticallyAdjustsContentInset = objc.registerName("automaticallyAdjustsContentInset");
late final _sel_setAutomaticallyAdjustsContentInset_ = objc.registerName("setAutomaticallyAdjustsContentInset:");
late final _sel_showsScale = objc.registerName("showsScale");
late final _sel_setShowsScale_ = objc.registerName("setShowsScale:");
late final _class_MLNScaleBar = objc.getClass("MLNScaleBar");

/// MLNScaleBar
extension type MLNScaleBar._(objc.ObjCObject object$) implements objc.ObjCObject {
  /// Constructs a [MLNScaleBar] that points to the same underlying object as [other].
  MLNScaleBar.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNScaleBar] that wraps the given raw object pointer.
  MLNScaleBar.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNScaleBar].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNScaleBar);

}

extension MLNScaleBar$Methods on MLNScaleBar {

}

late final _sel_scaleBar = objc.registerName("scaleBar");
late final _sel_scaleBarShouldShowDarkStyles = objc.registerName("scaleBarShouldShowDarkStyles");
late final _sel_setScaleBarShouldShowDarkStyles_ = objc.registerName("setScaleBarShouldShowDarkStyles:");
late final _sel_scaleBarUsesMetricSystem = objc.registerName("scaleBarUsesMetricSystem");
late final _sel_setScaleBarUsesMetricSystem_ = objc.registerName("setScaleBarUsesMetricSystem:");
late final _sel_scaleBarPosition = objc.registerName("scaleBarPosition");
final _objc_msgSend_1c31cvt = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setScaleBarPosition_ = objc.registerName("setScaleBarPosition:");
final _objc_msgSend_8fd115 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_scaleBarMargins = objc.registerName("scaleBarMargins");
late final _sel_setScaleBarMargins_ = objc.registerName("setScaleBarMargins:");
late final _sel_showsCompassView = objc.registerName("showsCompassView");
late final _sel_setShowsCompassView_ = objc.registerName("setShowsCompassView:");
late final _sel_compassView = objc.registerName("compassView");
late final _sel_compassViewPosition = objc.registerName("compassViewPosition");
late final _sel_setCompassViewPosition_ = objc.registerName("setCompassViewPosition:");
late final _sel_compassViewMargins = objc.registerName("compassViewMargins");
late final _sel_setCompassViewMargins_ = objc.registerName("setCompassViewMargins:");
late final _sel_showsLogoView = objc.registerName("showsLogoView");
late final _sel_setShowsLogoView_ = objc.registerName("setShowsLogoView:");
late final _sel_logoView = objc.registerName("logoView");
late final _sel_logoViewPosition = objc.registerName("logoViewPosition");
late final _sel_setLogoViewPosition_ = objc.registerName("setLogoViewPosition:");
late final _sel_logoViewMargins = objc.registerName("logoViewMargins");
late final _sel_setLogoViewMargins_ = objc.registerName("setLogoViewMargins:");
late final _sel_showsAttributionButton = objc.registerName("showsAttributionButton");
late final _sel_setShowsAttributionButton_ = objc.registerName("setShowsAttributionButton:");
late final _sel_attributionButton = objc.registerName("attributionButton");
late final _sel_attributionButtonPosition = objc.registerName("attributionButtonPosition");
late final _sel_setAttributionButtonPosition_ = objc.registerName("setAttributionButtonPosition:");
late final _sel_attributionButtonMargins = objc.registerName("attributionButtonMargins");
late final _sel_setAttributionButtonMargins_ = objc.registerName("setAttributionButtonMargins:");
late final _sel_showAttribution_ = objc.registerName("showAttribution:");
late final _sel_preferredFramesPerSecond = objc.registerName("preferredFramesPerSecond");
late final _sel_setPreferredFramesPerSecond_ = objc.registerName("setPreferredFramesPerSecond:");
late final _sel_prefetchesTiles = objc.registerName("prefetchesTiles");
late final _sel_setPrefetchesTiles_ = objc.registerName("setPrefetchesTiles:");
late final _sel_tileCacheEnabled = objc.registerName("tileCacheEnabled");
late final _sel_setTileCacheEnabled_ = objc.registerName("setTileCacheEnabled:");
late final _sel_tileLodMinRadius = objc.registerName("tileLodMinRadius");
late final _sel_setTileLodMinRadius_ = objc.registerName("setTileLodMinRadius:");
late final _sel_tileLodScale = objc.registerName("tileLodScale");
late final _sel_setTileLodScale_ = objc.registerName("setTileLodScale:");
late final _sel_tileLodPitchThreshold = objc.registerName("tileLodPitchThreshold");
late final _sel_setTileLodPitchThreshold_ = objc.registerName("setTileLodPitchThreshold:");
late final _sel_tileLodZoomShift = objc.registerName("tileLodZoomShift");
late final _sel_setTileLodZoomShift_ = objc.registerName("setTileLodZoomShift:");
late final _sel_disableLocationManager = objc.registerName("disableLocationManager");
late final _protocol_MLNLocationManager = objc.getProtocol("MLNLocationManager");

/// MLNLocationManager
extension type MLNLocationManager._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [MLNLocationManager] that points to the same underlying object as [other].
  MLNLocationManager.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNLocationManager] that wraps the given raw object pointer.
  MLNLocationManager.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNLocationManager].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNLocationManager);
  }
}

extension MLNLocationManager$Methods on MLNLocationManager {

}

  interface class MLNLocationManager$Builder {
  
    /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_MLNLocationManager.cast());

  /// Builds an object that implements the MLNLocationManager protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNLocationManager implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNLocationManager');
    
    builder.addProtocol($protocol);
    return MLNLocationManager.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNLocationManager protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder, {bool $keepIsolateAlive = true}) {
    
    builder.addProtocol($protocol);
  }

  
  
}
late final _sel_locationManager = objc.registerName("locationManager");
late final _sel_setLocationManager_ = objc.registerName("setLocationManager:");
late final _sel_showsUserLocation = objc.registerName("showsUserLocation");
late final _sel_setShowsUserLocation_ = objc.registerName("setShowsUserLocation:");
late final _sel_dynamicNavigationCameraAnimationDuration = objc.registerName("dynamicNavigationCameraAnimationDuration");
late final _sel_setDynamicNavigationCameraAnimationDuration_ = objc.registerName("setDynamicNavigationCameraAnimationDuration:");
late final _sel_shouldRequestAuthorizationToUseLocationServices = objc.registerName("shouldRequestAuthorizationToUseLocationServices");
late final _sel_setShouldRequestAuthorizationToUseLocationServices_ = objc.registerName("setShouldRequestAuthorizationToUseLocationServices:");
late final _sel_isUserLocationVisible = objc.registerName("isUserLocationVisible");
late final _class_MLNUserLocation = objc.getClass("MLNUserLocation");

/// MLNUserLocation
extension type MLNUserLocation._(objc.ObjCObject object$) implements objc.ObjCObject {
  /// Constructs a [MLNUserLocation] that points to the same underlying object as [other].
  MLNUserLocation.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNUserLocation] that wraps the given raw object pointer.
  MLNUserLocation.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNUserLocation].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNUserLocation);

}

extension MLNUserLocation$Methods on MLNUserLocation {

}

late final _sel_userLocation = objc.registerName("userLocation");
late final _sel_userTrackingMode = objc.registerName("userTrackingMode");
final _objc_msgSend_1swtepj = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setUserTrackingMode_ = objc.registerName("setUserTrackingMode:");
final _objc_msgSend_xoapar = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_setUserTrackingMode_animated_ = objc.registerName("setUserTrackingMode:animated:");
final _objc_msgSend_7oa3sf = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , bool )>();
late final _sel_setUserTrackingMode_animated_completionHandler_ = objc.registerName("setUserTrackingMode:animated:completionHandler:");
final _objc_msgSend_1iu40ms = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_userLocationVerticalAlignment = objc.registerName("userLocationVerticalAlignment");
final _objc_msgSend_1m9zum6 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setUserLocationVerticalAlignment_ = objc.registerName("setUserLocationVerticalAlignment:");
final _objc_msgSend_47doj4 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_setUserLocationVerticalAlignment_animated_ = objc.registerName("setUserLocationVerticalAlignment:animated:");
final _objc_msgSend_1qddrus = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , bool )>();
late final _sel_updateUserLocationAnnotationView = objc.registerName("updateUserLocationAnnotationView");
late final _sel_updateUserLocationAnnotationViewAnimatedWithDuration_ = objc.registerName("updateUserLocationAnnotationViewAnimatedWithDuration:");
late final _sel_showsUserHeadingIndicator = objc.registerName("showsUserHeadingIndicator");
late final _sel_setShowsUserHeadingIndicator_ = objc.registerName("setShowsUserHeadingIndicator:");
late final _sel_displayHeadingCalibration = objc.registerName("displayHeadingCalibration");
late final _sel_setDisplayHeadingCalibration_ = objc.registerName("setDisplayHeadingCalibration:");
late final _sel_targetCoordinate = objc.registerName("targetCoordinate");
late final _sel_setTargetCoordinate_ = objc.registerName("setTargetCoordinate:");
late final _sel_setTargetCoordinate_animated_ = objc.registerName("setTargetCoordinate:animated:");
final _objc_msgSend_o7hjv2 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , bool )>();
late final _sel_setTargetCoordinate_animated_completionHandler_ = objc.registerName("setTargetCoordinate:animated:completionHandler:");
final _objc_msgSend_1pbhom5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_isZoomEnabled = objc.registerName("isZoomEnabled");
late final _sel_setZoomEnabled_ = objc.registerName("setZoomEnabled:");
late final _sel_isQuickZoomReversed = objc.registerName("isQuickZoomReversed");
late final _sel_setQuickZoomReversed_ = objc.registerName("setQuickZoomReversed:");
late final _sel_isScrollEnabled = objc.registerName("isScrollEnabled");
late final _sel_setScrollEnabled_ = objc.registerName("setScrollEnabled:");
late final _sel_panScrollingMode = objc.registerName("panScrollingMode");
final _objc_msgSend_1vb5jwj = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setPanScrollingMode_ = objc.registerName("setPanScrollingMode:");
final _objc_msgSend_k7jknj = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_isRotateEnabled = objc.registerName("isRotateEnabled");
late final _sel_setRotateEnabled_ = objc.registerName("setRotateEnabled:");
late final _sel_isPitchEnabled = objc.registerName("isPitchEnabled");
late final _sel_setPitchEnabled_ = objc.registerName("setPitchEnabled:");
late final _sel_anchorRotateOrZoomGesturesToCenterCoordinate = objc.registerName("anchorRotateOrZoomGesturesToCenterCoordinate");
late final _sel_setAnchorRotateOrZoomGesturesToCenterCoordinate_ = objc.registerName("setAnchorRotateOrZoomGesturesToCenterCoordinate:");
late final _sel_isHapticFeedbackEnabled = objc.registerName("isHapticFeedbackEnabled");
late final _sel_setHapticFeedbackEnabled_ = objc.registerName("setHapticFeedbackEnabled:");
late final _sel_decelerationRate = objc.registerName("decelerationRate");
late final _sel_setDecelerationRate_ = objc.registerName("setDecelerationRate:");
late final _sel_setCenterCoordinate_animated_ = objc.registerName("setCenterCoordinate:animated:");
late final _sel_setCenterCoordinate_zoomLevel_animated_ = objc.registerName("setCenterCoordinate:zoomLevel:animated:");
final _objc_msgSend_sbs4d5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Double , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , double , bool )>();
late final _sel_setCenterCoordinate_zoomLevel_direction_animated_ = objc.registerName("setCenterCoordinate:zoomLevel:direction:animated:");
final _objc_msgSend_3zczym = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Double , ffi.Double , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , double , double , bool )>();
late final _sel_setCenterCoordinate_zoomLevel_direction_animated_completionHandler_ = objc.registerName("setCenterCoordinate:zoomLevel:direction:animated:completionHandler:");
final _objc_msgSend_d9pvdp = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Double , ffi.Double , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , double , double , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_zoomLevel = objc.registerName("zoomLevel");
late final _sel_setZoomLevel_ = objc.registerName("setZoomLevel:");
late final _sel_setZoomLevel_animated_ = objc.registerName("setZoomLevel:animated:");
final _objc_msgSend_ghxo7e = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double , bool )>();
late final _sel_maximumScreenBounds = objc.registerName("maximumScreenBounds");
final _objc_msgSend_ygoa6a = objc.msgSendPointer.cast<ffi.NativeFunction<MLNCoordinateBounds Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<MLNCoordinateBounds Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_ygoa6aStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MLNCoordinateBounds> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<MLNCoordinateBounds> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setMaximumScreenBounds_ = objc.registerName("setMaximumScreenBounds:");
final _objc_msgSend_9ay59k = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds )>();
late final _sel_direction = objc.registerName("direction");
late final _sel_setDirection_ = objc.registerName("setDirection:");
late final _sel_setDirection_animated_ = objc.registerName("setDirection:animated:");
late final _sel_minimumPitch = objc.registerName("minimumPitch");
late final _sel_setMinimumPitch_ = objc.registerName("setMinimumPitch:");
late final _sel_maximumPitch = objc.registerName("maximumPitch");
late final _sel_setMaximumPitch_ = objc.registerName("setMaximumPitch:");
late final _sel_resetNorth = objc.registerName("resetNorth");
late final _sel_resetPosition = objc.registerName("resetPosition");
late final _sel_visibleCoordinateBounds = objc.registerName("visibleCoordinateBounds");
late final _sel_setVisibleCoordinateBounds_ = objc.registerName("setVisibleCoordinateBounds:");
late final _sel_setVisibleCoordinateBounds_animated_ = objc.registerName("setVisibleCoordinateBounds:animated:");
final _objc_msgSend_148tmbg = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , bool )>();
late final _sel_setVisibleCoordinateBounds_edgePadding_animated_ = objc.registerName("setVisibleCoordinateBounds:edgePadding:animated:");
final _objc_msgSend_18wcmvu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , UIEdgeInsets , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , UIEdgeInsets , bool )>();
late final _sel_setVisibleCoordinateBounds_edgePadding_animated_completionHandler_ = objc.registerName("setVisibleCoordinateBounds:edgePadding:animated:completionHandler:");
final _objc_msgSend_1v6m6tt = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , UIEdgeInsets , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , UIEdgeInsets , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_setVisibleCoordinates_count_edgePadding_animated_ = objc.registerName("setVisibleCoordinates:count:edgePadding:animated:");
final _objc_msgSend_1evryr5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , ffi.UnsignedLong , UIEdgeInsets , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , int , UIEdgeInsets , bool )>();
late final _sel_setVisibleCoordinates_count_edgePadding_direction_duration_animationTimingFunction_completionHandler_ = objc.registerName("setVisibleCoordinates:count:edgePadding:direction:duration:animationTimingFunction:completionHandler:");
final _objc_msgSend_v2jdd0 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , ffi.UnsignedLong , UIEdgeInsets , ffi.Double , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , int , UIEdgeInsets , double , double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_showAnnotations_animated_ = objc.registerName("showAnnotations:animated:");
late final _sel_showAnnotations_edgePadding_animated_ = objc.registerName("showAnnotations:edgePadding:animated:");
final _objc_msgSend_1f4zv7b = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , bool )>();
late final _sel_showAnnotations_edgePadding_animated_completionHandler_ = objc.registerName("showAnnotations:edgePadding:animated:completionHandler:");
final _objc_msgSend_16lja1o = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_setCamera_ = objc.registerName("setCamera:");
late final _sel_setCamera_animated_ = objc.registerName("setCamera:animated:");
late final _sel_setCamera_withDuration_animationTimingFunction_ = objc.registerName("setCamera:withDuration:animationTimingFunction:");
final _objc_msgSend_r1s65y = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_setCamera_withDuration_animationTimingFunction_completionHandler_ = objc.registerName("setCamera:withDuration:animationTimingFunction:completionHandler:");
final _objc_msgSend_1s40ged = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_setCamera_withDuration_animationTimingFunction_edgePadding_completionHandler_ = objc.registerName("setCamera:withDuration:animationTimingFunction:edgePadding:completionHandler:");
final _objc_msgSend_tm3gbn = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_flyToCamera_completionHandler_ = objc.registerName("flyToCamera:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_flyToCamera_withDuration_completionHandler_ = objc.registerName("flyToCamera:withDuration:completionHandler:");
final _objc_msgSend_a85mgj = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_flyToCamera_withDuration_peakAltitude_completionHandler_ = objc.registerName("flyToCamera:withDuration:peakAltitude:completionHandler:");
final _objc_msgSend_b0p9a0 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , ffi.Double , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , double , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_flyToCamera_edgePadding_withDuration_completionHandler_ = objc.registerName("flyToCamera:edgePadding:withDuration:completionHandler:");
final _objc_msgSend_s17tgr = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , ffi.Double , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets , double , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_cameraThatFitsCoordinateBounds_ = objc.registerName("cameraThatFitsCoordinateBounds:");
final _objc_msgSend_5pnf8k = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds )>();
late final _sel_cameraThatFitsCoordinateBounds_edgePadding_ = objc.registerName("cameraThatFitsCoordinateBounds:edgePadding:");
final _objc_msgSend_1a5ayri = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , UIEdgeInsets )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , UIEdgeInsets )>();
late final _sel_camera_fittingCoordinateBounds_edgePadding_ = objc.registerName("camera:fittingCoordinateBounds:edgePadding:");
final _objc_msgSend_1v2rrrs = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , MLNCoordinateBounds , UIEdgeInsets )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , MLNCoordinateBounds , UIEdgeInsets )>();
late final _class_MLNShape = objc.getClass("MLNShape");
late final _sel_shapeWithData_encoding_error_ = objc.registerName("shapeWithData:encoding:error:");
final _objc_msgSend_1nomli1 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();
late final _sel_geoJSONDataUsingEncoding_ = objc.registerName("geoJSONDataUsingEncoding:");
late final _protocol_MLNAnnotation = objc.getProtocol("MLNAnnotation");

/// MLNAnnotation
extension type MLNAnnotation._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [MLNAnnotation] that points to the same underlying object as [other].
  MLNAnnotation.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNAnnotation] that wraps the given raw object pointer.
  MLNAnnotation.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNAnnotation].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNAnnotation);
  }
}

extension MLNAnnotation$Methods on MLNAnnotation {

}

  interface class MLNAnnotation$Builder {
  
    /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_MLNAnnotation.cast());

  /// Builds an object that implements the MLNAnnotation protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNAnnotation implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNAnnotation');
    
    builder.addProtocol($protocol);
    return MLNAnnotation.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNAnnotation protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder, {bool $keepIsolateAlive = true}) {
    
    builder.addProtocol($protocol);
  }

  
  
}

/// MLNShape
extension type MLNShape._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,MLNAnnotation,objc.NSSecureCoding {
  /// Constructs a [MLNShape] that points to the same underlying object as [other].
  MLNShape.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNShape] that wraps the given raw object pointer.
  MLNShape.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNShape].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShape);

  /// alloc
  static MLNShape alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNShape, _sel_alloc);
    return MLNShape.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNShape allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNShape, _sel_allocWithZone_, zone);
    return MLNShape.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNShape new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNShape, _sel_new);
    return MLNShape.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNShape, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNShape, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNShape constructed with the default `new` method.
  MLNShape() : this.as(new$().object$);

}

extension MLNShape$Methods on MLNShape {

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// Returns the GeoJSON string representation of the shape encapsulated in a data
/// object.
/// 
/// @param encoding The string encoding to use.
/// @return A data object containing the shapes GeoJSON string representation.
  objc.NSData geoJSONDataUsingEncoding(int encoding) {
    final $ret = _objc_msgSend_14hpxwa(object$.ref.pointer, _sel_geoJSONDataUsingEncoding_, encoding);
    return objc.NSData.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNShape init() {
  objc.checkOsVersionInternal('MLNShape.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNShape.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNShape? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: false, release: true);
  }


  /// The subtitle of the shape annotation. The default value of this property is
/// `nil`.
/// 
/// This property is ignored when the shape is used in an ``MLNShapeSource``. To
/// provide additional information about a shape used in a shape source, create an
/// ``MLNFeature`` and add an attribute to the ``MLNFeature/attributes`` property.
  set subtitle(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSubtitle_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// The title of the shape annotation.
/// 
/// The default value of this property is `nil`.
/// 
/// This property is ignored when the shape is used in an ``MLNShapeSource``. To name
/// a shape used in a shape source, create an ``MLNFeature`` and add an attribute to
/// the ``MLNFeature/attributes`` property.
  set title(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// The subtitle of the shape annotation. The default value of this property is
/// `nil`.
/// 
/// This property is ignored when the shape is used in an ``MLNShapeSource``. To
/// provide additional information about a shape used in a shape source, create an
/// ``MLNFeature`` and add an attribute to the ``MLNFeature/attributes`` property.
  objc.NSString? get subtitle {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_subtitle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// The title of the shape annotation.
/// 
/// The default value of this property is `nil`.
/// 
/// This property is ignored when the shape is used in an ``MLNShapeSource``. To name
/// a shape used in a shape source, create an ``MLNFeature`` and add an attribute to
/// the ``MLNFeature/attributes`` property.
  objc.NSString? get title {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_camera_fittingShape_edgePadding_ = objc.registerName("camera:fittingShape:edgePadding:");
final _objc_msgSend_53bjzp = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets )>();
late final _sel_cameraThatFitsShape_direction_edgePadding_ = objc.registerName("cameraThatFitsShape:direction:edgePadding:");
final _objc_msgSend_ebhzse = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double , UIEdgeInsets )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , double , UIEdgeInsets )>();
late final _sel_anchorPointForGesture_ = objc.registerName("anchorPointForGesture:");
final _objc_msgSend_1mpyy6y = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_1mpyy6yStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_contentInset = objc.registerName("contentInset");
late final _sel_setContentInset_ = objc.registerName("setContentInset:");
late final _sel_cameraEdgeInsets = objc.registerName("cameraEdgeInsets");
late final _sel_setContentInset_animated_ = objc.registerName("setContentInset:animated:");
final _objc_msgSend_6ueq99 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets , bool )>();
late final _sel_setContentInset_animated_completionHandler_ = objc.registerName("setContentInset:animated:completionHandler:");
final _objc_msgSend_1vx0lfy = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , UIEdgeInsets , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_convertPoint_toCoordinateFromView_ = objc.registerName("convertPoint:toCoordinateFromView:");
final _objc_msgSend_4xp05x = objc.msgSendPointer.cast<ffi.NativeFunction<CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_4xp05xStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CLLocationCoordinate2D> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<CLLocationCoordinate2D> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_convertCoordinate_toPointToView_ = objc.registerName("convertCoordinate:toPointToView:");
final _objc_msgSend_mus1wv = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_mus1wvStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_convertRect_toCoordinateBoundsFromView_ = objc.registerName("convertRect:toCoordinateBoundsFromView:");
final _objc_msgSend_1f65wix = objc.msgSendPointer.cast<ffi.NativeFunction<MLNCoordinateBounds Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<MLNCoordinateBounds Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_1f65wixStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MLNCoordinateBounds> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<MLNCoordinateBounds> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_convertCoordinateBounds_toRectToView_ = objc.registerName("convertCoordinateBounds:toRectToView:");
final _objc_msgSend_18hv5gj = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_18hv5gjStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.CGRect> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_metersPerPointAtLatitude_ = objc.registerName("metersPerPointAtLatitude:");
final _objc_msgSend_1tczmpv = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double )>();
final _objc_msgSend_1tczmpvFpret = objc.msgSendFpretPointer.cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Double )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , double )>();
late final _class_MLNMapProjection = objc.getClass("MLNMapProjection");
late final _sel_initWithMapView_ = objc.registerName("initWithMapView:");
late final _sel_setCamera_withEdgeInsets_ = objc.registerName("setCamera:withEdgeInsets:");
final _objc_msgSend_1c0ferf = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , UIEdgeInsets )>();
late final _sel_setVisibleCoordinateBounds_edgePadding_ = objc.registerName("setVisibleCoordinateBounds:edgePadding:");
final _objc_msgSend_vmuxgq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , UIEdgeInsets )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateBounds , UIEdgeInsets )>();
late final _sel_convertPoint_ = objc.registerName("convertPoint:");
final _objc_msgSend_zdqa7 = objc.msgSendPointer.cast<ffi.NativeFunction<CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint )>>().asFunction<CLLocationCoordinate2D Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint )>();
final _objc_msgSend_zdqa7Stret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CLLocationCoordinate2D> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint )>>().asFunction<void Function(ffi.Pointer<CLLocationCoordinate2D> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint )>();
late final _sel_convertCoordinate_ = objc.registerName("convertCoordinate:");
final _objc_msgSend_p1qkdl = objc.msgSendPointer.cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D )>>().asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D )>();
final _objc_msgSend_p1qkdlStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D )>>().asFunction<void Function(ffi.Pointer<objc.CGPoint> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , CLLocationCoordinate2D )>();
late final _sel_metersPerPoint = objc.registerName("metersPerPoint");

/// The aim of this class is to provide the functionality of changing the camera state and
/// converting between map view screen coordinates and geographical coordinates without
/// changing the actual map view camera state.
extension type MLNMapProjection._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNMapProjection] that points to the same underlying object as [other].
  MLNMapProjection.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMapProjection] that wraps the given raw object pointer.
  MLNMapProjection.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMapProjection].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapProjection);

  /// alloc
  static MLNMapProjection alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapProjection, _sel_alloc);
    return MLNMapProjection.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMapProjection allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMapProjection, _sel_allocWithZone_, zone);
    return MLNMapProjection.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNMapProjection new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapProjection, _sel_new);
    return MLNMapProjection.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNMapProjection constructed with the default `new` method.
  MLNMapProjection() : this.as(new$().object$);

}

extension MLNMapProjection$Methods on MLNMapProjection {

  /// A camera representing the current projection state
  MLNMapCamera get camera {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_camera);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// Converts a geographic coordinate to a point in the map view's the projection
/// was initialized with coordinate system.
/// 
/// @param coordinate The geographic coordinate to convert.
/// @return The point corresponding to the given geographic coordinate.
  objc.CGPoint convertCoordinate(CLLocationCoordinate2D coordinate) {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_p1qkdlStret($ptr, object$.ref.pointer, _sel_convertCoordinate_, coordinate) : $ptr.ref = _objc_msgSend_p1qkdl(object$.ref.pointer, _sel_convertCoordinate_, coordinate);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// Converts a point in the coordinate system of the map view the projection
/// was initialized with to the geographical coordinate.
/// 
/// @param point The point to convert.
/// @return The geographic coordinate at the given point.
  CLLocationCoordinate2D convertPoint(objc.CGPoint point) {
    final $ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants ? _objc_msgSend_zdqa7Stret($ptr, object$.ref.pointer, _sel_convertPoint_, point) : $ptr.ref = _objc_msgSend_zdqa7(object$.ref.pointer, _sel_convertPoint_, point);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(
        $finalizable);

  }


  /// init
  MLNMapProjection init() {
  objc.checkOsVersionInternal('MLNMapProjection.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapProjection.fromPointer($ret, retain: false, release: true);
  }


  /// Initializes and returns the new projection object with the current
/// camera state from the provided map view.
/// 
/// @param mapView The map view the camera state to use for the initialization.
/// @return An initialized map projection.
  MLNMapProjection initWithMapView(MLNMapView mapView) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithMapView_, mapView.ref.pointer);
    return MLNMapProjection.fromPointer($ret, retain: false, release: true);
  }


  /// The distance in meters spanned by a single point for the current camera.
  double get metersPerPoint {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_metersPerPoint) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_metersPerPoint);

  }


  /// Change the projection state with camera and padding values.
/// 
/// @param camera The new camera to be used in the projection calculation.
/// @param insets The insets applied on top of the camera be used in the projection calculation.
/// 
/// > Note: ``MLNMapView`` instance frame must not be changed since this projection is initialized,
/// otherwise the calculation may be wrong.
  void setCamera(MLNMapCamera camera, {required UIEdgeInsets withEdgeInsets}) {
_objc_msgSend_1c0ferf(object$.ref.pointer, _sel_setCamera_withEdgeInsets_, camera.ref.pointer, withEdgeInsets);

  }


  /// Change the projection state to make the provided bounds visible with the specified inset.
/// 
/// @param bounds The bounds that the viewport should fit.
/// @param insets The insets applied on top of the viewport to be used in the projection calculation.
/// 
/// > Note: ``MLNMapView`` instance frame must not be changed since this projection is initialized,
/// otherwise the calculation may be wrong.
  void setVisibleCoordinateBounds(MLNCoordinateBounds bounds, {required UIEdgeInsets edgePadding}) {
_objc_msgSend_vmuxgq(object$.ref.pointer, _sel_setVisibleCoordinateBounds_edgePadding_, bounds, edgePadding);

  }

}

late final _sel_mapProjection = objc.registerName("mapProjection");
late final _sel_annotations = objc.registerName("annotations");
late final _sel_addAnnotation_ = objc.registerName("addAnnotation:");
late final _sel_addAnnotations_ = objc.registerName("addAnnotations:");
late final _sel_removeAnnotation_ = objc.registerName("removeAnnotation:");
late final _sel_removeAnnotations_ = objc.registerName("removeAnnotations:");
late final _class_MLNAnnotationView = objc.getClass("MLNAnnotationView");

/// MLNAnnotationView
extension type MLNAnnotationView._(objc.ObjCObject object$) implements objc.ObjCObject {
  /// Constructs a [MLNAnnotationView] that points to the same underlying object as [other].
  MLNAnnotationView.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNAnnotationView] that wraps the given raw object pointer.
  MLNAnnotationView.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNAnnotationView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNAnnotationView);

}

extension MLNAnnotationView$Methods on MLNAnnotationView {

}

late final _sel_viewForAnnotation_ = objc.registerName("viewForAnnotation:");
late final _class_MLNAnnotationImage = objc.getClass("MLNAnnotationImage");

/// MLNAnnotationImage
extension type MLNAnnotationImage._(objc.ObjCObject object$) implements objc.ObjCObject {
  /// Constructs a [MLNAnnotationImage] that points to the same underlying object as [other].
  MLNAnnotationImage.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNAnnotationImage] that wraps the given raw object pointer.
  MLNAnnotationImage.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNAnnotationImage].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNAnnotationImage);

}

extension MLNAnnotationImage$Methods on MLNAnnotationImage {

}

late final _sel_dequeueReusableAnnotationImageWithIdentifier_ = objc.registerName("dequeueReusableAnnotationImageWithIdentifier:");
late final _sel_dequeueReusableAnnotationViewWithIdentifier_ = objc.registerName("dequeueReusableAnnotationViewWithIdentifier:");
late final _sel_visibleAnnotations = objc.registerName("visibleAnnotations");
late final _sel_visibleAnnotationsInRect_ = objc.registerName("visibleAnnotationsInRect:");
late final _sel_selectedAnnotations = objc.registerName("selectedAnnotations");
late final _sel_setSelectedAnnotations_ = objc.registerName("setSelectedAnnotations:");
late final _sel_selectAnnotation_animated_ = objc.registerName("selectAnnotation:animated:");
late final _sel_selectAnnotation_animated_completionHandler_ = objc.registerName("selectAnnotation:animated:completionHandler:");
final _objc_msgSend_na2nx0 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_selectAnnotation_moveIntoView_animateSelection_completionHandler_ = objc.registerName("selectAnnotation:moveIntoView:animateSelection:completionHandler:");
final _objc_msgSend_2nhnqw = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , bool , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_deselectAnnotation_animated_ = objc.registerName("deselectAnnotation:animated:");
late final _sel_overlays = objc.registerName("overlays");
late final _protocol_MLNOverlay = objc.getProtocol("MLNOverlay");

/// MLNOverlay
extension type MLNOverlay._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [MLNOverlay] that points to the same underlying object as [other].
  MLNOverlay.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNOverlay] that wraps the given raw object pointer.
  MLNOverlay.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNOverlay].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNOverlay);
  }
}

extension MLNOverlay$Methods on MLNOverlay {

}

  interface class MLNOverlay$Builder {
  
    /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_MLNOverlay.cast());

  /// Builds an object that implements the MLNOverlay protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNOverlay implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNOverlay');
    
    builder.addProtocol($protocol);
    return MLNOverlay.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNOverlay protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder, {bool $keepIsolateAlive = true}) {
    
    builder.addProtocol($protocol);
  }

  
  
}
late final _sel_addOverlay_ = objc.registerName("addOverlay:");
late final _sel_addOverlays_ = objc.registerName("addOverlays:");
late final _sel_removeOverlay_ = objc.registerName("removeOverlay:");
late final _sel_removeOverlays_ = objc.registerName("removeOverlays:");
late final _sel_visibleFeaturesAtPoint_ = objc.registerName("visibleFeaturesAtPoint:");
final _objc_msgSend_wgkxx2 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint )>();
late final _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_ = objc.registerName("visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:");
late final _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_predicate_ = objc.registerName("visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:");
final _objc_msgSend_19l1l5m = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGPoint , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_visibleFeaturesInRect_ = objc.registerName("visibleFeaturesInRect:");
late final _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_ = objc.registerName("visibleFeaturesInRect:inStyleLayersWithIdentifiers:");
late final _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_predicate_ = objc.registerName("visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:");
final _objc_msgSend_1o8sa9u = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.CGRect , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_debugMask = objc.registerName("debugMask");
final _objc_msgSend_1kwkjor = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setDebugMask_ = objc.registerName("setDebugMask:");
final _objc_msgSend_pisvbv = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_isRenderingStatsViewEnabled = objc.registerName("isRenderingStatsViewEnabled");
late final _sel_enableRenderingStatsView_ = objc.registerName("enableRenderingStatsView:");
late final _sel_getActionJournalLogFiles = objc.registerName("getActionJournalLogFiles");
late final _sel_getActionJournalLog = objc.registerName("getActionJournalLog");
late final _sel_clearActionJournalLog = objc.registerName("clearActionJournalLog");
late final _sel_triggerRepaint = objc.registerName("triggerRepaint");
late final _sel_addPluginLayerType_ = objc.registerName("addPluginLayerType:");

/// An interactive, customizable map view with an interface similar to the one
/// provided by Apples MapKit.
/// 
/// Using ``MLNMapView``, you can embed the map inside a view, allow users to
/// manipulate it with standard gestures, animate the map between different
/// viewpoints, and present information in the form of annotations and overlays.
/// 
/// The map view loads scalable vector tiles that conform to the
/// <a href="https://github.com/mapbox/vector-tile-spec">Mapbox Vector Tile Specification</a>.
/// It styles them with a style that conforms to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Spec</a>.
/// Such styles can be designed with
/// <a href="https://maplibre.org/maputnik/">Maputnik</a>.
/// 
/// 
/// Because ``MLNMapView`` loads asynchronously, several delegate methods are available
/// for receiving map-related updates. These methods can be used to ensure that certain operations
/// have completed before taking any additional actions. Information on these methods is located
/// in the ``MLNMapViewDelegate`` protocol documentation.
/// 
/// Adding your own gesture recognizer to ``MLNMapView`` will block the corresponding
/// gesture recognizer built into ``MLNMapView``. To avoid conflicts, define which
/// gesture takes precedence. For example, you can create your own
/// `UITapGestureRecognizer` that will be invoked only if the default ``MLNMapView``
/// tap gesture fails:
/// 
/// ```swift
/// let mapTapGestureRecognizer = UITapGestureRecognizer(target: self, action:
/// #selector(myCustomFunction)) for recognizer in mapView.gestureRecognizers! where recognizer is
/// UITapGestureRecognizer { mapTapGestureRecognizer.require(toFail: recognizer)
/// }
/// mapView.addGestureRecognizer(mapTapGestureRecognizer)
/// ```
/// 
/// > Note: You are responsible for getting permission to use the map data and for
/// ensuring that your use adheres to the relevant terms of use.
extension type MLNMapView._(objc.ObjCObject object$) implements objc.ObjCObject,UIView,MLNStylable {
  /// Constructs a [MLNMapView] that points to the same underlying object as [other].
  MLNMapView.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMapView] that wraps the given raw object pointer.
  MLNMapView.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMapView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMapView);

  /// alloc
  static MLNMapView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapView, _sel_alloc);
    return MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMapView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMapView, _sel_allocWithZone_, zone);
    return MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// appearance
  static MLNMapView appearance() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapView, _sel_appearance);
    return MLNMapView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:
  static MLNMapView appearanceForTraitCollection(UITraitCollection trait) {
  objc.checkOsVersionInternal('MLNMapView.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_MLNMapView, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return MLNMapView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedIn:
  static MLNMapView appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
  objc.checkOsVersionInternal('MLNMapView.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_MLNMapView, _sel_appearanceForTraitCollection_whenContainedIn_, trait.ref.pointer, whenContainedIn?.ref.pointer ?? ffi.nullptr);
    return MLNMapView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static MLNMapView appearanceForTraitCollection$2(UITraitCollection trait, {required objc.NSArray whenContainedInInstancesOfClasses}) {
  objc.checkOsVersionInternal('MLNMapView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_MLNMapView, _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_, trait.ref.pointer, whenContainedInInstancesOfClasses.ref.pointer);
    return MLNMapView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedIn:
  static MLNMapView appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
  objc.checkOsVersionInternal('MLNMapView.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_MLNMapView, _sel_appearanceWhenContainedIn_, ContainerClass?.ref.pointer ?? ffi.nullptr);
    return MLNMapView.fromPointer($ret, retain: true, release: true);
  }


  /// appearanceWhenContainedInInstancesOfClasses:
  static MLNMapView appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
  objc.checkOsVersionInternal('MLNMapView.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_MLNMapView, _sel_appearanceWhenContainedInInstancesOfClasses_, containerTypes.ref.pointer);
    return MLNMapView.fromPointer($ret, retain: true, release: true);
  }


  /// layerClass
  static objc.ObjCObject getLayerClass() {
  objc.checkOsVersionInternal('MLNMapView.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_MLNMapView, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// new
  static MLNMapView new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMapView, _sel_new);
    return MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute(int attribute) {
  objc.checkOsVersionInternal('MLNMapView.userInterfaceLayoutDirectionForSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_racczx(_class_MLNMapView, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_, attribute);

  }


  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static int userInterfaceLayoutDirectionForSemanticContentAttribute$1(int semanticContentAttribute, {required int relativeToLayoutDirection}) {
  objc.checkOsVersionInternal('MLNMapView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_tz4p54(_class_MLNMapView, _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_, semanticContentAttribute, relativeToLayoutDirection);

  }
  /// Returns a new instance of MLNMapView constructed with the default `new` method.
  MLNMapView() : this.as(new$().object$);

}

extension MLNMapView$Methods on MLNMapView {

  /// Adds an annotation to the map view.
/// 
/// > Note: ``MLNMultiPolyline``, ``MLNMultiPolyline``, ``MLNMultiPolyline``, and
/// ``MLNPointCollection`` objects cannot be added to the map view at this time.
/// Any multipoint, multipolyline, multipolygon, shape or point collection
/// object that is specified is silently ignored.
/// 
/// @param annotation The annotation object to add to the receiver. This object
/// must conform to the ``MLNAnnotation`` protocol. The map view retains the
/// annotation object.
/// 
/// #### Related examples
/// - TODO: add a line annotation from GeoJSON.
/// - TODO: add an annotation to an ``MLNMapView`` object.
  void addAnnotation(MLNAnnotation annotation) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addAnnotation_, annotation.ref.pointer);

  }


  /// Adds an array of annotations to the map view.
/// 
/// > Note: ``MLNMultiPolyline``, ``MLNMultiPolyline``, and ``MLNMultiPolyline`` objects
/// cannot be added to the map view at this time. Nor can ``MLNMultiPoint``
/// objects that are not instances of ``MLNPolyline`` or ``MLNPolyline``. Any
/// multipoint, multipolyline, multipolygon, or shape collection objects that
/// are specified are silently ignored.
/// 
/// @param annotations An array of annotation objects. Each object in the array
/// must conform to the ``MLNAnnotation`` protocol. The map view retains each
/// individual annotation object.
  void addAnnotations(objc.NSArray annotations) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addAnnotations_, annotations.ref.pointer);

  }


  /// Adds a single overlay object to the map.
/// 
/// To remove an overlay from a map, use the `-removeOverlay:` method.
/// 
/// @param overlay The overlay object to add. This object must conform to the
/// ``MLNOverlay`` protocol.
  void addOverlay(MLNOverlay overlay) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addOverlay_, overlay.ref.pointer);

  }


  /// Adds an array of overlay objects to the map.
/// 
/// To remove multiple overlays from a map, use the `-removeOverlays:` method.
/// 
/// @param overlays An array of objects, each of which must conform to the
/// ``MLNOverlay`` protocol.
  void addOverlays(objc.NSArray overlays) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addOverlays_, overlays.ref.pointer);

  }


  /// Adds a plug-in layer that is external to this library
  void addPluginLayerType(objc.ObjCObject pluginLayerClass) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_addPluginLayerType_, pluginLayerClass.ref.pointer);

  }


  /// Returns the point in this views coordinate system on which to anchor in
/// response to a user-initiated gesture.
/// 
/// For example, a pinch-to-zoom gesture would anchor the map at the midpoint of
/// the pinch.
/// 
/// If the ``userTrackingMode`` property is not ``MLNUserTrackingMode/MLNUserTrackingModeNone``, the
/// user annotation is used as the anchor point.
/// 
/// Subclasses may override this method to provide specialized behavior - for
/// example, anchoring on the maps center point to provide a "locked" zooming
/// mode.
/// 
/// @param gesture An anchorable user gesture.
/// @return The point on which to anchor in response to the gesture.
  objc.CGPoint anchorPointForGesture(UIGestureRecognizer gesture) {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_1mpyy6yStret($ptr, object$.ref.pointer, _sel_anchorPointForGesture_, gesture.ref.pointer) : $ptr.ref = _objc_msgSend_1mpyy6y(object$.ref.pointer, _sel_anchorPointForGesture_, gesture.ref.pointer);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// A Boolean value that determines whether gestures are anchored to the center coordinate of the map
/// while rotating or zooming. Default value is set to NO.
  bool get anchorRotateOrZoomGesturesToCenterCoordinate {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_anchorRotateOrZoomGesturesToCenterCoordinate);

  }


  /// The complete list of annotations associated with the receiver. (read-only)
/// 
/// The objects in this array must adopt the ``MLNAnnotation`` protocol. If no
/// annotations are associated with the map view, the value of this property is
/// `nil`.
  objc.NSArray? get annotations {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_annotations);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// A view showing legally required copyright notices,
/// positioned at the bottom-right of the map view.
/// 
/// If you choose to reimplement this view, assign the `-showAttribution:` method
/// as the action for your view to present the default notices and settings.
/// 
/// > Note: Attribution is often required for many vector sources,
/// OpenStreetMap data, or other data such as satellite or terrain
/// data. If that applies to this map view, do not hide this view or remove
/// any notices from it.
  UIButton get attributionButton {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributionButton);
    return UIButton.fromPointer($ret, retain: true, release: true);
  }


  /// A `CGPoint` indicating the position offset of the attribution.
  objc.CGPoint get attributionButtonMargins {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_attributionButtonMargins) : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_attributionButtonMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// The position of the attribution button. The default value is
/// ``MLNOrnamentPosition/MLNOrnamentPositionBottomRight``.
  int get attributionButtonPosition {
    return _objc_msgSend_1c31cvt(object$.ref.pointer, _sel_attributionButtonPosition);

  }


  /// A boolean value that indicates if whether the map view should automatically
/// adjust its content insets.
/// 
/// When this property is set to `YES` the map automatically updates its
/// `contentInset` property to account for any area not covered by navigation bars,
/// tab bars, toolbars, and other ancestors that obscure the map view.
  bool get automaticallyAdjustsContentInset {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_automaticallyAdjustsContentInset);

  }


  /// A camera representing the current viewpoint of the map.
  MLNMapCamera get camera {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_camera);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// Returns the camera that best fits the given coordinate bounds with some
/// additional padding on each side, matching an existing camera as much as
/// possible.
/// 
/// @param camera The camera that the return camera should adhere to. All values
/// on this camera will be manipulated except for pitch and direction.
/// @param bounds The coordinate bounds to fit to the receivers viewport.
/// @param insets The minimum padding (in screen points) that would be visible
/// around the returned camera object if it were set as the receivers camera.
/// @return A camera object centered on the same location as the coordinate bounds
/// with zoom level as high (close to the ground) as possible while still
/// including the entire coordinate bounds. The initial camera's pitch and
/// direction will be honored.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
/// depending on the order of notification delivery.
  MLNMapCamera camera$1(MLNMapCamera camera, {required MLNCoordinateBounds fittingCoordinateBounds,required UIEdgeInsets edgePadding}) {
    final $ret = _objc_msgSend_1v2rrrs(object$.ref.pointer, _sel_camera_fittingCoordinateBounds_edgePadding_, camera.ref.pointer, fittingCoordinateBounds, edgePadding);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// Returns the camera that best fits the given shape with some additional padding
/// on each side, matching an existing camera as much as possible.
/// 
/// @param camera The camera that the return camera should adhere to. All values
/// on this camera will be manipulated except for pitch and direction.
/// @param shape The shape to fit to the receivers viewport.
/// @param insets The minimum padding (in screen points) that would be visible
/// around the returned camera object if it were set as the receivers camera.
/// @return A camera object centered on the shape's center with zoom level as high
/// (close to the ground) as possible while still including the entire shape.
/// The initial camera's pitch and direction will be honored.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
/// depending on the order of notification delivery.
  MLNMapCamera camera$2(MLNMapCamera camera, {required MLNShape fittingShape,required UIEdgeInsets edgePadding}) {
    final $ret = _objc_msgSend_53bjzp(object$.ref.pointer, _sel_camera_fittingShape_edgePadding_, camera.ref.pointer, fittingShape.ref.pointer, edgePadding);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// The current edge insets of the current map views camera.
/// 
/// Camera edge insets are formed as accumulation of map view's content insets
/// and the edge padding passed to the method like `seCamera:...edgePadding:`,
/// `setVisibleCoordinates:...edgePadding:`, `showAnnotations:...edgePadding:` etc.
/// 
/// The camera edge insets influences the `centerCoordinate` of the viewport.
/// This value is read-only, in order to apply paddings,  use either persistent
/// `contentInset`, either transient `edgePadding` parameter of the `set...` methods.
  UIEdgeInsets get cameraEdgeInsets {
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_cameraEdgeInsets) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_cameraEdgeInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// Returns the camera that best fits the given coordinate bounds.
/// 
/// @param bounds The coordinate bounds to fit to the receivers viewport.
/// @return A camera object centered on the same location as the coordinate
/// bounds with zoom level as high (close to the ground) as possible while still
/// including the entire coordinate bounds. The camera object uses the current
/// direction and pitch.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
/// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsCoordinateBounds(MLNCoordinateBounds bounds) {
    final $ret = _objc_msgSend_5pnf8k(object$.ref.pointer, _sel_cameraThatFitsCoordinateBounds_, bounds);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// Returns the camera that best fits the given coordinate bounds with some
/// additional padding on each side.
/// 
/// @param bounds The coordinate bounds to fit to the receivers viewport.
/// @param insets The minimum padding (in screen points) that would be visible
/// around the returned camera object if it were set as the receivers camera.
/// @return A camera object centered on the same location as the coordinate bounds
/// with zoom level as high (close to the ground) as possible while still
/// including the entire coordinate bounds. The camera object uses the current
/// direction and pitch.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
/// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsCoordinateBounds$1(MLNCoordinateBounds bounds, {required UIEdgeInsets edgePadding}) {
    final $ret = _objc_msgSend_1a5ayri(object$.ref.pointer, _sel_cameraThatFitsCoordinateBounds_edgePadding_, bounds, edgePadding);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// Returns the camera that best fits the given shape with some additional padding
/// on each side while looking in the specified direction.
/// 
/// @param shape The shape to fit to the receivers viewport.
/// @param direction The direction of the viewport, measured in degrees clockwise
/// from true north.
/// @param insets The minimum padding (in screen points) that would be visible
/// around the returned camera object if it were set as the receivers camera.
/// @return A camera object centered on the shape's center with zoom level as high
/// (close to the ground) as possible while still including the entire shape.
/// The camera object uses the current pitch.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`; you may receive a `nil` return value
/// depending on the order of notification delivery.
  MLNMapCamera cameraThatFitsShape(MLNShape shape, {required double direction,required UIEdgeInsets edgePadding}) {
    final $ret = _objc_msgSend_ebhzse(object$.ref.pointer, _sel_cameraThatFitsShape_direction_edgePadding_, shape.ref.pointer, direction, edgePadding);
    return MLNMapCamera.fromPointer($ret, retain: true, release: true);
  }


  /// The geographic coordinate at the center of the map view.
/// 
/// Changing the value of this property centers the map on the new coordinate
/// without changing the current zoom level.
/// 
/// Changing the value of this property updates the map view immediately. If you
/// want to animate the change, use the `-setCenterCoordinate:animated:` method
/// instead.
  CLLocationCoordinate2D get centerCoordinate {
    final $ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants ? _objc_msgSend_18o5nokStret($ptr, object$.ref.pointer, _sel_centerCoordinate) : $ptr.ref = _objc_msgSend_18o5nok(object$.ref.pointer, _sel_centerCoordinate);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(
        $finalizable);

  }


  /// Clear stored action journal events.
  void clearActionJournalLog() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_clearActionJournalLog);

  }


  /// A control indicating the maps direction and allowing the user to manipulate
/// the direction, positioned in the upper-right corner.
  MLNCompassButton get compassView {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_compassView);
    return MLNCompassButton.fromPointer($ret, retain: true, release: true);
  }


  /// A `CGPoint` indicating the position offset of the compass.
  objc.CGPoint get compassViewMargins {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_compassViewMargins) : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_compassViewMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// The position of the compass view. The default value is
/// ``MLNOrnamentPosition/MLNOrnamentPositionTopRight``.
  int get compassViewPosition {
    return _objc_msgSend_1c31cvt(object$.ref.pointer, _sel_compassViewPosition);

  }


  /// The distance from the edges of the map views frame to the edges of the map
/// views logical viewport.
/// 
/// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
/// properties such as `centerCoordinate` assume a viewport that matches the map
/// views frame. Otherwise, those properties are inset, excluding part of the
/// frame from the viewport. For instance, if the only the top edge is inset, the
/// map center is effectively shifted downward.
/// 
/// When the map views superview is an instance of `UIViewController` whose
/// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
/// property may be overridden at any time.
/// 
/// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
/// use the map views property ``MLNMapView/automaticallyAdjustsContentInset``instead.
/// 
/// Changing the value of this property updates the map view immediately. If you
/// want to animate the change, use the `-setContentInset:animated:completionHandler:`
/// method instead.
  UIEdgeInsets get contentInset {
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants ? _objc_msgSend_ct4cu5Stret($ptr, object$.ref.pointer, _sel_contentInset) : $ptr.ref = _objc_msgSend_ct4cu5(object$.ref.pointer, _sel_contentInset);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<UIEdgeInsets>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<UIEdgeInsets>(
        $finalizable);

  }


  /// Converts a geographic coordinate to a point in the given views coordinate
/// system.
/// 
/// @param coordinate The geographic coordinate to convert.
/// @param view The view in whose coordinate system the returned point should be
/// expressed. If this parameter is `nil`, the returned point is expressed
/// in the windows coordinate system. If `view` is not `nil`, it must
/// belong to the same window as the map view.
/// @return The point (in the appropriate view or window coordinate system)
/// corresponding to the given geographic coordinate.
/// 
/// #### Related examples
/// - TODO: Point conversion: learn how to convert a map coordinate to a `CGPoint` object.
  objc.CGPoint convertCoordinate(CLLocationCoordinate2D coordinate, {UIView? toPointToView}) {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_mus1wvStret($ptr, object$.ref.pointer, _sel_convertCoordinate_toPointToView_, coordinate, toPointToView?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_mus1wv(object$.ref.pointer, _sel_convertCoordinate_toPointToView_, coordinate, toPointToView?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// Converts a geographic bounding box to a rectangle in the given views
/// coordinate system.
/// 
/// To bring both sides of the antimeridian or international date line into view,
/// specify some longitudes less than 180 degrees or greater than 180 degrees. For
/// example, to show both Tokyo and San Francisco simultaneously, you could set the
/// visible bounds to extend from (35.68476, 220.24257) to (37.78428, 122.41310).
/// 
/// @param bounds The geographic bounding box to convert.
/// @param view The view in whose coordinate system the returned rectangle should
/// be expressed. If this parameter is `nil`, the returned rectangle is
/// expressed in the windows coordinate system. If `view` is not `nil`, it must
/// belong to the same window as the map view.
  objc.CGRect convertCoordinateBounds(MLNCoordinateBounds bounds, {UIView? toRectToView}) {
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants ? _objc_msgSend_18hv5gjStret($ptr, object$.ref.pointer, _sel_convertCoordinateBounds_toRectToView_, bounds, toRectToView?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_18hv5gj(object$.ref.pointer, _sel_convertCoordinateBounds_toRectToView_, bounds, toRectToView?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGRect>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGRect>(
        $finalizable);

  }


  /// Converts a point in the given views coordinate system to a geographic
/// coordinate.
/// 
/// @param point The point to convert.
/// @param view The view in whose coordinate system the point is expressed.
/// @return The geographic coordinate at the given point.
/// 
/// #### Related examples
/// - TODO: Point conversion example to learn how to convert a `CGPoint` to a map coordinate.
  CLLocationCoordinate2D convertPoint$2(objc.CGPoint point, {UIView? toCoordinateFromView}) {
    final $ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants ? _objc_msgSend_4xp05xStret($ptr, object$.ref.pointer, _sel_convertPoint_toCoordinateFromView_, point, toCoordinateFromView?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_4xp05x(object$.ref.pointer, _sel_convertPoint_toCoordinateFromView_, point, toCoordinateFromView?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(
        $finalizable);

  }


  /// Converts a rectangle in the given views coordinate system to a geographic
/// bounding box.
/// 
/// If the returned coordinate bounds contains a longitude is less than 180 degrees
/// or greater than 180 degrees, the bounding box straddles the antimeridian or
/// international date line.
/// 
/// @param rect The rectangle to convert.
/// @param view The view in whose coordinate system the rectangle is expressed.
/// @return The geographic bounding box coextensive with the given rectangle.
  MLNCoordinateBounds convertRect$2(objc.CGRect rect, {UIView? toCoordinateBoundsFromView}) {
    final $ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants ? _objc_msgSend_1f65wixStret($ptr, object$.ref.pointer, _sel_convertRect_toCoordinateBoundsFromView_, rect, toCoordinateBoundsFromView?.ref.pointer ?? ffi.nullptr) : $ptr.ref = _objc_msgSend_1f65wix(object$.ref.pointer, _sel_convertRect_toCoordinateBoundsFromView_, rect, toCoordinateBoundsFromView?.ref.pointer ?? ffi.nullptr);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(
        $finalizable);

  }


  /// The options that determine which debugging aids are shown on the map.
/// 
/// These options are all disabled by default and should remain disabled in
/// released software for performance and aesthetic reasons.
  int get debugMask {
    return _objc_msgSend_1kwkjor(object$.ref.pointer, _sel_debugMask);

  }


  /// A floating-point value that determines the rate of deceleration after the user
/// lifts their finger.
/// 
/// Your application can use the ``MLNMapViewDecelerationRateNormal`` and
/// ``MLNMapViewDecelerationRateFast`` constants as reference points for reasonable
/// deceleration rates. ``MLNMapViewDecelerationRateImmediate`` can be used to
/// disable deceleration entirely.
  double get decelerationRate {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_decelerationRate) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_decelerationRate);

  }


  /// The receivers delegate.
/// 
/// A map view sends messages to its delegate to notify it of changes to its
/// contents or the viewpoint. The delegate also provides information about
/// annotations displayed on the map, such as the styles to apply to individual
/// annotations.
  MLNMapViewDelegate? get delegate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_delegate);
    return $ret.address == 0 ? null : MLNMapViewDelegate.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a reusable annotation image object associated with its identifier.
/// 
/// For performance reasons, you should generally reuse ``MLNAnnotationImage``
/// objects for identical-looking annotations in your map views. Dequeueing
/// saves time and memory during performance-critical operations such as
/// scrolling.
/// 
/// @param identifier A string identifying the annotation image to be reused.
/// This string is the same one you specify when initially returning the
/// annotation image object using the `-mapView:imageForAnnotation:` method.
/// @return An annotation image object with the given identifier, or `nil` if no
/// such object exists in the reuse queue.
/// 
/// #### Related examples
/// - TODO: Add annotation views and images: learn how to most efficiently
/// reuse an ``MLNAnnotationImage``.
  MLNAnnotationImage? dequeueReusableAnnotationImageWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_dequeueReusableAnnotationImageWithIdentifier_, identifier.ref.pointer);
    return $ret.address == 0 ? null : MLNAnnotationImage.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a reusable annotation view object associated with its identifier.
/// 
/// For performance reasons, you should generally reuse ``MLNAnnotationView``
/// objects for identical-looking annotations in your map views. Dequeueing
/// saves time and memory during performance-critical operations such as
/// scrolling.
/// 
/// @param identifier A string identifying the annotation view to be reused.
/// This string is the same one you specify when initially returning the
/// annotation view object using the `-mapView:viewForAnnotation:` method.
/// @return An annotation view object with the given identifier, or `nil` if no
/// such object exists in the reuse queue.
  MLNAnnotationView? dequeueReusableAnnotationViewWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_dequeueReusableAnnotationViewWithIdentifier_, identifier.ref.pointer);
    return $ret.address == 0 ? null : MLNAnnotationView.fromPointer($ret, retain: true, release: true);
  }


  /// Deselects an annotation and hides its callout view.
/// 
/// @param annotation The annotation object to deselect.
/// @param animated If `YES`, the callout view is animated offscreen.
  void deselectAnnotation(MLNAnnotation? annotation, {required bool animated}) {
_objc_msgSend_6p7ndb(object$.ref.pointer, _sel_deselectAnnotation_animated_, annotation?.ref.pointer ?? ffi.nullptr, animated);

  }


  /// The heading of the map, measured in degrees clockwise from true north.
/// 
/// The value `0` means that the top edge of the map view corresponds to true
/// north. The value `90` means the top of the map is pointing due east. The
/// value `180` means the top of the map points due south, and so on.
/// 
/// Changing the value of this property updates the map view immediately. If you
/// want to animate the change, use the `-setDirection:animated:` method instead.
  double get direction {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_direction) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_direction);

  }


  /// Disabled using a current location manager.
  void disableLocationManager() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_disableLocationManager);

  }


  /// Whether the map view should display a heading calibration alert when necessary.
/// The default value is `YES`.
  bool get displayHeadingCalibration {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_displayHeadingCalibration);

  }


  /// A boolean value indicating whether camera animation duration is set based
/// on the time difference between the last location update and the current one
/// or the default animation duration of 1 second.
/// 
/// The default value of this property is `NO`
  bool get dynamicNavigationCameraAnimationDuration {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_dynamicNavigationCameraAnimationDuration);

  }


  /// Enable a rendering statistics overlay with ``MLNRenderingStats`` values.
  void enableRenderingStatsView(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_enableRenderingStatsView_, value);

  }


  /// Moves the viewpoint to a different location using a transition animation that
/// evokes powered flight and a default duration based on the length of the flight
/// path.
/// 
/// The transition animation seamlessly incorporates zooming and panning to help
/// the user find his or her bearings even after traversing a great distance.
/// 
/// @param camera The new viewpoint.
/// @param completion The block to execute after the animation finishes.
  void flyToCamera(MLNMapCamera camera, {objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_o762yo(object$.ref.pointer, _sel_flyToCamera_completionHandler_, camera.ref.pointer, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Moves the viewpoint to a different location using a transition animation that
/// evokes powered flight.
/// 
/// The transition animation seamlessly incorporates zooming and panning to help
/// the user find his or her bearings even after traversing a great distance.
/// 
/// @param camera The new viewpoint.
/// @param insets The minimum padding (in screen points) that would be visible
/// around the returned camera object if it were set as the receiver's camera.
/// @param duration The amount of time, measured in seconds, that the transition
/// animation should take. Specify `0` to jump to the new viewpoint
/// instantaneously. Specify a negative value to use the default duration, which
/// is based on the length of the flight path.
/// @param completion The block to execute after the animation finishes.
  void flyToCamera$1(MLNMapCamera camera, {required UIEdgeInsets edgePadding,required double withDuration,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_s17tgr(object$.ref.pointer, _sel_flyToCamera_edgePadding_withDuration_completionHandler_, camera.ref.pointer, edgePadding, withDuration, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Moves the viewpoint to a different location using a transition animation that
/// evokes powered flight and an optional transition duration.
/// 
/// The transition animation seamlessly incorporates zooming and panning to help
/// the user find his or her bearings even after traversing a great distance.
/// 
/// @param camera The new viewpoint.
/// @param duration The amount of time, measured in seconds, that the transition
/// animation should take. Specify `0` to jump to the new viewpoint
/// instantaneously. Specify a negative value to use the default duration, which
/// is based on the length of the flight path.
/// @param completion The block to execute after the animation finishes.
  void flyToCamera$2(MLNMapCamera camera, {required double withDuration,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_a85mgj(object$.ref.pointer, _sel_flyToCamera_withDuration_completionHandler_, camera.ref.pointer, withDuration, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Moves the viewpoint to a different location using a transition animation that
/// evokes powered flight and an optional transition duration and peak altitude.
/// 
/// The transition animation seamlessly incorporates zooming and panning to help
/// the user find his or her bearings even after traversing a great distance.
/// 
/// @param camera The new viewpoint.
/// @param duration The amount of time, measured in seconds, that the transition
/// animation should take. Specify `0` to jump to the new viewpoint
/// instantaneously. Specify a negative value to use the default duration, which
/// is based on the length of the flight path.
/// @param peakAltitude The altitude, measured in meters, at the midpoint of the
/// animation. The value of this parameter is ignored if it is negative or if
/// the animation transition resulting from a similar call to
/// `-setCamera:animated:` would have a midpoint at a higher altitude.
/// @param completion The block to execute after the animation finishes.
  void flyToCamera$3(MLNMapCamera camera, {required double withDuration,required double peakAltitude,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_b0p9a0(object$.ref.pointer, _sel_flyToCamera_withDuration_peakAltitude_completionHandler_, camera.ref.pointer, withDuration, peakAltitude, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Get the action journal events from oldest to newest.
/// 
/// Each element contains a serialized json object with the event data.
/// Example
/// `{
/// "name" : "onTileAction",
/// "time" : "2025-04-17T13:13:13.974Z",
/// "styleName" : "Streets",
/// "styleURL" : "maptiler://maps/streets",
/// "event" : {
/// "action" : "RequestedFromNetwork",
/// "tileX" : 0,
/// "tileY" : 0,
/// "tileZ" : 0,
/// "overscaledZ" : 0,
/// "sourceID" : "openmaptiles"
/// }
/// }`
  objc.NSArray getActionJournalLog() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_getActionJournalLog);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Get the list of action journal log files from oldest to newest.
/// 
/// @return An array of log file paths.
  objc.NSArray getActionJournalLogFiles() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_getActionJournalLogFiles);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNMapView init() {
  objc.checkOsVersionInternal('MLNMapView.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNMapView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// initWithFrame:
  MLNMapView initWithFrame(objc.CGRect frame) {
  objc.checkOsVersionInternal('MLNMapView.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// Initializes and returns a newly allocated map view with the specified frame
/// and the default style.
/// 
/// @param frame The frame for the view, measured in points.
/// @param options The map instance options
/// @return An initialized map view.
  MLNMapView initWithFrame$1(objc.CGRect frame, {required MLNMapOptions options}) {
    final $ret = _objc_msgSend_gxusyk(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_options_, frame, options.ref.pointer);
    return MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// Initializes and returns a newly allocated map view with the specified frame
/// and style JSON.
/// 
/// @param frame The frame for the view, measured in points.
/// @param styleJSON JSON string of the map style to display. The JSON must conform to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
/// Specify `nil` for the default style.
/// @return An initialized map view.
  MLNMapView initWithFrame$2(objc.CGRect frame, {required objc.NSString styleJSON}) {
    final $ret = _objc_msgSend_gxusyk(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_styleJSON_, frame, styleJSON.ref.pointer);
    return MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// Initializes and returns a newly allocated map view with the specified frame
/// and style URL.
/// 
/// @param frame The frame for the view, measured in points.
/// @param styleURL URL of the map style to display. The URL may be a full HTTP
/// or HTTPS URL, a canonical URL or a path to a local file relative
/// to the applications resource path. Specify `nil` for the default style.
/// @return An initialized map view.
/// 
/// #### Related examples
/// 
/// - TODO: initialize an ``MLNMapView`` with a custom style
/// - TODO: how to initialize an ``MLNMapView`` with a third-party tile source
  MLNMapView initWithFrame$3(objc.CGRect frame, {objc.NSURL? styleURL}) {
    final $ret = _objc_msgSend_gxusyk(object$.ref.retainAndReturnPointer(), _sel_initWithFrame_styleURL_, frame, styleURL?.ref.pointer ?? ffi.nullptr);
    return MLNMapView.fromPointer($ret, retain: false, release: true);
  }


  /// A Boolean value that determines whether the user will receive haptic feedback
/// for certain interactions with the map.
/// 
/// When this property is set to `YES`, the default, a `UIImpactFeedbackStyleLight`
/// haptic feedback event be played when the user rotates the map to due north
/// (0).
/// 
/// This feature requires a device that supports haptic feedback, running iOS 10 or
/// newer.
  bool get isHapticFeedbackEnabled {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHapticFeedbackEnabled);

  }


  /// A Boolean value that determines whether the user may change the pitch (tilt) of
/// the map.
/// 
/// When this property is set to `YES`, the default, the user may tilt the map by
/// vertically dragging two fingers.
/// 
/// This property controls only user interactions with the map. If you set the
/// value of this property to `NO`, you may still change the pitch of the map
/// programmatically.
/// 
/// The default value of this property is `YES`.
  bool get isPitchEnabled {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isPitchEnabled);

  }


  /// A boolean value that reverses the direction of the quick zoom gesture.
/// 
/// When this property is set, the zoom-in and zoom-out behavior during the quick
/// zoom gesture (also called one-finger zoom) is reversed, aligning with the
/// behavior in Apple Maps. The default value is `NO`.
  bool get isQuickZoomReversed {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isQuickZoomReversed);

  }


  /// Returns the status of the rendering statistics overlay.
  bool isRenderingStatsViewEnabled() {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isRenderingStatsViewEnabled);

  }


  /// A Boolean value that determines whether the user may rotate the map,
/// changing the direction.
/// 
/// When this property is set to `YES`, the default, the user may rotate the map
/// by moving two fingers in a circular motion.
/// 
/// This property controls only user interactions with the map. If you set the
/// value of this property to `NO`, you may still rotate the map
/// programmatically.
  bool get isRotateEnabled {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isRotateEnabled);

  }


  /// A Boolean value that determines whether the user may scroll around the map,
/// changing the center coordinate.
/// 
/// When this property is set to `YES`, the default, the user may scroll the map
/// by dragging or swiping with one finger.
/// 
/// This property controls only user interactions with the map. If you set the
/// value of this property to `NO`, you may still change the map location
/// programmatically.
  bool get isScrollEnabled {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isScrollEnabled);

  }


  /// A Boolean value indicating whether the devices current location is visible in
/// the map view.
/// 
/// Use `showsUserLocation` to control the visibility of the on-screen user
/// location annotation.
  bool get isUserLocationVisible {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isUserLocationVisible);

  }


  /// A Boolean value that determines whether the user may zoom the map in and
/// out, changing the zoom level.
/// 
/// When this property is set to `YES`, the default, the user may zoom the map
/// in and out by pinching two fingers or by double tapping, holding, and moving
/// the finger up and down.
/// 
/// This property controls only user interactions with the map. If you set the
/// value of this property to `NO`, you may still change the map zoom
/// programmatically.
  bool get isZoomEnabled {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isZoomEnabled);

  }


  /// The object that this map view uses to start and stop the delivery of
/// location-related updates.
/// 
/// To receive the current user location, implement the
/// ``MLNMapViewDelegate/mapView:didUpdateUserLocation:`` and
/// ``MLNMapViewDelegate/mapView:didFailToLocateUserWithError:`` methods.
/// 
/// If setting this property to `nil` or if no custom manager is provided this
/// property is set to the default location manager.
/// 
/// ``MLNMapView`` uses a default location manager. If you want to substitute your
/// own location manager, you should do so by setting this property before setting
/// `showsUserLocation` to `YES`. To restore the default location manager,
/// set this property to `nil`.
  MLNLocationManager get locationManager {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_locationManager);
    return MLNLocationManager.fromPointer($ret, retain: true, release: true);
  }


  /// A logo, the MapLibre logo by default, positioned in the lower-left corner.
/// You are not required to display this, but some vector-sources may require attribution.
  UIImageView get logoView {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_logoView);
    return UIImageView.fromPointer($ret, retain: true, release: true);
  }


  /// A `CGPoint` indicating the position offset of the logo.
  objc.CGPoint get logoViewMargins {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_logoViewMargins) : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_logoViewMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// The position of the logo view. The default value is
/// ``MLNOrnamentPosition/MLNOrnamentPositionBottomLeft``.
  int get logoViewPosition {
    return _objc_msgSend_1c31cvt(object$.ref.pointer, _sel_logoViewPosition);

  }


  /// Returns the new map projection instance initialized with the map view,
/// i.e. with the current camera state.
  MLNMapProjection mapProjection() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mapProjection);
    return MLNMapProjection.fromPointer($ret, retain: true, release: true);
  }


  /// The maximum pitch of the maps camera toward the horizon measured in degrees.
/// 
/// If the value of this property is smaller than that of the `minimumPitch`
/// property, the behavior is undefined. The pitch may not exceed 60 degrees
/// regardless of this property.
/// 
/// The default value of this property is 60 degrees.
  double get maximumPitch {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_maximumPitch) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_maximumPitch);

  }


  /// The maximum bounds of the map that can be shown on screen.
  MLNCoordinateBounds get maximumScreenBounds {
    final $ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants ? _objc_msgSend_ygoa6aStret($ptr, object$.ref.pointer, _sel_maximumScreenBounds) : $ptr.ref = _objc_msgSend_ygoa6a(object$.ref.pointer, _sel_maximumScreenBounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(
        $finalizable);

  }


  /// The maximum zoom level the map can be shown at.
/// 
/// If the value of this property is smaller than that of the
/// minimumZoomLevel property, the behavior is undefined.
/// 
/// The default maximumZoomLevel is 22. The upper bound for this property
/// is 25.5.
  double get maximumZoomLevel {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_maximumZoomLevel) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_maximumZoomLevel);

  }


  /// Returns the distance spanned by one point in the map views coordinate system
/// at the given latitude and current zoom level.
/// 
/// The distance between points decreases as the latitude approaches the poles.
/// This relationship parallels the relationship between longitudinal coordinates
/// at different latitudes.
/// 
/// @param latitude The latitude of the geographic coordinate represented by the
/// point.
/// @return The distance in meters spanned by a single point.
  double metersPerPointAtLatitude(double latitude) {
    return objc.useMsgSendVariants ? _objc_msgSend_1tczmpvFpret(object$.ref.pointer, _sel_metersPerPointAtLatitude_, latitude) : _objc_msgSend_1tczmpv(object$.ref.pointer, _sel_metersPerPointAtLatitude_, latitude);

  }


  /// The minimum pitch of the maps camera toward the horizon measured in degrees.
/// 
/// If the value of this property is greater than that of the `maximumPitch`
/// property, the behavior is undefined. The pitch may not be less than 0
/// regardless of this property.
/// 
/// The default value of this property is 0 degrees, allowing the map to appear
/// two-dimensional.
  double get minimumPitch {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_minimumPitch) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_minimumPitch);

  }


  /// The minimum zoom level at which the map can be shown.
/// 
/// Depending on the map views aspect ratio, the map view may be prevented
/// from reaching the minimum zoom level, in order to keep the map from
/// repeating within the current viewport.
/// 
/// If the value of this property is greater than that of the
/// maximumZoomLevel property, the behavior is undefined.
/// 
/// The default minimumZoomLevel is 0.
  double get minimumZoomLevel {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_minimumZoomLevel) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_minimumZoomLevel);

  }


  /// The complete list of overlays associated with the receiver. (read-only)
/// 
/// The objects in this array must adopt the ``MLNOverlay`` protocol. If no
/// overlays are associated with the map view, the value of this property is
/// empty array.
  objc.NSArray get overlays {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_overlays);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// The scrolling mode the user is allowed to use to interact with the map.
/// 
/// `MLNPanScrollingModeHorizontal` only allows the user to scroll horizontally on the map,
/// restricting a user's ability to scroll vertically.
/// `MLNPanScrollingModeVertical` only allows the user to scroll vertically on the map,
/// restricting a user's ability to scroll horizontally.
/// ``MLNPanScrollingMode/MLNPanScrollingModeDefault`` allows the user to scroll both horizontally and
/// vertically on the map.
/// 
/// By default, this property is set to ``MLNPanScrollingMode/MLNPanScrollingModeDefault``.
  int get panScrollingMode {
    return _objc_msgSend_1vb5jwj(object$.ref.pointer, _sel_panScrollingMode);

  }


  /// The preferred frame rate at which the map view is rendered.
/// 
/// The default value for this property is
/// ``MLNMapViewPreferredFramesPerSecondDefault``, which will adaptively set the
/// preferred frame rate based on the capability of the users device to maintain
/// a smooth experience.
/// 
/// In addition to the provided ``MLNMapViewPreferredFramesPerSecond`` options, this
/// property can be set to arbitrary integer values.
/// 
/// @see `CADisplayLink.preferredFramesPerSecond`
  int get preferredFramesPerSecond {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_preferredFramesPerSecond);

  }


  /// A Boolean value indicating whether the map should prefetch tiles.
/// 
/// When this property is set to `YES`, the map view prefetches tiles designed for
/// a low zoom level and displays them until receiving more detailed tiles for the
/// current zoom level. The prefetched tiles typically contain simplified versions
/// of each shape, improving the map views perceived performance.
/// 
/// The default value of this property is `YES`.
  bool get prefetchesTiles {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_prefetchesTiles);

  }


  /// Reloads the style.
/// 
/// You do not normally need to call this method. The map view automatically
/// responds to changes in network connectivity by reloading the style.
/// 
/// This method does not bust the cache. Even if the style has recently changed on
/// the server, calling this method does not necessarily ensure that the map view
/// reflects those changes.
  void reloadStyle(objc.ObjCObject? sender) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_reloadStyle_, sender?.ref.pointer ?? ffi.nullptr);

  }


  /// Removes an annotation from the map view, deselecting it if it is selected.
/// 
/// Removing an annotation object dissociates it from the map view entirely,
/// preventing it from being displayed on the map. Thus you would typically call
/// this method only when you want to hide or delete a given annotation.
/// 
/// @param annotation The annotation object to remove. This object must conform
/// to the ``MLNAnnotation`` protocol
  void removeAnnotation(MLNAnnotation annotation) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeAnnotation_, annotation.ref.pointer);

  }


  /// Removes an array of annotations from the map view, deselecting any selected
/// annotations in the array.
/// 
/// Removing annotation objects dissociates them from the map view entirely,
/// preventing them from being displayed on the map. Thus you would typically
/// call this method only when you want to hide or delete the given annotations.
/// 
/// @param annotations The array of annotation objects to remove. Objects in the
/// array must conform to the ``MLNAnnotation`` protocol.
  void removeAnnotations(objc.NSArray annotations) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeAnnotations_, annotations.ref.pointer);

  }


  /// Removes a single overlay object from the map.
/// 
/// If the specified overlay is not currently associated with the map view, this
/// method does nothing.
/// 
/// @param overlay The overlay object to remove.
  void removeOverlay(MLNOverlay overlay) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeOverlay_, overlay.ref.pointer);

  }


  /// Removes one or more overlay objects from the map.
/// 
/// If a given overlay object is not associated with the map view, it is ignored.
/// 
/// @param overlays An array of objects, each of which conforms to the ``MLNOverlay``
/// protocol.
  void removeOverlays(objc.NSArray overlays) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_removeOverlays_, overlays.ref.pointer);

  }


  /// Resets the map rotation to a northern heading a `direction` of `0` degrees.
  void resetNorth() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_resetNorth);

  }


  /// Resets the map to the current styles default viewport.
/// 
/// If the style doesnt specify a default viewport, the map resets to a minimum
/// zoom level, a center coordinate of (0, 0), and a northern heading.
  void resetPosition() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_resetPosition);

  }


  /// A control indicating the scale of the map. The scale bar is positioned in the
/// upper-left corner. Enable the scale bar via `showsScale`.
  MLNScaleBar get scaleBar {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_scaleBar);
    return MLNScaleBar.fromPointer($ret, retain: true, release: true);
  }


  /// A `CGPoint` indicating the position offset of the scale bar.
  objc.CGPoint get scaleBarMargins {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_scaleBarMargins) : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_scaleBarMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<objc.CGPoint>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<objc.CGPoint>(
        $finalizable);

  }


  /// The position of the scale bar. The default value is
/// ``MLNOrnamentPosition/MLNOrnamentPositionTopLeft``.
  int get scaleBarPosition {
    return _objc_msgSend_1c31cvt(object$.ref.pointer, _sel_scaleBarPosition);

  }


  /// Sets whether the scale uses styles that make it easier to read on a dark styled map
  bool get scaleBarShouldShowDarkStyles {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_scaleBarShouldShowDarkStyles);

  }


  /// Sets whether the scale uses metric
  bool get scaleBarUsesMetricSystem {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_scaleBarUsesMetricSystem);

  }


  /// Deprecated. Selects an annotation and displays its callout view.
/// 
/// The `animated` parameter determines whether the selection is animated including whether the map is
/// panned to bring the annotation into view, specifically:
/// 
/// | `animated` parameter | Effect |
/// |------------------|--------|
/// | `NO`             | The annotation is selected, and the callout is presented. However the map is
/// not panned to bring the annotation or callout into view. The presentation of the callout is NOT
/// animated. | | `YES`            | The annotation is selected, and the callout is presented. If the
/// annotation is not visible (or is partially visible) *and* is of type ``MLNPointAnnotation``, the
/// map is panned so that the annotation and its callout are brought into view. The annotation is *not*
/// centered within the viewport. |
/// 
/// Note that a selection initiated by a single tap gesture is always animated.
/// 
/// To specify a completion handler to execute after the animation finishes, use
/// the `-selectAnnotation:animated:completionHandler:` method.
/// 
/// @param annotation The annotation object to select.
/// @param animated If `YES`, the annotation and callout view are animated on-screen.
/// 
/// > Note: In versions prior to `4.0.0` selecting an offscreen annotation did not
/// change the camera.
  void selectAnnotation(MLNAnnotation annotation, {required bool animated}) {
_objc_msgSend_6p7ndb(object$.ref.pointer, _sel_selectAnnotation_animated_, annotation.ref.pointer, animated);

  }


  /// Selects an annotation and displays its callout view with an optional completion
/// handler.
/// 
/// The `animated` parameter determines whether the selection is animated including whether the map is
/// panned to bring the annotation into view, specifically:
/// 
/// | `animated` parameter | Effect |
/// |------------------|--------|
/// | `NO`             | The annotation is selected, and the callout is presented. However the map is
/// not panned to bring the annotation or callout into view. The presentation of the callout is NOT
/// animated. | | `YES`            | The annotation is selected, and the callout is presented. If the
/// annotation is not visible (or is partially visible) *and* is of type ``MLNPointAnnotation``, the
/// map is panned so that the annotation and its callout are brought into view. The annotation is *not*
/// centered within the viewport. |
/// 
/// Note that a selection initiated by a single tap gesture is always animated.
/// 
/// @param annotation The annotation object to select.
/// @param animated If `YES`, the annotation and callout view are animated on-screen.
/// @param completion The block executed after the animation finishes.
/// 
/// > Note: In versions prior to `4.0.0` selecting an offscreen annotation did not
/// change the camera.
  void selectAnnotation$1(MLNAnnotation annotation, {required bool animated,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_na2nx0(object$.ref.pointer, _sel_selectAnnotation_animated_completionHandler_, annotation.ref.pointer, animated, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// :nodoc:
/// Selects an annotation and displays its callout view with an optional completion
/// handler. This method should be considered "alpha" and as such is subject to
/// change.
/// 
/// @param annotation The annotation object to select.
/// @param moveIntoView If the annotation is not visible (or is partially visible) *and* is of type
/// ``MLNPointAnnotation``, the map is panned so that the annotation and its callout are brought into
/// view. The annotation is *not* centered within the viewport.
/// @param animateSelection If `YES`, the annotation's selection state and callout view's presentation
/// are animated.
/// @param completion The block executed after the animation finishes.
  void selectAnnotation$2(MLNAnnotation annotation, {required bool moveIntoView,required bool animateSelection,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_2nhnqw(object$.ref.pointer, _sel_selectAnnotation_moveIntoView_animateSelection_completionHandler_, annotation.ref.pointer, moveIntoView, animateSelection, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// The currently selected annotations.
/// 
/// Assigning a new array to this property selects only the first annotation in
/// the array.
/// 
/// If the annotation is of type ``MLNPointAnnotation`` and is offscreen, the camera
/// will animate to bring the annotation and its callout just on screen. If you
/// need finer control, consider using `-selectAnnotation:animated:`.
/// 
/// > Note: In versions prior to `4.0.0` if the annotation was offscreen it was not
/// selected.
  objc.NSArray get selectedAnnotations {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_selectedAnnotations);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// A Boolean value that determines whether gestures are anchored to the center coordinate of the map
/// while rotating or zooming. Default value is set to NO.
  set anchorRotateOrZoomGesturesToCenterCoordinate(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAnchorRotateOrZoomGesturesToCenterCoordinate_, value);

  }


  /// A `CGPoint` indicating the position offset of the attribution.
  set attributionButtonMargins(objc.CGPoint value) {
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setAttributionButtonMargins_, value);

  }


  /// The position of the attribution button. The default value is
/// ``MLNOrnamentPosition/MLNOrnamentPositionBottomRight``.
  set attributionButtonPosition(int value) {
_objc_msgSend_8fd115(object$.ref.pointer, _sel_setAttributionButtonPosition_, value);

  }


  /// A boolean value that indicates if whether the map view should automatically
/// adjust its content insets.
/// 
/// When this property is set to `YES` the map automatically updates its
/// `contentInset` property to account for any area not covered by navigation bars,
/// tab bars, toolbars, and other ancestors that obscure the map view.
  set automaticallyAdjustsContentInset(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setAutomaticallyAdjustsContentInset_, value);

  }


  /// A camera representing the current viewpoint of the map.
  set camera(MLNMapCamera value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCamera_, value.ref.pointer);

  }


  /// Moves the viewpoint to a different location with respect to the map with an
/// optional transition animation. For animated changes, wait until the map view has
/// finished loading before calling this method.
/// 
/// @param camera The new viewpoint.
/// @param animated Specify `YES` if you want the map view to animate the change to
/// the new viewpoint or `NO` if you want the map to display the new viewpoint
/// immediately.
/// 
/// #### Related examples
/// - TODO: Camera animation: learn how to trigger an animation that rotates around a central point.
  void setCamera(MLNMapCamera camera, {required bool animated}) {
_objc_msgSend_6p7ndb(object$.ref.pointer, _sel_setCamera_animated_, camera.ref.pointer, animated);

  }


  /// Moves the viewpoint to a different location with respect to the map with an
/// optional transition duration and timing function. For animated changes, wait
/// until the map view has finished loading before calling this method.
/// 
/// @param camera The new viewpoint.
/// @param duration The amount of time, measured in seconds, that the transition
/// animation should take. Specify `0` to jump to the new viewpoint
/// instantaneously.
/// @param function A timing function used for the animation. Set this parameter to
/// `nil` for a transition that matches most system animations. If the duration
/// is `0`, this parameter is ignored.
/// 
/// #### Related examples
/// - TODO: Camera animation: learn how to create a timed animation that
/// rotates around a central point for a specific duration.
  void setCamera$1(MLNMapCamera camera, {required double withDuration,CAMediaTimingFunction? animationTimingFunction}) {
_objc_msgSend_r1s65y(object$.ref.pointer, _sel_setCamera_withDuration_animationTimingFunction_, camera.ref.pointer, withDuration, animationTimingFunction?.ref.pointer ?? ffi.nullptr);

  }


  /// Moves the viewpoint to a different location with respect to the map with an
/// optional transition duration and timing function. For animated changes, wait
/// until the map view has finished loading before calling this method.
/// 
/// @param camera The new viewpoint.
/// @param duration The amount of time, measured in seconds, that the transition
/// animation should take. Specify `0` to jump to the new viewpoint
/// instantaneously.
/// @param function A timing function used for the animation. Set this parameter to
/// `nil` for a transition that matches most system animations. If the duration
/// is `0`, this parameter is ignored.
/// @param completion The block to execute after the animation finishes.
  void setCamera$2(MLNMapCamera camera, {required double withDuration,CAMediaTimingFunction? animationTimingFunction,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_1s40ged(object$.ref.pointer, _sel_setCamera_withDuration_animationTimingFunction_completionHandler_, camera.ref.pointer, withDuration, animationTimingFunction?.ref.pointer ?? ffi.nullptr, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Moves the viewpoint to a different location with respect to the map with an
/// optional transition duration and timing function, and optionally some additional
/// padding on each side. For animated changes, wait until the map view has
/// finished loading before calling this method.
/// 
/// @param camera The new viewpoint.
/// @param duration The amount of time, measured in seconds, that the transition
/// animation should take. Specify `0` to jump to the new viewpoint
/// instantaneously.
/// @param function A timing function used for the animation. Set this parameter to
/// `nil` for a transition that matches most system animations. If the duration
/// is `0`, this parameter is ignored.
/// @param edgePadding The minimum padding (in screen points) that would be visible
/// around the returned camera object if it were set as the receivers camera.
/// @param completion The block to execute after the animation finishes.
  void setCamera$3(MLNMapCamera camera, {required double withDuration,CAMediaTimingFunction? animationTimingFunction,required UIEdgeInsets edgePadding,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_tm3gbn(object$.ref.pointer, _sel_setCamera_withDuration_animationTimingFunction_edgePadding_completionHandler_, camera.ref.pointer, withDuration, animationTimingFunction?.ref.pointer ?? ffi.nullptr, edgePadding, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// The geographic coordinate at the center of the map view.
/// 
/// Changing the value of this property centers the map on the new coordinate
/// without changing the current zoom level.
/// 
/// Changing the value of this property updates the map view immediately. If you
/// want to animate the change, use the `-setCenterCoordinate:animated:` method
/// instead.
  set centerCoordinate(CLLocationCoordinate2D value) {
_objc_msgSend_1zv0am(object$.ref.pointer, _sel_setCenterCoordinate_, value);

  }


  /// Changes the center coordinate of the map and optionally animates the change.
/// 
/// Changing the center coordinate centers the map on the new coordinate without
/// changing the current zoom level. For animated changes, wait until the map view has
/// finished loading before calling this method.
/// 
/// @param coordinate The new center coordinate for the map.
/// @param animated Specify `YES` if you want the map view to scroll to the new
/// location or `NO` if you want the map to display the new location
/// immediately.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate(CLLocationCoordinate2D coordinate, {required bool animated}) {
_objc_msgSend_o7hjv2(object$.ref.pointer, _sel_setCenterCoordinate_animated_, coordinate, animated);

  }


  /// Changes the center coordinate and zoom level of the map and optionally animates
/// the change. For animated changes, wait until the map view has
/// finished loading before calling this method.
/// 
/// @param centerCoordinate The new center coordinate for the map.
/// @param zoomLevel The new zoom level for the map.
/// @param animated Specify `YES` if you want the map view to animate scrolling and
/// zooming to the new location or `NO` if you want the map to display the new
/// location immediately.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate$1(CLLocationCoordinate2D centerCoordinate, {required double zoomLevel,required bool animated}) {
_objc_msgSend_sbs4d5(object$.ref.pointer, _sel_setCenterCoordinate_zoomLevel_animated_, centerCoordinate, zoomLevel, animated);

  }


  /// Changes the center coordinate, zoom level, and direction of the map and
/// optionally animates the change. For animated changes, wait until the map view has
/// finished loading before calling this method.
/// 
/// @param centerCoordinate The new center coordinate for the map.
/// @param zoomLevel The new zoom level for the map.
/// @param direction The new direction for the map, measured in degrees relative to
/// true north. A negative value leaves the maps direction unchanged.
/// @param animated Specify `YES` if you want the map view to animate scrolling,
/// zooming, and rotating to the new location or `NO` if you want the map to
/// display the new location immediately.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate$2(CLLocationCoordinate2D centerCoordinate, {required double zoomLevel,required double direction,required bool animated}) {
_objc_msgSend_3zczym(object$.ref.pointer, _sel_setCenterCoordinate_zoomLevel_direction_animated_, centerCoordinate, zoomLevel, direction, animated);

  }


  /// Changes the center coordinate, zoom level, and direction of the map, calling a
/// completion handler at the end of an optional animation. For animated changes,
/// wait until the map view has finished loading before calling this method.
/// 
/// @param centerCoordinate The new center coordinate for the map.
/// @param zoomLevel The new zoom level for the map.
/// @param direction The new direction for the map, measured in degrees relative to
/// true north. A negative value leaves the maps direction unchanged.
/// @param animated Specify `YES` if you want the map view to animate scrolling,
/// zooming, and rotating to the new location or `NO` if you want the map to
/// display the new location immediately.
/// @param completion The block executed after the animation finishes.
/// 
/// > Note: The behavior of this method is undefined if called in response to
/// `UIApplicationWillTerminateNotification`.
  void setCenterCoordinate$3(CLLocationCoordinate2D centerCoordinate, {required double zoomLevel,required double direction,required bool animated,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_d9pvdp(object$.ref.pointer, _sel_setCenterCoordinate_zoomLevel_direction_animated_completionHandler_, centerCoordinate, zoomLevel, direction, animated, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// A `CGPoint` indicating the position offset of the compass.
  set compassViewMargins(objc.CGPoint value) {
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setCompassViewMargins_, value);

  }


  /// The position of the compass view. The default value is
/// ``MLNOrnamentPosition/MLNOrnamentPositionTopRight``.
  set compassViewPosition(int value) {
_objc_msgSend_8fd115(object$.ref.pointer, _sel_setCompassViewPosition_, value);

  }


  /// The distance from the edges of the map views frame to the edges of the map
/// views logical viewport.
/// 
/// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
/// properties such as `centerCoordinate` assume a viewport that matches the map
/// views frame. Otherwise, those properties are inset, excluding part of the
/// frame from the viewport. For instance, if the only the top edge is inset, the
/// map center is effectively shifted downward.
/// 
/// When the map views superview is an instance of `UIViewController` whose
/// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
/// property may be overridden at any time.
/// 
/// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
/// use the map views property ``MLNMapView/automaticallyAdjustsContentInset``instead.
/// 
/// Changing the value of this property updates the map view immediately. If you
/// want to animate the change, use the `-setContentInset:animated:completionHandler:`
/// method instead.
  set contentInset(UIEdgeInsets value) {
_objc_msgSend_1g8fos5(object$.ref.pointer, _sel_setContentInset_, value);

  }


  /// Deprecated. Sets the distance from the edges of the map views frame to the edges
/// of the map views logical viewport with an optional transition animation.
/// 
/// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
/// properties such as `centerCoordinate` assume a viewport that matches the map
/// views frame. Otherwise, those properties are inset, excluding part of the
/// frame from the viewport. For instance, if the only the top edge is inset, the
/// map center is effectively shifted downward.
/// 
/// When the map views superview is an instance of `UIViewController` whose
/// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
/// property may be overridden at any time.
/// 
/// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
/// use the map views property ``MLNMapView/automaticallyAdjustsContentInset``instead.
/// 
/// To specify a completion handler to execute after the animation finishes, use
/// the `-setContentInset:animated:completionHandler:` method.
/// 
/// @param contentInset The new values to inset the content by.
/// @param animated Specify `YES` if you want the map view to animate the change to
/// the content inset or `NO` if you want the map to inset the content
/// immediately.
  void setContentInset(UIEdgeInsets contentInset, {required bool animated}) {
_objc_msgSend_6ueq99(object$.ref.pointer, _sel_setContentInset_animated_, contentInset, animated);

  }


  /// Sets the distance from the edges of the map views frame to the edges of the
/// map views logical viewport with an optional transition animation and
/// completion handler.
/// 
/// When the value of this property is equal to `UIEdgeInsetsZero`, viewport
/// properties such as `centerCoordinate` assume a viewport that matches the map
/// views frame. Otherwise, those properties are inset, excluding part of the
/// frame from the viewport. For instance, if the only the top edge is inset, the
/// map center is effectively shifted downward.
/// 
/// When the map views superview is an instance of `UIViewController` whose
/// `automaticallyAdjustsScrollViewInsets` property is `YES`, the value of this
/// property may be overridden at any time.
/// 
/// The usage of `automaticallyAdjustsScrollViewInsets` has been deprecated
/// use the map views property ``MLNMapView/automaticallyAdjustsContentInset``instead.
/// 
/// @param contentInset The new values to inset the content by.
/// @param animated Specify `YES` if you want the map view to animate the change to
/// the content inset or `NO` if you want the map to inset the content
/// immediately.
/// @param completion The block executed after the animation finishes.
  void setContentInset$1(UIEdgeInsets contentInset, {required bool animated,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_1vx0lfy(object$.ref.pointer, _sel_setContentInset_animated_completionHandler_, contentInset, animated, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// The options that determine which debugging aids are shown on the map.
/// 
/// These options are all disabled by default and should remain disabled in
/// released software for performance and aesthetic reasons.
  set debugMask(int value) {
_objc_msgSend_pisvbv(object$.ref.pointer, _sel_setDebugMask_, value);

  }


  /// A floating-point value that determines the rate of deceleration after the user
/// lifts their finger.
/// 
/// Your application can use the ``MLNMapViewDecelerationRateNormal`` and
/// ``MLNMapViewDecelerationRateFast`` constants as reference points for reasonable
/// deceleration rates. ``MLNMapViewDecelerationRateImmediate`` can be used to
/// disable deceleration entirely.
  set decelerationRate(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setDecelerationRate_, value);

  }


  /// The receivers delegate.
/// 
/// A map view sends messages to its delegate to notify it of changes to its
/// contents or the viewpoint. The delegate also provides information about
/// annotations displayed on the map, such as the styles to apply to individual
/// annotations.
  set delegate(MLNMapViewDelegate? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// The heading of the map, measured in degrees clockwise from true north.
/// 
/// The value `0` means that the top edge of the map view corresponds to true
/// north. The value `90` means the top of the map is pointing due east. The
/// value `180` means the top of the map points due south, and so on.
/// 
/// Changing the value of this property updates the map view immediately. If you
/// want to animate the change, use the `-setDirection:animated:` method instead.
  set direction(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setDirection_, value);

  }


  /// Changes the heading of the map and optionally animates the change.
/// 
/// @param direction The heading of the map, measured in degrees clockwise from
/// true north.
/// @param animated Specify `YES` if you want the map view to animate the change
/// to the new heading or `NO` if you want the map to display the new
/// heading immediately.
/// 
/// Changing the heading rotates the map without changing the current center
/// coordinate or zoom level.
  void setDirection(double direction, {required bool animated}) {
_objc_msgSend_ghxo7e(object$.ref.pointer, _sel_setDirection_animated_, direction, animated);

  }


  /// Whether the map view should display a heading calibration alert when necessary.
/// The default value is `YES`.
  set displayHeadingCalibration(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setDisplayHeadingCalibration_, value);

  }


  /// A boolean value indicating whether camera animation duration is set based
/// on the time difference between the last location update and the current one
/// or the default animation duration of 1 second.
/// 
/// The default value of this property is `NO`
  set dynamicNavigationCameraAnimationDuration(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setDynamicNavigationCameraAnimationDuration_, value);

  }


  /// A Boolean value that determines whether the user will receive haptic feedback
/// for certain interactions with the map.
/// 
/// When this property is set to `YES`, the default, a `UIImpactFeedbackStyleLight`
/// haptic feedback event be played when the user rotates the map to due north
/// (0).
/// 
/// This feature requires a device that supports haptic feedback, running iOS 10 or
/// newer.
  set isHapticFeedbackEnabled(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHapticFeedbackEnabled_, value);

  }


  /// The object that this map view uses to start and stop the delivery of
/// location-related updates.
/// 
/// To receive the current user location, implement the
/// ``MLNMapViewDelegate/mapView:didUpdateUserLocation:`` and
/// ``MLNMapViewDelegate/mapView:didFailToLocateUserWithError:`` methods.
/// 
/// If setting this property to `nil` or if no custom manager is provided this
/// property is set to the default location manager.
/// 
/// ``MLNMapView`` uses a default location manager. If you want to substitute your
/// own location manager, you should do so by setting this property before setting
/// `showsUserLocation` to `YES`. To restore the default location manager,
/// set this property to `nil`.
  set locationManager(MLNLocationManager value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLocationManager_, value.ref.pointer);

  }


  /// A `CGPoint` indicating the position offset of the logo.
  set logoViewMargins(objc.CGPoint value) {
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setLogoViewMargins_, value);

  }


  /// The position of the logo view. The default value is
/// ``MLNOrnamentPosition/MLNOrnamentPositionBottomLeft``.
  set logoViewPosition(int value) {
_objc_msgSend_8fd115(object$.ref.pointer, _sel_setLogoViewPosition_, value);

  }


  /// The maximum pitch of the maps camera toward the horizon measured in degrees.
/// 
/// If the value of this property is smaller than that of the `minimumPitch`
/// property, the behavior is undefined. The pitch may not exceed 60 degrees
/// regardless of this property.
/// 
/// The default value of this property is 60 degrees.
  set maximumPitch(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setMaximumPitch_, value);

  }


  /// The maximum bounds of the map that can be shown on screen.
  set maximumScreenBounds(MLNCoordinateBounds value) {
_objc_msgSend_9ay59k(object$.ref.pointer, _sel_setMaximumScreenBounds_, value);

  }


  /// The maximum zoom level the map can be shown at.
/// 
/// If the value of this property is smaller than that of the
/// minimumZoomLevel property, the behavior is undefined.
/// 
/// The default maximumZoomLevel is 22. The upper bound for this property
/// is 25.5.
  set maximumZoomLevel(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setMaximumZoomLevel_, value);

  }


  /// The minimum pitch of the maps camera toward the horizon measured in degrees.
/// 
/// If the value of this property is greater than that of the `maximumPitch`
/// property, the behavior is undefined. The pitch may not be less than 0
/// regardless of this property.
/// 
/// The default value of this property is 0 degrees, allowing the map to appear
/// two-dimensional.
  set minimumPitch(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setMinimumPitch_, value);

  }


  /// The minimum zoom level at which the map can be shown.
/// 
/// Depending on the map views aspect ratio, the map view may be prevented
/// from reaching the minimum zoom level, in order to keep the map from
/// repeating within the current viewport.
/// 
/// If the value of this property is greater than that of the
/// maximumZoomLevel property, the behavior is undefined.
/// 
/// The default minimumZoomLevel is 0.
  set minimumZoomLevel(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setMinimumZoomLevel_, value);

  }


  /// The scrolling mode the user is allowed to use to interact with the map.
/// 
/// `MLNPanScrollingModeHorizontal` only allows the user to scroll horizontally on the map,
/// restricting a user's ability to scroll vertically.
/// `MLNPanScrollingModeVertical` only allows the user to scroll vertically on the map,
/// restricting a user's ability to scroll horizontally.
/// ``MLNPanScrollingMode/MLNPanScrollingModeDefault`` allows the user to scroll both horizontally and
/// vertically on the map.
/// 
/// By default, this property is set to ``MLNPanScrollingMode/MLNPanScrollingModeDefault``.
  set panScrollingMode(int value) {
_objc_msgSend_k7jknj(object$.ref.pointer, _sel_setPanScrollingMode_, value);

  }


  /// A Boolean value that determines whether the user may change the pitch (tilt) of
/// the map.
/// 
/// When this property is set to `YES`, the default, the user may tilt the map by
/// vertically dragging two fingers.
/// 
/// This property controls only user interactions with the map. If you set the
/// value of this property to `NO`, you may still change the pitch of the map
/// programmatically.
/// 
/// The default value of this property is `YES`.
  set isPitchEnabled(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setPitchEnabled_, value);

  }


  /// The preferred frame rate at which the map view is rendered.
/// 
/// The default value for this property is
/// ``MLNMapViewPreferredFramesPerSecondDefault``, which will adaptively set the
/// preferred frame rate based on the capability of the users device to maintain
/// a smooth experience.
/// 
/// In addition to the provided ``MLNMapViewPreferredFramesPerSecond`` options, this
/// property can be set to arbitrary integer values.
/// 
/// @see `CADisplayLink.preferredFramesPerSecond`
  set preferredFramesPerSecond(int value) {
_objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setPreferredFramesPerSecond_, value);

  }


  /// A Boolean value indicating whether the map should prefetch tiles.
/// 
/// When this property is set to `YES`, the map view prefetches tiles designed for
/// a low zoom level and displays them until receiving more detailed tiles for the
/// current zoom level. The prefetched tiles typically contain simplified versions
/// of each shape, improving the map views perceived performance.
/// 
/// The default value of this property is `YES`.
  set prefetchesTiles(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setPrefetchesTiles_, value);

  }


  /// A boolean value that reverses the direction of the quick zoom gesture.
/// 
/// When this property is set, the zoom-in and zoom-out behavior during the quick
/// zoom gesture (also called one-finger zoom) is reversed, aligning with the
/// behavior in Apple Maps. The default value is `NO`.
  set isQuickZoomReversed(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setQuickZoomReversed_, value);

  }


  /// A Boolean value that determines whether the user may rotate the map,
/// changing the direction.
/// 
/// When this property is set to `YES`, the default, the user may rotate the map
/// by moving two fingers in a circular motion.
/// 
/// This property controls only user interactions with the map. If you set the
/// value of this property to `NO`, you may still rotate the map
/// programmatically.
  set isRotateEnabled(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setRotateEnabled_, value);

  }


  /// A `CGPoint` indicating the position offset of the scale bar.
  set scaleBarMargins(objc.CGPoint value) {
_objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setScaleBarMargins_, value);

  }


  /// The position of the scale bar. The default value is
/// ``MLNOrnamentPosition/MLNOrnamentPositionTopLeft``.
  set scaleBarPosition(int value) {
_objc_msgSend_8fd115(object$.ref.pointer, _sel_setScaleBarPosition_, value);

  }


  /// Sets whether the scale uses styles that make it easier to read on a dark styled map
  set scaleBarShouldShowDarkStyles(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setScaleBarShouldShowDarkStyles_, value);

  }


  /// Sets whether the scale uses metric
  set scaleBarUsesMetricSystem(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setScaleBarUsesMetricSystem_, value);

  }


  /// A Boolean value that determines whether the user may scroll around the map,
/// changing the center coordinate.
/// 
/// When this property is set to `YES`, the default, the user may scroll the map
/// by dragging or swiping with one finger.
/// 
/// This property controls only user interactions with the map. If you set the
/// value of this property to `NO`, you may still change the map location
/// programmatically.
  set isScrollEnabled(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setScrollEnabled_, value);

  }


  /// The currently selected annotations.
/// 
/// Assigning a new array to this property selects only the first annotation in
/// the array.
/// 
/// If the annotation is of type ``MLNPointAnnotation`` and is offscreen, the camera
/// will animate to bring the annotation and its callout just on screen. If you
/// need finer control, consider using `-selectAnnotation:animated:`.
/// 
/// > Note: In versions prior to `4.0.0` if the annotation was offscreen it was not
/// selected.
  set selectedAnnotations(objc.NSArray value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSelectedAnnotations_, value.ref.pointer);

  }


  /// A Boolean value indicating whether the map may request authorization to use location services.
/// 
/// Setting this property to `YES` causes the map view to use the Core Location
/// framework to request authorization when authorizationStatus == kCLAuthorizationStatusNotDetermined.
/// 
/// The default value of this property is `YES`.
  set shouldRequestAuthorizationToUseLocationServices(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShouldRequestAuthorizationToUseLocationServices_, value);

  }


  /// A Boolean value indicating whether the map may display Attribution Button.
/// 
/// The view controlled by this property is available at `attributionButton`. The default value
/// of this property is `YES`.
  set showsAttributionButton(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsAttributionButton_, value);

  }


  /// A Boolean value indicating whether the map may display Compass View.
/// 
/// The view controlled by this property is available at `compassView`. The default value
/// of this property is `YES`.
  set showsCompassView(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsCompassView_, value);

  }


  /// A Boolean value indicating whether the map may display MapLibre logo.
/// 
/// The view controlled by this property is available at `logoView`. The default value
/// of this property is `YES`.
  set showsLogoView(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsLogoView_, value);

  }


  /// A Boolean value indicating whether the map may display scale information.
/// 
/// The scale bar may not be shown at all zoom levels. The scale bar becomes visible
/// when the maximum distance visible on the map view is less than 400 miles (800
/// kilometers). The zoom level where this occurs depends on the latitude at the map
/// views center coordinate, as well as the device screen width. At latitudes
/// farther from the equator, the scale bar becomes visible at lower zoom levels.
/// 
/// The unit of measurement is determined by the user's device locale.
/// 
/// The view controlled by this property is available at `scaleBar`. The default value
/// of this property is `NO`.
  set showsScale(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsScale_, value);

  }


  /// A Boolean value indicating whether the user location annotation may display a
/// permanent heading indicator.
/// 
/// Setting this property to `YES` causes the default user location annotation to
/// appear and always show an arrow-shaped heading indicator, if heading is
/// available. This property does not rotate the map; for that, see
/// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading``.
/// 
/// This property has no effect when ``userTrackingMode`` is
/// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading`` or
/// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
/// 
/// The default value of this property is `NO`.
  set showsUserHeadingIndicator(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsUserHeadingIndicator_, value);

  }


  /// A Boolean value indicating whether the map may display the user location.
/// 
/// Setting this property to `YES` causes the map view to use the Core Location
/// framework to find the current location. As long as this property is `YES`, the
/// map view continues to track the users location and update it periodically.
/// 
/// This property does not indicate whether the users position is actually visible
/// on the map, only whether the map view is allowed to display it. To determine
/// whether the users position is visible, use the `userLocationVisible` property.
/// The default value of this property is `NO`.
/// 
/// Your app must specify a value for `NSLocationWhenInUseUsageDescription` or
/// `NSLocationAlwaysUsageDescription` in its `Info.plist` to satisfy the
/// requirements of the underlying Core Location framework when enabling this
/// property.
/// 
/// If you implement a custom location manager, set the `locationManager` before
/// calling `showsUserLocation`.
  set showsUserLocation(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setShowsUserLocation_, value);

  }


  /// The style JSON representation of the map.
/// 
/// Setting this property results in an asynchronous style change. If you wish to know when the style
/// change is complete, observe the ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` method
/// on ``MLNMapViewDelegate``.
/// 
/// The JSON must conform to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
/// 
/// @throws NSInvalidArgumentException if styleJSON is nil or invalid JSON
  set styleJSON(objc.NSString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setStyleJSON_, value.ref.pointer);

  }


  /// URL of the style currently displayed in the receiver.
/// 
/// The URL may be a full HTTP or HTTPS URL, canonical URL, or
/// a path to a local file relative to the applications resource path.
/// 
/// If you set this property to `nil`, the receiver will use the default style
/// and this property will automatically be set to that styles URL.
/// 
/// If you want to modify the current style without replacing it outright, or if
/// you want to introspect individual style attributes, use the `style` property.
/// 
/// #### Related examples
/// - TODO: change the style of a map at runtime.
  set styleURL(objc.NSURL value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setStyleURL_, value.ref.pointer);

  }


  /// The geographic coordinate that is the subject of observation as the user
/// location is being tracked.
/// 
/// By default, this property is set to an invalid coordinate, indicating that
/// there is no target. In course tracking mode, the target forms one of two foci
/// in the viewport, the other being the user location annotation. Typically, this
/// property is set to a destination or waypoint in a real-time navigation scene.
/// As the user annotation moves toward the target, the map automatically zooms in
/// to fit both foci optimally within the viewport.
/// 
/// This property has no effect if the `userTrackingMode` property is set to a
/// value other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
/// 
/// Changing the value of this property updates the map view with an animated
/// transition. If you dont want to animate the change, use the
/// `-setTargetCoordinate:animated:` method instead.
  set targetCoordinate(CLLocationCoordinate2D value) {
_objc_msgSend_1zv0am(object$.ref.pointer, _sel_setTargetCoordinate_, value);

  }


  /// Deprecated. Sets the geographic coordinate that is the subject of observation as
/// the user location is being tracked, with an optional transition animation.
/// 
/// By default, the target coordinate is set to an invalid coordinate, indicating
/// that there is no target. In course tracking mode, the target forms one of two
/// foci in the viewport, the other being the user location annotation. Typically,
/// the target is set to a destination or waypoint in a real-time navigation scene.
/// As the user annotation moves toward the target, the map automatically zooms in
/// to fit both foci optimally within the viewport.
/// 
/// This method has no effect if the `userTrackingMode` property is set to a value
/// other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
/// 
/// To specify a completion handler to execute after the animation finishes, use
/// the `-setTargetCoordinate:animated:completionHandler:` method.
/// 
/// @param targetCoordinate The target coordinate to fit within the viewport.
/// @param animated If `YES`, the map animates to fit the target within the map
/// view. If `NO`, the map fits the target instantaneously.
  void setTargetCoordinate(CLLocationCoordinate2D targetCoordinate, {required bool animated}) {
_objc_msgSend_o7hjv2(object$.ref.pointer, _sel_setTargetCoordinate_animated_, targetCoordinate, animated);

  }


  /// Sets the geographic coordinate that is the subject of observation as the user
/// location is being tracked, with an optional transition animation and completion
/// handler.
/// 
/// By default, the target coordinate is set to an invalid coordinate, indicating
/// that there is no target. In course tracking mode, the target forms one of two
/// foci in the viewport, the other being the user location annotation. Typically,
/// the target is set to a destination or waypoint in a real-time navigation scene.
/// As the user annotation moves toward the target, the map automatically zooms in
/// to fit both foci optimally within the viewport.
/// 
/// This method has no effect if the `userTrackingMode` property is set to a value
/// other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
/// 
/// @param targetCoordinate The target coordinate to fit within the viewport.
/// @param animated If `YES`, the map animates to fit the target within the map
/// view. If `NO`, the map fits the target instantaneously.
/// @param completion The block executed after the animation finishes.
  void setTargetCoordinate$1(CLLocationCoordinate2D targetCoordinate, {required bool animated,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_1pbhom5(object$.ref.pointer, _sel_setTargetCoordinate_animated_completionHandler_, targetCoordinate, animated, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// A Boolean value indicating whether the map may cache tiles for different zoom levels or not.
/// 
/// When this property is set to `YES`,  the map view consumes more memory and
/// provide a smoother user experience when zoom in/out.
/// 
/// The default value of this property is `YES`.
  set tileCacheEnabled(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setTileCacheEnabled_, value);

  }


  /// Camera based tile level of detail controls
/// 
/// Minimum radius around the view point in unit of tiles in which the fine
/// grained zoom level tiles are always used when performing LOD
/// radius must be greater than 1 (At least 1 fine detailed tile is present)
/// A smaller radius value may improve performance at the cost of quality (tiles away from
/// camera use lower Zoom levels)
  set tileLodMinRadius(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setTileLodMinRadius_, value);

  }


  /// Camera based tile level of detail controls
/// 
/// Pitch angle in radians above which LOD calculation is performed
/// A smaller radius value may improve performance at the cost of quality
  set tileLodPitchThreshold(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setTileLodPitchThreshold_, value);

  }


  /// Camera based tile level of detail controls
/// 
/// Factor for the distance to the camera view point
/// A value larger than 1 increases the distance to the camera view point reducing LOD
/// Larger values may improve performance at the cost of quality (tiles away from camera
/// use lower Zoom levels)
  set tileLodScale(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setTileLodScale_, value);

  }


  /// Camera based tile level of detail controls
/// 
/// Shift applied to the Zoom level during LOD calculation
/// A negative value shifts the Zoom level to a coarser level reducing quality but improving
/// performance A positive value shifts the Zoom level to a finer level increasing details but
/// negatively affecting performance A value of zero (default) does not apply any shift to the Zoom
/// level It is not recommended to change the default value unless performance is critical and the loss
/// of quality is acceptable. A value of -1 reduces the number of displayed tiles by a factor of 4 on
/// average It is recommended to first configure the pixelRatio before adjusting TileLodZoomShift.
  set tileLodZoomShift(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setTileLodZoomShift_, value);

  }


  /// The vertical alignment of the user location annotation within the receiver. The
/// default value is ``MLNAnnotationVerticalAlignment/MLNAnnotationVerticalAlignmentCenter``.
/// 
/// Changing the value of this property updates the map view with an animated
/// transition. If you dont want to animate the change, use the
/// `-setUserLocationVerticalAlignment:animated:` method instead.
  set userLocationVerticalAlignment(int value) {
_objc_msgSend_47doj4(object$.ref.pointer, _sel_setUserLocationVerticalAlignment_, value);

  }


  /// Sets the vertical alignment of the user location annotation within the
/// receiver, with an optional transition.
/// 
/// @param alignment The vertical alignment of the user location annotation.
/// @param animated If `YES`, the user location annotation animates to its new
/// position within the map view. If `NO`, the user location annotation
/// instantaneously moves to its new position.
  void setUserLocationVerticalAlignment(int alignment, {required bool animated}) {
_objc_msgSend_1qddrus(object$.ref.pointer, _sel_setUserLocationVerticalAlignment_animated_, alignment, animated);

  }


  /// The mode used to track the user location. The default value is
/// ``MLNUserTrackingMode/MLNUserTrackingModeNone``.
/// 
/// Changing the value of this property updates the map view with an animated
/// transition. If you dont want to animate the change, use the
/// `-setUserTrackingMode:animated:` method instead.
/// 
/// #### Related examples
/// - TODO: Customize the user location annotation and learn how to customize the
/// default user location annotation shown by ``MLNUserTrackingMode``.
  set userTrackingMode(int value) {
_objc_msgSend_xoapar(object$.ref.pointer, _sel_setUserTrackingMode_, value);

  }


  /// Deprecated. Sets the mode used to track the user location, with an optional transition.
/// 
/// To specify a completion handler to execute after the animation finishes, use
/// the `-setUserTrackingMode:animated:completionHandler:` method.
/// 
/// @param mode The mode used to track the user location.
/// @param animated If `YES`, there is an animated transition from the current
/// viewport to a viewport that results from the change to `mode`. If `NO`, the
/// map view instantaneously changes to the new viewport. This parameter only
/// affects the initial transition; subsequent changes to the user location or
/// heading are always animated.
  void setUserTrackingMode(int mode, {required bool animated}) {
_objc_msgSend_7oa3sf(object$.ref.pointer, _sel_setUserTrackingMode_animated_, mode, animated);

  }


  /// Sets the mode used to track the user location, with an optional transition and
/// completion handler.
/// 
/// @param mode The mode used to track the user location.
/// @param animated If `YES`, there is an animated transition from the current
/// viewport to a viewport that results from the change to `mode`. If `NO`, the
/// map view instantaneously changes to the new viewport. This parameter only
/// affects the initial transition; subsequent changes to the user location or
/// heading are always animated.
/// @param completion The block executed after the animation finishes.
  void setUserTrackingMode$1(int mode, {required bool animated,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_1iu40ms(object$.ref.pointer, _sel_setUserTrackingMode_animated_completionHandler_, mode, animated, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// The coordinate bounds visible in the receivers viewport.
/// 
/// Changing the value of this property updates the receiver immediately. If you
/// want to animate the change, call `-setVisibleCoordinateBounds:animated:`
/// instead.
/// 
/// If a longitude is less than 180 degrees or greater than 180 degrees, the
/// visible bounds straddles the antimeridian or international date line. For
/// example, if both Tokyo and San Francisco are visible, the visible bounds might
/// extend from (35.68476, 220.24257) to (37.78428, 122.41310).
  set visibleCoordinateBounds(MLNCoordinateBounds value) {
_objc_msgSend_9ay59k(object$.ref.pointer, _sel_setVisibleCoordinateBounds_, value);

  }


  /// Changes the receivers viewport to fit the given coordinate bounds,
/// optionally animating the change.
/// 
/// To bring both sides of the antimeridian or international date line into view,
/// specify some longitudes less than 180 degrees or greater than 180 degrees. For
/// example, to show both Tokyo and San Francisco simultaneously, you could set the
/// visible bounds to extend from (35.68476, 220.24257) to (37.78428, 122.41310).
/// 
/// @param bounds The bounds that the viewport will show in its entirety.
/// @param animated Specify `YES` to animate the change by smoothly scrolling
/// and zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinateBounds(MLNCoordinateBounds bounds, {required bool animated}) {
_objc_msgSend_148tmbg(object$.ref.pointer, _sel_setVisibleCoordinateBounds_animated_, bounds, animated);

  }


  /// Deprecated. Changes the receivers viewport to fit the given coordinate bounds with
/// some additional padding on each side.
/// 
/// To bring both sides of the antimeridian or international date line into view,
/// specify some longitudes less than 180 degrees or greater than 180 degrees. For
/// example, to show both Tokyo and San Francisco simultaneously, you could set the
/// visible bounds to extend from (35.68476, 220.24257) to (37.78428, 122.41310).
/// 
/// To specify a completion handler to execute after the animation finishes, use
/// the `-setVisibleCoordinateBounds:edgePadding:animated:completionHandler:` method.
/// 
/// @param bounds The bounds that the viewport will show in its entirety.
/// @param insets The minimum padding (in screen points) that will be visible
/// around the given coordinate bounds.
/// @param animated Specify `YES` to animate the change by smoothly scrolling and
/// zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinateBounds$1(MLNCoordinateBounds bounds, {required UIEdgeInsets edgePadding,required bool animated}) {
_objc_msgSend_18wcmvu(object$.ref.pointer, _sel_setVisibleCoordinateBounds_edgePadding_animated_, bounds, edgePadding, animated);

  }


  /// Changes the receivers viewport to fit the given coordinate bounds with some
/// additional padding on each side, optionally calling a completion handler.
/// 
/// To bring both sides of the antimeridian or international date line into view,
/// specify some longitudes less than 180 degrees or greater than 180 degrees. For
/// example, to show both Tokyo and San Francisco simultaneously, you could set the
/// visible bounds to extend from (35.68476, 220.24257) to (37.78428, 122.41310).
/// 
/// @param bounds The bounds that the viewport will show in its entirety.
/// @param insets The minimum padding (in screen points) that will be visible
/// around the given coordinate bounds.
/// @param animated Specify `YES` to animate the change by smoothly scrolling and
/// zooming or `NO` to immediately display the given bounds.
/// @param completion The block executed after the animation finishes.
  void setVisibleCoordinateBounds$2(MLNCoordinateBounds bounds, {required UIEdgeInsets edgePadding,required bool animated,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_1v6m6tt(object$.ref.pointer, _sel_setVisibleCoordinateBounds_edgePadding_animated_completionHandler_, bounds, edgePadding, animated, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Changes the receivers viewport to fit all of the given coordinates with some
/// additional padding on each side.
/// 
/// To bring both sides of the antimeridian or international date line into view,
/// specify some longitudes less than 180 degrees or greater than 180 degrees. For
/// example, to show both Tokyo and San Francisco simultaneously, you could set the
/// visible coordinates to (35.68476, 220.24257) and (37.78428, 122.41310).
/// 
/// @param coordinates The coordinates that the viewport will show.
/// @param count The number of coordinates. This number must not be greater than
/// the number of elements in `coordinates`.
/// @param insets The minimum padding (in screen points) that will be visible
/// around the given coordinate bounds.
/// @param animated Specify `YES` to animate the change by smoothly scrolling and
/// zooming or `NO` to immediately display the given bounds.
  void setVisibleCoordinates(ffi.Pointer<CLLocationCoordinate2D> coordinates, {required int count,required UIEdgeInsets edgePadding,required bool animated}) {
_objc_msgSend_1evryr5(object$.ref.pointer, _sel_setVisibleCoordinates_count_edgePadding_animated_, coordinates, count, edgePadding, animated);

  }


  /// Changes the receivers viewport to fit all of the given coordinates with some
/// additional padding on each side, optionally calling a completion handler.
/// 
/// To bring both sides of the antimeridian or international date line into view,
/// specify some longitudes less than 180 degrees or greater than 180 degrees. For
/// example, to show both Tokyo and San Francisco simultaneously, you could set the
/// visible coordinates to (35.68476, 220.24257) and (37.78428, 122.41310).
/// 
/// @param coordinates The coordinates that the viewport will show.
/// @param count The number of coordinates. This number must not be greater than
/// the number of elements in `coordinates`.
/// @param insets The minimum padding (in screen points) that will be visible
/// around the given coordinate bounds.
/// @param direction The direction to rotate the map to, measured in degrees
/// relative to true north. A negative value leaves the maps direction
/// unchanged.
/// @param duration The duration to animate the change in seconds.
/// @param function The timing function to animate the change.
/// @param completion The block executed after the animation finishes.
  void setVisibleCoordinates$1(ffi.Pointer<CLLocationCoordinate2D> coordinates, {required int count,required UIEdgeInsets edgePadding,required double direction,required double duration,CAMediaTimingFunction? animationTimingFunction,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_v2jdd0(object$.ref.pointer, _sel_setVisibleCoordinates_count_edgePadding_direction_duration_animationTimingFunction_completionHandler_, coordinates, count, edgePadding, direction, duration, animationTimingFunction?.ref.pointer ?? ffi.nullptr, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// A Boolean value that determines whether the user may zoom the map in and
/// out, changing the zoom level.
/// 
/// When this property is set to `YES`, the default, the user may zoom the map
/// in and out by pinching two fingers or by double tapping, holding, and moving
/// the finger up and down.
/// 
/// This property controls only user interactions with the map. If you set the
/// value of this property to `NO`, you may still change the map zoom
/// programmatically.
  set isZoomEnabled(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setZoomEnabled_, value);

  }


  /// The zoom level of the receiver.
/// 
/// In addition to affecting the visual size and detail of features on the map,
/// the zoom level affects the size of the vector tiles that are loaded. At zoom
/// level 0, each tile covers the entire world map; at zoom level 1, it covers 
/// of the world; at zoom level 2, <sup>1</sup><sub>16</sub> of the world, and
/// so on.
/// 
/// Changing the value of this property updates the map view immediately. If you
/// want to animate the change, use the `-setZoomLevel:animated:` method instead.
  set zoomLevel(double value) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setZoomLevel_, value);

  }


  /// Changes the zoom level of the map and optionally animates the change.
/// 
/// Changing the zoom level scales the map without changing the current center
/// coordinate.
/// 
/// @param zoomLevel The new zoom level for the map.
/// @param animated Specify `YES` if you want the map view to animate the change
/// to the new zoom level or `NO` if you want the map to display the new
/// zoom level immediately.
  void setZoomLevel(double zoomLevel, {required bool animated}) {
_objc_msgSend_ghxo7e(object$.ref.pointer, _sel_setZoomLevel_animated_, zoomLevel, animated);

  }


  /// A Boolean value indicating whether the map may request authorization to use location services.
/// 
/// Setting this property to `YES` causes the map view to use the Core Location
/// framework to request authorization when authorizationStatus == kCLAuthorizationStatusNotDetermined.
/// 
/// The default value of this property is `YES`.
  bool get shouldRequestAuthorizationToUseLocationServices {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_shouldRequestAuthorizationToUseLocationServices);

  }


  /// Sets the visible region so that the map displays the specified annotations.
/// 
/// Calling this method updates the value in the `visibleCoordinateBounds` property
/// and potentially other properties to reflect the new map region. A small amount
/// of padding is reserved around the edges of the map view. To specify a different
/// amount of padding, use the `-showAnnotations:edgePadding:animated:` method.
/// 
/// @param annotations The annotations that you want to be visible in the map.
/// @param animated `YES` if you want the map region change to be animated, or `NO`
/// if you want the map to display the new region immediately without animations.
  void showAnnotations(objc.NSArray annotations, {required bool animated}) {
_objc_msgSend_6p7ndb(object$.ref.pointer, _sel_showAnnotations_animated_, annotations.ref.pointer, animated);

  }


  /// Deprecated. Sets the visible region so that the map displays the specified
/// annotations with the specified amount of padding on each side.
/// 
/// Calling this method updates the value in the `visibleCoordinateBounds` property
/// and potentially other properties to reflect the new map region.
/// 
/// To specify a completion handler to execute after the animation finishes, use
/// the `-showAnnotations:edgePadding:animated:completionHandler:` method.
/// 
/// @param annotations The annotations that you want to be visible in the map.
/// @param insets The minimum padding (in screen points) around the edges of the
/// map view to keep clear of annotations.
/// @param animated `YES` if you want the map region change to be animated, or `NO`
/// if you want the map to display the new region immediately without animations.
  void showAnnotations$1(objc.NSArray annotations, {required UIEdgeInsets edgePadding,required bool animated}) {
_objc_msgSend_1f4zv7b(object$.ref.pointer, _sel_showAnnotations_edgePadding_animated_, annotations.ref.pointer, edgePadding, animated);

  }


  /// Sets the visible region so that the map displays the specified annotations with
/// the specified amount of padding on each side and an optional completion
/// handler.
/// 
/// Calling this method updates the value in the `visibleCoordinateBounds` property
/// and potentially other properties to reflect the new map region.
/// 
/// @param annotations The annotations that you want to be visible in the map.
/// @param insets The minimum padding (in screen points) around the edges of the
/// map view to keep clear of annotations.
/// @param animated `YES` if you want the map region change to be animated, or `NO`
/// if you want the map to display the new region immediately without animations.
/// @param completion The block executed after the animation finishes.
  void showAnnotations$2(objc.NSArray annotations, {required UIEdgeInsets edgePadding,required bool animated,objc.ObjCBlock<ffi.Void Function()>? completionHandler}) {
_objc_msgSend_16lja1o(object$.ref.pointer, _sel_showAnnotations_edgePadding_animated_completionHandler_, annotations.ref.pointer, edgePadding, animated, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Show the attribution action sheet.
/// 
/// This action is performed when the user taps on the attribution button provided
/// by default via the `attributionButton` property. If you implement a custom
/// attribution button, you should add this action to the button.
  void showAttribution(objc.ObjCObject sender) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_showAttribution_, sender.ref.pointer);

  }


  /// A Boolean value indicating whether the map may display Attribution Button.
/// 
/// The view controlled by this property is available at `attributionButton`. The default value
/// of this property is `YES`.
  bool get showsAttributionButton {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsAttributionButton);

  }


  /// A Boolean value indicating whether the map may display Compass View.
/// 
/// The view controlled by this property is available at `compassView`. The default value
/// of this property is `YES`.
  bool get showsCompassView {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsCompassView);

  }


  /// A Boolean value indicating whether the map may display MapLibre logo.
/// 
/// The view controlled by this property is available at `logoView`. The default value
/// of this property is `YES`.
  bool get showsLogoView {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsLogoView);

  }


  /// A Boolean value indicating whether the map may display scale information.
/// 
/// The scale bar may not be shown at all zoom levels. The scale bar becomes visible
/// when the maximum distance visible on the map view is less than 400 miles (800
/// kilometers). The zoom level where this occurs depends on the latitude at the map
/// views center coordinate, as well as the device screen width. At latitudes
/// farther from the equator, the scale bar becomes visible at lower zoom levels.
/// 
/// The unit of measurement is determined by the user's device locale.
/// 
/// The view controlled by this property is available at `scaleBar`. The default value
/// of this property is `NO`.
  bool get showsScale {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsScale);

  }


  /// A Boolean value indicating whether the user location annotation may display a
/// permanent heading indicator.
/// 
/// Setting this property to `YES` causes the default user location annotation to
/// appear and always show an arrow-shaped heading indicator, if heading is
/// available. This property does not rotate the map; for that, see
/// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading``.
/// 
/// This property has no effect when ``userTrackingMode`` is
/// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithHeading`` or
/// ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
/// 
/// The default value of this property is `NO`.
  bool get showsUserHeadingIndicator {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsUserHeadingIndicator);

  }


  /// A Boolean value indicating whether the map may display the user location.
/// 
/// Setting this property to `YES` causes the map view to use the Core Location
/// framework to find the current location. As long as this property is `YES`, the
/// map view continues to track the users location and update it periodically.
/// 
/// This property does not indicate whether the users position is actually visible
/// on the map, only whether the map view is allowed to display it. To determine
/// whether the users position is visible, use the `userLocationVisible` property.
/// The default value of this property is `NO`.
/// 
/// Your app must specify a value for `NSLocationWhenInUseUsageDescription` or
/// `NSLocationAlwaysUsageDescription` in its `Info.plist` to satisfy the
/// requirements of the underlying Core Location framework when enabling this
/// property.
/// 
/// If you implement a custom location manager, set the `locationManager` before
/// calling `showsUserLocation`.
  bool get showsUserLocation {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsUserLocation);

  }


  /// The style currently displayed in the receiver.
  MLNStyle? get style {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_style);
    return $ret.address == 0 ? null : MLNStyle.fromPointer($ret, retain: true, release: true);
  }


  /// The style JSON representation of the map.
/// 
/// Setting this property results in an asynchronous style change. If you wish to know when the style
/// change is complete, observe the ``MLNMapViewDelegate/mapView:didFinishLoadingStyle:`` method
/// on ``MLNMapViewDelegate``.
/// 
/// The JSON must conform to the
/// <a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a>.
/// 
/// @throws NSInvalidArgumentException if styleJSON is nil or invalid JSON
  objc.NSString get styleJSON {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_styleJSON);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// URL of the style currently displayed in the receiver.
/// 
/// The URL may be a full HTTP or HTTPS URL, canonical URL, or
/// a path to a local file relative to the applications resource path.
/// 
/// If you set this property to `nil`, the receiver will use the default style
/// and this property will automatically be set to that styles URL.
/// 
/// If you want to modify the current style without replacing it outright, or if
/// you want to introspect individual style attributes, use the `style` property.
/// 
/// #### Related examples
/// - TODO: change the style of a map at runtime.
  objc.NSURL get styleURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_styleURL);
    return objc.NSURL.fromPointer($ret, retain: true, release: true);
  }


  /// The geographic coordinate that is the subject of observation as the user
/// location is being tracked.
/// 
/// By default, this property is set to an invalid coordinate, indicating that
/// there is no target. In course tracking mode, the target forms one of two foci
/// in the viewport, the other being the user location annotation. Typically, this
/// property is set to a destination or waypoint in a real-time navigation scene.
/// As the user annotation moves toward the target, the map automatically zooms in
/// to fit both foci optimally within the viewport.
/// 
/// This property has no effect if the `userTrackingMode` property is set to a
/// value other than ``MLNUserTrackingMode/MLNUserTrackingModeFollowWithCourse``.
/// 
/// Changing the value of this property updates the map view with an animated
/// transition. If you dont want to animate the change, use the
/// `-setTargetCoordinate:animated:` method instead.
  CLLocationCoordinate2D get targetCoordinate {
    final $ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants ? _objc_msgSend_18o5nokStret($ptr, object$.ref.pointer, _sel_targetCoordinate) : $ptr.ref = _objc_msgSend_18o5nok(object$.ref.pointer, _sel_targetCoordinate);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(
        $finalizable);

  }


  /// A Boolean value indicating whether the map may cache tiles for different zoom levels or not.
/// 
/// When this property is set to `YES`,  the map view consumes more memory and
/// provide a smoother user experience when zoom in/out.
/// 
/// The default value of this property is `YES`.
  bool get tileCacheEnabled {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_tileCacheEnabled);

  }


  /// Camera based tile level of detail controls
/// 
/// Minimum radius around the view point in unit of tiles in which the fine
/// grained zoom level tiles are always used when performing LOD
/// radius must be greater than 1 (At least 1 fine detailed tile is present)
/// A smaller radius value may improve performance at the cost of quality (tiles away from
/// camera use lower Zoom levels)
  double get tileLodMinRadius {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_tileLodMinRadius) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_tileLodMinRadius);

  }


  /// Camera based tile level of detail controls
/// 
/// Pitch angle in radians above which LOD calculation is performed
/// A smaller radius value may improve performance at the cost of quality
  double get tileLodPitchThreshold {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_tileLodPitchThreshold) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_tileLodPitchThreshold);

  }


  /// Camera based tile level of detail controls
/// 
/// Factor for the distance to the camera view point
/// A value larger than 1 increases the distance to the camera view point reducing LOD
/// Larger values may improve performance at the cost of quality (tiles away from camera
/// use lower Zoom levels)
  double get tileLodScale {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_tileLodScale) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_tileLodScale);

  }


  /// Camera based tile level of detail controls
/// 
/// Shift applied to the Zoom level during LOD calculation
/// A negative value shifts the Zoom level to a coarser level reducing quality but improving
/// performance A positive value shifts the Zoom level to a finer level increasing details but
/// negatively affecting performance A value of zero (default) does not apply any shift to the Zoom
/// level It is not recommended to change the default value unless performance is critical and the loss
/// of quality is acceptable. A value of -1 reduces the number of displayed tiles by a factor of 4 on
/// average It is recommended to first configure the pixelRatio before adjusting TileLodZoomShift.
  double get tileLodZoomShift {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_tileLodZoomShift) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_tileLodZoomShift);

  }


  /// Triggers a repaint of the map.
  void triggerRepaint() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_triggerRepaint);

  }


  /// Updates the position of the user location annotation view by retreiving the user's last
/// known location.
  void updateUserLocationAnnotationView() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateUserLocationAnnotationView);

  }


  /// Updates the position of the user location annotation view by retreiving the user's last
/// known location with a specified duration.
/// @param duration The duration to animate the change in seconds.
  void updateUserLocationAnnotationViewAnimatedWithDuration(double duration) {
_objc_msgSend_hwm8nu(object$.ref.pointer, _sel_updateUserLocationAnnotationViewAnimatedWithDuration_, duration);

  }


  /// Returns the annotation object indicating the users current location.
  MLNUserLocation? get userLocation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_userLocation);
    return $ret.address == 0 ? null : MLNUserLocation.fromPointer($ret, retain: true, release: true);
  }


  /// The vertical alignment of the user location annotation within the receiver. The
/// default value is ``MLNAnnotationVerticalAlignment/MLNAnnotationVerticalAlignmentCenter``.
/// 
/// Changing the value of this property updates the map view with an animated
/// transition. If you dont want to animate the change, use the
/// `-setUserLocationVerticalAlignment:animated:` method instead.
  int get userLocationVerticalAlignment {
    return _objc_msgSend_1m9zum6(object$.ref.pointer, _sel_userLocationVerticalAlignment);

  }


  /// The mode used to track the user location. The default value is
/// ``MLNUserTrackingMode/MLNUserTrackingModeNone``.
/// 
/// Changing the value of this property updates the map view with an animated
/// transition. If you dont want to animate the change, use the
/// `-setUserTrackingMode:animated:` method instead.
/// 
/// #### Related examples
/// - TODO: Customize the user location annotation and learn how to customize the
/// default user location annotation shown by ``MLNUserTrackingMode``.
  int get userTrackingMode {
    return _objc_msgSend_1swtepj(object$.ref.pointer, _sel_userTrackingMode);

  }


  /// Returns an ``MLNAnnotationView`` if the given annotation is currently associated
/// with a view, otherwise nil.
/// 
/// @param annotation The annotation associated with the view.
/// Annotation must conform to the ``MLNAnnotation`` protocol.
  MLNAnnotationView? viewForAnnotation(MLNAnnotation annotation) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_viewForAnnotation_, annotation.ref.pointer);
    return $ret.address == 0 ? null : MLNAnnotationView.fromPointer($ret, retain: true, release: true);
  }


  /// The complete list of annotations associated with the receiver that are
/// currently visible.
/// 
/// The objects in this array must adopt the ``MLNAnnotation`` protocol. If no
/// annotations are associated with the map view or if no annotations associated
/// with the map view are currently visible, the value of this property is `nil`.
  objc.NSArray? get visibleAnnotations {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_visibleAnnotations);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Returns the list of annotations associated with the receiver that intersect with
/// the given rectangle.
/// 
/// @param rect A rectangle expressed in the map views coordinate system.
/// @return An array of objects that adopt the ``MLNAnnotation`` protocol or `nil` if
/// no annotations associated with the map view are currently visible in the
/// rectangle.
  objc.NSArray? visibleAnnotationsInRect(objc.CGRect rect) {
    final $ret = _objc_msgSend_15yz4e6(object$.ref.pointer, _sel_visibleAnnotationsInRect_, rect);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// The coordinate bounds visible in the receivers viewport.
/// 
/// Changing the value of this property updates the receiver immediately. If you
/// want to animate the change, call `-setVisibleCoordinateBounds:animated:`
/// instead.
/// 
/// If a longitude is less than 180 degrees or greater than 180 degrees, the
/// visible bounds straddles the antimeridian or international date line. For
/// example, if both Tokyo and San Francisco are visible, the visible bounds might
/// extend from (35.68476, 220.24257) to (37.78428, 122.41310).
  MLNCoordinateBounds get visibleCoordinateBounds {
    final $ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants ? _objc_msgSend_ygoa6aStret($ptr, object$.ref.pointer, _sel_visibleCoordinateBounds) : $ptr.ref = _objc_msgSend_ygoa6a(object$.ref.pointer, _sel_visibleCoordinateBounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(
        $finalizable);

  }


  /// Returns an array of rendered map features that intersect with a given point.
/// 
/// This method may return features from any of the maps style layers. To restrict
/// the search to a particular layer or layers, use the
/// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:` method. For more
/// information about searching for map features, see that methods documentation.
/// 
/// @param point A point expressed in the map views coordinate system.
/// @return An array of objects conforming to the ``MLNFeature`` protocol that
/// represent features in the sources used by the current style.
/// 
/// #### Related examples
/// - TODO: Select a feature within a layer: to learn how to query an
/// ``MLNMapView`` object for visible ``MLNMapView`` objects.
  objc.NSArray visibleFeaturesAtPoint(objc.CGPoint point) {
    final $ret = _objc_msgSend_wgkxx2(object$.ref.pointer, _sel_visibleFeaturesAtPoint_, point);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an array of rendered map features that intersect with a given point,
/// restricted to the given style layers.
/// 
/// This method returns all the intersecting features from the specified layers. To
/// filter the returned features, use the
/// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:` method. For
/// more information about searching for map features, see that methods
/// documentation.
/// 
/// @param point A point expressed in the map views coordinate system.
/// @param styleLayerIdentifiers A set of strings that correspond to the names
/// of layers defined in the current style. Only the features contained in
/// these layers are included in the returned array.
/// @return An array of objects conforming to the ``MLNFeature`` protocol that
/// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesAtPoint$1(objc.CGPoint point, {objc.NSSet? inStyleLayersWithIdentifiers}) {
    final $ret = _objc_msgSend_u7nfz8(object$.ref.pointer, _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_, point, inStyleLayersWithIdentifiers?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an array of rendered map features that intersect with a given point,
/// restricted to the given style layers and filtered by the given predicate.
/// 
/// Each object in the returned array represents a feature rendered by the
/// current style and provides access to attributes specified by the relevant map
/// content sources. The returned array includes features loaded by
/// ``MLNShapeSource`` and ``MLNShapeSource`` objects but does not include
/// anything from ``MLNRasterTileSource`` objects, or from video or canvas sources,
/// which are unsupported by this SDK.
/// 
/// The returned features are drawn by a style layer in the current style. For
/// example, suppose the current style uses the
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets/">Mapbox Streets source</a>,
/// but none of the specified style layers includes features that have the `maki`
/// property set to `bus`. If you pass a point corresponding to the location of a
/// bus stop into this method, the bus stop feature does not appear in the
/// resulting array. On the other hand, if the style does include bus stops, an
/// ``MLNFeature`` object representing that bus stop is returned and its
/// `featureAttributes` dictionary has the `maki` key set to `bus` (along with
/// other attributes). The dictionary contains only the attributes provided by the
/// tile source; it does not include computed attribute values or rules about how
/// the feature is rendered by the current style.
/// 
/// The returned array is sorted by z-order, starting with the topmost rendered
/// feature and ending with the bottommost rendered feature. A feature that is
/// rendered multiple times due to wrapping across the antimeridian at low zoom
/// levels is included only once, subject to the caveat that follows.
/// 
/// Features come from tiled vector data or GeoJSON data that is converted to tiles
/// internally, so feature geometries are clipped at tile boundaries and features
/// may appear duplicated across tiles. For example, suppose the specified point
/// lies along a road that spans the screen. The resulting array includes those
/// parts of the road that lie within the map tile that contain the specified
/// point, even if the road extends into other tiles.
/// 
/// To find out the layer names in a particular style, view the style in
/// <a href="https://maplibre.org/maputnik">Maputnik</a>.
/// 
/// Only visible features are returned. To obtain features regardless of
/// visibility, use the
/// ``MLNVectorTileSource/featuresInSourceLayersWithIdentifiers:predicate:`` and
/// ``MLNShapeSource/featuresMatchingPredicate:`` methods on the relevant sources.
/// 
/// The returned features may also include features corresponding to annotations.
/// These features are not object-equal to the ``MLNAnnotation`` objects that were
/// originally added to the map. To query the map for annotations, use
/// `visibleAnnotations` or ``MLNMapView/visibleAnnotationsInRect:``.
/// 
/// 
/// @param point A point expressed in the map views coordinate system.
/// @param styleLayerIdentifiers A set of strings that correspond to the names of
/// layers defined in the current style. Only the features contained in these
/// layers are included in the returned array.
/// @param predicate A predicate to filter the returned features.
/// @return An array of objects conforming to the ``MLNFeature`` protocol that
/// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesAtPoint$2(objc.CGPoint point, {objc.NSSet? inStyleLayersWithIdentifiers,NSPredicate? predicate}) {
    final $ret = _objc_msgSend_19l1l5m(object$.ref.pointer, _sel_visibleFeaturesAtPoint_inStyleLayersWithIdentifiers_predicate_, point, inStyleLayersWithIdentifiers?.ref.pointer ?? ffi.nullptr, predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an array of rendered map features that intersect with the given
/// rectangle.
/// 
/// This method may return features from any of the maps style layers. To restrict
/// the search to a particular layer or layers, use the
/// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:` method. For more
/// information about searching for map features, see that methods documentation.
/// 
/// @param rect A rectangle expressed in the map views coordinate system.
/// @return An array of objects conforming to the ``MLNFeature`` protocol that
/// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect(objc.CGRect rect) {
    final $ret = _objc_msgSend_15yz4e6(object$.ref.pointer, _sel_visibleFeaturesInRect_, rect);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an array of rendered map features that intersect with the given
/// rectangle, restricted to the given style layers.
/// 
/// This method returns all the intersecting features from the specified layers. To
/// filter the returned features, use the
/// `-visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:` method. For
/// more information about searching for map features, see that methods
/// documentation.
/// 
/// @param rect A rectangle expressed in the map views coordinate system.
/// @param styleLayerIdentifiers A set of strings that correspond to the names of
/// layers defined in the current style. Only the features contained in these
/// layers are included in the returned array.
/// @return An array of objects conforming to the ``MLNFeature`` protocol that
/// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect$1(objc.CGRect rect, {objc.NSSet? inStyleLayersWithIdentifiers}) {
    final $ret = _objc_msgSend_gxusyk(object$.ref.pointer, _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_, rect, inStyleLayersWithIdentifiers?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an array of rendered map features that intersect with the given
/// rectangle, restricted to the given style layers and filtered by the given
/// predicate.
/// 
/// Each object in the returned array represents a feature rendered by the
/// current style and provides access to attributes specified by the relevant map
/// content sources. The returned array includes features loaded by
/// ``MLNShapeSource`` and ``MLNShapeSource`` objects but does not include
/// anything from ``MLNRasterTileSource`` objects, or from video or canvas sources,
/// which are unsupported by this SDK.
/// 
/// The returned features are drawn by a style layer in the current style. For
/// example, suppose the current style uses a particular source,
/// but none of the specified style layers includes features that have the `maki`
/// property set to `bus`. If you pass a rectangle containing the location of a bus
/// stop into this method, the bus stop feature does not appear in the resulting
/// array. On the other hand, if the style does include bus stops, an ``MLNFeature``
/// object representing that bus stop is returned and its `featureAttributes`
/// dictionary has the `maki` key set to `bus` (along with other attributes). The
/// dictionary contains only the attributes provided by the tile source; it does
/// not include computed attribute values or rules about how the feature is
/// rendered by the current style.
/// 
/// The returned array is sorted by z-order, starting with the topmost rendered
/// feature and ending with the bottommost rendered feature. A feature that is
/// rendered multiple times due to wrapping across the antimeridian at low zoom
/// levels is included only once, subject to the caveat that follows.
/// 
/// Features come from tiled vector data or GeoJSON data that is converted to tiles
/// internally, so feature geometries are clipped at tile boundaries and features
/// may appear duplicated across tiles. For example, suppose the specified
/// rectangle intersects with a road that spans the screen. The resulting array
/// includes those parts of the road that lie within the map tiles covering the
/// specified rectangle, even if the road extends into other tiles. The portion of
/// the road within each map tile is included individually.
/// 
/// To find out the layer names in a particular style, view the style in
/// <a href="https://maplibre.org/maputnik">Maputnik</a>.
/// 
/// Only visible features are returned. To obtain features regardless of
/// visibility, use the
/// ``MLNVectorTileSource/featuresInSourceLayersWithIdentifiers:predicate:`` and
/// ``MLNShapeSource/featuresMatchingPredicate:`` methods on the relevant sources.
/// 
/// @param rect A rectangle expressed in the map views coordinate system.
/// @param styleLayerIdentifiers A set of strings that correspond to the names of
/// layers defined in the current style. Only the features contained in these
/// layers are included in the returned array.
/// @param predicate A predicate to filter the returned features.
/// @return An array of objects conforming to the ``MLNFeature`` protocol that
/// represent features in the sources used by the current style.
  objc.NSArray visibleFeaturesInRect$2(objc.CGRect rect, {objc.NSSet? inStyleLayersWithIdentifiers,NSPredicate? predicate}) {
    final $ret = _objc_msgSend_1o8sa9u(object$.ref.pointer, _sel_visibleFeaturesInRect_inStyleLayersWithIdentifiers_predicate_, rect, inStyleLayersWithIdentifiers?.ref.pointer ?? ffi.nullptr, predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// The zoom level of the receiver.
/// 
/// In addition to affecting the visual size and detail of features on the map,
/// the zoom level affects the size of the vector tiles that are loaded. At zoom
/// level 0, each tile covers the entire world map; at zoom level 1, it covers 
/// of the world; at zoom level 2, <sup>1</sup><sub>16</sub> of the world, and
/// so on.
/// 
/// Changing the value of this property updates the map view immediately. If you
/// want to animate the change, use the `-setZoomLevel:animated:` method instead.
  double get zoomLevel {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_zoomLevel) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_zoomLevel);

  }

}

late final _protocol_MLNCluster = objc.getProtocol("MLNCluster");
late final _sel_clusterIdentifier = objc.registerName("clusterIdentifier");

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSUInteger_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunction(int Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static int _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<int Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline , 0).cast();
  static int _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline , 0).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSUInteger_ffiVoid$CallExtension on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_clusterPointCount = objc.registerName("clusterPointCount");

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSDictionary_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.NSDictionary Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSDictionary_ffiVoid$CallExtension on objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)> {
  objc.NSDictionary call(ffi.Pointer<ffi.Void> arg0) =>objc.NSDictionary.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.NSDictionary ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSDictionary.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> listener(void Function(ffi.Pointer<ffi.Void> , objc.NSDictionary ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSDictionary.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.NSDictionary ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSDictionary.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSDictionary.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSDictionary$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSDictionary arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_attributeForKey_ = objc.registerName("attributeForKey:");
late final _sel_geoJSONDictionary = objc.registerName("geoJSONDictionary");
late final _protocol_MLNFeature = objc.getProtocol("MLNFeature");

/// The ``MLNFeature``  protocol is used to provide details about geographic features
/// contained in an ``MLNShapeSource`` or ``MLNVectorTileSource`` object. Each concrete
/// subclass of ``MLNShape`` in turn has a subclass that conforms to this protocol. A
/// feature object associates a shape with an optional identifier and attributes.
/// 
/// You can add custom data to display on the map by creating feature objects and
/// adding them to an ``MLNShapeSource`` using the
/// ``MLNShapeSource/initWithIdentifier:shape:options:`` method or
/// ``MLNShapeSource/shape`` property.
/// 
/// In addition to adding data to the map, you can also extract data from the map:
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods return feature
/// objects that correspond to features in the source. This enables you to inspect
/// the properties of features in vector tiles loaded by ``MLNVectorTileSource``
/// objects. You also reuse these feature objects as overlay annotations.
/// 
/// While it is possible to add ``MLNFeature``-conforming objects to the map as
/// annotations using ``MLNMapView/addAnnotations:`` and related methods, doing so
/// has trade-offs:
/// 
/// - Features added as annotations will not have ``identifier`` or ``attributes``
/// properties when used with feature querying.
/// 
/// - Features added as annotations become interactive. Taps and selection can be
/// handled in ``MLNMapViewDelegate/mapView:didSelectAnnotation:``.
extension type MLNFeature._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, MLNAnnotation {
  /// Constructs a [MLNFeature] that points to the same underlying object as [other].
  MLNFeature.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNFeature] that wraps the given raw object pointer.
  MLNFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNFeature].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNFeature);
  }
}

extension MLNFeature$Methods on MLNFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

  interface class MLNFeature$Builder {
  
    /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_MLNFeature.cast());

  /// Builds an object that implements the MLNFeature protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNFeature implement({required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNFeature');
        MLNFeature$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNFeature$Builder.attributes.implement(builder, attributes);    MLNFeature$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNFeature$Builder.identifier.implement(builder, identifier);    MLNFeature$Builder.setAttributes_.implement(builder, setAttributes_);    MLNFeature$Builder.setIdentifier_.implement(builder, setIdentifier_);
    builder.addProtocol($protocol);
    return MLNFeature.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNFeature protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder, {required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
        MLNFeature$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNFeature$Builder.attributes.implement(builder, attributes);    MLNFeature$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNFeature$Builder.identifier.implement(builder, identifier);    MLNFeature$Builder.setAttributes_.implement(builder, setAttributes_);    MLNFeature$Builder.setIdentifier_.implement(builder, setIdentifier_);
    builder.addProtocol($protocol);
  }

    /// Builds an object that implements the MLNFeature protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNFeature implementAsListener({required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNFeature');
        MLNFeature$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNFeature$Builder.attributes.implement(builder, attributes);    MLNFeature$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNFeature$Builder.identifier.implement(builder, identifier);    MLNFeature$Builder.setAttributes_.implementAsListener(builder, setAttributes_);    MLNFeature$Builder.setIdentifier_.implementAsListener(builder, setIdentifier_);
    builder.addProtocol($protocol);
    return MLNFeature.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNFeature protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder, {required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
        MLNFeature$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNFeature$Builder.attributes.implement(builder, attributes);    MLNFeature$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNFeature$Builder.identifier.implement(builder, identifier);    MLNFeature$Builder.setAttributes_.implementAsListener(builder, setAttributes_);    MLNFeature$Builder.setIdentifier_.implementAsListener(builder, setIdentifier_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the MLNFeature protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNFeature implementAsBlocking({required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNFeature');
        MLNFeature$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNFeature$Builder.attributes.implement(builder, attributes);    MLNFeature$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNFeature$Builder.identifier.implement(builder, identifier);    MLNFeature$Builder.setAttributes_.implementAsBlocking(builder, setAttributes_);    MLNFeature$Builder.setIdentifier_.implementAsBlocking(builder, setIdentifier_);
    builder.addProtocol($protocol);
    return MLNFeature.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNFeature protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder, {required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
        MLNFeature$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNFeature$Builder.attributes.implement(builder, attributes);    MLNFeature$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNFeature$Builder.identifier.implement(builder, identifier);    MLNFeature$Builder.setAttributes_.implementAsBlocking(builder, setAttributes_);    MLNFeature$Builder.setIdentifier_.implementAsBlocking(builder, setIdentifier_);
    builder.addProtocol($protocol);
  }

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
static final attributeForKey_ = objc.ObjCProtocolMethod<objc.ObjCObject? Function(objc.NSString )>(
      _protocol_MLNFeature,
      _sel_attributeForKey_,
      ffi.Native.addressOf<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>>(_NativeLibrary_protocolTrampoline_xr62hr).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNFeature,
          _sel_attributeForKey_,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.ObjCObject? Function(objc.NSString ) func) => ObjCBlock_objcObjCObjectImpl_ffiVoid_UIActivityItemsConfigurationMetadataKey.fromFunction((ffi.Pointer<ffi.Void> _, objc.NSString arg1) => func(arg1)),
      
    );
/// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
static final attributes = objc.ObjCProtocolMethod<objc.NSDictionary Function()>(
      _protocol_MLNFeature,
      _sel_attributes,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1mbt9g9).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNFeature,
          _sel_attributes,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.NSDictionary Function() func) => ObjCBlock_NSDictionary_ffiVoid.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );
/// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
static final geoJSONDictionary = objc.ObjCProtocolMethod<objc.NSDictionary Function()>(
      _protocol_MLNFeature,
      _sel_geoJSONDictionary,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1mbt9g9).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNFeature,
          _sel_geoJSONDictionary,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.NSDictionary Function() func) => ObjCBlock_NSDictionary_ffiVoid.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );
/// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
static final identifier = objc.ObjCProtocolMethod<objc.ObjCObject? Function()>(
      _protocol_MLNFeature,
      _sel_identifier,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1mbt9g9).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNFeature,
          _sel_identifier,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.ObjCObject? Function() func) => ObjCBlock_objcObjCObjectImpl_ffiVoid$1.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );
/// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
static final setAttributes_ = objc.ObjCProtocolListenableMethod<void Function(objc.NSDictionary )>(
      _protocol_MLNFeature,
      _sel_setAttributes_,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>>(_NativeLibrary_protocolTrampoline_18v1jvf).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNFeature,
          _sel_setAttributes_,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (void Function(objc.NSDictionary ) func) => ObjCBlock_ffiVoid_ffiVoid_NSDictionary.fromFunction((ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
          (void Function(objc.NSDictionary ) func) => ObjCBlock_ffiVoid_ffiVoid_NSDictionary.listener((ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
    (void Function(objc.NSDictionary ) func) => ObjCBlock_ffiVoid_ffiVoid_NSDictionary.blocking((ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),

    );
/// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
static final setIdentifier_ = objc.ObjCProtocolListenableMethod<void Function(objc.ObjCObject? )>(
      _protocol_MLNFeature,
      _sel_setIdentifier_,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>>(_NativeLibrary_protocolTrampoline_18v1jvf).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNFeature,
          _sel_setIdentifier_,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (void Function(objc.ObjCObject? ) func) => ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl.fromFunction((ffi.Pointer<ffi.Void> _, objc.ObjCObject? arg1) => func(arg1)),
          (void Function(objc.ObjCObject? ) func) => ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl.listener((ffi.Pointer<ffi.Void> _, objc.ObjCObject? arg1) => func(arg1)),
    (void Function(objc.ObjCObject? ) func) => ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl.blocking((ffi.Pointer<ffi.Void> _, objc.ObjCObject? arg1) => func(arg1)),

    );

}

/// A protocol that feature subclasses (i.e. those already conforming to
/// the ``MLNFeature`` protocol) conform to if they represent clusters.
/// 
/// Currently the only class that conforms to ``MLNCluster`` is
/// ``MLNPointFeatureCluster`` (a subclass of ``MLNPointFeatureCluster``).
/// 
/// To check if a feature is a cluster, check conformity to ``MLNCluster``, for
/// example:
/// 
/// ```swift
/// let shape = try! MLNShape(data: clusterShapeData, encoding: String.Encoding.utf8.rawValue)
/// 
/// guard let pointFeature = shape as? MLNPointFeature else {
/// throw ExampleError.unexpectedFeatureType
/// }
/// 
/// // Check for cluster conformance
/// guard let cluster = pointFeature as? MLNCluster else {
/// throw ExampleError.featureIsNotACluster
/// }
/// 
/// // Currently the only supported class that conforms to ``MLNCluster`` is
/// // ``MLNPointFeatureCluster``
/// guard cluster is MLNPointFeatureCluster else {
/// throw ExampleError.unexpectedFeatureType
/// }
/// ```
extension type MLNCluster._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, MLNFeature {
  /// Constructs a [MLNCluster] that points to the same underlying object as [other].
  MLNCluster.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNCluster] that wraps the given raw object pointer.
  MLNCluster.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNCluster].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNCluster);
  }
}

extension MLNCluster$Methods on MLNCluster {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// The identifier for the cluster.
  int get clusterIdentifier {
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_clusterIdentifier);

  }


  /// The number of points within this cluster
  int get clusterPointCount {
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_clusterPointCount);

  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

  interface class MLNCluster$Builder {
  
    /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_MLNCluster.cast());

  /// Builds an object that implements the MLNCluster protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNCluster implement({required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required int Function() clusterIdentifier, required int Function() clusterPointCount, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNCluster');
        MLNCluster$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNCluster$Builder.attributes.implement(builder, attributes);    MLNCluster$Builder.clusterIdentifier.implement(builder, clusterIdentifier);    MLNCluster$Builder.clusterPointCount.implement(builder, clusterPointCount);    MLNCluster$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNCluster$Builder.identifier.implement(builder, identifier);    MLNCluster$Builder.setAttributes_.implement(builder, setAttributes_);    MLNCluster$Builder.setIdentifier_.implement(builder, setIdentifier_);
    builder.addProtocol($protocol);
    return MLNCluster.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNCluster protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder, {required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required int Function() clusterIdentifier, required int Function() clusterPointCount, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
        MLNCluster$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNCluster$Builder.attributes.implement(builder, attributes);    MLNCluster$Builder.clusterIdentifier.implement(builder, clusterIdentifier);    MLNCluster$Builder.clusterPointCount.implement(builder, clusterPointCount);    MLNCluster$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNCluster$Builder.identifier.implement(builder, identifier);    MLNCluster$Builder.setAttributes_.implement(builder, setAttributes_);    MLNCluster$Builder.setIdentifier_.implement(builder, setIdentifier_);
    builder.addProtocol($protocol);
  }

    /// Builds an object that implements the MLNCluster protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNCluster implementAsListener({required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required int Function() clusterIdentifier, required int Function() clusterPointCount, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNCluster');
        MLNCluster$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNCluster$Builder.attributes.implement(builder, attributes);    MLNCluster$Builder.clusterIdentifier.implement(builder, clusterIdentifier);    MLNCluster$Builder.clusterPointCount.implement(builder, clusterPointCount);    MLNCluster$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNCluster$Builder.identifier.implement(builder, identifier);    MLNCluster$Builder.setAttributes_.implementAsListener(builder, setAttributes_);    MLNCluster$Builder.setIdentifier_.implementAsListener(builder, setIdentifier_);
    builder.addProtocol($protocol);
    return MLNCluster.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNCluster protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder, {required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required int Function() clusterIdentifier, required int Function() clusterPointCount, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
        MLNCluster$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNCluster$Builder.attributes.implement(builder, attributes);    MLNCluster$Builder.clusterIdentifier.implement(builder, clusterIdentifier);    MLNCluster$Builder.clusterPointCount.implement(builder, clusterPointCount);    MLNCluster$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNCluster$Builder.identifier.implement(builder, identifier);    MLNCluster$Builder.setAttributes_.implementAsListener(builder, setAttributes_);    MLNCluster$Builder.setIdentifier_.implementAsListener(builder, setIdentifier_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the MLNCluster protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNCluster implementAsBlocking({required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required int Function() clusterIdentifier, required int Function() clusterPointCount, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNCluster');
        MLNCluster$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNCluster$Builder.attributes.implement(builder, attributes);    MLNCluster$Builder.clusterIdentifier.implement(builder, clusterIdentifier);    MLNCluster$Builder.clusterPointCount.implement(builder, clusterPointCount);    MLNCluster$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNCluster$Builder.identifier.implement(builder, identifier);    MLNCluster$Builder.setAttributes_.implementAsBlocking(builder, setAttributes_);    MLNCluster$Builder.setIdentifier_.implementAsBlocking(builder, setIdentifier_);
    builder.addProtocol($protocol);
    return MLNCluster.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNCluster protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder, {required objc.ObjCObject? Function(objc.NSString ) attributeForKey_, required objc.NSDictionary Function() attributes, required int Function() clusterIdentifier, required int Function() clusterPointCount, required objc.NSDictionary Function() geoJSONDictionary, required objc.ObjCObject? Function() identifier, required void Function(objc.NSDictionary ) setAttributes_, required void Function(objc.ObjCObject? ) setIdentifier_, bool $keepIsolateAlive = true}) {
        MLNCluster$Builder.attributeForKey_.implement(builder, attributeForKey_);    MLNCluster$Builder.attributes.implement(builder, attributes);    MLNCluster$Builder.clusterIdentifier.implement(builder, clusterIdentifier);    MLNCluster$Builder.clusterPointCount.implement(builder, clusterPointCount);    MLNCluster$Builder.geoJSONDictionary.implement(builder, geoJSONDictionary);    MLNCluster$Builder.identifier.implement(builder, identifier);    MLNCluster$Builder.setAttributes_.implementAsBlocking(builder, setAttributes_);    MLNCluster$Builder.setIdentifier_.implementAsBlocking(builder, setIdentifier_);
    builder.addProtocol($protocol);
  }

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
static final attributeForKey_ = objc.ObjCProtocolMethod<objc.ObjCObject? Function(objc.NSString )>(
      _protocol_MLNCluster,
      _sel_attributeForKey_,
      ffi.Native.addressOf<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>>(_NativeLibrary_protocolTrampoline_xr62hr).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNCluster,
          _sel_attributeForKey_,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.ObjCObject? Function(objc.NSString ) func) => ObjCBlock_objcObjCObjectImpl_ffiVoid_UIActivityItemsConfigurationMetadataKey.fromFunction((ffi.Pointer<ffi.Void> _, objc.NSString arg1) => func(arg1)),
      
    );
/// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
static final attributes = objc.ObjCProtocolMethod<objc.NSDictionary Function()>(
      _protocol_MLNCluster,
      _sel_attributes,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1mbt9g9).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNCluster,
          _sel_attributes,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.NSDictionary Function() func) => ObjCBlock_NSDictionary_ffiVoid.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );
/// The identifier for the cluster.
static final clusterIdentifier = objc.ObjCProtocolMethod<int Function()>(
      _protocol_MLNCluster,
      _sel_clusterIdentifier,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1ckyi24).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNCluster,
          _sel_clusterIdentifier,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (int Function() func) => ObjCBlock_NSUInteger_ffiVoid.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );
/// The number of points within this cluster
static final clusterPointCount = objc.ObjCProtocolMethod<int Function()>(
      _protocol_MLNCluster,
      _sel_clusterPointCount,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1ckyi24).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNCluster,
          _sel_clusterPointCount,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (int Function() func) => ObjCBlock_NSUInteger_ffiVoid.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );
/// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
static final geoJSONDictionary = objc.ObjCProtocolMethod<objc.NSDictionary Function()>(
      _protocol_MLNCluster,
      _sel_geoJSONDictionary,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1mbt9g9).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNCluster,
          _sel_geoJSONDictionary,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.NSDictionary Function() func) => ObjCBlock_NSDictionary_ffiVoid.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );
/// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
static final identifier = objc.ObjCProtocolMethod<objc.ObjCObject? Function()>(
      _protocol_MLNCluster,
      _sel_identifier,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>>(_NativeLibrary_protocolTrampoline_1mbt9g9).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNCluster,
          _sel_identifier,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.ObjCObject? Function() func) => ObjCBlock_objcObjCObjectImpl_ffiVoid$1.fromFunction((ffi.Pointer<ffi.Void> _, ) => func()),
      
    );
/// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
static final setAttributes_ = objc.ObjCProtocolListenableMethod<void Function(objc.NSDictionary )>(
      _protocol_MLNCluster,
      _sel_setAttributes_,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>>(_NativeLibrary_protocolTrampoline_18v1jvf).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNCluster,
          _sel_setAttributes_,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (void Function(objc.NSDictionary ) func) => ObjCBlock_ffiVoid_ffiVoid_NSDictionary.fromFunction((ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
          (void Function(objc.NSDictionary ) func) => ObjCBlock_ffiVoid_ffiVoid_NSDictionary.listener((ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),
    (void Function(objc.NSDictionary ) func) => ObjCBlock_ffiVoid_ffiVoid_NSDictionary.blocking((ffi.Pointer<ffi.Void> _, objc.NSDictionary arg1) => func(arg1)),

    );
/// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
static final setIdentifier_ = objc.ObjCProtocolListenableMethod<void Function(objc.ObjCObject? )>(
      _protocol_MLNCluster,
      _sel_setIdentifier_,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>>(_NativeLibrary_protocolTrampoline_18v1jvf).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNCluster,
          _sel_setIdentifier_,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (void Function(objc.ObjCObject? ) func) => ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl.fromFunction((ffi.Pointer<ffi.Void> _, objc.ObjCObject? arg1) => func(arg1)),
          (void Function(objc.ObjCObject? ) func) => ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl.listener((ffi.Pointer<ffi.Void> _, objc.ObjCObject? arg1) => func(arg1)),
    (void Function(objc.ObjCObject? ) func) => ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl.blocking((ffi.Pointer<ffi.Void> _, objc.ObjCObject? arg1) => func(arg1)),

    );

}
late final _class_MLNPointAnnotation = objc.getClass("MLNPointAnnotation");
late final _sel_coordinate = objc.registerName("coordinate");
late final _sel_setCoordinate_ = objc.registerName("setCoordinate:");

/// An ``MLNPointAnnotation`` object represents a one-dimensional shape located at a
/// single geographical coordinate. Depending on how it is used, an
/// ``MLNPointAnnotation`` object is known as a point annotation or point shape. For
/// example, you could use a point shape to represent a city at low zoom levels, an
/// address at high zoom levels, or the location of a long press gesture.
/// 
/// You can add point shapes to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``s or
/// ``MLNVectorTileSource``s point shapes collectively using an ``MLNVectorTileSource`` or
/// ``MLNSymbolStyleLayer`` object.
/// 
/// For more interactivity, add a selectable point annotation to a map view using
/// the ``MLNMapView/addAnnotation:`` method. Alternatively, define your own model
/// class that conforms to the ``MLNAnnotation`` protocol. Configure a point
/// annotations appearance using
/// ``MLNMapViewDelegate/mapView:imageForAnnotation:`` or
/// ``MLNMapViewDelegate/mapView:viewForAnnotation:`` (iOS only). A point
/// annotations ``MLNShape/title`` and ``MLNShape/title`` properties define the
/// default content of the annotations callout (on iOS) or popover (on macOS).
/// 
/// To group multiple related points together in one shape, use an
/// ``MLNPointCollection`` or ``MLNPointCollection`` object. To access
/// a points attributes, use an ``MLNPointFeature`` object.
/// 
/// A point shape is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.2">Point</a> geometry
/// in GeoJSON.
/// 
/// #### Related examples
/// TODO: Mark a place on the map with an annotation
/// TODO: Mark a place on the map with an image
/// TODO: Default callout usage
/// Learn how to add ``MLNPointAnnotation`` objects to your map.
extension type MLNPointAnnotation._(objc.ObjCObject object$) implements objc.ObjCObject,MLNShape {
  /// Constructs a [MLNPointAnnotation] that points to the same underlying object as [other].
  MLNPointAnnotation.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPointAnnotation] that wraps the given raw object pointer.
  MLNPointAnnotation.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPointAnnotation].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointAnnotation);

  /// alloc
  static MLNPointAnnotation alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointAnnotation, _sel_alloc);
    return MLNPointAnnotation.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPointAnnotation allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPointAnnotation, _sel_allocWithZone_, zone);
    return MLNPointAnnotation.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPointAnnotation new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointAnnotation, _sel_new);
    return MLNPointAnnotation.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPointAnnotation, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPointAnnotation, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPointAnnotation constructed with the default `new` method.
  MLNPointAnnotation() : this.as(new$().object$);

}

extension MLNPointAnnotation$Methods on MLNPointAnnotation {

  /// The coordinate point of the shape, specified as a latitude and longitude.
  CLLocationCoordinate2D get coordinate {
    final $ptr = pkg_ffi.calloc<CLLocationCoordinate2D>();
    objc.useMsgSendVariants ? _objc_msgSend_18o5nokStret($ptr, object$.ref.pointer, _sel_coordinate) : $ptr.ref = _objc_msgSend_18o5nok(object$.ref.pointer, _sel_coordinate);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CLLocationCoordinate2D>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CLLocationCoordinate2D>(
        $finalizable);

  }


  /// init
  MLNPointAnnotation init() {
  objc.checkOsVersionInternal('MLNPointAnnotation.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointAnnotation.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPointAnnotation? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPointAnnotation.fromPointer($ret, retain: false, release: true);
  }


  /// The coordinate point of the shape, specified as a latitude and longitude.
  set coordinate(CLLocationCoordinate2D value) {
_objc_msgSend_1zv0am(object$.ref.pointer, _sel_setCoordinate_, value);

  }

}

late final _class_MLNPointCollection = objc.getClass("MLNPointCollection");
late final _sel_pointCollectionWithCoordinates_count_ = objc.registerName("pointCollectionWithCoordinates:count:");
final _objc_msgSend_i90tul = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , int )>();
late final _sel_coordinates = objc.registerName("coordinates");
final _objc_msgSend_k56nhe = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<CLLocationCoordinate2D> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<CLLocationCoordinate2D> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_pointCount = objc.registerName("pointCount");
late final _sel_getCoordinates_range_ = objc.registerName("getCoordinates:range:");
final _objc_msgSend_peohs4 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , objc.NSRange )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , objc.NSRange )>();

/// An ``MLNPointCollection`` object represents a shape consisting of one or more
/// disconnected vertices, specified as `CLLocationCoordinate2D` instances. The
/// points in the collection may be related but are not connected spatially. For
/// example, you could use a point collection to represent all the trees in an
/// orchard.
/// 
/// You can add point collections to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``s or
/// ``MLNVectorTileSource``s point collections collectively using an
/// ``MLNCircleStyleLayer`` or ``MLNCircleStyleLayer`` object. To access a point
/// collections attributes, use an ``MLNPointCollectionFeature`` object.
/// 
/// You cannot add an ``MLNPointCollection`` object directly to a map view as an
/// annotation. However, you can create individual ``MLNPointAnnotation`` objects
/// from the `coordinates` array and add those annotation objects to the map view
/// using the ``MLNMapView/addAnnotations:`` method.
/// 
/// A point collection is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.3">MultiPoint</a>
/// geometry in GeoJSON. Do not confuse ``MLNPointCollection`` with ``MLNPointCollection``,
/// the abstract superclass of ``MLNPolyline`` and ``MLNPolyline``.
extension type MLNPointCollection._(objc.ObjCObject object$) implements objc.ObjCObject,MLNShape,MLNOverlay {
  /// Constructs a [MLNPointCollection] that points to the same underlying object as [other].
  MLNPointCollection.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPointCollection] that wraps the given raw object pointer.
  MLNPointCollection.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPointCollection].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointCollection);

  /// alloc
  static MLNPointCollection alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointCollection, _sel_alloc);
    return MLNPointCollection.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPointCollection allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPointCollection, _sel_allocWithZone_, zone);
    return MLNPointCollection.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPointCollection new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointCollection, _sel_new);
    return MLNPointCollection.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns a ``MLNPointCollection`` object from the specified set of
/// coordinates.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the new object.
/// @param count The number of items in the `coords` array.
/// @return A new point collection object.
  static MLNPointCollection pointCollectionWithCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count}) {
    final $ret = _objc_msgSend_i90tul(_class_MLNPointCollection, _sel_pointCollectionWithCoordinates_count_, coords, count);
    return MLNPointCollection.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPointCollection, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPointCollection, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPointCollection constructed with the default `new` method.
  MLNPointCollection() : this.as(new$().object$);

}

extension MLNPointCollection$Methods on MLNPointCollection {

  /// The array of coordinates associated with the shape.
  ffi.Pointer<CLLocationCoordinate2D> get coordinates {
    return _objc_msgSend_k56nhe(object$.ref.pointer, _sel_coordinates);

  }


  /// Retrieves one or more coordinates associated with the shape.
/// 
/// @param coords On input, you must provide a C array of structures large enough
/// to hold the desired number of coordinates. On output, this structure
/// contains the requested coordinate data.
/// @param range The range of points you want. The `location` field indicates the
/// first point you are requesting, with `0` being the first point, `1` being
/// the second point, and so on. The `length` field indicates the number of
/// points you want. The array in _`coords`_ must be large enough to accommodate
/// the number of requested coordinates.
  void getCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required objc.NSRange range}) {
_objc_msgSend_peohs4(object$.ref.pointer, _sel_getCoordinates_range_, coords, range);

  }


  /// init
  MLNPointCollection init() {
  objc.checkOsVersionInternal('MLNPointCollection.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointCollection.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPointCollection? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPointCollection.fromPointer($ret, retain: false, release: true);
  }


  /// The number of coordinates associated with the shape.
  int get pointCount {
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_pointCount);

  }

}

late final _class_MLNMultiPoint = objc.getClass("MLNMultiPoint");
late final _sel_setCoordinates_count_ = objc.registerName("setCoordinates:count:");
final _objc_msgSend_xee6m1 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , int )>();
late final _sel_insertCoordinates_count_atIndex_ = objc.registerName("insertCoordinates:count:atIndex:");
final _objc_msgSend_1vf050y = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , ffi.UnsignedLong , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , int , int )>();
late final _sel_appendCoordinates_count_ = objc.registerName("appendCoordinates:count:");
late final _sel_replaceCoordinatesInRange_withCoordinates_ = objc.registerName("replaceCoordinatesInRange:withCoordinates:");
final _objc_msgSend_1krtrwi = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<CLLocationCoordinate2D> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<CLLocationCoordinate2D> )>();
late final _sel_replaceCoordinatesInRange_withCoordinates_count_ = objc.registerName("replaceCoordinatesInRange:withCoordinates:count:");
final _objc_msgSend_61jbin = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<CLLocationCoordinate2D> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<CLLocationCoordinate2D> , int )>();
late final _sel_removeCoordinatesInRange_ = objc.registerName("removeCoordinatesInRange:");
final _objc_msgSend_1e3pm0z = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange )>();

/// The ``MLNMultiPoint`` class is an abstract superclass used to define shapes
/// composed of multiple vertices.
/// 
/// Create instances of ``MLNPolyline`` or ``MLNPolyline`` in order to use
/// properties of ``MLNMultiPoint``. Do not create instances of ``MLNMultiPoint``
/// directly and do not create your own subclasses of this class. You can use
/// the method and properties of this class to access information about the
/// vertices of the line or polygon.
/// 
/// Do not confuse ``MLNMultiPoint`` with ``MLNMultiPoint``, which represents a
/// collection of related but disconnected points.
extension type MLNMultiPoint._(objc.ObjCObject object$) implements objc.ObjCObject,MLNShape {
  /// Constructs a [MLNMultiPoint] that points to the same underlying object as [other].
  MLNMultiPoint.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMultiPoint] that wraps the given raw object pointer.
  MLNMultiPoint.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMultiPoint].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPoint);

  /// alloc
  static MLNMultiPoint alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPoint, _sel_alloc);
    return MLNMultiPoint.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMultiPoint allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMultiPoint, _sel_allocWithZone_, zone);
    return MLNMultiPoint.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNMultiPoint new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPoint, _sel_new);
    return MLNMultiPoint.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNMultiPoint, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNMultiPoint, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNMultiPoint constructed with the default `new` method.
  MLNMultiPoint() : this.as(new$().object$);

}

extension MLNMultiPoint$Methods on MLNMultiPoint {

  /// Appends the given vertices to the shape.
/// 
/// If the shape is currently visible on the map as an annotation, it is redrawn
/// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
/// explicitly set the ``MLNShapeSource/shape`` property in order for any style
/// layers that use the source to be redrawn.
/// 
/// @param coords The array of coordinates to add to the shape. The data in this
/// array is copied to the shapes `coordinates` property.
/// @param count The number of items in the `coords` array.
  void appendCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count}) {
_objc_msgSend_xee6m1(object$.ref.pointer, _sel_appendCoordinates_count_, coords, count);

  }


  /// The array of vertices associated with the shape.
/// 
/// This C array is a pointer to a structure inside the multipoint object, which
/// may have a lifetime shorter than the multipoint object and will certainly not
/// have a longer lifetime. Therefore, you should copy the C array if it needs to
/// be stored outside of the memory context in which you use this property.
  ffi.Pointer<CLLocationCoordinate2D> get coordinates {
    return _objc_msgSend_k56nhe(object$.ref.pointer, _sel_coordinates);

  }


  /// Retrieves the vertices of part of the shape.
/// 
/// @param coords On input, you must provide a C array of `CLLocationCoordinate2D`
/// structures large enough to hold the desired number of coordinates. On
/// output, this structure contains the requested coordinate data.
/// @param range The range of vertices you want. The `location` field indicates
/// the first vertex you are requesting, with `0` being the first vertex, `1`
/// being the second vertex, and so on. The `length` field indicates the number
/// of vertices you want. The array in `coords` must be large enough to
/// accommodate the number of requested coordinates.
  void getCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required objc.NSRange range}) {
_objc_msgSend_peohs4(object$.ref.pointer, _sel_getCoordinates_range_, coords, range);

  }


  /// init
  MLNMultiPoint init() {
  objc.checkOsVersionInternal('MLNMultiPoint.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPoint.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNMultiPoint? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNMultiPoint.fromPointer($ret, retain: false, release: true);
  }


  /// Inserts the given vertices into the shape.
/// 
/// If the shape is currently visible on the map as an annotation, it is redrawn
/// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
/// explicitly set the ``MLNShapeSource/shape`` property in order for any style
/// layers that use the source to be redrawn.
/// 
/// @param coords The array of coordinates to insert into the shape. The data in
/// this array is copied to the shapes `coordinates` property.
/// @param count The number of items in the `coords` array.
/// @param index The zero-based index at which the first coordinate in `coords`
/// will appear in the `coordinates` property.
  void insertCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count,required int atIndex}) {
_objc_msgSend_1vf050y(object$.ref.pointer, _sel_insertCoordinates_count_atIndex_, coords, count, atIndex);

  }


  /// The number of vertices in the shape.
  int get pointCount {
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_pointCount);

  }


  /// Removes the vertices at the given range from the shape.
/// 
/// If the shape is currently visible on the map as an annotation, it is redrawn
/// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
/// explicitly set the ``MLNShapeSource/shape`` property in order for any style
/// layers that use the source to be redrawn.
/// 
/// If `range` extends beyond the shapes `coordinates` property, an
/// `NSRangeException` is raised.
/// 
/// @param range The range of vertices to remove. The `location` field indicates
/// the first vertex you are removing, with `0` being the first vertex, `1`
/// being the second vertex, and so on. The `length` field indicates the number
/// of vertices to remove.
  void removeCoordinatesInRange(objc.NSRange range) {
_objc_msgSend_1e3pm0z(object$.ref.pointer, _sel_removeCoordinatesInRange_, range);

  }


  /// Replaces the vertices at the given range in the shape with the same number of
/// vertices from a given C array.
/// 
/// If the shape is currently visible on the map as an annotation, it is redrawn
/// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
/// explicitly set the ``MLNShapeSource/shape`` property in order for any style
/// layers that use the source to be redrawn.
/// 
/// The number of coordinates in `coords` must be equal to the length of `range`.
/// If you want to insert or delete one or more vertices, use the
/// `-replaceCoordinatesInRange:withCoordinates:count:` method.
/// 
/// If `range` extends beyond the shapes `coordinates` property, an
/// `NSRangeException` is raised. If you want to append new vertices to the shape,
/// use the `-appendCoordinates:count:` method.
/// 
/// @param range The range of vertices to replace. The `location` field indicates
/// the first vertex you are replacing, with `0` being the first vertex, `1`
/// being the second vertex, and so on. The `length` field indicates the number
/// of vertices to replace.
/// @param coords The array of coordinates defining part of the shape. The data in
/// this array is copied to the shapes `coordinates` property.
  void replaceCoordinatesInRange(objc.NSRange range, {required ffi.Pointer<CLLocationCoordinate2D> withCoordinates}) {
_objc_msgSend_1krtrwi(object$.ref.pointer, _sel_replaceCoordinatesInRange_withCoordinates_, range, withCoordinates);

  }


  /// Replaces the vertices at the given range in the shape with the specified number
/// of vertices from a given C array.
/// 
/// If the shape is currently visible on the map as an annotation, it is redrawn
/// immediately. If the shape is part of an ``MLNShapeSource`` object, you must
/// explicitly set the ``MLNShapeSource/shape`` property in order for any style
/// layers that use the source to be redrawn.
/// 
/// If `count` is greater than the `length` field of `range`, some vertices will
/// effectively be inserted into the shape. On the other hand, if `count` is less
/// than the `length` field of `range`, some vertices will effectively be removed.
/// 
/// If `range` extends beyond the shapes `coordinates` property, an
/// `NSRangeException` is raised. If you want to append new vertices to the shape,
/// use the `-appendCoordinates:count:` method.
/// 
/// @param range The range of vertices to replace. The `location` field indicates
/// the first vertex you are replacing, with `0` being the first vertex, `1`
/// being the second vertex, and so on. The `length` field indicates the number
/// of vertices to replace.
/// @param coords The array of coordinates defining part of the shape. The data in
/// this array is copied to the shapes `coordinates` property.
/// @param count The number of coordinates from the `coords` array to insert in
/// place of the coordinates in `range`. The sum of `range`s length and this
/// count must not exceed the number of items currently in the `coordinates`
/// property.
  void replaceCoordinatesInRange$1(objc.NSRange range, {required ffi.Pointer<CLLocationCoordinate2D> withCoordinates,required int count}) {
_objc_msgSend_61jbin(object$.ref.pointer, _sel_replaceCoordinatesInRange_withCoordinates_count_, range, withCoordinates, count);

  }


  /// Sets the shapes vertices to the given C array of vertices.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the shapes `coordinates` property.
/// @param count The number of coordinates from the `coords` array.
  void setCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count}) {
_objc_msgSend_xee6m1(object$.ref.pointer, _sel_setCoordinates_count_, coords, count);

  }

}

late final _class_MLNPolygon = objc.getClass("MLNPolygon");
late final _sel_interiorPolygons = objc.registerName("interiorPolygons");
late final _sel_polygonWithCoordinates_count_ = objc.registerName("polygonWithCoordinates:count:");
late final _sel_polygonWithCoordinates_count_interiorPolygons_ = objc.registerName("polygonWithCoordinates:count:interiorPolygons:");
final _objc_msgSend_inmhr7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<CLLocationCoordinate2D> , int , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// An ``MLNPolygon`` object represents a closed shape consisting of four or more
/// vertices, specified as `CLLocationCoordinate2D` instances, and the edges that
/// connect them. For example, you could use a polygon shape to represent a
/// building, a lake, or an area you want to highlight.
/// 
/// You can add polygon shapes to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``s or
/// ``MLNVectorTileSource``s polygons collectively using an ``MLNVectorTileSource`` or
/// ``MLNSymbolStyleLayer`` object. To access a polygons attributes, use an
/// ``MLNPolygonFeature`` object.
/// 
/// Alternatively, you can add a polygon overlay directly to a map view using the
/// ``MLNMapView/addAnnotation:`` or ``MLNMapView/addOverlay:`` method. Configure
/// a polygon overlays appearance using
/// ``MLNMapViewDelegate/mapView:strokeColorForShapeAnnotation:`` and
/// ``MLNMapViewDelegate/mapView:fillColorForPolygonAnnotation:``.
/// 
/// The vertices are automatically connected in the order in which you provide
/// them. You should close the polygon by specifying the same
/// `CLLocationCoordinate2D` as the first and last vertices; otherwise, the
/// polygons fill may not cover the area you expect it to. To avoid filling the
/// space within the shape, give the polygon a transparent fill or use an
/// ``MLNPolyline`` object.
/// 
/// A polygon may have one or more interior polygons, or holes, that you specify as
/// ``MLNPolygon`` objects with the `+polygonWithCoordinates:count:interiorPolygons:`
/// method. For example, if a polygon represents a lake, it could exclude an island
/// within the lake using an interior polygon. Interior polygons may not themselves
/// have interior polygons. To represent a shape that includes a polygon within a
/// hole or, more generally, to group multiple polygons together in one shape, use
/// an ``MLNMultiPolygon`` or ``MLNMultiPolygon`` object.
/// 
/// To make the polygon straddle the antimeridian, specify some longitudes less
/// than 180 degrees or greater than 180 degrees.
/// 
/// #### Related examples
/// TODO: Add a polygon annotation, learn how to initialize an
/// ``MLNPolygon`` object from an array of coordinates.
extension type MLNPolygon._(objc.ObjCObject object$) implements objc.ObjCObject,MLNMultiPoint,MLNOverlay {
  /// Constructs a [MLNPolygon] that points to the same underlying object as [other].
  MLNPolygon.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPolygon] that wraps the given raw object pointer.
  MLNPolygon.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPolygon].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPolygon);

  /// alloc
  static MLNPolygon alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPolygon, _sel_alloc);
    return MLNPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPolygon allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPolygon, _sel_allocWithZone_, zone);
    return MLNPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPolygon new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPolygon, _sel_new);
    return MLNPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns an ``MLNPolygon`` object from the specified set of
/// coordinates.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the new object.
/// @param count The number of items in the `coords` array.
/// @return A new polygon object.
  static MLNPolygon polygonWithCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count}) {
    final $ret = _objc_msgSend_i90tul(_class_MLNPolygon, _sel_polygonWithCoordinates_count_, coords, count);
    return MLNPolygon.fromPointer($ret, retain: true, release: true);
  }


  /// Creates and returns an ``MLNPolygon`` object from the specified set of
/// coordinates and interior polygons.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the new object.
/// @param count The number of items in the `coords` array.
/// @param interiorPolygons An array of ``MLNPolygon`` objects that define regions
/// excluded from the overall shape. If this array is `nil` or empty, the shape
/// is considered to have no interior polygons.
/// @return A new polygon object.
  static MLNPolygon polygonWithCoordinates$1(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count,objc.NSArray? interiorPolygons}) {
    final $ret = _objc_msgSend_inmhr7(_class_MLNPolygon, _sel_polygonWithCoordinates_count_interiorPolygons_, coords, count, interiorPolygons?.ref.pointer ?? ffi.nullptr);
    return MLNPolygon.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPolygon, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPolygon, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPolygon constructed with the default `new` method.
  MLNPolygon() : this.as(new$().object$);

}

extension MLNPolygon$Methods on MLNPolygon {

  /// init
  MLNPolygon init() {
  objc.checkOsVersionInternal('MLNPolygon.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPolygon? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// The array of polygons nested inside the receiver.
/// 
/// The area occupied by any interior polygons is excluded from the overall shape.
/// Interior polygons should not overlap. An interior polygon should not have
/// interior polygons of its own.
/// 
/// If there are no interior polygons, the value of this property is `nil`.
  objc.NSArray? get interiorPolygons {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_interiorPolygons);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNMultiPolygon = objc.getClass("MLNMultiPolygon");
late final _sel_polygons = objc.registerName("polygons");
late final _sel_multiPolygonWithPolygons_ = objc.registerName("multiPolygonWithPolygons:");

/// An ``MLNMultiPolygon`` object represents a shape consisting of one or more
/// polygons that do not overlap. For example, you could use a multipolygon shape
/// to represent the body of land that consists of an island surrounded by an
/// atoll: the inner island would be one ``MLNPolygon`` object, while the surrounding
/// atoll would be another. You could also use a multipolygon shape to represent a
/// group of disconnected but related buildings.
/// 
/// You can add multipolygon shapes to the map by adding them to an
/// ``MLNShapeSource`` object. Configure the appearance of an ``MLNShapeSource``s or
/// ``MLNVectorTileSource``s multipolygons collectively using an ``MLNVectorTileSource``
/// or ``MLNSymbolStyleLayer`` object.
/// 
/// You cannot add an ``MLNMultiPolygon`` object directly to a map view using
/// ``MLNMapView/addAnnotation:`` or ``MLNMapView/addOverlay:``. However, you can
/// add the `polygons` arrays items as overlays individually.
extension type MLNMultiPolygon._(objc.ObjCObject object$) implements objc.ObjCObject,MLNShape,MLNOverlay {
  /// Constructs a [MLNMultiPolygon] that points to the same underlying object as [other].
  MLNMultiPolygon.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMultiPolygon] that wraps the given raw object pointer.
  MLNMultiPolygon.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMultiPolygon].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPolygon);

  /// alloc
  static MLNMultiPolygon alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPolygon, _sel_alloc);
    return MLNMultiPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMultiPolygon allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMultiPolygon, _sel_allocWithZone_, zone);
    return MLNMultiPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns a multipolygon object consisting of the given polygons.
/// 
/// @param polygons The array of polygons defining the shape.
/// @return A new multipolygon object.
  static MLNMultiPolygon multiPolygonWithPolygons(objc.NSArray polygons) {
    final $ret = _objc_msgSend_1sotr3r(_class_MLNMultiPolygon, _sel_multiPolygonWithPolygons_, polygons.ref.pointer);
    return MLNMultiPolygon.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static MLNMultiPolygon new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPolygon, _sel_new);
    return MLNMultiPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNMultiPolygon, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNMultiPolygon, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNMultiPolygon constructed with the default `new` method.
  MLNMultiPolygon() : this.as(new$().object$);

}

extension MLNMultiPolygon$Methods on MLNMultiPolygon {

  /// init
  MLNMultiPolygon init() {
  objc.checkOsVersionInternal('MLNMultiPolygon.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNMultiPolygon? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNMultiPolygon.fromPointer($ret, retain: false, release: true);
  }


  /// An array of polygons forming the multipolygon.
  objc.NSArray get polygons {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_polygons);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNPolyline = objc.getClass("MLNPolyline");
late final _sel_polylineWithCoordinates_count_ = objc.registerName("polylineWithCoordinates:count:");

/// An ``MLNPolyline`` object represents a shape consisting of two or more vertices,
/// specified as `CLLocationCoordinate2D` instances, and the line segments that
/// connect them. For example, you could use an polyline to represent a road or the
/// path along which something moves.
/// 
/// You can add polyline shapes to the map by adding them to an ``MLNShapeSource``
/// object. Configure the appearance of an ``MLNShapeSource``s or
/// ``MLNVectorTileSource``s polylines collectively using an ``MLNLineStyleLayer`` or
/// ``MLNSymbolStyleLayer`` object. To access a polylines attributes, use an
/// ``MLNPolylineFeature`` object.
/// 
/// Alternatively, you can add a polyline overlay directly to a map view using the
/// ``MLNMapView/addAnnotation:`` or ``MLNMapView/addOverlay:`` methods. Configure
/// a polyline overlays appearance using
/// ``MLNMapViewDelegate/mapView:strokeColorForShapeAnnotation:`` and
/// ``MLNMapViewDelegate/mapView:lineWidthForPolylineAnnotation:``.
/// 
/// The vertices are automatically connected in the order in which you provide
/// them. The first and last vertices are not connected to each other, but you can
/// specify the same `CLLocationCoordinate2D` as the first and last vertices in
/// order to close the polyline. To fill the space within the shape, use an
/// ``MLNPolygon`` object. To group multiple polylines together in one shape, use an
/// ``MLNMultiPolyline`` or ``MLNShapeCollection`` object.
/// 
/// To make the polyline go across the antimeridian or international date line,
/// specify some longitudes less than 180 degrees or greater than 180 degrees.
/// For example, a polyline that stretches from Tokyo to San Francisco would have
/// coordinates of (35.68476, -220.24257) and (37.78428, -122.41310).
/// 
/// ```swift
/// let coordinates = [
/// CLLocationCoordinate2D(latitude: 35.68476, longitude: -220.24257),
/// CLLocationCoordinate2D(latitude: 37.78428, longitude: -122.41310)
/// ]
/// let polyline = MLNPolyline(coordinates: coordinates, count: UInt(coordinates.count))
/// ```
/// 
/// A polyline is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.4">LineString</a>
/// geometry in GeoJSON.
/// 
/// #### Related examples
/// 
/// - <doc:LineOnUserTap>
/// - <doc:AnimatedLineExample>
extension type MLNPolyline._(objc.ObjCObject object$) implements objc.ObjCObject,MLNMultiPoint,MLNOverlay {
  /// Constructs a [MLNPolyline] that points to the same underlying object as [other].
  MLNPolyline.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPolyline] that wraps the given raw object pointer.
  MLNPolyline.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPolyline].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPolyline);

  /// alloc
  static MLNPolyline alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPolyline, _sel_alloc);
    return MLNPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPolyline allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPolyline, _sel_allocWithZone_, zone);
    return MLNPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPolyline new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPolyline, _sel_new);
    return MLNPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns an ``MLNPolyline`` object from the specified set of
/// coordinates.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the new object.
/// @param count The number of items in the `coords` array.
/// @return A new polyline object.
  static MLNPolyline polylineWithCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count}) {
    final $ret = _objc_msgSend_i90tul(_class_MLNPolyline, _sel_polylineWithCoordinates_count_, coords, count);
    return MLNPolyline.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPolyline, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPolyline, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPolyline constructed with the default `new` method.
  MLNPolyline() : this.as(new$().object$);

}

extension MLNPolyline$Methods on MLNPolyline {

  /// init
  MLNPolyline init() {
  objc.checkOsVersionInternal('MLNPolyline.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPolyline? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPolyline.fromPointer($ret, retain: false, release: true);
  }

}

late final _class_MLNMultiPolyline = objc.getClass("MLNMultiPolyline");
late final _sel_polylines = objc.registerName("polylines");
late final _sel_multiPolylineWithPolylines_ = objc.registerName("multiPolylineWithPolylines:");

/// An ``MLNMultiPolyline`` object represents a shape consisting of one or more
/// polylines. For example, you could use a multipolyline shape to represent both
/// sides of a divided highway (dual carriageway), excluding the median (central
/// reservation): each carriageway would be a distinct ``MLNPolyline`` object.
/// 
/// You can add multipolyline shapes to the map by adding them to an
/// ``MLNShapeSource`` object. Configure the appearance of an ``MLNShapeSource``s or
/// ``MLNVectorTileSource``s multipolylines collectively using an
/// ``MLNLineStyleLayer`` or ``MLNSymbolStyleLayer`` object.
/// 
/// You cannot add an ``MLNMultiPolyline`` object directly to a map view using
/// ``MLNMapView/addAnnotation:`` or ``MLNMapView/addOverlay:``. However, you can
/// add the `polylines` arrays items as overlays individually.
/// 
/// A multipolyline is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.5">MultiLineString</a>
/// geometry in GeoJSON.
extension type MLNMultiPolyline._(objc.ObjCObject object$) implements objc.ObjCObject,MLNShape,MLNOverlay {
  /// Constructs a [MLNMultiPolyline] that points to the same underlying object as [other].
  MLNMultiPolyline.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMultiPolyline] that wraps the given raw object pointer.
  MLNMultiPolyline.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMultiPolyline].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPolyline);

  /// alloc
  static MLNMultiPolyline alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPolyline, _sel_alloc);
    return MLNMultiPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMultiPolyline allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMultiPolyline, _sel_allocWithZone_, zone);
    return MLNMultiPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns a multipolyline object consisting of the given polylines.
/// 
/// @param polylines The array of polylines defining the shape.
/// @return A new multipolyline object.
  static MLNMultiPolyline multiPolylineWithPolylines(objc.NSArray polylines) {
    final $ret = _objc_msgSend_1sotr3r(_class_MLNMultiPolyline, _sel_multiPolylineWithPolylines_, polylines.ref.pointer);
    return MLNMultiPolyline.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static MLNMultiPolyline new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPolyline, _sel_new);
    return MLNMultiPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNMultiPolyline, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNMultiPolyline, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNMultiPolyline constructed with the default `new` method.
  MLNMultiPolyline() : this.as(new$().object$);

}

extension MLNMultiPolyline$Methods on MLNMultiPolyline {

  /// init
  MLNMultiPolyline init() {
  objc.checkOsVersionInternal('MLNMultiPolyline.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNMultiPolyline? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNMultiPolyline.fromPointer($ret, retain: false, release: true);
  }


  /// An array of polygons forming the multipolyline.
  objc.NSArray get polylines {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_polylines);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNShapeCollection = objc.getClass("MLNShapeCollection");
late final _sel_shapes = objc.registerName("shapes");
late final _sel_shapeCollectionWithShapes_ = objc.registerName("shapeCollectionWithShapes:");

/// An ``MLNShapeCollection`` object represents a shape consisting of zero or more
/// distinct but related shapes that are instances of ``MLNShape``. The constituent
/// shapes can be a mixture of different kinds of shapes.
/// 
/// ``MLNShapeCollection`` is most commonly used to add multiple shapes to a single
/// ``MLNShapeSource``. Configure the appearance of an ``MLNShapeSource``s or
/// ``MLNVectorTileSource``s shape collection collectively using an
/// ``MLNSymbolStyleLayer`` object, or use multiple instances of
/// ``MLNCircleStyleLayer``, ``MLNCircleStyleLayer``, and ``MLNCircleStyleLayer`` to
/// configure the appearance of each kind of shape inside the collection.
/// 
/// You cannot add an ``MLNShapeCollection`` object directly to a map view as an
/// annotation. However, you can create individual ``MLNPointAnnotation``,
/// ``MLNPolyline``, and ``MLNPolyline`` objects from the `shapes` array and add those
/// annotation objects to the map view using the ``MLNMapView/addAnnotations:``
/// method.
/// 
/// To represent a collection of point, polyline, or polygon shapes, it may be more
/// convenient to use an ``MLNPointCollection``, ``MLNPointCollection``, or
/// ``MLNMultiPolygon`` object, respectively. To access a shape collections
/// attributes, use the corresponding ``MLNFeature`` object.
/// 
/// A shape collection is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.8">GeometryCollection</a>
/// geometry in GeoJSON.
extension type MLNShapeCollection._(objc.ObjCObject object$) implements objc.ObjCObject,MLNShape {
  /// Constructs a [MLNShapeCollection] that points to the same underlying object as [other].
  MLNShapeCollection.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNShapeCollection] that wraps the given raw object pointer.
  MLNShapeCollection.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNShapeCollection].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShapeCollection);

  /// alloc
  static MLNShapeCollection alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNShapeCollection, _sel_alloc);
    return MLNShapeCollection.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNShapeCollection allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNShapeCollection, _sel_allocWithZone_, zone);
    return MLNShapeCollection.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNShapeCollection new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNShapeCollection, _sel_new);
    return MLNShapeCollection.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns a shape collection consisting of the given shapes.
/// 
/// @param shapes The array of shapes defining the shape collection. The data in
/// this array is copied to the new object.
/// @return A new shape collection object.
  static MLNShapeCollection shapeCollectionWithShapes(objc.NSArray shapes) {
    final $ret = _objc_msgSend_1sotr3r(_class_MLNShapeCollection, _sel_shapeCollectionWithShapes_, shapes.ref.pointer);
    return MLNShapeCollection.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNShapeCollection, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNShapeCollection, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNShapeCollection constructed with the default `new` method.
  MLNShapeCollection() : this.as(new$().object$);

}

extension MLNShapeCollection$Methods on MLNShapeCollection {

  /// init
  MLNShapeCollection init() {
  objc.checkOsVersionInternal('MLNShapeCollection.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNShapeCollection.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNShapeCollection? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNShapeCollection.fromPointer($ret, retain: false, release: true);
  }


  /// An array of shapes forming the shape collection.
  objc.NSArray get shapes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_shapes);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNEmptyFeature = objc.getClass("MLNEmptyFeature");

/// An ``MLNEmptyFeature`` object associates an empty shape with an optional
/// identifier and attributes.
extension type MLNEmptyFeature._(objc.ObjCObject object$) implements objc.ObjCObject,MLNShape,MLNFeature {
  /// Constructs a [MLNEmptyFeature] that points to the same underlying object as [other].
  MLNEmptyFeature.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNEmptyFeature] that wraps the given raw object pointer.
  MLNEmptyFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNEmptyFeature].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNEmptyFeature);

  /// alloc
  static MLNEmptyFeature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNEmptyFeature, _sel_alloc);
    return MLNEmptyFeature.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNEmptyFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNEmptyFeature, _sel_allocWithZone_, zone);
    return MLNEmptyFeature.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNEmptyFeature new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNEmptyFeature, _sel_new);
    return MLNEmptyFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNEmptyFeature, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNEmptyFeature, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNEmptyFeature constructed with the default `new` method.
  MLNEmptyFeature() : this.as(new$().object$);

}

extension MLNEmptyFeature$Methods on MLNEmptyFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNEmptyFeature init() {
  objc.checkOsVersionInternal('MLNEmptyFeature.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNEmptyFeature.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNEmptyFeature? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNEmptyFeature.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNPointFeature = objc.getClass("MLNPointFeature");

/// An ``MLNPointFeature`` object associates a point shape with an optional
/// identifier and attributes.
/// 
/// #### Related examples
/// - <doc:WebAPIDataExample>
extension type MLNPointFeature._(objc.ObjCObject object$) implements objc.ObjCObject,MLNPointAnnotation,MLNFeature {
  /// Constructs a [MLNPointFeature] that points to the same underlying object as [other].
  MLNPointFeature.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPointFeature] that wraps the given raw object pointer.
  MLNPointFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPointFeature].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointFeature);

  /// alloc
  static MLNPointFeature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointFeature, _sel_alloc);
    return MLNPointFeature.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPointFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPointFeature, _sel_allocWithZone_, zone);
    return MLNPointFeature.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPointFeature new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointFeature, _sel_new);
    return MLNPointFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPointFeature, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPointFeature, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPointFeature constructed with the default `new` method.
  MLNPointFeature() : this.as(new$().object$);

}

extension MLNPointFeature$Methods on MLNPointFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNPointFeature init() {
  objc.checkOsVersionInternal('MLNPointFeature.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointFeature.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPointFeature? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPointFeature.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNPointFeatureCluster = objc.getClass("MLNPointFeatureCluster");

/// An ``MLNPointFeatureCluster`` object associates a point shape (with an optional
/// identifier and attributes) and represents a point cluster.
/// 
/// @see ``MLNCluster``
/// 
/// #### Related examples
/// TODO: Clustering point data, learn how to initialize
/// clusters and add them to your map.
extension type MLNPointFeatureCluster._(objc.ObjCObject object$) implements objc.ObjCObject,MLNPointFeature,MLNCluster {
  /// Constructs a [MLNPointFeatureCluster] that points to the same underlying object as [other].
  MLNPointFeatureCluster.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPointFeatureCluster] that wraps the given raw object pointer.
  MLNPointFeatureCluster.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPointFeatureCluster].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointFeatureCluster);

  /// alloc
  static MLNPointFeatureCluster alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointFeatureCluster, _sel_alloc);
    return MLNPointFeatureCluster.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPointFeatureCluster allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPointFeatureCluster, _sel_allocWithZone_, zone);
    return MLNPointFeatureCluster.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPointFeatureCluster new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointFeatureCluster, _sel_new);
    return MLNPointFeatureCluster.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPointFeatureCluster, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPointFeatureCluster, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPointFeatureCluster constructed with the default `new` method.
  MLNPointFeatureCluster() : this.as(new$().object$);

}

extension MLNPointFeatureCluster$Methods on MLNPointFeatureCluster {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// The identifier for the cluster.
  int get clusterIdentifier {
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_clusterIdentifier);

  }


  /// The number of points within this cluster
  int get clusterPointCount {
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_clusterPointCount);

  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNPointFeatureCluster init() {
  objc.checkOsVersionInternal('MLNPointFeatureCluster.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointFeatureCluster.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPointFeatureCluster? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPointFeatureCluster.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNPolylineFeature = objc.getClass("MLNPolylineFeature");

/// An ``MLNPolylineFeature`` object associates a polyline shape with an optional
/// identifier and attributes.
/// 
/// A polyline feature is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.4">LineString</a>
/// feature in GeoJSON.
/// 
/// #### Related examples
/// - <doc:AnimatedLineExample>
extension type MLNPolylineFeature._(objc.ObjCObject object$) implements objc.ObjCObject,MLNPolyline,MLNFeature {
  /// Constructs a [MLNPolylineFeature] that points to the same underlying object as [other].
  MLNPolylineFeature.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPolylineFeature] that wraps the given raw object pointer.
  MLNPolylineFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPolylineFeature].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPolylineFeature);

  /// alloc
  static MLNPolylineFeature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPolylineFeature, _sel_alloc);
    return MLNPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPolylineFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPolylineFeature, _sel_allocWithZone_, zone);
    return MLNPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPolylineFeature new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPolylineFeature, _sel_new);
    return MLNPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns an ``MLNPolyline`` object from the specified set of
/// coordinates.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the new object.
/// @param count The number of items in the `coords` array.
/// @return A new polyline object.
  static MLNPolylineFeature polylineWithCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count}) {
    final $ret = _objc_msgSend_i90tul(_class_MLNPolylineFeature, _sel_polylineWithCoordinates_count_, coords, count);
    return MLNPolylineFeature.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPolylineFeature, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPolylineFeature, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPolylineFeature constructed with the default `new` method.
  MLNPolylineFeature() : this.as(new$().object$);

}

extension MLNPolylineFeature$Methods on MLNPolylineFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNPolylineFeature init() {
  objc.checkOsVersionInternal('MLNPolylineFeature.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPolylineFeature? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNPolygonFeature = objc.getClass("MLNPolygonFeature");

/// An ``MLNPolygonFeature`` object associates a polygon shape with an optional
/// identifier and attributes.
extension type MLNPolygonFeature._(objc.ObjCObject object$) implements objc.ObjCObject,MLNPolygon,MLNFeature {
  /// Constructs a [MLNPolygonFeature] that points to the same underlying object as [other].
  MLNPolygonFeature.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPolygonFeature] that wraps the given raw object pointer.
  MLNPolygonFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPolygonFeature].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPolygonFeature);

  /// alloc
  static MLNPolygonFeature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPolygonFeature, _sel_alloc);
    return MLNPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPolygonFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPolygonFeature, _sel_allocWithZone_, zone);
    return MLNPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPolygonFeature new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPolygonFeature, _sel_new);
    return MLNPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns an ``MLNPolygon`` object from the specified set of
/// coordinates.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the new object.
/// @param count The number of items in the `coords` array.
/// @return A new polygon object.
  static MLNPolygonFeature polygonWithCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count}) {
    final $ret = _objc_msgSend_i90tul(_class_MLNPolygonFeature, _sel_polygonWithCoordinates_count_, coords, count);
    return MLNPolygonFeature.fromPointer($ret, retain: true, release: true);
  }


  /// Creates and returns an ``MLNPolygon`` object from the specified set of
/// coordinates and interior polygons.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the new object.
/// @param count The number of items in the `coords` array.
/// @param interiorPolygons An array of ``MLNPolygon`` objects that define regions
/// excluded from the overall shape. If this array is `nil` or empty, the shape
/// is considered to have no interior polygons.
/// @return A new polygon object.
  static MLNPolygonFeature polygonWithCoordinates$1(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count,objc.NSArray? interiorPolygons}) {
    final $ret = _objc_msgSend_inmhr7(_class_MLNPolygonFeature, _sel_polygonWithCoordinates_count_interiorPolygons_, coords, count, interiorPolygons?.ref.pointer ?? ffi.nullptr);
    return MLNPolygonFeature.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPolygonFeature, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPolygonFeature, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPolygonFeature constructed with the default `new` method.
  MLNPolygonFeature() : this.as(new$().object$);

}

extension MLNPolygonFeature$Methods on MLNPolygonFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNPolygonFeature init() {
  objc.checkOsVersionInternal('MLNPolygonFeature.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPolygonFeature? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNPointCollectionFeature = objc.getClass("MLNPointCollectionFeature");

/// An ``MLNPointCollectionFeature`` object associates a point collection with an
/// optional identifier and attributes.
/// 
/// A point collection feature is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.3">MultiPoint</a>
/// feature in GeoJSON.
extension type MLNPointCollectionFeature._(objc.ObjCObject object$) implements objc.ObjCObject,MLNPointCollection,MLNFeature {
  /// Constructs a [MLNPointCollectionFeature] that points to the same underlying object as [other].
  MLNPointCollectionFeature.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNPointCollectionFeature] that wraps the given raw object pointer.
  MLNPointCollectionFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNPointCollectionFeature].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNPointCollectionFeature);

  /// alloc
  static MLNPointCollectionFeature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointCollectionFeature, _sel_alloc);
    return MLNPointCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNPointCollectionFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNPointCollectionFeature, _sel_allocWithZone_, zone);
    return MLNPointCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNPointCollectionFeature new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNPointCollectionFeature, _sel_new);
    return MLNPointCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns a ``MLNPointCollection`` object from the specified set of
/// coordinates.
/// 
/// @param coords The array of coordinates defining the shape. The data in this
/// array is copied to the new object.
/// @param count The number of items in the `coords` array.
/// @return A new point collection object.
  static MLNPointCollectionFeature pointCollectionWithCoordinates(ffi.Pointer<CLLocationCoordinate2D> coords, {required int count}) {
    final $ret = _objc_msgSend_i90tul(_class_MLNPointCollectionFeature, _sel_pointCollectionWithCoordinates_count_, coords, count);
    return MLNPointCollectionFeature.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNPointCollectionFeature, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNPointCollectionFeature, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNPointCollectionFeature constructed with the default `new` method.
  MLNPointCollectionFeature() : this.as(new$().object$);

}

extension MLNPointCollectionFeature$Methods on MLNPointCollectionFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNPointCollectionFeature init() {
  objc.checkOsVersionInternal('MLNPointCollectionFeature.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNPointCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNPointCollectionFeature? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNPointCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNMultiPolylineFeature = objc.getClass("MLNMultiPolylineFeature");

/// An ``MLNMultiPolylineFeature`` object associates a multipolyline shape with an
/// optional identifier and attributes.
/// 
/// A multipolyline feature is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.1.5">MultiLineString</a>
/// feature in GeoJSON.
extension type MLNMultiPolylineFeature._(objc.ObjCObject object$) implements objc.ObjCObject,MLNMultiPolyline,MLNFeature {
  /// Constructs a [MLNMultiPolylineFeature] that points to the same underlying object as [other].
  MLNMultiPolylineFeature.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMultiPolylineFeature] that wraps the given raw object pointer.
  MLNMultiPolylineFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMultiPolylineFeature].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPolylineFeature);

  /// alloc
  static MLNMultiPolylineFeature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPolylineFeature, _sel_alloc);
    return MLNMultiPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMultiPolylineFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMultiPolylineFeature, _sel_allocWithZone_, zone);
    return MLNMultiPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns a multipolyline object consisting of the given polylines.
/// 
/// @param polylines The array of polylines defining the shape.
/// @return A new multipolyline object.
  static MLNMultiPolylineFeature multiPolylineWithPolylines(objc.NSArray polylines) {
    final $ret = _objc_msgSend_1sotr3r(_class_MLNMultiPolylineFeature, _sel_multiPolylineWithPolylines_, polylines.ref.pointer);
    return MLNMultiPolylineFeature.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static MLNMultiPolylineFeature new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPolylineFeature, _sel_new);
    return MLNMultiPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNMultiPolylineFeature, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNMultiPolylineFeature, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNMultiPolylineFeature constructed with the default `new` method.
  MLNMultiPolylineFeature() : this.as(new$().object$);

}

extension MLNMultiPolylineFeature$Methods on MLNMultiPolylineFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNMultiPolylineFeature init() {
  objc.checkOsVersionInternal('MLNMultiPolylineFeature.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNMultiPolylineFeature? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNMultiPolylineFeature.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNMultiPolygonFeature = objc.getClass("MLNMultiPolygonFeature");

/// An ``MLNMultiPolygonFeature`` object associates a multipolygon shape with an
/// optional identifier and attributes.
extension type MLNMultiPolygonFeature._(objc.ObjCObject object$) implements objc.ObjCObject,MLNMultiPolygon,MLNFeature {
  /// Constructs a [MLNMultiPolygonFeature] that points to the same underlying object as [other].
  MLNMultiPolygonFeature.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNMultiPolygonFeature] that wraps the given raw object pointer.
  MLNMultiPolygonFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNMultiPolygonFeature].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNMultiPolygonFeature);

  /// alloc
  static MLNMultiPolygonFeature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPolygonFeature, _sel_alloc);
    return MLNMultiPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNMultiPolygonFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNMultiPolygonFeature, _sel_allocWithZone_, zone);
    return MLNMultiPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns a multipolygon object consisting of the given polygons.
/// 
/// @param polygons The array of polygons defining the shape.
/// @return A new multipolygon object.
  static MLNMultiPolygonFeature multiPolygonWithPolygons(objc.NSArray polygons) {
    final $ret = _objc_msgSend_1sotr3r(_class_MLNMultiPolygonFeature, _sel_multiPolygonWithPolygons_, polygons.ref.pointer);
    return MLNMultiPolygonFeature.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static MLNMultiPolygonFeature new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNMultiPolygonFeature, _sel_new);
    return MLNMultiPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNMultiPolygonFeature, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNMultiPolygonFeature, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNMultiPolygonFeature constructed with the default `new` method.
  MLNMultiPolygonFeature() : this.as(new$().object$);

}

extension MLNMultiPolygonFeature$Methods on MLNMultiPolygonFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNMultiPolygonFeature init() {
  objc.checkOsVersionInternal('MLNMultiPolygonFeature.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNMultiPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNMultiPolygonFeature? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNMultiPolygonFeature.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNShapeCollectionFeature = objc.getClass("MLNShapeCollectionFeature");

/// An ``MLNShapeCollectionFeature`` object associates a shape collection with an
/// optional identifier and attributes.
/// 
/// ``MLNShapeCollectionFeature`` is most commonly used to add multiple shapes to a
/// single ``MLNShapeSource``. Configure the appearance of an ``MLNSource``s shape
/// collection collectively using an ``MLNSymbolStyleLayer`` object, or use multiple
/// instances of ``MLNCircleStyleLayer``, ``MLNFillStyleLayer``, and
/// ``MLNLineStyleLayer`` to configure the appearance of each kind of shape inside
/// the collection.
/// 
/// A shape collection feature is known as a
/// <a href="https://tools.ietf.org/html/rfc7946#section-3.3">feature collection</a>
/// in GeoJSON.
/// 
/// #### Related examples
/// TODO: Add multiple shapes from a single shape source, learn how to
/// add shape data to your map using an ``MLNShapeCollectionFeature`` object.
extension type MLNShapeCollectionFeature._(objc.ObjCObject object$) implements objc.ObjCObject,MLNShapeCollection,MLNFeature {
  /// Constructs a [MLNShapeCollectionFeature] that points to the same underlying object as [other].
  MLNShapeCollectionFeature.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNShapeCollectionFeature] that wraps the given raw object pointer.
  MLNShapeCollectionFeature.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNShapeCollectionFeature].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShapeCollectionFeature);

  /// alloc
  static MLNShapeCollectionFeature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNShapeCollectionFeature, _sel_alloc);
    return MLNShapeCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNShapeCollectionFeature allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNShapeCollectionFeature, _sel_allocWithZone_, zone);
    return MLNShapeCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNShapeCollectionFeature new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNShapeCollectionFeature, _sel_new);
    return MLNShapeCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// Creates and returns a shape collection consisting of the given shapes.
/// 
/// @param shapes The array of shapes defining the shape collection. The data in
/// this array is copied to the new object.
/// @return A new shape collection object.
  static MLNShapeCollectionFeature shapeCollectionWithShapes(objc.NSArray shapes) {
    final $ret = _objc_msgSend_1sotr3r(_class_MLNShapeCollectionFeature, _sel_shapeCollectionWithShapes_, shapes.ref.pointer);
    return MLNShapeCollectionFeature.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an ``MLNShape`` object initialized with the given data interpreted as a
/// string containing a GeoJSON object.
/// 
/// If the GeoJSON object is a geometry, the returned value is a kind of
/// ``MLNShape``. If it is a feature object, the returned value is a kind of
/// ``MLNShape`` that conforms to the ``MLNShape`` protocol. If it is a feature
/// collection object, the returned value is an instance of
/// ``MLNShapeCollectionFeature``.
/// 
/// ### Example
/// 
/// ```swift
/// let url = mainBundle.url(forResource: "amsterdam", withExtension: "geojson")!
/// let data = try! Data(contentsOf: url)
/// let feature = try! MLNShape(data: data, encoding: String.Encoding.utf8.rawValue) as!
/// MLNShapeCollectionFeature
/// ```
/// 
/// @param data String data containing GeoJSON source code.
/// @param encoding The encoding used by `data`.
/// @param outError Upon return, if an error has occurred, a pointer to an
/// `NSError` object describing the error. Pass in `NULL` to ignore any error.
/// @return An ``MLNShape`` object representation of `data`, or `nil` if `data` could
/// not be parsed as valid GeoJSON source code. If `nil`, `outError` contains an
/// `NSError` object describing the problem.
  static MLNShape? shapeWithData(objc.NSData data, {required int encoding}) {
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1nomli1(_class_MLNShapeCollectionFeature, _sel_shapeWithData_encoding_error_, data.ref.pointer, encoding, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNShapeCollectionFeature, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNShapeCollectionFeature constructed with the default `new` method.
  MLNShapeCollectionFeature() : this.as(new$().object$);

}

extension MLNShapeCollectionFeature$Methods on MLNShapeCollectionFeature {

  /// Returns the feature attribute for the given attribute name.
/// 
/// See the ``attributes`` propertys documentation for details on keys and values
/// associated with this method.
  objc.ObjCObject? attributeForKey(objc.NSString key) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_attributeForKey_, key.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  objc.NSDictionary get attributes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributes);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a dictionary that can be serialized as a GeoJSON Feature representation
/// of an instance of an ``MLNFeature`` subclass.
/// 
/// The dictionary includes a `geometry` key corresponding to the receivers
/// underlying geometry data, a `properties` key corresponding to the receivers
/// `attributes` property, and an `id` key corresponding to the receivers
/// ``identifier` property.
  objc.NSDictionary geoJSONDictionary() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_geoJSONDictionary);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  objc.ObjCObject? get identifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// init
  MLNShapeCollectionFeature init() {
  objc.checkOsVersionInternal('MLNShapeCollectionFeature.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNShapeCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNShapeCollectionFeature? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNShapeCollectionFeature.fromPointer($ret, retain: false, release: true);
  }


  /// A dictionary of attributes for this feature.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare a key of the attribute
/// dictionary to the value you want to include. For example, if you want an
/// ``MLNLineStyleLayer`` object to display only important features, you might assign
/// a value above 50 to the important features `importance` attribute, then set
/// ``MLNVectorStyleLayer/predicate`` to an
/// [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) with the format
/// `importance > 50`.
/// 
/// You can also configure many layout and paint attributes of an ``MLNStyleLayer``
/// object to match the value of an attribute in this dictionary whenever it
/// renders this feature. For example, if you display features in an
/// ``MLNShapeSource`` using an ``MLNCircleStyleLayer``, you can assign a `halfway`
/// attribute to each of the sources features, then set
/// ``MLNCircleStyleLayer/circleRadius`` to an expression for the key path `halfway`.
/// 
/// The ``MLNSymbolStyleLayer/text`` and ``MLNSymbolStyleLayer/iconImageName``
/// properties allow you to use attributes yet another way. For example, to label
/// features in an ``MLNShapeSource`` object by their names, you can assign a `name`
/// attribute to each of the sources features, then set
/// ``MLNSymbolStyleLayer/text`` to an expression for the constant string value
/// `{name}`. See the
/// <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for more information about expressions.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the keys and values of
/// each features attribute dictionary are determined by the source. Each
/// attribute name is a string, while each attribute value may be a null value,
/// Boolean value, integer, floating-point number, or string. These data types are
/// mapped to instances of the following Foundation classes:
/// 
/// | In the tile source        | In this dictionary |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Null                      | `NSNull` | | Boolean                   | `NSNumber` (use the
/// `boolValue` property)                                     | | Integer                   |
/// `NSNumber` (use the `unsignedLongLongValue` or `longLongValue` property)      | | Floating-point
/// number      | `NSNumber` (use the `doubleValue` property)                                  | |
/// String                    | `NSString` |
/// 
/// When adding a feature to an ``MLNShapeSource``, use the same Foundation types
/// listed above for each attribute value. In addition to the Foundation types, you
/// may also set an attribute to an `NSColor` (macOS) or `UIColor` (iOS), which
/// will be converted into its
/// <a href="https://maplibre.org/maplibre-style-spec/types/#color">CSS string representation</a>
/// when the feature is added to an ``MLNShapeSource``. This can be convenient when
/// using the attribute to supply a value for a color-typed layout or paint
/// attribute via a key path expression.
/// 
/// Note that while it is possible to change this value on feature
/// instances obtained from ``MLNMapView/visibleFeaturesAtPoint:`` and related
/// methods, there will be no effect on the map. Setting this value can be useful
/// when the feature instance is used to initialize an ``MLNShapeSource`` and that
/// source is added to the map and styled.
  set attributes(objc.NSDictionary value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setAttributes_, value.ref.pointer);

  }


  /// An object that uniquely identifies the feature in its containing content
/// source.
/// 
/// You can configure an ``MLNVectorStyleLayer`` object to include or exclude a
/// specific feature in an ``MLNShapeSource`` or ``MLNVectorTileSource``. In the
/// ``MLNVectorStyleLayer/predicate`` property, compare the special `$id` attribute
/// to the features identifier.
/// 
/// In vector tiles loaded by ``MLNVectorTileSource`` objects, the identifier
/// corresponds to the
/// <a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1#42-features">feature
/// identifier</a>
/// (`id`). If the source does not specify the features identifier, the value of
/// this property is `nil`. If specified, the identifier may be an integer,
/// floating-point number, or string. These data types are mapped to instances of
/// the following Foundation classes:
/// 
/// | In the tile source        | This property |
/// |---------------------------|-------------------------------------------------------------------------------|
/// | Integer                   | `NSNumber` (use the `unsignedLongLongValue` or `longLongValue`
/// property)      | | Floating-point number      | `NSNumber` (use the `doubleValue` property) | |
/// String                    | `NSString` |
/// 
/// The identifier should be set before adding the feature to an ``MLNShapeSource``
/// object; setting it afterwards has no effect on the maps contents. While it is
/// possible to change this value on feature instances obtained from
/// ``MLNMapView/visibleFeaturesAtPoint:`` and related methods, doing so likewise
/// has no effect on the maps contents.
  set identifier(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// shapes
  objc.NSArray get shapes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_shapes);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNTileSource = objc.getClass("MLNTileSource");
late final _sel_configurationURL = objc.registerName("configurationURL");
late final _sel_attributionInfos = objc.registerName("attributionInfos");
late final _sel_attributionHTMLString = objc.registerName("attributionHTMLString");

/// ``MLNTileSource`` is a map content source that supplies map tiles to be shown on
/// the map. The location of and metadata about the tiles are defined either by an
/// option dictionary or by an external file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` or ``MLNRasterStyleLayer`` objects. Use a style layer to
/// control the appearance of content supplied by the tile source.
/// 
/// A tile source is also known as a tile set. To learn about the structure of a
/// Mapbox-hosted tile set, view it in
/// <a href="https://www.mapbox.com/studio/tilesets/">Mapbox Studios Tilesets editor</a>.
/// 
/// Create instances of ``MLNRasterTileSource`` and ``MLNRasterTileSource`` in order
/// to use ``MLNTileSource``'s properties and methods. Do not create instances of
/// ``MLNTileSource`` directly, and do not create your own subclasses of this class.
extension type MLNTileSource._(objc.ObjCObject object$) implements objc.ObjCObject,MLNSource {
  /// Constructs a [MLNTileSource] that points to the same underlying object as [other].
  MLNTileSource.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNTileSource] that wraps the given raw object pointer.
  MLNTileSource.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNTileSource].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNTileSource);

  /// alloc
  static MLNTileSource alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNTileSource, _sel_alloc);
    return MLNTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNTileSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNTileSource, _sel_allocWithZone_, zone);
    return MLNTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNTileSource new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNTileSource, _sel_new);
    return MLNTileSource.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNTileSource constructed with the default `new` method.
  MLNTileSource() : this.as(new$().object$);

}

extension MLNTileSource$Methods on MLNTileSource {

  /// The attribution HTML string associated with this source.
/// 
/// By default, this is nil. If the source is initialized with a
/// configuration URL, this is nil until the configuration JSON file
/// is loaded.
  objc.NSString? get attributionHTMLString {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributionHTMLString);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// An array of ``MLNAttributionInfo`` objects that define the attribution
/// statements to be displayed when the map is shown to the user.
/// 
/// By default, this array is empty. If the source is initialized with a
/// configuration URL, this array is also empty until the configuration JSON file
/// is loaded.
  objc.NSArray get attributionInfos {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributionInfos);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// The URL to the TileJSON configuration file that specifies the contents of the
/// source.
/// 
/// If the receiver was initialized using
/// `-initWithIdentifier:tileURLTemplates:options`, this property is set to `nil`.
  objc.NSURL? get configurationURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_configurationURL);
    return $ret.address == 0 ? null : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNTileSource init() {
  objc.checkOsVersionInternal('MLNTileSource.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a source initialized with an identifier.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @return An initialized source.
  MLNTileSource initWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNTileSource.fromPointer($ret, retain: false, release: true);
  }

}

late final _class_MLNVectorTileSource = objc.getClass("MLNVectorTileSource");
late final _sel_initWithIdentifier_configurationURL_ = objc.registerName("initWithIdentifier:configurationURL:");
late final _sel_initWithIdentifier_configurationURLString_ = objc.registerName("initWithIdentifier:configurationURLString:");
late final _sel_initWithIdentifier_tileURLTemplates_options_ = objc.registerName("initWithIdentifier:tileURLTemplates:options:");
late final _sel_featuresInSourceLayersWithIdentifiers_predicate_ = objc.registerName("featuresInSourceLayersWithIdentifiers:predicate:");

/// ``MLNVectorTileSource`` is a map content source that supplies tiled vector data
/// in <a href="https://www.mapbox.com/vector-tiles/">Mapbox Vector Tile</a> format
/// to be shown on the map. The location of and metadata about the tiles are
/// defined either by an option dictionary or by an external file that conforms to
/// the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A vector tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNVectorStyleLayer`` objects. A vector style layer defines the appearance of
/// any content supplied by the vector tile source.
/// 
/// ``MLNVectorTileSource`` is optimized for data sets that are too large to fit
/// completely in memory, such as vector tile sets or data sets managed in
/// <a href="https://www.mapbox.com/studio/">Mapbox Studio</a>. For
/// <a href="http://geojson.org/">GeoJSON</a> data, use the ``MLNShapeSource``
/// class. For tiled data that changes dynamically, the ``MLNComputedShapeSource``
/// class may be a suitable alternative.
/// 
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/sources/#vector"><code>vector</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNVectorTileSource`` object that you can use to initialize new style layers.
/// You can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
/// 
/// Within each vector tile, each geometric coordinate must lie between
/// 1&nbsp;&nbsp;<var>extent</var> and
/// (<var>extent</var>&nbsp;&nbsp;2)&nbsp;&nbsp;1, inclusive. Any vector style
/// layer initialized with a vector tile source must have a non-`nil` value in its
/// `sourceLayerIdentifier` property.
/// 
/// Commonly used vector tile sources include
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-streets/">Mapbox Streets</a>,
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-terrain/">Mapbox Terrain</a>,
/// and
/// <a href="https://www.mapbox.com/vector-tiles/mapbox-traffic-v1/">Mapbox Traffic</a>.
/// 
/// ### Example
/// 
/// ```swift
/// let source = MLNVectorTileSource(identifier: "pois", tileURLTemplates:
/// ["https://example.com/vector-tiles/{z}/{x}/{y}.mvt"], options: [ .minimumZoomLevel: 9,
/// .maximumZoomLevel: 16,
/// .attributionInfos: [
/// MLNAttributionInfo(title: NSAttributedString(string: " Mapbox"), url: URL(string:
/// "https://mapbox.com"))
/// ]
/// ])
/// mapView.style?.addSource(source)
/// ```
/// 
/// #### Related examples
/// TODO: Data-driven circles, learn how to add data to your map using
/// an ``MLNVectorTileSource`` object.
extension type MLNVectorTileSource._(objc.ObjCObject object$) implements objc.ObjCObject,MLNTileSource {
  /// Constructs a [MLNVectorTileSource] that points to the same underlying object as [other].
  MLNVectorTileSource.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNVectorTileSource] that wraps the given raw object pointer.
  MLNVectorTileSource.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNVectorTileSource].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNVectorTileSource);

  /// alloc
  static MLNVectorTileSource alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNVectorTileSource, _sel_alloc);
    return MLNVectorTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNVectorTileSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNVectorTileSource, _sel_allocWithZone_, zone);
    return MLNVectorTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNVectorTileSource new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNVectorTileSource, _sel_new);
    return MLNVectorTileSource.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNVectorTileSource constructed with the default `new` method.
  MLNVectorTileSource() : this.as(new$().object$);

}

extension MLNVectorTileSource$Methods on MLNVectorTileSource {

  /// Returns an array of map features loaded by this source, restricted to the given
/// source layers and filtered by the given predicate.
/// 
/// Each object in the returned array represents a feature loaded by the source and
/// provides access to attributes specified as part of the loaded feature. The
/// source loads a feature if the source is added to an ``MLNMapView``s style; that
/// style has a layer that uses the source; and the map view has recently scrolled
/// to the region containing the feature.
/// 
/// Features come from tiled vector data that is converted to tiles internally, so
/// feature geometries are clipped at tile boundaries and features may appear
/// duplicated across tiles. For example, suppose part of a lengthy polyline
/// representing a road has recently scrolled into view. The resulting array
/// includes those parts of the road that lie within the map tiles that the source
/// has loaded, even if the road extends into other tiles. The portion of the road
/// within each map tile is included individually.
/// 
/// Returned features may not necessarily be visible to the user at the time they
/// are loaded: the style may contain a layer that forces the sources tiles to
/// load but filters out the features in question, preventing them from being
/// drawn. To obtain only _visible_ features, use the
/// ``MLNMapView/visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:``
/// or
/// ``MLNMapView/visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:``
/// method.
/// 
/// @param sourceLayerIdentifiers The source layers to include in the query. Only
/// the features contained in these source layers are included in the returned
/// array. This array may not be empty.
/// @param predicate A predicate to filter the returned features. Use `nil` to
/// include all loaded features.
/// @return An array of objects conforming to the ``MLNFeature`` protocol that
/// represent features loaded by the source that match the predicate.
  objc.NSArray featuresInSourceLayersWithIdentifiers(objc.NSSet sourceLayerIdentifiers, {NSPredicate? predicate}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.pointer, _sel_featuresInSourceLayersWithIdentifiers_predicate_, sourceLayerIdentifiers.ref.pointer, predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNVectorTileSource init() {
  objc.checkOsVersionInternal('MLNVectorTileSource.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNVectorTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a source initialized with an identifier.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @return An initialized source.
  MLNVectorTileSource initWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNVectorTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a vector tile source initialized with an identifier and configuration
/// URL.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// The URL may be a full HTTP or HTTPS URL or a canonical
/// URL. The URL should point to a JSON file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param configurationURL A URL to a TileJSON configuration file describing the
/// sources contents and other metadata.
/// @return An initialized vector tile source.
  MLNVectorTileSource initWithIdentifier$1(objc.NSString identifier, {required objc.NSURL configurationURL}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_configurationURL_, identifier.ref.pointer, configurationURL.ref.pointer);
    return MLNVectorTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a vector tile source initialized with an identifier and a
/// string-based configuration URL.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// The string may be a full HTTP or HTTPS URL or a canonical URL. The string should
/// point to a JSON file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// 
/// This constructor can be used for URLs that cause problems with `NSURL`s URL
/// parsing behavior. For example, URLs starting with `pmtiles://https://` were
/// not parsed correctly on iOS17.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param configurationURLString A string to a TileJSON configuration file
/// describing the sources contents and other metadata.
/// @return An initialized vector tile source.
  MLNVectorTileSource initWithIdentifier$2(objc.NSString identifier, {required objc.NSString configurationURLString}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_configurationURLString_, identifier.ref.pointer, configurationURLString.ref.pointer);
    return MLNVectorTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a vector tile source initialized an identifier, tile URL templates, and
/// options.
/// 
/// Tile URL templates are strings that specify the URLs of the vector tiles to
/// load. See the <a href="../tile-url-templates.html">Tile URL Templates</a>
/// guide for information about the format of a tile URL template.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param tileURLTemplates An array of tile URL template strings. Only the first
/// string is used; any additional strings are ignored.
/// @param options A dictionary containing configuration options. See
/// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
/// the default values.
/// @return An initialized tile source.
  MLNVectorTileSource initWithIdentifier$3(objc.NSString identifier, {required objc.NSArray tileURLTemplates,objc.NSDictionary? options}) {
    final $ret = _objc_msgSend_11spmsz(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_tileURLTemplates_options_, identifier.ref.pointer, tileURLTemplates.ref.pointer, options?.ref.pointer ?? ffi.nullptr);
    return MLNVectorTileSource.fromPointer($ret, retain: false, release: true);
  }

}

late final _class_MLNShapeSource = objc.getClass("MLNShapeSource");
late final _sel_initWithIdentifier_URL_options_ = objc.registerName("initWithIdentifier:URL:options:");
late final _sel_initWithIdentifier_shape_options_ = objc.registerName("initWithIdentifier:shape:options:");
late final _sel_initWithIdentifier_features_options_ = objc.registerName("initWithIdentifier:features:options:");
late final _sel_initWithIdentifier_shapes_options_ = objc.registerName("initWithIdentifier:shapes:options:");
late final _sel_URL = objc.registerName("URL");
late final _sel_setURL_ = objc.registerName("setURL:");
late final _sel_featuresMatchingPredicate_ = objc.registerName("featuresMatchingPredicate:");
late final _sel_leavesOfCluster_offset_limit_ = objc.registerName("leavesOfCluster:offset:limit:");
final _objc_msgSend_17wuhyd = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , int )>();
late final _sel_childrenOfCluster_ = objc.registerName("childrenOfCluster:");
late final _sel_zoomLevelForExpandingCluster_ = objc.registerName("zoomLevelForExpandingCluster:");
final _objc_msgSend_mabicu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
final _objc_msgSend_mabicuFpret = objc.msgSendFpretPointer.cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<double Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// ``MLNShapeSource`` is a map content source that supplies vector shapes to be
/// shown on the map. The shapes may be instances of ``MLNShape`` or ``MLNShape``,
/// or they may be defined by local or external
/// <a href="http://geojson.org/">GeoJSON</a> code. A shape source is added to an
/// ``MLNStyle`` object along with an ``MLNStyle`` object. The vector style
/// layer defines the appearance of any content supplied by the shape source. You
/// can update a shape source by setting its `shape` or `URL` property.
/// 
/// ``MLNShapeSource`` is optimized for data sets that change dynamically and fit
/// completely in memory. For large data sets that do not fit completely in memory,
/// use the ``MLNComputedShapeSource`` or ``MLNComputedShapeSource`` class.
/// 
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-geojson"><code>geojson</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNShapeSource`` object that you can use to refine the maps content and
/// initialize new style layers. You can also add and remove sources dynamically
/// using methods such as ``MLNStyle/addSource:`` and
/// ``MLNStyle/sourceWithIdentifier:``.
/// 
/// Any vector style layer initialized with a shape source should have a `nil`
/// value in its `sourceLayerIdentifier` property.
/// 
/// ### Example
/// 
/// ```swift
/// var coordinates: [CLLocationCoordinate2D] = [
/// CLLocationCoordinate2D(latitude: 37.77, longitude: -122.42),
/// CLLocationCoordinate2D(latitude: 38.91, longitude: -77.04),
/// ]
/// let polyline = MLNPolylineFeature(coordinates: &coordinates, count: UInt(coordinates.count))
/// let source = MLNShapeSource(identifier: "lines", features: [polyline], options: nil)
/// mapView.style?.addSource(source)
/// ```
/// 
/// #### Related examples
/// TODO: Cluster point data
/// TODO: Use images to cluster point data
/// TODO: Add live data
/// Learn how to add data to your map using this ``MLNSource`` object.
extension type MLNShapeSource._(objc.ObjCObject object$) implements objc.ObjCObject,MLNSource {
  /// Constructs a [MLNShapeSource] that points to the same underlying object as [other].
  MLNShapeSource.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNShapeSource] that wraps the given raw object pointer.
  MLNShapeSource.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNShapeSource].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNShapeSource);

  /// alloc
  static MLNShapeSource alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNShapeSource, _sel_alloc);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNShapeSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNShapeSource, _sel_allocWithZone_, zone);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNShapeSource new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNShapeSource, _sel_new);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNShapeSource constructed with the default `new` method.
  MLNShapeSource() : this.as(new$().object$);

}

extension MLNShapeSource$Methods on MLNShapeSource {

  /// The URL to the GeoJSON document that specifies the contents of the source.
/// 
/// If the receiver was initialized using `-initWithIdentifier:shape:options:`,
/// this property is set to `nil`.
  objc.NSURL? get URL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0 ? null : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an array of map features that are the immediate children of the specified
/// cluster *on the next zoom level*. The may include features that also conform to
/// the ``MLNCluster`` protocol (currently only objects of type ``MLNCluster``).
/// 
/// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
/// ``MLNPointFeatureCluster`` protocol).
/// 
/// @return An array of objects that conform to the ``MLNFeature`` protocol.
/// 
/// > Note: The returned array may contain the `cluster` that was passed in, if the next
/// zoom level doesn't match the zoom level for expanding that cluster. See
/// ``MLNShapeSource/zoomLevelForExpandingCluster:``.
  objc.NSArray childrenOfCluster(MLNPointFeatureCluster cluster) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_childrenOfCluster_, cluster.ref.pointer);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Returns an array of map features for this source, filtered by the given
/// predicate.
/// 
/// Each object in the returned array represents a feature for the current style
/// and provides access to attributes specified via the `shape` property.
/// 
/// Features come from tiled GeoJSON data that is converted to tiles internally,
/// so feature geometries are clipped at tile boundaries and features
/// may appear duplicated across tiles. For example, suppose this source contains a
/// long polyline representing a road. The resulting array includes those parts of
/// the road that lie within the map tiles that the source has loaded, even if the
/// road extends into other tiles. The portion of the road within each map tile is
/// included individually.
/// 
/// Returned features may not necessarily be visible to the user at the time they
/// are loaded: the style may lack a layer that draws the features in question. To
/// obtain only _visible_ features, use the
/// ``MLNMapView/visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:predicate:``
/// or
/// ``MLNMapView/visibleFeaturesInRect:inStyleLayersWithIdentifiers:predicate:``
/// method.
/// 
/// @param predicate A predicate to filter the returned features. Use `nil` to
/// include all features in the source.
/// @return An array of objects conforming to the ``MLNFeature`` protocol that
/// represent features in the source that match the predicate.
  objc.NSArray featuresMatchingPredicate(NSPredicate? predicate) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_featuresMatchingPredicate_, predicate?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNShapeSource init() {
  objc.checkOsVersionInternal('MLNShapeSource.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a source initialized with an identifier.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @return An initialized source.
  MLNShapeSource initWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a shape source with an identifier, URL, and dictionary of options for
/// the source.
/// 
/// This class supports the following options: ``MLNShapeSourceOptionClustered``,
/// ``MLNShapeSourceOptionClusterRadius``,
/// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
/// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
/// ``MLNShapeSourceOptionBuffer``, and
/// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
/// source are not clipped or wrapped automatically.
/// 
/// @param identifier A string that uniquely identifies the source.
/// @param url An HTTP(S) URL, absolute file URL, or local file URL relative to the
/// current applications resource bundle.
/// @param options An `NSDictionary` of options for this source.
/// @return An initialized shape source.
/// 
/// #### Related examples
/// TODO: Add live data, learn how to add live data to your map by
/// updating the an ``MLNShapeSource`` object's `URL` property.
  MLNShapeSource initWithIdentifier$1(objc.NSString identifier, {required objc.NSURL URL,objc.NSDictionary? options}) {
    final $ret = _objc_msgSend_11spmsz(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_URL_options_, identifier.ref.pointer, URL.ref.pointer, options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a shape source with an identifier, an array of features, and a dictionary
/// of options for the source.
/// 
/// This class supports the following options: ``MLNShapeSourceOptionClustered``,
/// ``MLNShapeSourceOptionClusterRadius``,
/// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
/// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
/// ``MLNShapeSourceOptionBuffer``, and
/// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
/// source are not clipped or wrapped automatically.
/// 
/// Unlike `-initWithIdentifier:shapes:options:`, this method accepts ``MLNFeature``
/// instances, such as ``MLNPointFeature`` objects, whose attributes you can use when
/// applying a predicate to ``MLNVectorStyleLayer`` or configuring a style layers
/// appearance.
/// 
/// To create a shape from GeoJSON source code, use the
/// ``MLNShape/shapeWithData:encoding:error:`` method.
/// 
/// @param identifier A string that uniquely identifies the source.
/// @param features An array of objects that conform to the MLNFeature protocol.
/// @param options An `NSDictionary` of options for this source.
/// @return An initialized shape source.
  MLNShapeSource initWithIdentifier$2(objc.NSString identifier, {required objc.NSArray features,objc.NSDictionary? options}) {
    final $ret = _objc_msgSend_11spmsz(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_features_options_, identifier.ref.pointer, features.ref.pointer, options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a shape source with an identifier, a shape, and dictionary of options
/// for the source.
/// 
/// This class supports the following options: ``MLNShapeSourceOptionClustered``,
/// ``MLNShapeSourceOptionClusterRadius``, ``MLNShapeSourceOptionClusterMinPoints``,
/// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
/// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
/// ``MLNShapeSourceOptionBuffer``, and
/// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
/// source are not clipped or wrapped automatically.
/// 
/// To specify attributes about the shape, use an instance of an ``MLNShape``
/// subclass that conforms to the ``MLNFeature`` protocol, such as ``MLNFeature``.
/// To include multiple shapes in the source, use an ``MLNShapeCollection`` or
/// ``MLNShapeCollectionFeature`` object, or use the
/// `-initWithIdentifier:features:options:` or
/// `-initWithIdentifier:shapes:options:` methods.
/// 
/// To create a shape from GeoJSON source code, use the
/// ``MLNShape/shapeWithData:encoding:error:`` method.
/// 
/// @param identifier A string that uniquely identifies the source.
/// @param shape A concrete subclass of ``MLNShape``
/// @param options An `NSDictionary` of options for this source.
/// @return An initialized shape source.
/// 
/// #### Related examples
/// TODO: Animate a line, learn how to animate line data by continously
/// updating an ``MLNShapeSource``'s `shape` attribute.
  MLNShapeSource initWithIdentifier$3(objc.NSString identifier, {MLNShape? shape,objc.NSDictionary? options}) {
    final $ret = _objc_msgSend_11spmsz(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_shape_options_, identifier.ref.pointer, shape?.ref.pointer ?? ffi.nullptr, options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a shape source with an identifier, an array of shapes, and a dictionary of
/// options for the source.
/// 
/// This class supports the following options: ``MLNShapeSourceOptionClustered``,
/// ``MLNShapeSourceOptionClusterRadius``,
/// ``MLNShapeSourceOptionMaximumZoomLevelForClustering``,
/// ``MLNShapeSourceOptionMinimumZoomLevel``, ``MLNShapeSourceOptionMinimumZoomLevel``,
/// ``MLNShapeSourceOptionBuffer``, and
/// ``MLNShapeSourceOptionSimplificationTolerance``. Shapes provided by a shape
/// source are not clipped or wrapped automatically.
/// 
/// Any ``MLNFeature`` instance passed into this initializer is treated as an ordinary
/// shape, causing any attributes to be inaccessible to an ``MLNVectorStyleLayer`` when
/// evaluating a predicate or configuring certain layout or paint attributes. To
/// preserve the attributes associated with each feature, use the
/// `-initWithIdentifier:features:options:` method instead.
/// 
/// To create a shape from GeoJSON source code, use the
/// ``MLNShape/shapeWithData:encoding:error:`` method.
/// 
/// @param identifier A string that uniquely identifies the source.
/// @param shapes An array of shapes; each shape is a member of a concrete subclass of MLNShape.
/// @param options An `NSDictionary` of options for this source.
/// @return An initialized shape source.
  MLNShapeSource initWithIdentifier$4(objc.NSString identifier, {required objc.NSArray shapes,objc.NSDictionary? options}) {
    final $ret = _objc_msgSend_11spmsz(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_shapes_options_, identifier.ref.pointer, shapes.ref.pointer, options?.ref.pointer ?? ffi.nullptr);
    return MLNShapeSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an array of map features that are the leaves of the specified cluster.
/// ("Leaves" are the original points that belong to the cluster.)
/// 
/// This method supports pagination; you supply an offset (number of features to skip)
/// and a maximum number of features to return.
/// 
/// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
/// ``MLNPointFeatureCluster`` protocol).
/// @param offset Number of features to skip.
/// @param limit The maximum number of features to return
/// 
/// @return An array of objects that conform to the ``MLNFeature`` protocol.
  objc.NSArray leavesOfCluster(MLNPointFeatureCluster cluster, {required int offset,required int limit}) {
    final $ret = _objc_msgSend_17wuhyd(object$.ref.pointer, _sel_leavesOfCluster_offset_limit_, cluster.ref.pointer, offset, limit);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// The contents of the source. A shape can represent a GeoJSON geometry, a
/// feature, or a collection of features.
/// 
/// If the receiver was initialized using `-initWithIdentifier:URL:options:`, this
/// property is set to `nil`. This property is unavailable until the receiver is
/// passed into ``MLNStyle/addSource:``.
/// 
/// You can get/set the shapes within a collection via this property. Actions must
/// be performed on the application's main thread.
  set shape(MLNShape? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setShape_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// The URL to the GeoJSON document that specifies the contents of the source.
/// 
/// If the receiver was initialized using `-initWithIdentifier:shape:options:`,
/// this property is set to `nil`.
  set URL(objc.NSURL? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// The contents of the source. A shape can represent a GeoJSON geometry, a
/// feature, or a collection of features.
/// 
/// If the receiver was initialized using `-initWithIdentifier:URL:options:`, this
/// property is set to `nil`. This property is unavailable until the receiver is
/// passed into ``MLNStyle/addSource:``.
/// 
/// You can get/set the shapes within a collection via this property. Actions must
/// be performed on the application's main thread.
  MLNShape? get shape {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_shape);
    return $ret.address == 0 ? null : MLNShape.fromPointer($ret, retain: true, release: true);
  }


  /// Returns the zoom level at which the given cluster expands.
/// 
/// @param cluster An object of type ``MLNPointFeatureCluster`` (that conforms to the
/// ``MLNPointFeatureCluster`` protocol).
/// 
/// @return Zoom level. This should be >= 0; any negative return value should be
/// considered an error.
  double zoomLevelForExpandingCluster(MLNPointFeatureCluster cluster) {
    return objc.useMsgSendVariants ? _objc_msgSend_mabicuFpret(object$.ref.pointer, _sel_zoomLevelForExpandingCluster_, cluster.ref.pointer) : _objc_msgSend_mabicu(object$.ref.pointer, _sel_zoomLevelForExpandingCluster_, cluster.ref.pointer);

  }

}

late final _class_MLNImageSource = objc.getClass("MLNImageSource");
late final _sel_initWithIdentifier_coordinateQuad_URL_ = objc.registerName("initWithIdentifier:coordinateQuad:URL:");
final _objc_msgSend_judg3a = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , MLNCoordinateQuad , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , MLNCoordinateQuad , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_initWithIdentifier_coordinateQuad_image_ = objc.registerName("initWithIdentifier:coordinateQuad:image:");
final _objc_msgSend_1ua371c = objc.msgSendPointer.cast<ffi.NativeFunction<MLNCoordinateQuad Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<MLNCoordinateQuad Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_1ua371cStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MLNCoordinateQuad> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<MLNCoordinateQuad> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setCoordinates_ = objc.registerName("setCoordinates:");
final _objc_msgSend_1wvd2xm = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateQuad )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , MLNCoordinateQuad )>();

/// ``MLNImageSource`` is a content source that is used for a georeferenced raster
/// image to be shown on the map. The georeferenced image scales and rotates as the
/// user zooms and rotates the map. Images may also be used as icons or patterns
/// in a style layer. To register an image for use as an icon or pattern,
/// use the ``MLNStyle/setImage:forName:`` method. To configure a point
/// annotations image, use the ``MLNAnnotationImage`` class.
/// 
/// The geographic location of the raster image content, supplied with
/// ``MLNCoordinateQuad``, can be non-axis aligned.
/// ``MLNImageSource`` supports raster content from `NSURL`, `NSImage` (macOS), or
/// `UIImage` (iOS).
/// An image source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` objects. Use a raster style layer to control the
/// appearance of content supplied by the image source.
/// 
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-image"><code>image</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNImageSource`` object that you can use to initialize new style layers. You
/// can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
/// 
/// ### Example
/// 
/// ```swift
/// let coordinates = MLNCoordinateQuad(
/// topLeft: CLLocationCoordinate2D(latitude: 46.437, longitude: -80.425),
/// bottomLeft: CLLocationCoordinate2D(latitude: 37.936, longitude: -80.425),
/// bottomRight: CLLocationCoordinate2D(latitude: 37.936, longitude: -71.516),
/// topRight: CLLocationCoordinate2D(latitude: 46.437, longitude: -71.516))
/// let source = MLNImageSource(identifier: "radar", coordinateQuad: coordinates, url: URL(string:
/// "https://maplibre.org/maplibre-gl-js-docs/assets/radar.gif")!) mapView.style?.addSource(source)
/// ```
/// 
/// #### Related examples
/// TODO: Add an image, learn how to add an image to your map using ``MLNImageSource``.
extension type MLNImageSource._(objc.ObjCObject object$) implements objc.ObjCObject,MLNSource {
  /// Constructs a [MLNImageSource] that points to the same underlying object as [other].
  MLNImageSource.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNImageSource] that wraps the given raw object pointer.
  MLNImageSource.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNImageSource].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNImageSource);

  /// alloc
  static MLNImageSource alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNImageSource, _sel_alloc);
    return MLNImageSource.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNImageSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNImageSource, _sel_allocWithZone_, zone);
    return MLNImageSource.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNImageSource new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNImageSource, _sel_new);
    return MLNImageSource.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNImageSource constructed with the default `new` method.
  MLNImageSource() : this.as(new$().object$);

}

extension MLNImageSource$Methods on MLNImageSource {

  /// The URL to the source image.
/// 
/// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:image:` or
/// the `image` property is set, this property is set to `nil`.
  objc.NSURL? get URL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0 ? null : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }


  /// The coordinates at which the corners of the source image will be placed.
  MLNCoordinateQuad get coordinates {
    final $ptr = pkg_ffi.calloc<MLNCoordinateQuad>();
    objc.useMsgSendVariants ? _objc_msgSend_1ua371cStret($ptr, object$.ref.pointer, _sel_coordinates) : $ptr.ref = _objc_msgSend_1ua371c(object$.ref.pointer, _sel_coordinates);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateQuad>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateQuad>(
        $finalizable);

  }


  /// The source image.
/// 
/// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:URL:` or if the `URL`
/// property is set, this property is set to `nil`.
  UIImage? get image {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_image);
    return $ret.address == 0 ? null : UIImage.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNImageSource init() {
  objc.checkOsVersionInternal('MLNImageSource.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNImageSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a source initialized with an identifier.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @return An initialized source.
  MLNImageSource initWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNImageSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a georeferenced image source with an identifier, coordinates and a URL.
/// 
/// @param identifier A string that uniquely identifies the source.
/// @param coordinateQuad the top left, top right, bottom right, and bottom left coordinates for the
/// image.
/// @param url An HTTP(S) URL, absolute file URL, or local file URL relative to the
/// current applications resource bundle.
/// @return An initialized shape source.
  MLNImageSource initWithIdentifier$1(objc.NSString identifier, {required MLNCoordinateQuad coordinateQuad,required objc.NSURL URL}) {
    final $ret = _objc_msgSend_judg3a(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_coordinateQuad_URL_, identifier.ref.pointer, coordinateQuad, URL.ref.pointer);
    return MLNImageSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a georeferenced image source with an identifier, coordinates and an image.
/// 
/// @param identifier A string that uniquely identifies the source.
/// @param coordinateQuad The top left, top right, bottom right, and bottom left coordinates for the
/// image.
/// @param image The image to display for the source.
/// @return An initialized shape source.
  MLNImageSource initWithIdentifier$2(objc.NSString identifier, {required MLNCoordinateQuad coordinateQuad,required UIImage image}) {
    final $ret = _objc_msgSend_judg3a(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_coordinateQuad_image_, identifier.ref.pointer, coordinateQuad, image.ref.pointer);
    return MLNImageSource.fromPointer($ret, retain: false, release: true);
  }


  /// The coordinates at which the corners of the source image will be placed.
  set coordinates(MLNCoordinateQuad value) {
_objc_msgSend_1wvd2xm(object$.ref.pointer, _sel_setCoordinates_, value);

  }


  /// The source image.
/// 
/// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:URL:` or if the `URL`
/// property is set, this property is set to `nil`.
  set image(UIImage? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// The URL to the source image.
/// 
/// If the receiver was initialized using `-initWithIdentifier:coordinateQuad:image:` or
/// the `image` property is set, this property is set to `nil`.
  set URL(objc.NSURL? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);

  }

}

late final _class_MLNRasterTileSource = objc.getClass("MLNRasterTileSource");
late final _sel_initWithIdentifier_configurationURL_tileSize_ = objc.registerName("initWithIdentifier:configurationURL:tileSize:");
final _objc_msgSend_hzzkpm = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , double )>();

/// ``MLNRasterTileSource`` is a map content source that supplies raster image tiles
/// to be shown on the map. The location of and metadata about the tiles are
/// defined either by an option dictionary or by an external file that conforms to
/// the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A raster tile source is added to an ``MLNStyle`` object along with one or more
/// ``MLNRasterStyleLayer`` objects. Use a raster style layer to control the
/// appearance of content supplied by the raster tile source.
/// 
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-raster"><code>raster</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNRasterTileSource`` object that you can use to initialize new style layers. You
/// can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
/// 
/// ### Example
/// 
/// ```swift
/// let source = MLNRasterTileSource(identifier: "clouds", tileURLTemplates:
/// ["https://example.com/raster-tiles/{z}/{x}/{y}.png"], options: [ .minimumZoomLevel: 9,
/// .maximumZoomLevel: 16,
/// .tileSize: 512,
/// .attributionInfos: [
/// MLNAttributionInfo(title: NSAttributedString(string: " Mapbox"), url: URL(string:
/// "https://mapbox.com"))
/// ]
/// ])
/// mapView.style?.addSource(source)
/// ```
/// 
/// #### Related examples
/// TODO: Add raster imagery, learn how to add a ``MLNRasterStyleLayer``
/// to your map using an ``MLNRasterTileSource``.
extension type MLNRasterTileSource._(objc.ObjCObject object$) implements objc.ObjCObject,MLNTileSource {
  /// Constructs a [MLNRasterTileSource] that points to the same underlying object as [other].
  MLNRasterTileSource.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNRasterTileSource] that wraps the given raw object pointer.
  MLNRasterTileSource.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNRasterTileSource].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterTileSource);

  /// alloc
  static MLNRasterTileSource alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNRasterTileSource, _sel_alloc);
    return MLNRasterTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNRasterTileSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNRasterTileSource, _sel_allocWithZone_, zone);
    return MLNRasterTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNRasterTileSource new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNRasterTileSource, _sel_new);
    return MLNRasterTileSource.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNRasterTileSource constructed with the default `new` method.
  MLNRasterTileSource() : this.as(new$().object$);

}

extension MLNRasterTileSource$Methods on MLNRasterTileSource {

  /// init
  MLNRasterTileSource init() {
  objc.checkOsVersionInternal('MLNRasterTileSource.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a source initialized with an identifier.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @return An initialized source.
  MLNRasterTileSource initWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNRasterTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a raster tile source initialized with an identifier and configuration
/// URL.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// The URL may be a full HTTP or HTTPS URL or canonical URL. The URL should
/// point to a JSON file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// 
/// If a Mapbox URL is specified, this source uses a tile size of 256. For all
/// other tilesets, the default value is 512. (See the
/// ``MLNTileSourceOptionTileSize`` documentation for more information about tile
/// sizes.) If you need to use a tile size other than the default, use the
/// `-initWithIdentifier:configurationURL:tileSize:` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param configurationURL A URL to a TileJSON configuration file describing the
/// sources contents and other metadata.
/// @return An initialized raster tile source.
  MLNRasterTileSource initWithIdentifier$1(objc.NSString identifier, {required objc.NSURL configurationURL}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_configurationURL_, identifier.ref.pointer, configurationURL.ref.pointer);
    return MLNRasterTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a raster tile source initialized with an identifier, configuration URL,
/// and tile size.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// The URL may be a full HTTP or HTTPS URL or, canonical URL. The URL should
/// point to a JSON file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param configurationURL A URL to a TileJSON configuration file describing the
/// sources contents and other metadata.
/// @param tileSize The width and height (measured in points) of each tiled image
/// in the raster tile source. See the ``MLNTileSourceOptionTileSize``
/// documentation for details.
/// @return An initialized raster tile source.
  MLNRasterTileSource initWithIdentifier$2(objc.NSString identifier, {required objc.NSURL configurationURL,required double tileSize}) {
    final $ret = _objc_msgSend_hzzkpm(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_configurationURL_tileSize_, identifier.ref.pointer, configurationURL.ref.pointer, tileSize);
    return MLNRasterTileSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a raster tile source initialized an identifier, tile URL templates, and
/// options.
/// 
/// Tile URL templates are strings that specify the URLs of the raster tile images
/// to load. See the <a href="../tile-url-templates.html">Tile URL Templates</a>
/// guide for information about the format of a tile URL template.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param tileURLTemplates An array of tile URL template strings. Only the first
/// string is used; any additional strings are ignored.
/// @param options A dictionary containing configuration options. See
/// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
/// the default values.
/// @return An initialized tile source.
  MLNRasterTileSource initWithIdentifier$3(objc.NSString identifier, {required objc.NSArray tileURLTemplates,objc.NSDictionary? options}) {
    final $ret = _objc_msgSend_11spmsz(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_tileURLTemplates_options_, identifier.ref.pointer, tileURLTemplates.ref.pointer, options?.ref.pointer ?? ffi.nullptr);
    return MLNRasterTileSource.fromPointer($ret, retain: false, release: true);
  }

}

late final _class_MLNRasterDEMSource = objc.getClass("MLNRasterDEMSource");

/// ``MLNRasterDEMSource`` is a map content source that supplies rasterized
/// <a href="https://en.wikipedia.org/wiki/Digital_elevation_model">digital elevation model</a>
/// (DEM) tiles to be shown on the map. The location of and metadata about the
/// tiles are defined either by an option dictionary or by an external file that
/// conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// A raster DEM source is added to an ``MLNStyle`` object along with one or more
/// ``MLNHillshadeStyleLayer`` objects. Use a hillshade style layer to control the
/// appearance of content supplied by the raster DEM source.
/// 
/// Each
/// <a href="https://maplibre.org/maplibre-style-spec/#sources-raster-dem"><code>raster-dem</code></a>
/// source defined by the style JSON file is represented at runtime by an
/// ``MLNRasterDEMSource`` object that you can use to initialize new style layers.
/// You can also add and remove sources dynamically using methods such as
/// ``MLNStyle/addSource:`` and ``MLNStyle/sourceWithIdentifier:``.
/// 
/// Currently, raster DEM sources only support the format used by
/// <a
/// href="https://docs.mapbox.com/help/troubleshooting/access-elevation-data/#mapbox-terrain-rgb">Mapbox
/// Terrain-RGB</a>.
/// 
/// ### Example
/// 
/// ```swift
/// let terrainRGBURL = URL(string: "maptiler://sources/terrain-rgb")!
/// let source = MLNRasterDEMSource(identifier: "hills", configurationURL: terrainRGBURL)
/// mapView.style?.addSource(source)
/// ```
extension type MLNRasterDEMSource._(objc.ObjCObject object$) implements objc.ObjCObject,MLNRasterTileSource {
  /// Constructs a [MLNRasterDEMSource] that points to the same underlying object as [other].
  MLNRasterDEMSource.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNRasterDEMSource] that wraps the given raw object pointer.
  MLNRasterDEMSource.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNRasterDEMSource].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterDEMSource);

  /// alloc
  static MLNRasterDEMSource alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNRasterDEMSource, _sel_alloc);
    return MLNRasterDEMSource.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNRasterDEMSource allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNRasterDEMSource, _sel_allocWithZone_, zone);
    return MLNRasterDEMSource.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNRasterDEMSource new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNRasterDEMSource, _sel_new);
    return MLNRasterDEMSource.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNRasterDEMSource constructed with the default `new` method.
  MLNRasterDEMSource() : this.as(new$().object$);

}

extension MLNRasterDEMSource$Methods on MLNRasterDEMSource {

  /// init
  MLNRasterDEMSource init() {
  objc.checkOsVersionInternal('MLNRasterDEMSource.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterDEMSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a source initialized with an identifier.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @return An initialized source.
  MLNRasterDEMSource initWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNRasterDEMSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a raster tile source initialized with an identifier and configuration
/// URL.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// The URL may be a full HTTP or HTTPS URL or canonical URL. The URL should
/// point to a JSON file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// 
/// If a Mapbox URL is specified, this source uses a tile size of 256. For all
/// other tilesets, the default value is 512. (See the
/// ``MLNTileSourceOptionTileSize`` documentation for more information about tile
/// sizes.) If you need to use a tile size other than the default, use the
/// `-initWithIdentifier:configurationURL:tileSize:` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param configurationURL A URL to a TileJSON configuration file describing the
/// sources contents and other metadata.
/// @return An initialized raster tile source.
  MLNRasterDEMSource initWithIdentifier$1(objc.NSString identifier, {required objc.NSURL configurationURL}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_configurationURL_, identifier.ref.pointer, configurationURL.ref.pointer);
    return MLNRasterDEMSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a raster tile source initialized with an identifier, configuration URL,
/// and tile size.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// The URL may be a full HTTP or HTTPS URL or, canonical URL. The URL should
/// point to a JSON file that conforms to the
/// <a href="https://github.com/mapbox/tilejson-spec/">TileJSON specification</a>.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param configurationURL A URL to a TileJSON configuration file describing the
/// sources contents and other metadata.
/// @param tileSize The width and height (measured in points) of each tiled image
/// in the raster tile source. See the ``MLNTileSourceOptionTileSize``
/// documentation for details.
/// @return An initialized raster tile source.
  MLNRasterDEMSource initWithIdentifier$2(objc.NSString identifier, {required objc.NSURL configurationURL,required double tileSize}) {
    final $ret = _objc_msgSend_hzzkpm(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_configurationURL_tileSize_, identifier.ref.pointer, configurationURL.ref.pointer, tileSize);
    return MLNRasterDEMSource.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a raster tile source initialized an identifier, tile URL templates, and
/// options.
/// 
/// Tile URL templates are strings that specify the URLs of the raster tile images
/// to load. See the <a href="../tile-url-templates.html">Tile URL Templates</a>
/// guide for information about the format of a tile URL template.
/// 
/// After initializing and configuring the source, add it to a map views style
/// using the ``MLNStyle/addSource:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param tileURLTemplates An array of tile URL template strings. Only the first
/// string is used; any additional strings are ignored.
/// @param options A dictionary containing configuration options. See
/// ``MLNTileSourceOption`` for available keys and values. Pass in `nil` to use
/// the default values.
/// @return An initialized tile source.
  MLNRasterDEMSource initWithIdentifier$3(objc.NSString identifier, {required objc.NSArray tileURLTemplates,objc.NSDictionary? options}) {
    final $ret = _objc_msgSend_11spmsz(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_tileURLTemplates_options_, identifier.ref.pointer, tileURLTemplates.ref.pointer, options?.ref.pointer ?? ffi.nullptr);
    return MLNRasterDEMSource.fromPointer($ret, retain: false, release: true);
  }

}

late final _class_MLNBackgroundStyleLayer = objc.getClass("MLNBackgroundStyleLayer");
late final _sel_backgroundColorTransition = objc.registerName("backgroundColorTransition");
late final _sel_setBackgroundColorTransition_ = objc.registerName("setBackgroundColorTransition:");
late final _sel_backgroundOpacity = objc.registerName("backgroundOpacity");
late final _sel_setBackgroundOpacity_ = objc.registerName("setBackgroundOpacity:");
late final _sel_backgroundOpacityTransition = objc.registerName("backgroundOpacityTransition");
late final _sel_setBackgroundOpacityTransition_ = objc.registerName("setBackgroundOpacityTransition:");
late final _sel_backgroundPattern = objc.registerName("backgroundPattern");
late final _sel_setBackgroundPattern_ = objc.registerName("setBackgroundPattern:");
late final _sel_backgroundPatternTransition = objc.registerName("backgroundPatternTransition");
late final _sel_setBackgroundPatternTransition_ = objc.registerName("setBackgroundPatternTransition:");

/// An ``MLNBackgroundStyleLayer`` is a style layer that covers the entire map. Use
/// a background style layer to configure a color or pattern to show below all
/// other map content. If the styles other layers use the Mapbox Streets source,
/// the background style layer is responsible for drawing land, whereas the oceans
/// and other bodies of water are drawn by ``MLNBackgroundStyleLayer`` objects.
/// 
/// A background style layer is typically the bottommost layer in a style, because
/// it covers the entire map and can occlude any layers below it. You can therefore
/// access it by getting the last item in the ``MLNStyle/layers`` array.
/// 
/// If the background style layer is transparent or omitted from the style, any
/// portion of the map view that does not show another style layer is transparent.
extension type MLNBackgroundStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNStyleLayer {
  /// Constructs a [MLNBackgroundStyleLayer] that points to the same underlying object as [other].
  MLNBackgroundStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNBackgroundStyleLayer] that wraps the given raw object pointer.
  MLNBackgroundStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNBackgroundStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNBackgroundStyleLayer);

  /// alloc
  static MLNBackgroundStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNBackgroundStyleLayer, _sel_alloc);
    return MLNBackgroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNBackgroundStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNBackgroundStyleLayer, _sel_allocWithZone_, zone);
    return MLNBackgroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNBackgroundStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNBackgroundStyleLayer, _sel_new);
    return MLNBackgroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNBackgroundStyleLayer constructed with the default `new` method.
  MLNBackgroundStyleLayer() : this.as(new$().object$);

}

extension MLNBackgroundStyleLayer$Methods on MLNBackgroundStyleLayer {

  /// The color with which the background will be drawn.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `backgroundPattern` is set to
/// `nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get backgroundColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_backgroundColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `backgroundColor` property.
/// 
/// This property corresponds to the `background-color-transition` property in the style JSON file format.
  MLNTransition get backgroundColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_backgroundColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_backgroundColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The opacity at which the background will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get backgroundOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_backgroundOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `backgroundOpacity` property.
/// 
/// This property corresponds to the `background-opacity-transition` property in the style JSON file format.
  MLNTransition get backgroundOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_backgroundOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_backgroundOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Name of image in style images to use for drawing an image background. For
/// seamless patterns, image width and height must be a factor of two (2, 4, 8,
/// ..., 512).
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get backgroundPattern {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_backgroundPattern);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `backgroundPattern` property.
/// 
/// This property corresponds to the `background-pattern-transition` property in the style JSON file format.
  MLNTransition get backgroundPatternTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_backgroundPatternTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_backgroundPatternTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// init
  MLNBackgroundStyleLayer init() {
  objc.checkOsVersionInternal('MLNBackgroundStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNBackgroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a background style layer initialized with an identifier.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
  MLNBackgroundStyleLayer initWithIdentifier(objc.NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_, identifier.ref.pointer);
    return MLNBackgroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// The color with which the background will be drawn.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `backgroundPattern` is set to
/// `nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set backgroundColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBackgroundColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `backgroundColor` property.
/// 
/// This property corresponds to the `background-color-transition` property in the style JSON file format.
  set backgroundColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setBackgroundColorTransition_, value);

  }


  /// The opacity at which the background will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set backgroundOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBackgroundOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `backgroundOpacity` property.
/// 
/// This property corresponds to the `background-opacity-transition` property in the style JSON file format.
  set backgroundOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setBackgroundOpacityTransition_, value);

  }


  /// Name of image in style images to use for drawing an image background. For
/// seamless patterns, image width and height must be a factor of two (2, 4, 8,
/// ..., 512).
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set backgroundPattern(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setBackgroundPattern_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `backgroundPattern` property.
/// 
/// This property corresponds to the `background-pattern-transition` property in the style JSON file format.
  set backgroundPatternTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setBackgroundPatternTransition_, value);

  }

}

late final _class_MLNForegroundStyleLayer = objc.getClass("MLNForegroundStyleLayer");
late final _sel_sourceIdentifier = objc.registerName("sourceIdentifier");

/// ``MLNForegroundStyleLayer`` is an abstract superclass for style layers whose
/// content is defined by an ``MLNSource`` object.
/// 
/// Create instances of ``MLNRasterStyleLayer``, ``MLNRasterStyleLayer``, and the
/// concrete subclasses of ``MLNVectorStyleLayer`` in order to use
/// ``MLNForegroundStyleLayer``'s methods. Do not create instances of
/// ``MLNForegroundStyleLayer`` directly, and do not create your own subclasses of
/// this class.
extension type MLNForegroundStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNStyleLayer {
  /// Constructs a [MLNForegroundStyleLayer] that points to the same underlying object as [other].
  MLNForegroundStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNForegroundStyleLayer] that wraps the given raw object pointer.
  MLNForegroundStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNForegroundStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNForegroundStyleLayer);

  /// alloc
  static MLNForegroundStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNForegroundStyleLayer, _sel_alloc);
    return MLNForegroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNForegroundStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNForegroundStyleLayer, _sel_allocWithZone_, zone);
    return MLNForegroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNForegroundStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNForegroundStyleLayer, _sel_new);
    return MLNForegroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNForegroundStyleLayer constructed with the default `new` method.
  MLNForegroundStyleLayer() : this.as(new$().object$);

}

extension MLNForegroundStyleLayer$Methods on MLNForegroundStyleLayer {

  /// init
  MLNForegroundStyleLayer init() {
  objc.checkOsVersionInternal('MLNForegroundStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNForegroundStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Identifier of the source from which the receiver obtains the data to style.
  objc.NSString? get sourceIdentifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sourceIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNVectorStyleLayer = objc.getClass("MLNVectorStyleLayer");
late final _sel_sourceLayerIdentifier = objc.registerName("sourceLayerIdentifier");
late final _sel_setSourceLayerIdentifier_ = objc.registerName("setSourceLayerIdentifier:");
late final _sel_setPredicate_ = objc.registerName("setPredicate:");

/// ``MLNVectorStyleLayer`` is an abstract superclass for style layers whose content
/// is defined by an ``MLNShapeSource`` or ``MLNShapeSource`` object.
/// 
/// Create instances of ``MLNCircleStyleLayer``, ``MLNCircleStyleLayer``,
/// ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``, and
/// ``MLNSymbolStyleLayer`` in order to use ``MLNSymbolStyleLayer``'s properties and
/// methods. Do not create instances of ``MLNVectorStyleLayer`` directly, and do not
/// create your own subclasses of this class.
extension type MLNVectorStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNForegroundStyleLayer {
  /// Constructs a [MLNVectorStyleLayer] that points to the same underlying object as [other].
  MLNVectorStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNVectorStyleLayer] that wraps the given raw object pointer.
  MLNVectorStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNVectorStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNVectorStyleLayer);

  /// alloc
  static MLNVectorStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNVectorStyleLayer, _sel_alloc);
    return MLNVectorStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNVectorStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNVectorStyleLayer, _sel_allocWithZone_, zone);
    return MLNVectorStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNVectorStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNVectorStyleLayer, _sel_new);
    return MLNVectorStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNVectorStyleLayer constructed with the default `new` method.
  MLNVectorStyleLayer() : this.as(new$().object$);

}

extension MLNVectorStyleLayer$Methods on MLNVectorStyleLayer {

  /// init
  MLNVectorStyleLayer init() {
  objc.checkOsVersionInternal('MLNVectorStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNVectorStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// The style layers predicate.
/// 
/// Use the style layers predicate to include only the features in the source
/// layer that satisfy a condition that you define. If the style layer initially
/// comes from the style, its predicate corresponds to the
/// <a href="https://maplibre.org/maplibre-style-spec/#layer-filter">`filter`</a>
/// property in the style JSON.
/// 
/// See the <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for details about the predicate syntax supported by this class.
/// 
/// ### Example
/// 
/// To filter the layer to include only the features whose `index` attribute is 5
/// or 10 and whose `ele` attribute is at least 1,500, you could create an
/// `NSCompoundPredicate` along these lines:
/// 
/// ```swift
/// let layer = MLNLineStyleLayer(identifier: "contour", source: terrain)
/// layer.sourceLayerIdentifier = "contours"
/// layer.predicate = NSPredicate(format: "(index == 5 || index == 10) && CAST(ele, 'NSNumber') >=
/// 1500.0") mapView.style?.addLayer(layer)
/// ```
  NSPredicate? get predicate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_predicate);
    return $ret.address == 0 ? null : NSPredicate.fromPointer($ret, retain: true, release: true);
  }


  /// The style layers predicate.
/// 
/// Use the style layers predicate to include only the features in the source
/// layer that satisfy a condition that you define. If the style layer initially
/// comes from the style, its predicate corresponds to the
/// <a href="https://maplibre.org/maplibre-style-spec/#layer-filter">`filter`</a>
/// property in the style JSON.
/// 
/// See the <a href="../predicates-and-expressions.html">Predicates and Expressions</a>
/// guide for details about the predicate syntax supported by this class.
/// 
/// ### Example
/// 
/// To filter the layer to include only the features whose `index` attribute is 5
/// or 10 and whose `ele` attribute is at least 1,500, you could create an
/// `NSCompoundPredicate` along these lines:
/// 
/// ```swift
/// let layer = MLNLineStyleLayer(identifier: "contour", source: terrain)
/// layer.sourceLayerIdentifier = "contours"
/// layer.predicate = NSPredicate(format: "(index == 5 || index == 10) && CAST(ele, 'NSNumber') >=
/// 1500.0") mapView.style?.addLayer(layer)
/// ```
  set predicate(NSPredicate? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setPredicate_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// Identifier of the layer within the source identified by the `sourceIdentifier`
/// property from which the receiver obtains the data to style.
  set sourceLayerIdentifier(objc.NSString? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSourceLayerIdentifier_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// Identifier of the layer within the source identified by the `sourceIdentifier`
/// property from which the receiver obtains the data to style.
  objc.NSString? get sourceLayerIdentifier {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sourceLayerIdentifier);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNCircleStyleLayer = objc.getClass("MLNCircleStyleLayer");
late final _sel_initWithIdentifier_source_ = objc.registerName("initWithIdentifier:source:");
late final _sel_circleSortKey = objc.registerName("circleSortKey");
late final _sel_setCircleSortKey_ = objc.registerName("setCircleSortKey:");
late final _sel_circleBlur = objc.registerName("circleBlur");
late final _sel_setCircleBlur_ = objc.registerName("setCircleBlur:");
late final _sel_circleBlurTransition = objc.registerName("circleBlurTransition");
late final _sel_setCircleBlurTransition_ = objc.registerName("setCircleBlurTransition:");
late final _sel_circleColor = objc.registerName("circleColor");
late final _sel_setCircleColor_ = objc.registerName("setCircleColor:");
late final _sel_circleColorTransition = objc.registerName("circleColorTransition");
late final _sel_setCircleColorTransition_ = objc.registerName("setCircleColorTransition:");
late final _sel_circleOpacity = objc.registerName("circleOpacity");
late final _sel_setCircleOpacity_ = objc.registerName("setCircleOpacity:");
late final _sel_circleOpacityTransition = objc.registerName("circleOpacityTransition");
late final _sel_setCircleOpacityTransition_ = objc.registerName("setCircleOpacityTransition:");
late final _sel_circlePitchAlignment = objc.registerName("circlePitchAlignment");
late final _sel_setCirclePitchAlignment_ = objc.registerName("setCirclePitchAlignment:");
late final _sel_circleRadius = objc.registerName("circleRadius");
late final _sel_setCircleRadius_ = objc.registerName("setCircleRadius:");
late final _sel_circleRadiusTransition = objc.registerName("circleRadiusTransition");
late final _sel_setCircleRadiusTransition_ = objc.registerName("setCircleRadiusTransition:");
late final _sel_circleScaleAlignment = objc.registerName("circleScaleAlignment");
late final _sel_setCircleScaleAlignment_ = objc.registerName("setCircleScaleAlignment:");
late final _sel_circlePitchScale = objc.registerName("circlePitchScale");
late final _sel_setCirclePitchScale_ = objc.registerName("setCirclePitchScale:");
late final _sel_circleStrokeColor = objc.registerName("circleStrokeColor");
late final _sel_setCircleStrokeColor_ = objc.registerName("setCircleStrokeColor:");
late final _sel_circleStrokeColorTransition = objc.registerName("circleStrokeColorTransition");
late final _sel_setCircleStrokeColorTransition_ = objc.registerName("setCircleStrokeColorTransition:");
late final _sel_circleStrokeOpacity = objc.registerName("circleStrokeOpacity");
late final _sel_setCircleStrokeOpacity_ = objc.registerName("setCircleStrokeOpacity:");
late final _sel_circleStrokeOpacityTransition = objc.registerName("circleStrokeOpacityTransition");
late final _sel_setCircleStrokeOpacityTransition_ = objc.registerName("setCircleStrokeOpacityTransition:");
late final _sel_circleStrokeWidth = objc.registerName("circleStrokeWidth");
late final _sel_setCircleStrokeWidth_ = objc.registerName("setCircleStrokeWidth:");
late final _sel_circleStrokeWidthTransition = objc.registerName("circleStrokeWidthTransition");
late final _sel_setCircleStrokeWidthTransition_ = objc.registerName("setCircleStrokeWidthTransition:");
late final _sel_circleTranslation = objc.registerName("circleTranslation");
late final _sel_setCircleTranslation_ = objc.registerName("setCircleTranslation:");
late final _sel_circleTranslationTransition = objc.registerName("circleTranslationTransition");
late final _sel_setCircleTranslationTransition_ = objc.registerName("setCircleTranslationTransition:");
late final _sel_circleTranslate = objc.registerName("circleTranslate");
late final _sel_setCircleTranslate_ = objc.registerName("setCircleTranslate:");
late final _sel_circleTranslationAnchor = objc.registerName("circleTranslationAnchor");
late final _sel_setCircleTranslationAnchor_ = objc.registerName("setCircleTranslationAnchor:");
late final _sel_circleTranslateAnchor = objc.registerName("circleTranslateAnchor");
late final _sel_setCircleTranslateAnchor_ = objc.registerName("setCircleTranslateAnchor:");

/// An ``MLNCircleStyleLayer`` is a style layer that renders one or more filled
/// circles on the map.
/// 
/// Use a circle style layer to configure the visual appearance of point or point
/// collection features. These features can come from vector tiles loaded by an
/// ``MLNCircleStyleLayer`` object, or they can be ``MLNCircleStyleLayer``,
/// ``MLNCircleStyleLayer``, ``MLNCircleStyleLayer``, or ``MLNCircleStyleLayer``
/// instances in an ``MLNCircleStyleLayer`` or ``MLNCircleStyleLayer`` object.
/// 
/// A circle style layer renders circles whose radii are measured in screen units.
/// To display circles on the map whose radii correspond to real-world distances,
/// use many-sided regular polygons and configure their appearance using an
/// ``MLNCircleStyleLayer`` object.
/// 
/// You can access an existing circle style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new circle style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
/// 
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/dds-circle-layer/">Data-driven
/// circles</a>, <a
/// href="https://docs.mapbox.com/ios/maps/examples/shape-collection/">Add multiple
/// shapes from a single shape source</a>, and <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster point
/// data</a> examples to learn how to add circles to your map using this style
/// layer.
/// 
/// ### Example
/// 
/// ```swift
/// ```
extension type MLNCircleStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNVectorStyleLayer {
  /// Constructs a [MLNCircleStyleLayer] that points to the same underlying object as [other].
  MLNCircleStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNCircleStyleLayer] that wraps the given raw object pointer.
  MLNCircleStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNCircleStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNCircleStyleLayer);

  /// alloc
  static MLNCircleStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNCircleStyleLayer, _sel_alloc);
    return MLNCircleStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNCircleStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNCircleStyleLayer, _sel_allocWithZone_, zone);
    return MLNCircleStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNCircleStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNCircleStyleLayer, _sel_new);
    return MLNCircleStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNCircleStyleLayer constructed with the default `new` method.
  MLNCircleStyleLayer() : this.as(new$().object$);

}

extension MLNCircleStyleLayer$Methods on MLNCircleStyleLayer {

  /// Amount to blur the circle. 1 blurs the circle such that only the centerpoint is
/// full opacity.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get circleBlur {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleBlur);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `circleBlur` property.
/// 
/// This property corresponds to the `circle-blur-transition` property in the style JSON file format.
  MLNTransition get circleBlurTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_circleBlurTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_circleBlurTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The fill color of the circle.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get circleColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `circleColor` property.
/// 
/// This property corresponds to the `circle-color-transition` property in the style JSON file format.
  MLNTransition get circleColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_circleColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_circleColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The opacity at which the circle will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get circleOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `circleOpacity` property.
/// 
/// This property corresponds to the `circle-opacity-transition` property in the style JSON file format.
  MLNTransition get circleOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_circleOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_circleOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Orientation of circle when map is pitched.
/// 
/// The default value of this property is an expression that evaluates to
/// `viewport`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNCirclePitchAlignment` values
/// Any of the following constant string values:
/// `map`: The circle is aligned to the plane of the map.
/// `viewport`: The circle is aligned to the plane of the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get circlePitchAlignment {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circlePitchAlignment);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// circlePitchScale
  NSExpression get circlePitchScale {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circlePitchScale);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Circle radius.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `5`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get circleRadius {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleRadius);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `circleRadius` property.
/// 
/// This property corresponds to the `circle-radius-transition` property in the style JSON file format.
  MLNTransition get circleRadiusTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_circleRadiusTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_circleRadiusTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Controls the scaling behavior of the circle when the map is pitched.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-circle-pitch-scale"><code>circle-pitch-scale</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNCircleScaleAlignment` values
/// Any of the following constant string values:
/// `map`: Circles are scaled according to their apparent distance to the
/// camera.
/// `viewport`: Circles are not scaled.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get circleScaleAlignment {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleScaleAlignment);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Sorts features in ascending order based on this value. Features with a higher
/// sort key will appear above features with a lower sort key.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get circleSortKey {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleSortKey);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The stroke color of the circle.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get circleStrokeColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleStrokeColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `circleStrokeColor` property.
/// 
/// This property corresponds to the `circle-stroke-color-transition` property in the style JSON file format.
  MLNTransition get circleStrokeColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_circleStrokeColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_circleStrokeColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The opacity of the circle's stroke.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get circleStrokeOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleStrokeOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `circleStrokeOpacity` property.
/// 
/// This property corresponds to the `circle-stroke-opacity-transition` property in the style JSON file format.
  MLNTransition get circleStrokeOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_circleStrokeOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_circleStrokeOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The width of the circle's stroke. Strokes are placed outside of the
/// `circleRadius`.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get circleStrokeWidth {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleStrokeWidth);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `circleStrokeWidth` property.
/// 
/// This property corresponds to the `circle-stroke-width-transition` property in the style JSON file format.
  MLNTransition get circleStrokeWidthTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_circleStrokeWidthTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_circleStrokeWidthTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// circleTranslate
  NSExpression get circleTranslate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleTranslate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// circleTranslateAnchor
  NSExpression get circleTranslateAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleTranslateAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The geometry's offset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate"><code>circle-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get circleTranslation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleTranslation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Controls the frame of reference for `circleTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `circleTranslation` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate-anchor"><code>circle-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNCircleTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The circle is translated relative to the map.
/// `viewport`: The circle is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get circleTranslationAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_circleTranslationAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `circleTranslation` property.
/// 
/// This property corresponds to the `circle-translate-transition` property in the style JSON file format.
  MLNTransition get circleTranslationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_circleTranslationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_circleTranslationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// init
  MLNCircleStyleLayer init() {
  objc.checkOsVersionInternal('MLNCircleStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNCircleStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a circle style layer initialized with an identifier and source.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param source The source from which to obtain the data to style. If the source
/// has not yet been added to the current style, the behavior is undefined.
/// @return An initialized foreground style layer.
  MLNCircleStyleLayer initWithIdentifier(objc.NSString identifier, {required MLNSource source}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_source_, identifier.ref.pointer, source.ref.pointer);
    return MLNCircleStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Amount to blur the circle. 1 blurs the circle such that only the centerpoint is
/// full opacity.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set circleBlur(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleBlur_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `circleBlur` property.
/// 
/// This property corresponds to the `circle-blur-transition` property in the style JSON file format.
  set circleBlurTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setCircleBlurTransition_, value);

  }


  /// The fill color of the circle.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set circleColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `circleColor` property.
/// 
/// This property corresponds to the `circle-color-transition` property in the style JSON file format.
  set circleColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setCircleColorTransition_, value);

  }


  /// The opacity at which the circle will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set circleOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `circleOpacity` property.
/// 
/// This property corresponds to the `circle-opacity-transition` property in the style JSON file format.
  set circleOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setCircleOpacityTransition_, value);

  }


  /// Orientation of circle when map is pitched.
/// 
/// The default value of this property is an expression that evaluates to
/// `viewport`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNCirclePitchAlignment` values
/// Any of the following constant string values:
/// `map`: The circle is aligned to the plane of the map.
/// `viewport`: The circle is aligned to the plane of the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set circlePitchAlignment(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCirclePitchAlignment_, value.ref.pointer);

  }


  /// setCirclePitchScale:
  set circlePitchScale(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCirclePitchScale_, value.ref.pointer);

  }


  /// Circle radius.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `5`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set circleRadius(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleRadius_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `circleRadius` property.
/// 
/// This property corresponds to the `circle-radius-transition` property in the style JSON file format.
  set circleRadiusTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setCircleRadiusTransition_, value);

  }


  /// Controls the scaling behavior of the circle when the map is pitched.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-circle-pitch-scale"><code>circle-pitch-scale</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNCircleScaleAlignment` values
/// Any of the following constant string values:
/// `map`: Circles are scaled according to their apparent distance to the
/// camera.
/// `viewport`: Circles are not scaled.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set circleScaleAlignment(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleScaleAlignment_, value.ref.pointer);

  }


  /// Sorts features in ascending order based on this value. Features with a higher
/// sort key will appear above features with a lower sort key.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set circleSortKey(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleSortKey_, value.ref.pointer);

  }


  /// The stroke color of the circle.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set circleStrokeColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleStrokeColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `circleStrokeColor` property.
/// 
/// This property corresponds to the `circle-stroke-color-transition` property in the style JSON file format.
  set circleStrokeColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setCircleStrokeColorTransition_, value);

  }


  /// The opacity of the circle's stroke.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set circleStrokeOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleStrokeOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `circleStrokeOpacity` property.
/// 
/// This property corresponds to the `circle-stroke-opacity-transition` property in the style JSON file format.
  set circleStrokeOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setCircleStrokeOpacityTransition_, value);

  }


  /// The width of the circle's stroke. Strokes are placed outside of the
/// `circleRadius`.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set circleStrokeWidth(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleStrokeWidth_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `circleStrokeWidth` property.
/// 
/// This property corresponds to the `circle-stroke-width-transition` property in the style JSON file format.
  set circleStrokeWidthTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setCircleStrokeWidthTransition_, value);

  }


  /// setCircleTranslate:
  set circleTranslate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleTranslate_, value.ref.pointer);

  }


  /// setCircleTranslateAnchor:
  set circleTranslateAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleTranslateAnchor_, value.ref.pointer);

  }


  /// The geometry's offset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate"><code>circle-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set circleTranslation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleTranslation_, value.ref.pointer);

  }


  /// Controls the frame of reference for `circleTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `circleTranslation` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-circle-translate-anchor"><code>circle-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNCircleTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The circle is translated relative to the map.
/// `viewport`: The circle is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set circleTranslationAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setCircleTranslationAnchor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `circleTranslation` property.
/// 
/// This property corresponds to the `circle-translate-transition` property in the style JSON file format.
  set circleTranslationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setCircleTranslationTransition_, value);

  }

}

late final _class_MLNFillExtrusionStyleLayer = objc.getClass("MLNFillExtrusionStyleLayer");
late final _sel_fillExtrusionBase = objc.registerName("fillExtrusionBase");
late final _sel_setFillExtrusionBase_ = objc.registerName("setFillExtrusionBase:");
late final _sel_fillExtrusionBaseTransition = objc.registerName("fillExtrusionBaseTransition");
late final _sel_setFillExtrusionBaseTransition_ = objc.registerName("setFillExtrusionBaseTransition:");
late final _sel_fillExtrusionColor = objc.registerName("fillExtrusionColor");
late final _sel_setFillExtrusionColor_ = objc.registerName("setFillExtrusionColor:");
late final _sel_fillExtrusionColorTransition = objc.registerName("fillExtrusionColorTransition");
late final _sel_setFillExtrusionColorTransition_ = objc.registerName("setFillExtrusionColorTransition:");
late final _sel_fillExtrusionHasVerticalGradient = objc.registerName("fillExtrusionHasVerticalGradient");
late final _sel_setFillExtrusionHasVerticalGradient_ = objc.registerName("setFillExtrusionHasVerticalGradient:");
late final _sel_fillExtrusionVerticalGradient = objc.registerName("fillExtrusionVerticalGradient");
late final _sel_setFillExtrusionVerticalGradient_ = objc.registerName("setFillExtrusionVerticalGradient:");
late final _sel_fillExtrusionHeight = objc.registerName("fillExtrusionHeight");
late final _sel_setFillExtrusionHeight_ = objc.registerName("setFillExtrusionHeight:");
late final _sel_fillExtrusionHeightTransition = objc.registerName("fillExtrusionHeightTransition");
late final _sel_setFillExtrusionHeightTransition_ = objc.registerName("setFillExtrusionHeightTransition:");
late final _sel_fillExtrusionOpacity = objc.registerName("fillExtrusionOpacity");
late final _sel_setFillExtrusionOpacity_ = objc.registerName("setFillExtrusionOpacity:");
late final _sel_fillExtrusionOpacityTransition = objc.registerName("fillExtrusionOpacityTransition");
late final _sel_setFillExtrusionOpacityTransition_ = objc.registerName("setFillExtrusionOpacityTransition:");
late final _sel_fillExtrusionPattern = objc.registerName("fillExtrusionPattern");
late final _sel_setFillExtrusionPattern_ = objc.registerName("setFillExtrusionPattern:");
late final _sel_fillExtrusionPatternTransition = objc.registerName("fillExtrusionPatternTransition");
late final _sel_setFillExtrusionPatternTransition_ = objc.registerName("setFillExtrusionPatternTransition:");
late final _sel_fillExtrusionTranslation = objc.registerName("fillExtrusionTranslation");
late final _sel_setFillExtrusionTranslation_ = objc.registerName("setFillExtrusionTranslation:");
late final _sel_fillExtrusionTranslationTransition = objc.registerName("fillExtrusionTranslationTransition");
late final _sel_setFillExtrusionTranslationTransition_ = objc.registerName("setFillExtrusionTranslationTransition:");
late final _sel_fillExtrusionTranslate = objc.registerName("fillExtrusionTranslate");
late final _sel_setFillExtrusionTranslate_ = objc.registerName("setFillExtrusionTranslate:");
late final _sel_fillExtrusionTranslationAnchor = objc.registerName("fillExtrusionTranslationAnchor");
late final _sel_setFillExtrusionTranslationAnchor_ = objc.registerName("setFillExtrusionTranslationAnchor:");
late final _sel_fillExtrusionTranslateAnchor = objc.registerName("fillExtrusionTranslateAnchor");
late final _sel_setFillExtrusionTranslateAnchor_ = objc.registerName("setFillExtrusionTranslateAnchor:");

/// An ``MLNFillExtrusionStyleLayer`` is a style layer that renders one or more 3D
/// extruded polygons on the map.
/// 
/// Use a fill-extrusion style layer to configure the visual appearance of polygon
/// or multipolygon features. These features can come from vector tiles loaded by
/// an ``MLNFillExtrusionStyleLayer`` object, or they can be
/// ``MLNFillExtrusionStyleLayer``, ``MLNFillExtrusionStyleLayer``,
/// ``MLNFillExtrusionStyleLayer``, or ``MLNFillExtrusionStyleLayer`` instances in
/// an ``MLNFillExtrusionStyleLayer`` or ``MLNFillExtrusionStyleLayer`` object.
/// 
/// You can access an existing fill-extrusion style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new fill-extrusion style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
/// 
/// #### Related examples
/// See the <a href="https://docs.mapbox.com/ios/maps/examples/extrusions/">Display
/// 3D buildings</a> example to learn how to add and style 3D layers on a map.
/// 
/// ### Example
/// 
/// ```swift
/// ```
extension type MLNFillExtrusionStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNVectorStyleLayer {
  /// Constructs a [MLNFillExtrusionStyleLayer] that points to the same underlying object as [other].
  MLNFillExtrusionStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNFillExtrusionStyleLayer] that wraps the given raw object pointer.
  MLNFillExtrusionStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNFillExtrusionStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNFillExtrusionStyleLayer);

  /// alloc
  static MLNFillExtrusionStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNFillExtrusionStyleLayer, _sel_alloc);
    return MLNFillExtrusionStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNFillExtrusionStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNFillExtrusionStyleLayer, _sel_allocWithZone_, zone);
    return MLNFillExtrusionStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNFillExtrusionStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNFillExtrusionStyleLayer, _sel_new);
    return MLNFillExtrusionStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNFillExtrusionStyleLayer constructed with the default `new` method.
  MLNFillExtrusionStyleLayer() : this.as(new$().object$);

}

extension MLNFillExtrusionStyleLayer$Methods on MLNFillExtrusionStyleLayer {

  /// The height with which to extrude the base of this layer. Must be less than or
/// equal to `fillExtrusionHeight`.
/// 
/// This property is measured in meters.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `fillExtrusionHeight` is
/// non-`nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillExtrusionBase {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionBase);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillExtrusionBase` property.
/// 
/// This property corresponds to the `fill-extrusion-base-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionBaseTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillExtrusionBaseTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillExtrusionBaseTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The base color of this layer. The extrusion's surfaces will be shaded
/// differently based on this color in combination with the `light` settings. If
/// this color is specified with an alpha component, the alpha component will be
/// ignored; use `fillExtrusionOpacity` to set layer opacityco.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `fillExtrusionPattern` is set to
/// `nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillExtrusionColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillExtrusionColor` property.
/// 
/// This property corresponds to the `fill-extrusion-color-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillExtrusionColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillExtrusionColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If
/// true, sides will be shaded slightly darker farther down.
/// 
/// The default value of this property is an expression that evaluates to `YES`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-vertical-gradient"><code>fill-extrusion-vertical-gradient</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get fillExtrusionHasVerticalGradient {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionHasVerticalGradient);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The height with which to extrude this layer.
/// 
/// This property is measured in meters.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillExtrusionHeight {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionHeight);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillExtrusionHeight` property.
/// 
/// This property corresponds to the `fill-extrusion-height-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionHeightTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillExtrusionHeightTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillExtrusionHeightTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The opacity of the entire fill extrusion layer. This is rendered on a
/// per-layer, not per-feature, basis, and data-driven styling is not available.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get fillExtrusionOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillExtrusionOpacity` property.
/// 
/// This property corresponds to the `fill-extrusion-opacity-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillExtrusionOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillExtrusionOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Name of image in style images to use for drawing image fill-extrusions. For
/// seamless patterns, image width and height must be a factor of two (2, 4, 8,
/// ..., 512).
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillExtrusionPattern {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionPattern);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillExtrusionPattern` property.
/// 
/// This property corresponds to the `fill-extrusion-pattern-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionPatternTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillExtrusionPatternTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillExtrusionPatternTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// fillExtrusionTranslate
  NSExpression get fillExtrusionTranslate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionTranslate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// fillExtrusionTranslateAnchor
  NSExpression get fillExtrusionTranslateAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionTranslateAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The geometry's offset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate"><code>fill-extrusion-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get fillExtrusionTranslation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionTranslation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Controls the frame of reference for `fillExtrusionTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `fillExtrusionTranslation` is
/// non-`nil`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate-anchor"><code>fill-extrusion-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNFillExtrusionTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The fill extrusion is translated relative to the map.
/// `viewport`: The fill extrusion is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get fillExtrusionTranslationAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionTranslationAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillExtrusionTranslation` property.
/// 
/// This property corresponds to the `fill-extrusion-translate-transition` property in the style JSON file format.
  MLNTransition get fillExtrusionTranslationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillExtrusionTranslationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillExtrusionTranslationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// fillExtrusionVerticalGradient
  NSExpression get fillExtrusionVerticalGradient {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillExtrusionVerticalGradient);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNFillExtrusionStyleLayer init() {
  objc.checkOsVersionInternal('MLNFillExtrusionStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNFillExtrusionStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a fill-extrusion style layer initialized with an identifier and source.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param source The source from which to obtain the data to style. If the source
/// has not yet been added to the current style, the behavior is undefined.
/// @return An initialized foreground style layer.
  MLNFillExtrusionStyleLayer initWithIdentifier(objc.NSString identifier, {required MLNSource source}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_source_, identifier.ref.pointer, source.ref.pointer);
    return MLNFillExtrusionStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// The height with which to extrude the base of this layer. Must be less than or
/// equal to `fillExtrusionHeight`.
/// 
/// This property is measured in meters.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `fillExtrusionHeight` is
/// non-`nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillExtrusionBase(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionBase_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillExtrusionBase` property.
/// 
/// This property corresponds to the `fill-extrusion-base-transition` property in the style JSON file format.
  set fillExtrusionBaseTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillExtrusionBaseTransition_, value);

  }


  /// The base color of this layer. The extrusion's surfaces will be shaded
/// differently based on this color in combination with the `light` settings. If
/// this color is specified with an alpha component, the alpha component will be
/// ignored; use `fillExtrusionOpacity` to set layer opacityco.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `fillExtrusionPattern` is set to
/// `nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillExtrusionColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillExtrusionColor` property.
/// 
/// This property corresponds to the `fill-extrusion-color-transition` property in the style JSON file format.
  set fillExtrusionColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillExtrusionColorTransition_, value);

  }


  /// Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If
/// true, sides will be shaded slightly darker farther down.
/// 
/// The default value of this property is an expression that evaluates to `YES`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-vertical-gradient"><code>fill-extrusion-vertical-gradient</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set fillExtrusionHasVerticalGradient(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionHasVerticalGradient_, value.ref.pointer);

  }


  /// The height with which to extrude this layer.
/// 
/// This property is measured in meters.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillExtrusionHeight(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionHeight_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillExtrusionHeight` property.
/// 
/// This property corresponds to the `fill-extrusion-height-transition` property in the style JSON file format.
  set fillExtrusionHeightTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillExtrusionHeightTransition_, value);

  }


  /// The opacity of the entire fill extrusion layer. This is rendered on a
/// per-layer, not per-feature, basis, and data-driven styling is not available.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set fillExtrusionOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillExtrusionOpacity` property.
/// 
/// This property corresponds to the `fill-extrusion-opacity-transition` property in the style JSON file format.
  set fillExtrusionOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillExtrusionOpacityTransition_, value);

  }


  /// Name of image in style images to use for drawing image fill-extrusions. For
/// seamless patterns, image width and height must be a factor of two (2, 4, 8,
/// ..., 512).
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillExtrusionPattern(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionPattern_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillExtrusionPattern` property.
/// 
/// This property corresponds to the `fill-extrusion-pattern-transition` property in the style JSON file format.
  set fillExtrusionPatternTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillExtrusionPatternTransition_, value);

  }


  /// setFillExtrusionTranslate:
  set fillExtrusionTranslate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionTranslate_, value.ref.pointer);

  }


  /// setFillExtrusionTranslateAnchor:
  set fillExtrusionTranslateAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionTranslateAnchor_, value.ref.pointer);

  }


  /// The geometry's offset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate"><code>fill-extrusion-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set fillExtrusionTranslation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionTranslation_, value.ref.pointer);

  }


  /// Controls the frame of reference for `fillExtrusionTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `fillExtrusionTranslation` is
/// non-`nil`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-extrusion-translate-anchor"><code>fill-extrusion-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNFillExtrusionTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The fill extrusion is translated relative to the map.
/// `viewport`: The fill extrusion is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set fillExtrusionTranslationAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionTranslationAnchor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillExtrusionTranslation` property.
/// 
/// This property corresponds to the `fill-extrusion-translate-transition` property in the style JSON file format.
  set fillExtrusionTranslationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillExtrusionTranslationTransition_, value);

  }


  /// setFillExtrusionVerticalGradient:
  set fillExtrusionVerticalGradient(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillExtrusionVerticalGradient_, value.ref.pointer);

  }

}

late final _class_MLNFillStyleLayer = objc.getClass("MLNFillStyleLayer");
late final _sel_fillSortKey = objc.registerName("fillSortKey");
late final _sel_setFillSortKey_ = objc.registerName("setFillSortKey:");
late final _sel_isFillAntialiased = objc.registerName("isFillAntialiased");
late final _sel_setFillAntialiased_ = objc.registerName("setFillAntialiased:");
late final _sel_fillAntialias = objc.registerName("fillAntialias");
late final _sel_setFillAntialias_ = objc.registerName("setFillAntialias:");
late final _sel_fillColor = objc.registerName("fillColor");
late final _sel_setFillColor_ = objc.registerName("setFillColor:");
late final _sel_fillColorTransition = objc.registerName("fillColorTransition");
late final _sel_setFillColorTransition_ = objc.registerName("setFillColorTransition:");
late final _sel_fillOpacity = objc.registerName("fillOpacity");
late final _sel_setFillOpacity_ = objc.registerName("setFillOpacity:");
late final _sel_fillOpacityTransition = objc.registerName("fillOpacityTransition");
late final _sel_setFillOpacityTransition_ = objc.registerName("setFillOpacityTransition:");
late final _sel_fillOutlineColor = objc.registerName("fillOutlineColor");
late final _sel_setFillOutlineColor_ = objc.registerName("setFillOutlineColor:");
late final _sel_fillOutlineColorTransition = objc.registerName("fillOutlineColorTransition");
late final _sel_setFillOutlineColorTransition_ = objc.registerName("setFillOutlineColorTransition:");
late final _sel_fillPattern = objc.registerName("fillPattern");
late final _sel_setFillPattern_ = objc.registerName("setFillPattern:");
late final _sel_fillPatternTransition = objc.registerName("fillPatternTransition");
late final _sel_setFillPatternTransition_ = objc.registerName("setFillPatternTransition:");
late final _sel_fillTranslation = objc.registerName("fillTranslation");
late final _sel_setFillTranslation_ = objc.registerName("setFillTranslation:");
late final _sel_fillTranslationTransition = objc.registerName("fillTranslationTransition");
late final _sel_setFillTranslationTransition_ = objc.registerName("setFillTranslationTransition:");
late final _sel_fillTranslate = objc.registerName("fillTranslate");
late final _sel_setFillTranslate_ = objc.registerName("setFillTranslate:");
late final _sel_fillTranslationAnchor = objc.registerName("fillTranslationAnchor");
late final _sel_setFillTranslationAnchor_ = objc.registerName("setFillTranslationAnchor:");
late final _sel_fillTranslateAnchor = objc.registerName("fillTranslateAnchor");
late final _sel_setFillTranslateAnchor_ = objc.registerName("setFillTranslateAnchor:");

/// An ``MLNFillStyleLayer`` is a style layer that renders one or more filled (and
/// optionally stroked) polygons on the map.
/// 
/// Use a fill style layer to configure the visual appearance of polygon or
/// multipolygon features. These features can come from vector tiles loaded by an
/// ``MLNFillStyleLayer`` object, or they can be ``MLNFillStyleLayer``,
/// ``MLNFillStyleLayer``, ``MLNFillStyleLayer``, or ``MLNFillStyleLayer``
/// instances in an ``MLNFillStyleLayer`` or ``MLNFillStyleLayer`` object.
/// 
/// You can access an existing fill style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new fill style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
/// 
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/select-layer/">Select a feature
/// within a layer</a> example to learn how to use a `TERNARY` expression to modify
/// the `fillOpacity` of an ``MLNFillStyleLayer`` object. See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/fill-pattern/">Add a pattern to
/// a polygon</a> example to learn how to use an image to add pattern to the
/// features styled by a ``MLNFillStyleLayer``.
/// 
/// ### Example
/// 
/// ```swift
/// ```
extension type MLNFillStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNVectorStyleLayer {
  /// Constructs a [MLNFillStyleLayer] that points to the same underlying object as [other].
  MLNFillStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNFillStyleLayer] that wraps the given raw object pointer.
  MLNFillStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNFillStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNFillStyleLayer);

  /// alloc
  static MLNFillStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNFillStyleLayer, _sel_alloc);
    return MLNFillStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNFillStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNFillStyleLayer, _sel_allocWithZone_, zone);
    return MLNFillStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNFillStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNFillStyleLayer, _sel_new);
    return MLNFillStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNFillStyleLayer constructed with the default `new` method.
  MLNFillStyleLayer() : this.as(new$().object$);

}

extension MLNFillStyleLayer$Methods on MLNFillStyleLayer {

  /// fillAntialias
  NSExpression get fillAntialias {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillAntialias);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The color of the filled part of this layer.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `fillPattern` is set to `nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillColor` property.
/// 
/// This property corresponds to the `fill-color-transition` property in the style JSON file format.
  MLNTransition get fillColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The opacity of the entire fill layer. In contrast to the `fillColor`, this
/// value will also affect the 1pt stroke around the fill, if the stroke is used.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillOpacity` property.
/// 
/// This property corresponds to the `fill-opacity-transition` property in the style JSON file format.
  MLNTransition get fillOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The outline color of the fill. Matches the value of `fillColor` if unspecified.
/// 
/// This property is only applied to the style if `fillPattern` is set to `nil`,
/// and `fillAntialiased` is set to an expression that evaluates to `YES`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillOutlineColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillOutlineColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillOutlineColor` property.
/// 
/// This property corresponds to the `fill-outline-color-transition` property in the style JSON file format.
  MLNTransition get fillOutlineColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillOutlineColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillOutlineColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Name of image in sprite to use for drawing image fills. For seamless patterns,
/// image width and height must be a factor of two (2, 4, 8, ..., 512). Note that
/// zoom-dependent expressions will be evaluated only at integer zoom levels.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillPattern {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillPattern);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillPattern` property.
/// 
/// This property corresponds to the `fill-pattern-transition` property in the style JSON file format.
  MLNTransition get fillPatternTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillPatternTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillPatternTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Sorts features in ascending order based on this value. Features with a higher
/// sort key will appear above features with a lower sort key.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get fillSortKey {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillSortKey);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// fillTranslate
  NSExpression get fillTranslate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillTranslate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// fillTranslateAnchor
  NSExpression get fillTranslateAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillTranslateAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The geometry's offset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate"><code>fill-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get fillTranslation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillTranslation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Controls the frame of reference for `fillTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `fillTranslation` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate-anchor"><code>fill-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNFillTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The fill is translated relative to the map.
/// `viewport`: The fill is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get fillTranslationAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_fillTranslationAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `fillTranslation` property.
/// 
/// This property corresponds to the `fill-translate-transition` property in the style JSON file format.
  MLNTransition get fillTranslationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_fillTranslationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_fillTranslationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// init
  MLNFillStyleLayer init() {
  objc.checkOsVersionInternal('MLNFillStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNFillStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a fill style layer initialized with an identifier and source.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param source The source from which to obtain the data to style. If the source
/// has not yet been added to the current style, the behavior is undefined.
/// @return An initialized foreground style layer.
  MLNFillStyleLayer initWithIdentifier(objc.NSString identifier, {required MLNSource source}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_source_, identifier.ref.pointer, source.ref.pointer);
    return MLNFillStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Whether or not the fill should be antialiased.
/// 
/// The default value of this property is an expression that evaluates to `YES`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-antialias"><code>fill-antialias</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get isFillAntialiased {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_isFillAntialiased);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// setFillAntialias:
  set fillAntialias(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillAntialias_, value.ref.pointer);

  }


  /// Whether or not the fill should be antialiased.
/// 
/// The default value of this property is an expression that evaluates to `YES`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-antialias"><code>fill-antialias</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set isFillAntialiased(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillAntialiased_, value.ref.pointer);

  }


  /// The color of the filled part of this layer.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `fillPattern` is set to `nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillColor` property.
/// 
/// This property corresponds to the `fill-color-transition` property in the style JSON file format.
  set fillColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillColorTransition_, value);

  }


  /// The opacity of the entire fill layer. In contrast to the `fillColor`, this
/// value will also affect the 1pt stroke around the fill, if the stroke is used.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillOpacity` property.
/// 
/// This property corresponds to the `fill-opacity-transition` property in the style JSON file format.
  set fillOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillOpacityTransition_, value);

  }


  /// The outline color of the fill. Matches the value of `fillColor` if unspecified.
/// 
/// This property is only applied to the style if `fillPattern` is set to `nil`,
/// and `fillAntialiased` is set to an expression that evaluates to `YES`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillOutlineColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillOutlineColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillOutlineColor` property.
/// 
/// This property corresponds to the `fill-outline-color-transition` property in the style JSON file format.
  set fillOutlineColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillOutlineColorTransition_, value);

  }


  /// Name of image in sprite to use for drawing image fills. For seamless patterns,
/// image width and height must be a factor of two (2, 4, 8, ..., 512). Note that
/// zoom-dependent expressions will be evaluated only at integer zoom levels.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillPattern(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillPattern_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillPattern` property.
/// 
/// This property corresponds to the `fill-pattern-transition` property in the style JSON file format.
  set fillPatternTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillPatternTransition_, value);

  }


  /// Sorts features in ascending order based on this value. Features with a higher
/// sort key will appear above features with a lower sort key.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set fillSortKey(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillSortKey_, value.ref.pointer);

  }


  /// setFillTranslate:
  set fillTranslate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillTranslate_, value.ref.pointer);

  }


  /// setFillTranslateAnchor:
  set fillTranslateAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillTranslateAnchor_, value.ref.pointer);

  }


  /// The geometry's offset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate"><code>fill-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set fillTranslation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillTranslation_, value.ref.pointer);

  }


  /// Controls the frame of reference for `fillTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `fillTranslation` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-fill-translate-anchor"><code>fill-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNFillTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The fill is translated relative to the map.
/// `viewport`: The fill is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set fillTranslationAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setFillTranslationAnchor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `fillTranslation` property.
/// 
/// This property corresponds to the `fill-translate-transition` property in the style JSON file format.
  set fillTranslationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setFillTranslationTransition_, value);

  }

}

late final _class_MLNHeatmapStyleLayer = objc.getClass("MLNHeatmapStyleLayer");
late final _sel_heatmapColor = objc.registerName("heatmapColor");
late final _sel_setHeatmapColor_ = objc.registerName("setHeatmapColor:");
late final _sel_heatmapIntensity = objc.registerName("heatmapIntensity");
late final _sel_setHeatmapIntensity_ = objc.registerName("setHeatmapIntensity:");
late final _sel_heatmapIntensityTransition = objc.registerName("heatmapIntensityTransition");
late final _sel_setHeatmapIntensityTransition_ = objc.registerName("setHeatmapIntensityTransition:");
late final _sel_heatmapOpacity = objc.registerName("heatmapOpacity");
late final _sel_setHeatmapOpacity_ = objc.registerName("setHeatmapOpacity:");
late final _sel_heatmapOpacityTransition = objc.registerName("heatmapOpacityTransition");
late final _sel_setHeatmapOpacityTransition_ = objc.registerName("setHeatmapOpacityTransition:");
late final _sel_heatmapRadius = objc.registerName("heatmapRadius");
late final _sel_setHeatmapRadius_ = objc.registerName("setHeatmapRadius:");
late final _sel_heatmapRadiusTransition = objc.registerName("heatmapRadiusTransition");
late final _sel_setHeatmapRadiusTransition_ = objc.registerName("setHeatmapRadiusTransition:");
late final _sel_heatmapWeight = objc.registerName("heatmapWeight");
late final _sel_setHeatmapWeight_ = objc.registerName("setHeatmapWeight:");

/// An ``MLNHeatmapStyleLayer`` is a style layer that renders a <a
/// href="https://en.wikipedia.org/wiki/Heat_map">heatmap</a>.
/// 
/// A heatmap visualizes the spatial distribution of a large, dense set of point
/// data, using color to avoid cluttering the map with individual points at low
/// zoom levels. The points are weighted by an attribute you specify. Use a heatmap
/// style layer in conjunction with point or point collection features. These
/// features can come from vector tiles loaded by an ``MLNHeatmapStyleLayer``
/// object, or they can be ``MLNHeatmapStyleLayer``, ``MLNHeatmapStyleLayer``,
/// ``MLNHeatmapStyleLayer``, or ``MLNHeatmapStyleLayer`` instances in an
/// ``MLNHeatmapStyleLayer`` or ``MLNHeatmapStyleLayer`` object.
/// 
/// Consider accompanying a heatmap style layer with an ``MLNHeatmapStyleLayer`` or
/// ``MLNHeatmapStyleLayer`` at high zoom levels. If you are unsure whether the
/// point data in an ``MLNHeatmapStyleLayer`` is dense enough to warrant a heatmap,
/// you can alternatively cluster the source using the ``MLNHeatmapStyleLayer``
/// option and render the data using an ``MLNHeatmapStyleLayer`` or
/// ``MLNHeatmapStyleLayer``.
/// 
/// You can access an existing heatmap style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new heatmap style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
/// 
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/heatmap-example/">Create a
/// heatmap layer</a> example to learn how to add this style layer to your map.
/// 
/// ### Example
/// 
/// ```swift
/// ```
extension type MLNHeatmapStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNVectorStyleLayer {
  /// Constructs a [MLNHeatmapStyleLayer] that points to the same underlying object as [other].
  MLNHeatmapStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNHeatmapStyleLayer] that wraps the given raw object pointer.
  MLNHeatmapStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNHeatmapStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNHeatmapStyleLayer);

  /// alloc
  static MLNHeatmapStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNHeatmapStyleLayer, _sel_alloc);
    return MLNHeatmapStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNHeatmapStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNHeatmapStyleLayer, _sel_allocWithZone_, zone);
    return MLNHeatmapStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNHeatmapStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNHeatmapStyleLayer, _sel_new);
    return MLNHeatmapStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNHeatmapStyleLayer constructed with the default `new` method.
  MLNHeatmapStyleLayer() : this.as(new$().object$);

}

extension MLNHeatmapStyleLayer$Methods on MLNHeatmapStyleLayer {

  /// The color of each screen point based on its density value in a heatmap. This
/// property is normally set to an interpolation or step expression with the
/// `$heatmapDensity` value as its input.
/// 
/// The default value of this property is an expression that evaluates to a rainbow
/// color scale from blue to red. Set this property to `nil` to reset it to the
/// default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$heatmapDensity` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get heatmapColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heatmapColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Similar to `heatmapWeight` but controls the intensity of the heatmap globally.
/// Primarily used for adjusting the heatmap based on zoom level.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get heatmapIntensity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heatmapIntensity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `heatmapIntensity` property.
/// 
/// This property corresponds to the `heatmap-intensity-transition` property in the style JSON file format.
  MLNTransition get heatmapIntensityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_heatmapIntensityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_heatmapIntensityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The global opacity at which the heatmap layer will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get heatmapOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heatmapOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `heatmapOpacity` property.
/// 
/// This property corresponds to the `heatmap-opacity-transition` property in the style JSON file format.
  MLNTransition get heatmapOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_heatmapOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_heatmapOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Radius of influence of one heatmap point in points. Increasing the value makes
/// the heatmap smoother, but less detailed.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `30`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 1
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get heatmapRadius {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heatmapRadius);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `heatmapRadius` property.
/// 
/// This property corresponds to the `heatmap-radius-transition` property in the style JSON file format.
  MLNTransition get heatmapRadiusTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_heatmapRadiusTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_heatmapRadiusTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// A measure of how much an individual point contributes to the heatmap. A value
/// of 10 would be equivalent to having 10 points of weight 1 in the same spot.
/// Especially useful when combined with clustering.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get heatmapWeight {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heatmapWeight);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNHeatmapStyleLayer init() {
  objc.checkOsVersionInternal('MLNHeatmapStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNHeatmapStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a heatmap style layer initialized with an identifier and source.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param source The source from which to obtain the data to style. If the source
/// has not yet been added to the current style, the behavior is undefined.
/// @return An initialized foreground style layer.
  MLNHeatmapStyleLayer initWithIdentifier(objc.NSString identifier, {required MLNSource source}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_source_, identifier.ref.pointer, source.ref.pointer);
    return MLNHeatmapStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// The color of each screen point based on its density value in a heatmap. This
/// property is normally set to an interpolation or step expression with the
/// `$heatmapDensity` value as its input.
/// 
/// The default value of this property is an expression that evaluates to a rainbow
/// color scale from blue to red. Set this property to `nil` to reset it to the
/// default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$heatmapDensity` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set heatmapColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHeatmapColor_, value.ref.pointer);

  }


  /// Similar to `heatmapWeight` but controls the intensity of the heatmap globally.
/// Primarily used for adjusting the heatmap based on zoom level.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set heatmapIntensity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHeatmapIntensity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `heatmapIntensity` property.
/// 
/// This property corresponds to the `heatmap-intensity-transition` property in the style JSON file format.
  set heatmapIntensityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setHeatmapIntensityTransition_, value);

  }


  /// The global opacity at which the heatmap layer will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set heatmapOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHeatmapOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `heatmapOpacity` property.
/// 
/// This property corresponds to the `heatmap-opacity-transition` property in the style JSON file format.
  set heatmapOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setHeatmapOpacityTransition_, value);

  }


  /// Radius of influence of one heatmap point in points. Increasing the value makes
/// the heatmap smoother, but less detailed.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `30`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 1
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set heatmapRadius(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHeatmapRadius_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `heatmapRadius` property.
/// 
/// This property corresponds to the `heatmap-radius-transition` property in the style JSON file format.
  set heatmapRadiusTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setHeatmapRadiusTransition_, value);

  }


  /// A measure of how much an individual point contributes to the heatmap. A value
/// of 10 would be equivalent to having 10 points of weight 1 in the same spot.
/// Especially useful when combined with clustering.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set heatmapWeight(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHeatmapWeight_, value.ref.pointer);

  }

}

late final _class_MLNHillshadeStyleLayer = objc.getClass("MLNHillshadeStyleLayer");
late final _sel_hillshadeAccentColor = objc.registerName("hillshadeAccentColor");
late final _sel_setHillshadeAccentColor_ = objc.registerName("setHillshadeAccentColor:");
late final _sel_hillshadeAccentColorTransition = objc.registerName("hillshadeAccentColorTransition");
late final _sel_setHillshadeAccentColorTransition_ = objc.registerName("setHillshadeAccentColorTransition:");
late final _sel_hillshadeExaggeration = objc.registerName("hillshadeExaggeration");
late final _sel_setHillshadeExaggeration_ = objc.registerName("setHillshadeExaggeration:");
late final _sel_hillshadeExaggerationTransition = objc.registerName("hillshadeExaggerationTransition");
late final _sel_setHillshadeExaggerationTransition_ = objc.registerName("setHillshadeExaggerationTransition:");
late final _sel_hillshadeHighlightColor = objc.registerName("hillshadeHighlightColor");
late final _sel_setHillshadeHighlightColor_ = objc.registerName("setHillshadeHighlightColor:");
late final _sel_hillshadeHighlightColorTransition = objc.registerName("hillshadeHighlightColorTransition");
late final _sel_setHillshadeHighlightColorTransition_ = objc.registerName("setHillshadeHighlightColorTransition:");
late final _sel_hillshadeIlluminationAnchor = objc.registerName("hillshadeIlluminationAnchor");
late final _sel_setHillshadeIlluminationAnchor_ = objc.registerName("setHillshadeIlluminationAnchor:");
late final _sel_hillshadeIlluminationDirection = objc.registerName("hillshadeIlluminationDirection");
late final _sel_setHillshadeIlluminationDirection_ = objc.registerName("setHillshadeIlluminationDirection:");
late final _sel_hillshadeShadowColor = objc.registerName("hillshadeShadowColor");
late final _sel_setHillshadeShadowColor_ = objc.registerName("setHillshadeShadowColor:");
late final _sel_hillshadeShadowColorTransition = objc.registerName("hillshadeShadowColorTransition");
late final _sel_setHillshadeShadowColorTransition_ = objc.registerName("setHillshadeShadowColorTransition:");

/// An ``MLNHillshadeStyleLayer`` is a style layer that renders raster <a
/// href="https://en.wikipedia.org/wiki/Digital_elevation_model">digital elevation
/// model</a> (DEM) tiles on the map.
/// 
/// Use a hillshade style layer to configure the color parameters of raster tiles
/// loaded by an ``MLNHillshadeStyleLayer`` object. For example, you could use a
/// hillshade style layer to render <a
/// href="https://docs.mapbox.com/help/troubleshooting/access-elevation-data/#mapbox-terrain-rgb">Mapbox
/// Terrain-RGB</a> data.
/// 
/// To display posterized hillshading based on vector shapes, as with the <a
/// href="https://www.mapbox.com/vector-tiles/mapbox-terrain/">Mapbox Terrain</a>
/// source, use an ``MLNHillshadeStyleLayer`` object in conjunction with several
/// ``MLNHillshadeStyleLayer`` objects.
/// 
/// You can access an existing hillshade style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new hillshade style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
/// 
/// ### Example
/// 
/// ```swift
/// ```
extension type MLNHillshadeStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNForegroundStyleLayer {
  /// Constructs a [MLNHillshadeStyleLayer] that points to the same underlying object as [other].
  MLNHillshadeStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNHillshadeStyleLayer] that wraps the given raw object pointer.
  MLNHillshadeStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNHillshadeStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNHillshadeStyleLayer);

  /// alloc
  static MLNHillshadeStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNHillshadeStyleLayer, _sel_alloc);
    return MLNHillshadeStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNHillshadeStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNHillshadeStyleLayer, _sel_allocWithZone_, zone);
    return MLNHillshadeStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNHillshadeStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNHillshadeStyleLayer, _sel_new);
    return MLNHillshadeStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNHillshadeStyleLayer constructed with the default `new` method.
  MLNHillshadeStyleLayer() : this.as(new$().object$);

}

extension MLNHillshadeStyleLayer$Methods on MLNHillshadeStyleLayer {

  /// The shading color used to accentuate rugged terrain like sharp cliffs and
/// gorges.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get hillshadeAccentColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hillshadeAccentColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `hillshadeAccentColor` property.
/// 
/// This property corresponds to the `hillshade-accent-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeAccentColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_hillshadeAccentColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_hillshadeAccentColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Intensity of the hillshade
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0.5`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get hillshadeExaggeration {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hillshadeExaggeration);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `hillshadeExaggeration` property.
/// 
/// This property corresponds to the `hillshade-exaggeration-transition` property in the style JSON file format.
  MLNTransition get hillshadeExaggerationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_hillshadeExaggerationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_hillshadeExaggerationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The shading color of areas that faces towards the light source.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.whiteColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get hillshadeHighlightColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hillshadeHighlightColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `hillshadeHighlightColor` property.
/// 
/// This property corresponds to the `hillshade-highlight-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeHighlightColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_hillshadeHighlightColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_hillshadeHighlightColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Direction of light source when map is rotated.
/// 
/// The default value of this property is an expression that evaluates to
/// `viewport`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNHillshadeIlluminationAnchor` values
/// Any of the following constant string values:
/// `map`: The hillshade illumination is relative to the north direction.
/// `viewport`: The hillshade illumination is relative to the top of the
/// viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get hillshadeIlluminationAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hillshadeIlluminationAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The direction of the light source used to generate the hillshading with 0 as
/// the top of the viewport if `hillshadeIlluminationAnchor` is set to
/// `MLNHillshadeIlluminationAnchorViewport` and due north if
/// `hillshadeIlluminationAnchor` is set to `MLNHillshadeIlluminationAnchorMap`.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `335`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 359 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get hillshadeIlluminationDirection {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hillshadeIlluminationDirection);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The shading color of areas that face away from the light source.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get hillshadeShadowColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hillshadeShadowColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `hillshadeShadowColor` property.
/// 
/// This property corresponds to the `hillshade-shadow-color-transition` property in the style JSON file format.
  MLNTransition get hillshadeShadowColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_hillshadeShadowColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_hillshadeShadowColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// init
  MLNHillshadeStyleLayer init() {
  objc.checkOsVersionInternal('MLNHillshadeStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNHillshadeStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a hillshade style layer initialized with an identifier and source.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param source The source from which to obtain the data to style. If the source
/// has not yet been added to the current style, the behavior is undefined.
/// @return An initialized foreground style layer.
  MLNHillshadeStyleLayer initWithIdentifier(objc.NSString identifier, {required MLNSource source}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_source_, identifier.ref.pointer, source.ref.pointer);
    return MLNHillshadeStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// The shading color used to accentuate rugged terrain like sharp cliffs and
/// gorges.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set hillshadeAccentColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHillshadeAccentColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `hillshadeAccentColor` property.
/// 
/// This property corresponds to the `hillshade-accent-color-transition` property in the style JSON file format.
  set hillshadeAccentColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setHillshadeAccentColorTransition_, value);

  }


  /// Intensity of the hillshade
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0.5`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set hillshadeExaggeration(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHillshadeExaggeration_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `hillshadeExaggeration` property.
/// 
/// This property corresponds to the `hillshade-exaggeration-transition` property in the style JSON file format.
  set hillshadeExaggerationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setHillshadeExaggerationTransition_, value);

  }


  /// The shading color of areas that faces towards the light source.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.whiteColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set hillshadeHighlightColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHillshadeHighlightColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `hillshadeHighlightColor` property.
/// 
/// This property corresponds to the `hillshade-highlight-color-transition` property in the style JSON file format.
  set hillshadeHighlightColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setHillshadeHighlightColorTransition_, value);

  }


  /// Direction of light source when map is rotated.
/// 
/// The default value of this property is an expression that evaluates to
/// `viewport`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNHillshadeIlluminationAnchor` values
/// Any of the following constant string values:
/// `map`: The hillshade illumination is relative to the north direction.
/// `viewport`: The hillshade illumination is relative to the top of the
/// viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set hillshadeIlluminationAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHillshadeIlluminationAnchor_, value.ref.pointer);

  }


  /// The direction of the light source used to generate the hillshading with 0 as
/// the top of the viewport if `hillshadeIlluminationAnchor` is set to
/// `MLNHillshadeIlluminationAnchorViewport` and due north if
/// `hillshadeIlluminationAnchor` is set to `MLNHillshadeIlluminationAnchorMap`.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `335`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 359 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set hillshadeIlluminationDirection(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHillshadeIlluminationDirection_, value.ref.pointer);

  }


  /// The shading color of areas that face away from the light source.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set hillshadeShadowColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setHillshadeShadowColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `hillshadeShadowColor` property.
/// 
/// This property corresponds to the `hillshade-shadow-color-transition` property in the style JSON file format.
  set hillshadeShadowColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setHillshadeShadowColorTransition_, value);

  }

}

late final _class_MLNLineStyleLayer = objc.getClass("MLNLineStyleLayer");
late final _sel_lineCap = objc.registerName("lineCap");
late final _sel_setLineCap_ = objc.registerName("setLineCap:");
late final _sel_lineJoin = objc.registerName("lineJoin");
late final _sel_setLineJoin_ = objc.registerName("setLineJoin:");
late final _sel_lineMiterLimit = objc.registerName("lineMiterLimit");
late final _sel_setLineMiterLimit_ = objc.registerName("setLineMiterLimit:");
late final _sel_lineRoundLimit = objc.registerName("lineRoundLimit");
late final _sel_setLineRoundLimit_ = objc.registerName("setLineRoundLimit:");
late final _sel_lineSortKey = objc.registerName("lineSortKey");
late final _sel_setLineSortKey_ = objc.registerName("setLineSortKey:");
late final _sel_lineBlur = objc.registerName("lineBlur");
late final _sel_setLineBlur_ = objc.registerName("setLineBlur:");
late final _sel_lineBlurTransition = objc.registerName("lineBlurTransition");
late final _sel_setLineBlurTransition_ = objc.registerName("setLineBlurTransition:");
late final _sel_lineColor = objc.registerName("lineColor");
late final _sel_setLineColor_ = objc.registerName("setLineColor:");
late final _sel_lineColorTransition = objc.registerName("lineColorTransition");
late final _sel_setLineColorTransition_ = objc.registerName("setLineColorTransition:");
late final _sel_lineDashPattern = objc.registerName("lineDashPattern");
late final _sel_setLineDashPattern_ = objc.registerName("setLineDashPattern:");
late final _sel_lineDashPatternTransition = objc.registerName("lineDashPatternTransition");
late final _sel_setLineDashPatternTransition_ = objc.registerName("setLineDashPatternTransition:");
late final _sel_lineDasharray = objc.registerName("lineDasharray");
late final _sel_setLineDasharray_ = objc.registerName("setLineDasharray:");
late final _sel_lineGapWidth = objc.registerName("lineGapWidth");
late final _sel_setLineGapWidth_ = objc.registerName("setLineGapWidth:");
late final _sel_lineGapWidthTransition = objc.registerName("lineGapWidthTransition");
late final _sel_setLineGapWidthTransition_ = objc.registerName("setLineGapWidthTransition:");
late final _sel_lineGradient = objc.registerName("lineGradient");
late final _sel_setLineGradient_ = objc.registerName("setLineGradient:");
late final _sel_lineOffset = objc.registerName("lineOffset");
late final _sel_setLineOffset_ = objc.registerName("setLineOffset:");
late final _sel_lineOffsetTransition = objc.registerName("lineOffsetTransition");
late final _sel_setLineOffsetTransition_ = objc.registerName("setLineOffsetTransition:");
late final _sel_lineOpacity = objc.registerName("lineOpacity");
late final _sel_setLineOpacity_ = objc.registerName("setLineOpacity:");
late final _sel_lineOpacityTransition = objc.registerName("lineOpacityTransition");
late final _sel_setLineOpacityTransition_ = objc.registerName("setLineOpacityTransition:");
late final _sel_linePattern = objc.registerName("linePattern");
late final _sel_setLinePattern_ = objc.registerName("setLinePattern:");
late final _sel_linePatternTransition = objc.registerName("linePatternTransition");
late final _sel_setLinePatternTransition_ = objc.registerName("setLinePatternTransition:");
late final _sel_lineTranslation = objc.registerName("lineTranslation");
late final _sel_setLineTranslation_ = objc.registerName("setLineTranslation:");
late final _sel_lineTranslationTransition = objc.registerName("lineTranslationTransition");
late final _sel_setLineTranslationTransition_ = objc.registerName("setLineTranslationTransition:");
late final _sel_lineTranslate = objc.registerName("lineTranslate");
late final _sel_setLineTranslate_ = objc.registerName("setLineTranslate:");
late final _sel_lineTranslationAnchor = objc.registerName("lineTranslationAnchor");
late final _sel_setLineTranslationAnchor_ = objc.registerName("setLineTranslationAnchor:");
late final _sel_lineTranslateAnchor = objc.registerName("lineTranslateAnchor");
late final _sel_setLineTranslateAnchor_ = objc.registerName("setLineTranslateAnchor:");
late final _sel_lineWidth = objc.registerName("lineWidth");
late final _sel_setLineWidth_ = objc.registerName("setLineWidth:");
late final _sel_lineWidthTransition = objc.registerName("lineWidthTransition");
late final _sel_setLineWidthTransition_ = objc.registerName("setLineWidthTransition:");

/// An ``MLNLineStyleLayer`` is a style layer that renders one or more stroked
/// polylines on the map.
/// 
/// Use a line style layer to configure the visual appearance of polyline or
/// multipolyline features. These features can come from vector tiles loaded by an
/// ``MLNLineStyleLayer`` object, or they can be ``MLNLineStyleLayer``,
/// ``MLNLineStyleLayer``, ``MLNLineStyleLayer``, or ``MLNLineStyleLayer``
/// instances in an ``MLNLineStyleLayer`` or ``MLNLineStyleLayer`` object.
/// 
/// You can access an existing line style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new line style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
/// 
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/shape-collection/">Add multiple
/// shapes from a single shape source</a> example to learn how to add a line to
/// your map using this style layer. See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/runtime-add-line/">Add a line
/// style layer from GeoJSON</a> example to learn how to add and style line data to
/// an ``MLNMapView`` object at runtime.
/// 
/// ### Example
/// 
/// ```swift
/// ```
extension type MLNLineStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNVectorStyleLayer {
  /// Constructs a [MLNLineStyleLayer] that points to the same underlying object as [other].
  MLNLineStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNLineStyleLayer] that wraps the given raw object pointer.
  MLNLineStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNLineStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNLineStyleLayer);

  /// alloc
  static MLNLineStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNLineStyleLayer, _sel_alloc);
    return MLNLineStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNLineStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNLineStyleLayer, _sel_allocWithZone_, zone);
    return MLNLineStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNLineStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNLineStyleLayer, _sel_new);
    return MLNLineStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNLineStyleLayer constructed with the default `new` method.
  MLNLineStyleLayer() : this.as(new$().object$);

}

extension MLNLineStyleLayer$Methods on MLNLineStyleLayer {

  /// init
  MLNLineStyleLayer init() {
  objc.checkOsVersionInternal('MLNLineStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNLineStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a line style layer initialized with an identifier and source.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param source The source from which to obtain the data to style. If the source
/// has not yet been added to the current style, the behavior is undefined.
/// @return An initialized foreground style layer.
  MLNLineStyleLayer initWithIdentifier(objc.NSString identifier, {required MLNSource source}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_source_, identifier.ref.pointer, source.ref.pointer);
    return MLNLineStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Blur applied to the line, in points.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get lineBlur {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineBlur);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `lineBlur` property.
/// 
/// This property corresponds to the `line-blur-transition` property in the style JSON file format.
  MLNTransition get lineBlurTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_lineBlurTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_lineBlurTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The display of line endings.
/// 
/// The default value of this property is an expression that evaluates to `butt`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNLineCap` values
/// Any of the following constant string values:
/// `butt`: A cap with a squared-off end which is drawn to the exact endpoint
/// of the line.
/// `round`: A cap with a rounded end which is drawn beyond the endpoint of the
/// line at a radius of one-half of the line's width and centered on the endpoint
/// of the line.
/// `square`: A cap with a squared-off end which is drawn beyond the endpoint
/// of the line at a distance of one-half of the line's width.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get lineCap {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineCap);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The color with which the line will be drawn.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `linePattern` is set to `nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get lineColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `lineColor` property.
/// 
/// This property corresponds to the `line-color-transition` property in the style JSON file format.
  MLNTransition get lineColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_lineColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_lineColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Specifies the lengths of the alternating dashes and gaps that form the dash
/// pattern. The lengths are later scaled by the line width. To convert a dash
/// length to points, multiply the length by the current line width. Note that
/// GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to
/// the expected scale. Also note that zoom-dependent expressions will be evaluated
/// only at integer zoom levels.
/// 
/// This property is measured in line widths.
/// 
/// This property is only applied to the style if `linePattern` is set to `nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-line-dasharray"><code>line-dasharray</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant array values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get lineDashPattern {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineDashPattern);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `lineDashPattern` property.
/// 
/// This property corresponds to the `line-dasharray-transition` property in the style JSON file format.
  MLNTransition get lineDashPatternTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_lineDashPatternTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_lineDashPatternTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// lineDasharray
  NSExpression get lineDasharray {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineDasharray);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Draws a line casing outside of a line's actual path. Value indicates the width
/// of the inner gap.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get lineGapWidth {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineGapWidth);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `lineGapWidth` property.
/// 
/// This property corresponds to the `line-gap-width-transition` property in the style JSON file format.
  MLNTransition get lineGapWidthTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_lineGapWidthTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_lineGapWidthTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The color gradient with which the line will be drawn. This property only has an
/// effect on lines defined by an ``MLNShapeSource`` whose ``MLNShapeSource``
/// option is set to `YES`.
/// 
/// This property is only applied to the style if `lineDasharray` is set to `nil`,
/// and `linePattern` is set to `nil`, and the data source requirements are met.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$lineProgress` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get lineGradient {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineGradient);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The display of lines when joining.
/// 
/// The default value of this property is an expression that evaluates to `miter`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNLineJoin` values
/// Any of the following constant string values:
/// `bevel`: A join with a squared-off end which is drawn beyond the endpoint
/// of the line at a distance of one-half of the line's width.
/// `round`: A join with a rounded end which is drawn beyond the endpoint of
/// the line at a radius of one-half of the line's width and centered on the
/// endpoint of the line.
/// `miter`: A join with a sharp, angled corner which is drawn with the outer
/// sides beyond the endpoint of the path until they meet.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get lineJoin {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineJoin);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Used to automatically convert miter joins to bevel joins for sharp angles.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `2`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `lineJoin` is set to an
/// expression that evaluates to `miter`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get lineMiterLimit {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineMiterLimit);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The line's offset. For linear features, a positive value offsets the line to
/// the right, relative to the direction of the line, and a negative value to the
/// left. For polygon features, a positive value results in an inset, and a
/// negative value results in an outset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get lineOffset {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineOffset);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `lineOffset` property.
/// 
/// This property corresponds to the `line-offset-transition` property in the style JSON file format.
  MLNTransition get lineOffsetTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_lineOffsetTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_lineOffsetTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The opacity at which the line will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get lineOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `lineOpacity` property.
/// 
/// This property corresponds to the `line-opacity-transition` property in the style JSON file format.
  MLNTransition get lineOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_lineOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_lineOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Name of image in style images to use for drawing image lines. For seamless
/// patterns, image width must be a factor of two (2, 4, 8, ..., 512).
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get linePattern {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_linePattern);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `linePattern` property.
/// 
/// This property corresponds to the `line-pattern-transition` property in the style JSON file format.
  MLNTransition get linePatternTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_linePatternTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_linePatternTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Used to automatically convert round joins to miter joins for shallow angles.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1.05`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `lineJoin` is set to an
/// expression that evaluates to `round`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get lineRoundLimit {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineRoundLimit);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Sorts features in ascending order based on this value. Features with a higher
/// sort key will appear above features with a lower sort key.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get lineSortKey {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineSortKey);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// lineTranslate
  NSExpression get lineTranslate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineTranslate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// lineTranslateAnchor
  NSExpression get lineTranslateAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineTranslateAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The geometry's offset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate"><code>line-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get lineTranslation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineTranslation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Controls the frame of reference for `lineTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `lineTranslation` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate-anchor"><code>line-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNLineTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The line is translated relative to the map.
/// `viewport`: The line is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get lineTranslationAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineTranslationAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `lineTranslation` property.
/// 
/// This property corresponds to the `line-translate-transition` property in the style JSON file format.
  MLNTransition get lineTranslationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_lineTranslationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_lineTranslationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Stroke thickness.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get lineWidth {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lineWidth);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `lineWidth` property.
/// 
/// This property corresponds to the `line-width-transition` property in the style JSON file format.
  MLNTransition get lineWidthTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_lineWidthTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_lineWidthTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Blur applied to the line, in points.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set lineBlur(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineBlur_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `lineBlur` property.
/// 
/// This property corresponds to the `line-blur-transition` property in the style JSON file format.
  set lineBlurTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLineBlurTransition_, value);

  }


  /// The display of line endings.
/// 
/// The default value of this property is an expression that evaluates to `butt`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNLineCap` values
/// Any of the following constant string values:
/// `butt`: A cap with a squared-off end which is drawn to the exact endpoint
/// of the line.
/// `round`: A cap with a rounded end which is drawn beyond the endpoint of the
/// line at a radius of one-half of the line's width and centered on the endpoint
/// of the line.
/// `square`: A cap with a squared-off end which is drawn beyond the endpoint
/// of the line at a distance of one-half of the line's width.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set lineCap(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineCap_, value.ref.pointer);

  }


  /// The color with which the line will be drawn.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `linePattern` is set to `nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set lineColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `lineColor` property.
/// 
/// This property corresponds to the `line-color-transition` property in the style JSON file format.
  set lineColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLineColorTransition_, value);

  }


  /// Specifies the lengths of the alternating dashes and gaps that form the dash
/// pattern. The lengths are later scaled by the line width. To convert a dash
/// length to points, multiply the length by the current line width. Note that
/// GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to
/// the expected scale. Also note that zoom-dependent expressions will be evaluated
/// only at integer zoom levels.
/// 
/// This property is measured in line widths.
/// 
/// This property is only applied to the style if `linePattern` is set to `nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-line-dasharray"><code>line-dasharray</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant array values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set lineDashPattern(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineDashPattern_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `lineDashPattern` property.
/// 
/// This property corresponds to the `line-dasharray-transition` property in the style JSON file format.
  set lineDashPatternTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLineDashPatternTransition_, value);

  }


  /// setLineDasharray:
  set lineDasharray(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineDasharray_, value.ref.pointer);

  }


  /// Draws a line casing outside of a line's actual path. Value indicates the width
/// of the inner gap.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set lineGapWidth(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineGapWidth_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `lineGapWidth` property.
/// 
/// This property corresponds to the `line-gap-width-transition` property in the style JSON file format.
  set lineGapWidthTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLineGapWidthTransition_, value);

  }


  /// The color gradient with which the line will be drawn. This property only has an
/// effect on lines defined by an ``MLNShapeSource`` whose ``MLNShapeSource``
/// option is set to `YES`.
/// 
/// This property is only applied to the style if `lineDasharray` is set to `nil`,
/// and `linePattern` is set to `nil`, and the data source requirements are met.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$lineProgress` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set lineGradient(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineGradient_, value.ref.pointer);

  }


  /// The display of lines when joining.
/// 
/// The default value of this property is an expression that evaluates to `miter`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNLineJoin` values
/// Any of the following constant string values:
/// `bevel`: A join with a squared-off end which is drawn beyond the endpoint
/// of the line at a distance of one-half of the line's width.
/// `round`: A join with a rounded end which is drawn beyond the endpoint of
/// the line at a radius of one-half of the line's width and centered on the
/// endpoint of the line.
/// `miter`: A join with a sharp, angled corner which is drawn with the outer
/// sides beyond the endpoint of the path until they meet.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set lineJoin(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineJoin_, value.ref.pointer);

  }


  /// Used to automatically convert miter joins to bevel joins for sharp angles.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `2`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `lineJoin` is set to an
/// expression that evaluates to `miter`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set lineMiterLimit(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineMiterLimit_, value.ref.pointer);

  }


  /// The line's offset. For linear features, a positive value offsets the line to
/// the right, relative to the direction of the line, and a negative value to the
/// left. For polygon features, a positive value results in an inset, and a
/// negative value results in an outset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set lineOffset(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineOffset_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `lineOffset` property.
/// 
/// This property corresponds to the `line-offset-transition` property in the style JSON file format.
  set lineOffsetTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLineOffsetTransition_, value);

  }


  /// The opacity at which the line will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set lineOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `lineOpacity` property.
/// 
/// This property corresponds to the `line-opacity-transition` property in the style JSON file format.
  set lineOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLineOpacityTransition_, value);

  }


  /// Name of image in style images to use for drawing image lines. For seamless
/// patterns, image width must be a factor of two (2, 4, 8, ..., 512).
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set linePattern(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLinePattern_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `linePattern` property.
/// 
/// This property corresponds to the `line-pattern-transition` property in the style JSON file format.
  set linePatternTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLinePatternTransition_, value);

  }


  /// Used to automatically convert round joins to miter joins for shallow angles.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1.05`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `lineJoin` is set to an
/// expression that evaluates to `round`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set lineRoundLimit(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineRoundLimit_, value.ref.pointer);

  }


  /// Sorts features in ascending order based on this value. Features with a higher
/// sort key will appear above features with a lower sort key.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set lineSortKey(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineSortKey_, value.ref.pointer);

  }


  /// setLineTranslate:
  set lineTranslate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineTranslate_, value.ref.pointer);

  }


  /// setLineTranslateAnchor:
  set lineTranslateAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineTranslateAnchor_, value.ref.pointer);

  }


  /// The geometry's offset.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate"><code>line-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set lineTranslation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineTranslation_, value.ref.pointer);

  }


  /// Controls the frame of reference for `lineTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `lineTranslation` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-line-translate-anchor"><code>line-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNLineTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The line is translated relative to the map.
/// `viewport`: The line is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set lineTranslationAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineTranslationAnchor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `lineTranslation` property.
/// 
/// This property corresponds to the `line-translate-transition` property in the style JSON file format.
  set lineTranslationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLineTranslationTransition_, value);

  }


  /// Stroke thickness.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set lineWidth(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setLineWidth_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `lineWidth` property.
/// 
/// This property corresponds to the `line-width-transition` property in the style JSON file format.
  set lineWidthTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setLineWidthTransition_, value);

  }

}

late final _class_MLNRasterStyleLayer = objc.getClass("MLNRasterStyleLayer");
late final _sel_maximumRasterBrightness = objc.registerName("maximumRasterBrightness");
late final _sel_setMaximumRasterBrightness_ = objc.registerName("setMaximumRasterBrightness:");
late final _sel_maximumRasterBrightnessTransition = objc.registerName("maximumRasterBrightnessTransition");
late final _sel_setMaximumRasterBrightnessTransition_ = objc.registerName("setMaximumRasterBrightnessTransition:");
late final _sel_rasterBrightnessMax = objc.registerName("rasterBrightnessMax");
late final _sel_setRasterBrightnessMax_ = objc.registerName("setRasterBrightnessMax:");
late final _sel_minimumRasterBrightness = objc.registerName("minimumRasterBrightness");
late final _sel_setMinimumRasterBrightness_ = objc.registerName("setMinimumRasterBrightness:");
late final _sel_minimumRasterBrightnessTransition = objc.registerName("minimumRasterBrightnessTransition");
late final _sel_setMinimumRasterBrightnessTransition_ = objc.registerName("setMinimumRasterBrightnessTransition:");
late final _sel_rasterBrightnessMin = objc.registerName("rasterBrightnessMin");
late final _sel_setRasterBrightnessMin_ = objc.registerName("setRasterBrightnessMin:");
late final _sel_rasterContrast = objc.registerName("rasterContrast");
late final _sel_setRasterContrast_ = objc.registerName("setRasterContrast:");
late final _sel_rasterContrastTransition = objc.registerName("rasterContrastTransition");
late final _sel_setRasterContrastTransition_ = objc.registerName("setRasterContrastTransition:");
late final _sel_rasterFadeDuration = objc.registerName("rasterFadeDuration");
late final _sel_setRasterFadeDuration_ = objc.registerName("setRasterFadeDuration:");
late final _sel_rasterHueRotation = objc.registerName("rasterHueRotation");
late final _sel_setRasterHueRotation_ = objc.registerName("setRasterHueRotation:");
late final _sel_rasterHueRotationTransition = objc.registerName("rasterHueRotationTransition");
late final _sel_setRasterHueRotationTransition_ = objc.registerName("setRasterHueRotationTransition:");
late final _sel_rasterHueRotate = objc.registerName("rasterHueRotate");
late final _sel_setRasterHueRotate_ = objc.registerName("setRasterHueRotate:");
late final _sel_rasterOpacity = objc.registerName("rasterOpacity");
late final _sel_setRasterOpacity_ = objc.registerName("setRasterOpacity:");
late final _sel_rasterOpacityTransition = objc.registerName("rasterOpacityTransition");
late final _sel_setRasterOpacityTransition_ = objc.registerName("setRasterOpacityTransition:");
late final _sel_rasterResamplingMode = objc.registerName("rasterResamplingMode");
late final _sel_setRasterResamplingMode_ = objc.registerName("setRasterResamplingMode:");
late final _sel_rasterResampling = objc.registerName("rasterResampling");
late final _sel_setRasterResampling_ = objc.registerName("setRasterResampling:");
late final _sel_rasterSaturation = objc.registerName("rasterSaturation");
late final _sel_setRasterSaturation_ = objc.registerName("setRasterSaturation:");
late final _sel_rasterSaturationTransition = objc.registerName("rasterSaturationTransition");
late final _sel_setRasterSaturationTransition_ = objc.registerName("setRasterSaturationTransition:");

/// An ``MLNRasterStyleLayer`` is a style layer that renders georeferenced raster
/// imagery on the map, especially raster tiles.
/// 
/// Use a raster style layer to configure the color parameters of raster tiles
/// loaded by an ``MLNRasterStyleLayer`` object or raster images loaded by an
/// ``MLNRasterStyleLayer`` object. For example, you could use a raster style layer
/// to render <a href="https://www.mapbox.com/satellite/">Mapbox Satellite</a>
/// imagery, a <a
/// href="https://docs.mapbox.com/help/glossary/tileset/#raster-tilesets">raster
/// tile set</a> uploaded to Mapbox Studio, or a raster map authored in <a
/// href="https://tilemill-project.github.io/tilemill/">TileMill</a>, the classic
/// Mapbox Editor, or Mapbox Studio Classic.
/// 
/// Raster images may also be used as icons or patterns in a style layer. To
/// register an image for use as an icon or pattern, use the
/// ``MLNStyle/setImage:forName:`` method. To configure a point annotations image,
/// use the ``MLNRasterStyleLayer`` class.
/// 
/// You can access an existing raster style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new raster style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
/// 
/// #### Related examples
/// See the <a href="https://docs.mapbox.com/ios/maps/examples/image-source/">Add
/// an image</a> and <a
/// href="https://docs.mapbox.com/ios/maps/examples/source-custom-raster/">Add
/// raster imagery</a> examples to learn how to add imagery with this style layer.
/// 
/// ### Example
/// 
/// ```swift
/// ```
extension type MLNRasterStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNForegroundStyleLayer {
  /// Constructs a [MLNRasterStyleLayer] that points to the same underlying object as [other].
  MLNRasterStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNRasterStyleLayer] that wraps the given raw object pointer.
  MLNRasterStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNRasterStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNRasterStyleLayer);

  /// alloc
  static MLNRasterStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNRasterStyleLayer, _sel_alloc);
    return MLNRasterStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNRasterStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNRasterStyleLayer, _sel_allocWithZone_, zone);
    return MLNRasterStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNRasterStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNRasterStyleLayer, _sel_new);
    return MLNRasterStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNRasterStyleLayer constructed with the default `new` method.
  MLNRasterStyleLayer() : this.as(new$().object$);

}

extension MLNRasterStyleLayer$Methods on MLNRasterStyleLayer {

  /// init
  MLNRasterStyleLayer init() {
  objc.checkOsVersionInternal('MLNRasterStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNRasterStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a raster style layer initialized with an identifier and source.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param source The source from which to obtain the data to style. If the source
/// has not yet been added to the current style, the behavior is undefined.
/// @return An initialized foreground style layer.
  MLNRasterStyleLayer initWithIdentifier(objc.NSString identifier, {required MLNSource source}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_source_, identifier.ref.pointer, source.ref.pointer);
    return MLNRasterStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Increase or reduce the brightness of the image. The value is the maximum
/// brightness.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-max"><code>raster-brightness-max</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get maximumRasterBrightness {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_maximumRasterBrightness);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `maximumRasterBrightness` property.
/// 
/// This property corresponds to the `raster-brightness-max-transition` property in the style JSON file format.
  MLNTransition get maximumRasterBrightnessTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_maximumRasterBrightnessTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_maximumRasterBrightnessTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Increase or reduce the brightness of the image. The value is the minimum
/// brightness.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-min"><code>raster-brightness-min</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get minimumRasterBrightness {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_minimumRasterBrightness);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `minimumRasterBrightness` property.
/// 
/// This property corresponds to the `raster-brightness-min-transition` property in the style JSON file format.
  MLNTransition get minimumRasterBrightnessTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_minimumRasterBrightnessTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_minimumRasterBrightnessTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// rasterBrightnessMax
  NSExpression get rasterBrightnessMax {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterBrightnessMax);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// rasterBrightnessMin
  NSExpression get rasterBrightnessMin {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterBrightnessMin);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Increase or reduce the contrast of the image.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 1 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get rasterContrast {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterContrast);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `rasterContrast` property.
/// 
/// This property corresponds to the `raster-contrast-transition` property in the style JSON file format.
  MLNTransition get rasterContrastTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_rasterContrastTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_rasterContrastTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Fade duration when a new tile is added, or when a video is started or its
/// coordinates are updated.
/// 
/// This property is measured in milliseconds.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `300`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get rasterFadeDuration {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterFadeDuration);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// rasterHueRotate
  NSExpression get rasterHueRotate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterHueRotate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Rotates hues around the color wheel.
/// 
/// This property is measured in degrees.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-raster-hue-rotate"><code>raster-hue-rotate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get rasterHueRotation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterHueRotation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `rasterHueRotation` property.
/// 
/// This property corresponds to the `raster-hue-rotate-transition` property in the style JSON file format.
  MLNTransition get rasterHueRotationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_rasterHueRotationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_rasterHueRotationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The opacity at which the image will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get rasterOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `rasterOpacity` property.
/// 
/// This property corresponds to the `raster-opacity-transition` property in the style JSON file format.
  MLNTransition get rasterOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_rasterOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_rasterOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// rasterResampling
  NSExpression get rasterResampling {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterResampling);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The resampling/interpolation method to use for overscaling, also known as
/// texture magnification filter
/// 
/// The default value of this property is an expression that evaluates to `linear`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-raster-resampling"><code>raster-resampling</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNRasterResamplingMode` values
/// Any of the following constant string values:
/// `linear`: (Bi)linear filtering interpolates pixel values using the weighted
/// average of the four closest original source pixels creating a smooth but blurry
/// look when overscaled
/// `nearest`: Nearest neighbor filtering interpolates pixel values using the
/// nearest original source pixel creating a sharp but pixelated look when
/// overscaled
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get rasterResamplingMode {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterResamplingMode);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Increase or reduce the saturation of the image.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 1 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get rasterSaturation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rasterSaturation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `rasterSaturation` property.
/// 
/// This property corresponds to the `raster-saturation-transition` property in the style JSON file format.
  MLNTransition get rasterSaturationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_rasterSaturationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_rasterSaturationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Increase or reduce the brightness of the image. The value is the maximum
/// brightness.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-max"><code>raster-brightness-max</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set maximumRasterBrightness(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMaximumRasterBrightness_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `maximumRasterBrightness` property.
/// 
/// This property corresponds to the `raster-brightness-max-transition` property in the style JSON file format.
  set maximumRasterBrightnessTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setMaximumRasterBrightnessTransition_, value);

  }


  /// Increase or reduce the brightness of the image. The value is the minimum
/// brightness.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-raster-brightness-min"><code>raster-brightness-min</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set minimumRasterBrightness(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMinimumRasterBrightness_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `minimumRasterBrightness` property.
/// 
/// This property corresponds to the `raster-brightness-min-transition` property in the style JSON file format.
  set minimumRasterBrightnessTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setMinimumRasterBrightnessTransition_, value);

  }


  /// setRasterBrightnessMax:
  set rasterBrightnessMax(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterBrightnessMax_, value.ref.pointer);

  }


  /// setRasterBrightnessMin:
  set rasterBrightnessMin(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterBrightnessMin_, value.ref.pointer);

  }


  /// Increase or reduce the contrast of the image.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 1 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set rasterContrast(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterContrast_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `rasterContrast` property.
/// 
/// This property corresponds to the `raster-contrast-transition` property in the style JSON file format.
  set rasterContrastTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setRasterContrastTransition_, value);

  }


  /// Fade duration when a new tile is added, or when a video is started or its
/// coordinates are updated.
/// 
/// This property is measured in milliseconds.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `300`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set rasterFadeDuration(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterFadeDuration_, value.ref.pointer);

  }


  /// setRasterHueRotate:
  set rasterHueRotate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterHueRotate_, value.ref.pointer);

  }


  /// Rotates hues around the color wheel.
/// 
/// This property is measured in degrees.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-raster-hue-rotate"><code>raster-hue-rotate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set rasterHueRotation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterHueRotation_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `rasterHueRotation` property.
/// 
/// This property corresponds to the `raster-hue-rotate-transition` property in the style JSON file format.
  set rasterHueRotationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setRasterHueRotationTransition_, value);

  }


  /// The opacity at which the image will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set rasterOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `rasterOpacity` property.
/// 
/// This property corresponds to the `raster-opacity-transition` property in the style JSON file format.
  set rasterOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setRasterOpacityTransition_, value);

  }


  /// setRasterResampling:
  set rasterResampling(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterResampling_, value.ref.pointer);

  }


  /// The resampling/interpolation method to use for overscaling, also known as
/// texture magnification filter
/// 
/// The default value of this property is an expression that evaluates to `linear`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-raster-resampling"><code>raster-resampling</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNRasterResamplingMode` values
/// Any of the following constant string values:
/// `linear`: (Bi)linear filtering interpolates pixel values using the weighted
/// average of the four closest original source pixels creating a smooth but blurry
/// look when overscaled
/// `nearest`: Nearest neighbor filtering interpolates pixel values using the
/// nearest original source pixel creating a sharp but pixelated look when
/// overscaled
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set rasterResamplingMode(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterResamplingMode_, value.ref.pointer);

  }


  /// Increase or reduce the saturation of the image.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 1 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set rasterSaturation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setRasterSaturation_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `rasterSaturation` property.
/// 
/// This property corresponds to the `raster-saturation-transition` property in the style JSON file format.
  set rasterSaturationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setRasterSaturationTransition_, value);

  }

}

late final _class_MLNSymbolStyleLayer = objc.getClass("MLNSymbolStyleLayer");
late final _sel_iconAllowsOverlap = objc.registerName("iconAllowsOverlap");
late final _sel_setIconAllowsOverlap_ = objc.registerName("setIconAllowsOverlap:");
late final _sel_iconAllowOverlap = objc.registerName("iconAllowOverlap");
late final _sel_setIconAllowOverlap_ = objc.registerName("setIconAllowOverlap:");
late final _sel_iconAnchor = objc.registerName("iconAnchor");
late final _sel_setIconAnchor_ = objc.registerName("setIconAnchor:");
late final _sel_iconIgnoresPlacement = objc.registerName("iconIgnoresPlacement");
late final _sel_setIconIgnoresPlacement_ = objc.registerName("setIconIgnoresPlacement:");
late final _sel_iconIgnorePlacement = objc.registerName("iconIgnorePlacement");
late final _sel_setIconIgnorePlacement_ = objc.registerName("setIconIgnorePlacement:");
late final _sel_iconImageName = objc.registerName("iconImageName");
late final _sel_setIconImageName_ = objc.registerName("setIconImageName:");
late final _sel_iconImage = objc.registerName("iconImage");
late final _sel_setIconImage_ = objc.registerName("setIconImage:");
late final _sel_iconOffset = objc.registerName("iconOffset");
late final _sel_setIconOffset_ = objc.registerName("setIconOffset:");
late final _sel_isIconOptional = objc.registerName("isIconOptional");
late final _sel_setIconOptional_ = objc.registerName("setIconOptional:");
late final _sel_iconPadding = objc.registerName("iconPadding");
late final _sel_setIconPadding_ = objc.registerName("setIconPadding:");
late final _sel_iconPitchAlignment = objc.registerName("iconPitchAlignment");
late final _sel_setIconPitchAlignment_ = objc.registerName("setIconPitchAlignment:");
late final _sel_iconRotation = objc.registerName("iconRotation");
late final _sel_setIconRotation_ = objc.registerName("setIconRotation:");
late final _sel_iconRotate = objc.registerName("iconRotate");
late final _sel_setIconRotate_ = objc.registerName("setIconRotate:");
late final _sel_iconRotationAlignment = objc.registerName("iconRotationAlignment");
late final _sel_setIconRotationAlignment_ = objc.registerName("setIconRotationAlignment:");
late final _sel_iconScale = objc.registerName("iconScale");
late final _sel_setIconScale_ = objc.registerName("setIconScale:");
late final _sel_iconSize = objc.registerName("iconSize");
late final _sel_setIconSize_ = objc.registerName("setIconSize:");
late final _sel_iconTextFit = objc.registerName("iconTextFit");
late final _sel_setIconTextFit_ = objc.registerName("setIconTextFit:");
late final _sel_iconTextFitPadding = objc.registerName("iconTextFitPadding");
late final _sel_setIconTextFitPadding_ = objc.registerName("setIconTextFitPadding:");
late final _sel_keepsIconUpright = objc.registerName("keepsIconUpright");
late final _sel_setKeepsIconUpright_ = objc.registerName("setKeepsIconUpright:");
late final _sel_iconKeepUpright = objc.registerName("iconKeepUpright");
late final _sel_setIconKeepUpright_ = objc.registerName("setIconKeepUpright:");
late final _sel_keepsTextUpright = objc.registerName("keepsTextUpright");
late final _sel_setKeepsTextUpright_ = objc.registerName("setKeepsTextUpright:");
late final _sel_textKeepUpright = objc.registerName("textKeepUpright");
late final _sel_setTextKeepUpright_ = objc.registerName("setTextKeepUpright:");
late final _sel_maximumTextAngle = objc.registerName("maximumTextAngle");
late final _sel_setMaximumTextAngle_ = objc.registerName("setMaximumTextAngle:");
late final _sel_textMaxAngle = objc.registerName("textMaxAngle");
late final _sel_setTextMaxAngle_ = objc.registerName("setTextMaxAngle:");
late final _sel_maximumTextWidth = objc.registerName("maximumTextWidth");
late final _sel_setMaximumTextWidth_ = objc.registerName("setMaximumTextWidth:");
late final _sel_textMaxWidth = objc.registerName("textMaxWidth");
late final _sel_setTextMaxWidth_ = objc.registerName("setTextMaxWidth:");
late final _sel_symbolAvoidsEdges = objc.registerName("symbolAvoidsEdges");
late final _sel_setSymbolAvoidsEdges_ = objc.registerName("setSymbolAvoidsEdges:");
late final _sel_symbolAvoidEdges = objc.registerName("symbolAvoidEdges");
late final _sel_setSymbolAvoidEdges_ = objc.registerName("setSymbolAvoidEdges:");
late final _sel_symbolPlacement = objc.registerName("symbolPlacement");
late final _sel_setSymbolPlacement_ = objc.registerName("setSymbolPlacement:");
late final _sel_symbolScreenSpace = objc.registerName("symbolScreenSpace");
late final _sel_setSymbolScreenSpace_ = objc.registerName("setSymbolScreenSpace:");
late final _sel_symbolSortKey = objc.registerName("symbolSortKey");
late final _sel_setSymbolSortKey_ = objc.registerName("setSymbolSortKey:");
late final _sel_symbolSpacing = objc.registerName("symbolSpacing");
late final _sel_setSymbolSpacing_ = objc.registerName("setSymbolSpacing:");
late final _sel_symbolZOrder = objc.registerName("symbolZOrder");
late final _sel_setSymbolZOrder_ = objc.registerName("setSymbolZOrder:");
late final _sel_textField = objc.registerName("textField");
late final _sel_setTextField_ = objc.registerName("setTextField:");
late final _sel_textAllowsOverlap = objc.registerName("textAllowsOverlap");
late final _sel_setTextAllowsOverlap_ = objc.registerName("setTextAllowsOverlap:");
late final _sel_textAllowOverlap = objc.registerName("textAllowOverlap");
late final _sel_setTextAllowOverlap_ = objc.registerName("setTextAllowOverlap:");
late final _sel_textAnchor = objc.registerName("textAnchor");
late final _sel_setTextAnchor_ = objc.registerName("setTextAnchor:");
late final _sel_textFontNames = objc.registerName("textFontNames");
late final _sel_setTextFontNames_ = objc.registerName("setTextFontNames:");
late final _sel_textFont = objc.registerName("textFont");
late final _sel_setTextFont_ = objc.registerName("setTextFont:");
late final _sel_textFontSize = objc.registerName("textFontSize");
late final _sel_setTextFontSize_ = objc.registerName("setTextFontSize:");
late final _sel_textSize = objc.registerName("textSize");
late final _sel_setTextSize_ = objc.registerName("setTextSize:");
late final _sel_textIgnoresPlacement = objc.registerName("textIgnoresPlacement");
late final _sel_setTextIgnoresPlacement_ = objc.registerName("setTextIgnoresPlacement:");
late final _sel_textIgnorePlacement = objc.registerName("textIgnorePlacement");
late final _sel_setTextIgnorePlacement_ = objc.registerName("setTextIgnorePlacement:");
late final _sel_textJustification = objc.registerName("textJustification");
late final _sel_setTextJustification_ = objc.registerName("setTextJustification:");
late final _sel_textJustify = objc.registerName("textJustify");
late final _sel_setTextJustify_ = objc.registerName("setTextJustify:");
late final _sel_textLetterSpacing = objc.registerName("textLetterSpacing");
late final _sel_setTextLetterSpacing_ = objc.registerName("setTextLetterSpacing:");
late final _sel_textLineHeight = objc.registerName("textLineHeight");
late final _sel_setTextLineHeight_ = objc.registerName("setTextLineHeight:");
late final _sel_textOffset = objc.registerName("textOffset");
late final _sel_setTextOffset_ = objc.registerName("setTextOffset:");
late final _sel_isTextOptional = objc.registerName("isTextOptional");
late final _sel_setTextOptional_ = objc.registerName("setTextOptional:");
late final _sel_textPadding = objc.registerName("textPadding");
late final _sel_setTextPadding_ = objc.registerName("setTextPadding:");
late final _sel_textPitchAlignment = objc.registerName("textPitchAlignment");
late final _sel_setTextPitchAlignment_ = objc.registerName("setTextPitchAlignment:");
late final _sel_textRadialOffset = objc.registerName("textRadialOffset");
late final _sel_setTextRadialOffset_ = objc.registerName("setTextRadialOffset:");
late final _sel_textRotation = objc.registerName("textRotation");
late final _sel_setTextRotation_ = objc.registerName("setTextRotation:");
late final _sel_textRotate = objc.registerName("textRotate");
late final _sel_setTextRotate_ = objc.registerName("setTextRotate:");
late final _sel_textRotationAlignment = objc.registerName("textRotationAlignment");
late final _sel_setTextRotationAlignment_ = objc.registerName("setTextRotationAlignment:");
late final _sel_textTransform = objc.registerName("textTransform");
late final _sel_setTextTransform_ = objc.registerName("setTextTransform:");
late final _sel_textVariableAnchor = objc.registerName("textVariableAnchor");
late final _sel_setTextVariableAnchor_ = objc.registerName("setTextVariableAnchor:");
late final _sel_textVariableAnchorOffset = objc.registerName("textVariableAnchorOffset");
late final _sel_setTextVariableAnchorOffset_ = objc.registerName("setTextVariableAnchorOffset:");
late final _sel_textWritingModes = objc.registerName("textWritingModes");
late final _sel_setTextWritingModes_ = objc.registerName("setTextWritingModes:");
late final _sel_textWritingMode = objc.registerName("textWritingMode");
late final _sel_setTextWritingMode_ = objc.registerName("setTextWritingMode:");
late final _sel_iconColor = objc.registerName("iconColor");
late final _sel_setIconColor_ = objc.registerName("setIconColor:");
late final _sel_iconColorTransition = objc.registerName("iconColorTransition");
late final _sel_setIconColorTransition_ = objc.registerName("setIconColorTransition:");
late final _sel_iconHaloBlur = objc.registerName("iconHaloBlur");
late final _sel_setIconHaloBlur_ = objc.registerName("setIconHaloBlur:");
late final _sel_iconHaloBlurTransition = objc.registerName("iconHaloBlurTransition");
late final _sel_setIconHaloBlurTransition_ = objc.registerName("setIconHaloBlurTransition:");
late final _sel_iconHaloColor = objc.registerName("iconHaloColor");
late final _sel_setIconHaloColor_ = objc.registerName("setIconHaloColor:");
late final _sel_iconHaloColorTransition = objc.registerName("iconHaloColorTransition");
late final _sel_setIconHaloColorTransition_ = objc.registerName("setIconHaloColorTransition:");
late final _sel_iconHaloWidth = objc.registerName("iconHaloWidth");
late final _sel_setIconHaloWidth_ = objc.registerName("setIconHaloWidth:");
late final _sel_iconHaloWidthTransition = objc.registerName("iconHaloWidthTransition");
late final _sel_setIconHaloWidthTransition_ = objc.registerName("setIconHaloWidthTransition:");
late final _sel_iconOpacity = objc.registerName("iconOpacity");
late final _sel_setIconOpacity_ = objc.registerName("setIconOpacity:");
late final _sel_iconOpacityTransition = objc.registerName("iconOpacityTransition");
late final _sel_setIconOpacityTransition_ = objc.registerName("setIconOpacityTransition:");
late final _sel_iconTranslation = objc.registerName("iconTranslation");
late final _sel_setIconTranslation_ = objc.registerName("setIconTranslation:");
late final _sel_iconTranslationTransition = objc.registerName("iconTranslationTransition");
late final _sel_setIconTranslationTransition_ = objc.registerName("setIconTranslationTransition:");
late final _sel_iconTranslate = objc.registerName("iconTranslate");
late final _sel_setIconTranslate_ = objc.registerName("setIconTranslate:");
late final _sel_iconTranslationAnchor = objc.registerName("iconTranslationAnchor");
late final _sel_setIconTranslationAnchor_ = objc.registerName("setIconTranslationAnchor:");
late final _sel_iconTranslateAnchor = objc.registerName("iconTranslateAnchor");
late final _sel_setIconTranslateAnchor_ = objc.registerName("setIconTranslateAnchor:");
late final _sel_textColorTransition = objc.registerName("textColorTransition");
late final _sel_setTextColorTransition_ = objc.registerName("setTextColorTransition:");
late final _sel_textHaloBlur = objc.registerName("textHaloBlur");
late final _sel_setTextHaloBlur_ = objc.registerName("setTextHaloBlur:");
late final _sel_textHaloBlurTransition = objc.registerName("textHaloBlurTransition");
late final _sel_setTextHaloBlurTransition_ = objc.registerName("setTextHaloBlurTransition:");
late final _sel_textHaloColor = objc.registerName("textHaloColor");
late final _sel_setTextHaloColor_ = objc.registerName("setTextHaloColor:");
late final _sel_textHaloColorTransition = objc.registerName("textHaloColorTransition");
late final _sel_setTextHaloColorTransition_ = objc.registerName("setTextHaloColorTransition:");
late final _sel_textHaloWidth = objc.registerName("textHaloWidth");
late final _sel_setTextHaloWidth_ = objc.registerName("setTextHaloWidth:");
late final _sel_textHaloWidthTransition = objc.registerName("textHaloWidthTransition");
late final _sel_setTextHaloWidthTransition_ = objc.registerName("setTextHaloWidthTransition:");
late final _sel_textOpacity = objc.registerName("textOpacity");
late final _sel_setTextOpacity_ = objc.registerName("setTextOpacity:");
late final _sel_textOpacityTransition = objc.registerName("textOpacityTransition");
late final _sel_setTextOpacityTransition_ = objc.registerName("setTextOpacityTransition:");
late final _sel_textTranslation = objc.registerName("textTranslation");
late final _sel_setTextTranslation_ = objc.registerName("setTextTranslation:");
late final _sel_textTranslationTransition = objc.registerName("textTranslationTransition");
late final _sel_setTextTranslationTransition_ = objc.registerName("setTextTranslationTransition:");
late final _sel_textTranslate = objc.registerName("textTranslate");
late final _sel_setTextTranslate_ = objc.registerName("setTextTranslate:");
late final _sel_textTranslationAnchor = objc.registerName("textTranslationAnchor");
late final _sel_setTextTranslationAnchor_ = objc.registerName("setTextTranslationAnchor:");
late final _sel_textTranslateAnchor = objc.registerName("textTranslateAnchor");
late final _sel_setTextTranslateAnchor_ = objc.registerName("setTextTranslateAnchor:");

/// An ``MLNSymbolStyleLayer`` is a style layer that renders icon and text labels
/// at points or along lines on the map.
/// 
/// Use a symbol style layer to configure the visual appearance of feature labels.
/// These features can come from vector tiles loaded by an ``MLNSymbolStyleLayer``
/// object, or they can be ``MLNSymbolStyleLayer`` or ``MLNSymbolStyleLayer``
/// instances in an ``MLNSymbolStyleLayer`` or ``MLNSymbolStyleLayer`` object.
/// 
/// You can access an existing symbol style layer using the
/// ``MLNStyle/layerWithIdentifier:`` method if you know its identifier;
/// otherwise, find it using the ``MLNStyle/layers`` property. You can also create a
/// new symbol style layer and add it to the style using a method such as
/// ``MLNStyle/addLayer:``.
/// 
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/runtime-multiple-annotations/">Dynamically
/// style interactive points</a> and <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
/// images to cluster point data</a> examples learn how to style data on your map
/// using this layer.
/// 
/// ### Example
/// 
/// ```swift
/// ```
extension type MLNSymbolStyleLayer._(objc.ObjCObject object$) implements objc.ObjCObject,MLNVectorStyleLayer {
  /// Constructs a [MLNSymbolStyleLayer] that points to the same underlying object as [other].
  MLNSymbolStyleLayer.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNSymbolStyleLayer] that wraps the given raw object pointer.
  MLNSymbolStyleLayer.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNSymbolStyleLayer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNSymbolStyleLayer);

  /// alloc
  static MLNSymbolStyleLayer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNSymbolStyleLayer, _sel_alloc);
    return MLNSymbolStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNSymbolStyleLayer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNSymbolStyleLayer, _sel_allocWithZone_, zone);
    return MLNSymbolStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNSymbolStyleLayer new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNSymbolStyleLayer, _sel_new);
    return MLNSymbolStyleLayer.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNSymbolStyleLayer constructed with the default `new` method.
  MLNSymbolStyleLayer() : this.as(new$().object$);

}

extension MLNSymbolStyleLayer$Methods on MLNSymbolStyleLayer {

  /// iconAllowOverlap
  NSExpression get iconAllowOverlap {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconAllowOverlap);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// If true, the icon will be visible even if it collides with other previously
/// drawn symbols.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `iconOverlap` is set to `nil`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-allow-overlap"><code>icon-allow-overlap</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get iconAllowsOverlap {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconAllowsOverlap);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Part of the icon placed closest to the anchor.
/// 
/// The default value of this property is an expression that evaluates to `center`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconAnchor` values
/// Any of the following constant string values:
/// `center`: The center of the icon is placed closest to the anchor.
/// `left`: The left side of the icon is placed closest to the anchor.
/// `right`: The right side of the icon is placed closest to the anchor.
/// `top`: The top of the icon is placed closest to the anchor.
/// `bottom`: The bottom of the icon is placed closest to the anchor.
/// `top-left`: The top left corner of the icon is placed closest to the
/// anchor.
/// `top-right`: The top right corner of the icon is placed closest to the
/// anchor.
/// `bottom-left`: The bottom left corner of the icon is placed closest to the
/// anchor.
/// `bottom-right`: The bottom right corner of the icon is placed closest to
/// the anchor.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The tint color to apply to the icon. The `iconImageName` property must be set
/// to a template image.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `iconColor` property.
/// 
/// This property corresponds to the `icon-color-transition` property in the style JSON file format.
  MLNTransition get iconColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_iconColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_iconColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Fade out the halo towards the outside.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconHaloBlur {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconHaloBlur);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `iconHaloBlur` property.
/// 
/// This property corresponds to the `icon-halo-blur-transition` property in the style JSON file format.
  MLNTransition get iconHaloBlurTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_iconHaloBlurTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_iconHaloBlurTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The color of the icons halo. The `iconImageName` property must be set to a
/// template image.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.clearColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconHaloColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconHaloColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `iconHaloColor` property.
/// 
/// This property corresponds to the `icon-halo-color-transition` property in the style JSON file format.
  MLNTransition get iconHaloColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_iconHaloColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_iconHaloColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Distance of halo to the icon outline. 
/// The unit is in points only for SDF sprites that were created with a blur radius
/// of 8, multiplied by the display density. I.e., the radius needs to be 16 for
/// `@2x` sprites, etc.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconHaloWidth {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconHaloWidth);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `iconHaloWidth` property.
/// 
/// This property corresponds to the `icon-halo-width-transition` property in the style JSON file format.
  MLNTransition get iconHaloWidthTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_iconHaloWidthTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_iconHaloWidthTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// iconIgnorePlacement
  NSExpression get iconIgnorePlacement {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconIgnorePlacement);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// If true, other symbols can be visible even if they collide with the icon.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-ignore-placement"><code>icon-ignore-placement</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get iconIgnoresPlacement {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconIgnoresPlacement);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// iconImage
  NSExpression get iconImage {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconImage);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Name of a style image to use for drawing an image background.
/// 
/// Use the ``MLNStyle/setImage:forName:`` method to associate an image with a name
/// that you can set this property to.
/// 
/// Within a constant string value, a feature attribute name enclosed in curly
/// braces (e.g., `{token}`) is replaced with the value of the named attribute.
/// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
/// and key path expressions.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-image"><code>icon-image</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
/// 
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
/// images to cluster point data</a> example to learn how to dynamically set your
/// icons with an expression.
  NSExpression get iconImageName {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconImageName);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// iconKeepUpright
  NSExpression get iconKeepUpright {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconKeepUpright);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Offset distance of icon from its anchor.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 rightward and 0
/// downward. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconOffset {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconOffset);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The opacity at which the icon will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `iconOpacity` property.
/// 
/// This property corresponds to the `icon-opacity-transition` property in the style JSON file format.
  MLNTransition get iconOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_iconOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_iconOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Size of additional area round the icon bounding box used for detecting symbol
/// collisions.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `UIEdgeInsets` struct set to 2 points on all
/// sides. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIEdgeInsets` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconPadding {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconPadding);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Orientation of icon when map is pitched.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconPitchAlignment` values
/// Any of the following constant string values:
/// `map`: The icon is aligned to the plane of the map.
/// `viewport`: The icon is aligned to the plane of the viewport.
/// `auto`: Automatically matches the value of `icon-rotation-alignment`.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get iconPitchAlignment {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconPitchAlignment);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// iconRotate
  NSExpression get iconRotate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconRotate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Rotates the icon clockwise.
/// 
/// This property is measured in degrees.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-rotate"><code>icon-rotate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconRotation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconRotation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// In combination with `symbolPlacement`, determines the rotation behavior of
/// icons.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconRotationAlignment` values
/// Any of the following constant string values:
/// `map`: When `symbol-placement` is set to `point`, aligns icons east-west.
/// When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes
/// with the line.
/// `viewport`: Produces icons whose x-axes are aligned with the x-axis of the
/// viewport, regardless of the value of `symbol-placement`.
/// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
/// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
/// equivalent to `map`.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get iconRotationAlignment {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconRotationAlignment);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Scales the original size of the icon by the provided factor. The new point size
/// of the image will be the original point size multiplied by `iconScale`. 1 is
/// the original size; 3 triples the size of the image.
/// 
/// This property is measured in factor of the original icon sizes.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-size"><code>icon-size</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get iconScale {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconScale);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// iconSize
  NSExpression get iconSize {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconSize);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The directions in which the icon stretches to fit around the text. If the icon
/// image is a resizable image, the resizable areas may be stretched, while the cap
/// insets are always drawn at the original scale.
/// 
/// The default value of this property is an expression that evaluates to `none`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `text` is non-`nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconTextFit` values
/// Any of the following constant string values:
/// `none`: The icon is displayed at its intrinsic aspect ratio.
/// `width`: The icon is scaled in the x-dimension to fit the width of the
/// text.
/// `height`: The icon is scaled in the y-dimension to fit the height of the
/// text.
/// `both`: The icon is scaled in both x- and y-dimensions.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get iconTextFit {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconTextFit);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Size of the additional area added to dimensions determined by `iconTextFit`.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing `UIEdgeInsetsZero`. Set this property to `nil` to
/// reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `text` is non-`nil`, and `iconTextFit` is set to an expression that evaluates
/// to `MLNIconTextFitBoth`, `MLNIconTextFitWidth`, or `MLNIconTextFitHeight`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIEdgeInsets` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get iconTextFitPadding {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconTextFitPadding);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// iconTranslate
  NSExpression get iconTranslate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconTranslate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// iconTranslateAnchor
  NSExpression get iconTranslateAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconTranslateAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Distance that the icon's anchor is moved from its original placement.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate"><code>icon-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get iconTranslation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconTranslation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Controls the frame of reference for `iconTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `iconTranslation` is non-`nil`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate-anchor"><code>icon-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: Icons are translated relative to the map.
/// `viewport`: Icons are translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get iconTranslationAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_iconTranslationAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `iconTranslation` property.
/// 
/// This property corresponds to the `icon-translate-transition` property in the style JSON file format.
  MLNTransition get iconTranslationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_iconTranslationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_iconTranslationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// init
  MLNSymbolStyleLayer init() {
  objc.checkOsVersionInternal('MLNSymbolStyleLayer.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNSymbolStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// Returns a symbol style layer initialized with an identifier and source.
/// 
/// After initializing and configuring the style layer, add it to a map views
/// style using the ``MLNStyle/addLayer:`` or
/// ``MLNStyle/insertLayer:belowLayer:`` method.
/// 
/// @param identifier A string that uniquely identifies the source in the style to
/// which it is added.
/// @param source The source from which to obtain the data to style. If the source
/// has not yet been added to the current style, the behavior is undefined.
/// @return An initialized foreground style layer.
  MLNSymbolStyleLayer initWithIdentifier(objc.NSString identifier, {required MLNSource source}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithIdentifier_source_, identifier.ref.pointer, source.ref.pointer);
    return MLNSymbolStyleLayer.fromPointer($ret, retain: false, release: true);
  }


  /// If true, text will display without their corresponding icons when the icon
/// collides with other symbols and the text does not.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `text` is non-`nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get isIconOptional {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_isIconOptional);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// If true, icons will display without their corresponding text when the text
/// collides with other symbols and the icon does not.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `iconImageName` is non-`nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get isTextOptional {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_isTextOptional);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// If true, the icon may be flipped to prevent it from being rendered upside-down.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `iconRotationAlignment` is set to an expression that evaluates to `map`, and
/// `symbolPlacement` is set to an expression that evaluates to either
/// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
/// ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-keep-upright"><code>icon-keep-upright</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get keepsIconUpright {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_keepsIconUpright);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// If true, the text may be flipped vertically to prevent it from being rendered
/// upside-down.
/// 
/// The default value of this property is an expression that evaluates to `YES`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `textRotationAlignment` is set to an expression that evaluates to `map`, and
/// `symbolPlacement` is set to an expression that evaluates to either
/// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
/// ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-keep-upright"><code>text-keep-upright</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get keepsTextUpright {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_keepsTextUpright);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Maximum angle change between adjacent characters.
/// 
/// This property is measured in degrees.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `45`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `symbolPlacement` is set to an expression that evaluates to either
/// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
/// ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-angle"><code>text-max-angle</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get maximumTextAngle {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_maximumTextAngle);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The maximum line width for text wrapping.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `10`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-width"><code>text-max-width</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get maximumTextWidth {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_maximumTextWidth);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// setIconAllowOverlap:
  set iconAllowOverlap(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconAllowOverlap_, value.ref.pointer);

  }


  /// If true, the icon will be visible even if it collides with other previously
/// drawn symbols.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `iconOverlap` is set to `nil`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-allow-overlap"><code>icon-allow-overlap</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set iconAllowsOverlap(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconAllowsOverlap_, value.ref.pointer);

  }


  /// Part of the icon placed closest to the anchor.
/// 
/// The default value of this property is an expression that evaluates to `center`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconAnchor` values
/// Any of the following constant string values:
/// `center`: The center of the icon is placed closest to the anchor.
/// `left`: The left side of the icon is placed closest to the anchor.
/// `right`: The right side of the icon is placed closest to the anchor.
/// `top`: The top of the icon is placed closest to the anchor.
/// `bottom`: The bottom of the icon is placed closest to the anchor.
/// `top-left`: The top left corner of the icon is placed closest to the
/// anchor.
/// `top-right`: The top right corner of the icon is placed closest to the
/// anchor.
/// `bottom-left`: The bottom left corner of the icon is placed closest to the
/// anchor.
/// `bottom-right`: The bottom right corner of the icon is placed closest to
/// the anchor.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconAnchor_, value.ref.pointer);

  }


  /// The tint color to apply to the icon. The `iconImageName` property must be set
/// to a template image.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `iconColor` property.
/// 
/// This property corresponds to the `icon-color-transition` property in the style JSON file format.
  set iconColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setIconColorTransition_, value);

  }


  /// Fade out the halo towards the outside.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconHaloBlur(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconHaloBlur_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `iconHaloBlur` property.
/// 
/// This property corresponds to the `icon-halo-blur-transition` property in the style JSON file format.
  set iconHaloBlurTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setIconHaloBlurTransition_, value);

  }


  /// The color of the icons halo. The `iconImageName` property must be set to a
/// template image.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.clearColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconHaloColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconHaloColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `iconHaloColor` property.
/// 
/// This property corresponds to the `icon-halo-color-transition` property in the style JSON file format.
  set iconHaloColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setIconHaloColorTransition_, value);

  }


  /// Distance of halo to the icon outline. 
/// The unit is in points only for SDF sprites that were created with a blur radius
/// of 8, multiplied by the display density. I.e., the radius needs to be 16 for
/// `@2x` sprites, etc.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconHaloWidth(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconHaloWidth_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `iconHaloWidth` property.
/// 
/// This property corresponds to the `icon-halo-width-transition` property in the style JSON file format.
  set iconHaloWidthTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setIconHaloWidthTransition_, value);

  }


  /// setIconIgnorePlacement:
  set iconIgnorePlacement(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconIgnorePlacement_, value.ref.pointer);

  }


  /// If true, other symbols can be visible even if they collide with the icon.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-ignore-placement"><code>icon-ignore-placement</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set iconIgnoresPlacement(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconIgnoresPlacement_, value.ref.pointer);

  }


  /// setIconImage:
  set iconImage(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconImage_, value.ref.pointer);

  }


  /// Name of a style image to use for drawing an image background.
/// 
/// Use the ``MLNStyle/setImage:forName:`` method to associate an image with a name
/// that you can set this property to.
/// 
/// Within a constant string value, a feature attribute name enclosed in curly
/// braces (e.g., `{token}`) is replaced with the value of the named attribute.
/// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
/// and key path expressions.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-image"><code>icon-image</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
/// 
/// #### Related examples
/// See the <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
/// images to cluster point data</a> example to learn how to dynamically set your
/// icons with an expression.
  set iconImageName(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconImageName_, value.ref.pointer);

  }


  /// setIconKeepUpright:
  set iconKeepUpright(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconKeepUpright_, value.ref.pointer);

  }


  /// Offset distance of icon from its anchor.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 rightward and 0
/// downward. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconOffset(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconOffset_, value.ref.pointer);

  }


  /// The opacity at which the icon will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `iconOpacity` property.
/// 
/// This property corresponds to the `icon-opacity-transition` property in the style JSON file format.
  set iconOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setIconOpacityTransition_, value);

  }


  /// If true, text will display without their corresponding icons when the icon
/// collides with other symbols and the text does not.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `text` is non-`nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set isIconOptional(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconOptional_, value.ref.pointer);

  }


  /// Size of additional area round the icon bounding box used for detecting symbol
/// collisions.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `UIEdgeInsets` struct set to 2 points on all
/// sides. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIEdgeInsets` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconPadding(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconPadding_, value.ref.pointer);

  }


  /// Orientation of icon when map is pitched.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconPitchAlignment` values
/// Any of the following constant string values:
/// `map`: The icon is aligned to the plane of the map.
/// `viewport`: The icon is aligned to the plane of the viewport.
/// `auto`: Automatically matches the value of `icon-rotation-alignment`.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set iconPitchAlignment(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconPitchAlignment_, value.ref.pointer);

  }


  /// setIconRotate:
  set iconRotate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconRotate_, value.ref.pointer);

  }


  /// Rotates the icon clockwise.
/// 
/// This property is measured in degrees.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-rotate"><code>icon-rotate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconRotation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconRotation_, value.ref.pointer);

  }


  /// In combination with `symbolPlacement`, determines the rotation behavior of
/// icons.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconRotationAlignment` values
/// Any of the following constant string values:
/// `map`: When `symbol-placement` is set to `point`, aligns icons east-west.
/// When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes
/// with the line.
/// `viewport`: Produces icons whose x-axes are aligned with the x-axis of the
/// viewport, regardless of the value of `symbol-placement`.
/// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
/// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
/// equivalent to `map`.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set iconRotationAlignment(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconRotationAlignment_, value.ref.pointer);

  }


  /// Scales the original size of the icon by the provided factor. The new point size
/// of the image will be the original point size multiplied by `iconScale`. 1 is
/// the original size; 3 triples the size of the image.
/// 
/// This property is measured in factor of the original icon sizes.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-size"><code>icon-size</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set iconScale(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconScale_, value.ref.pointer);

  }


  /// setIconSize:
  set iconSize(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconSize_, value.ref.pointer);

  }


  /// The directions in which the icon stretches to fit around the text. If the icon
/// image is a resizable image, the resizable areas may be stretched, while the cap
/// insets are always drawn at the original scale.
/// 
/// The default value of this property is an expression that evaluates to `none`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `text` is non-`nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconTextFit` values
/// Any of the following constant string values:
/// `none`: The icon is displayed at its intrinsic aspect ratio.
/// `width`: The icon is scaled in the x-dimension to fit the width of the
/// text.
/// `height`: The icon is scaled in the y-dimension to fit the height of the
/// text.
/// `both`: The icon is scaled in both x- and y-dimensions.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set iconTextFit(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconTextFit_, value.ref.pointer);

  }


  /// Size of the additional area added to dimensions determined by `iconTextFit`.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing `UIEdgeInsetsZero`. Set this property to `nil` to
/// reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `text` is non-`nil`, and `iconTextFit` is set to an expression that evaluates
/// to `MLNIconTextFitBoth`, `MLNIconTextFitWidth`, or `MLNIconTextFitHeight`.
/// Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIEdgeInsets` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set iconTextFitPadding(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconTextFitPadding_, value.ref.pointer);

  }


  /// setIconTranslate:
  set iconTranslate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconTranslate_, value.ref.pointer);

  }


  /// setIconTranslateAnchor:
  set iconTranslateAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconTranslateAnchor_, value.ref.pointer);

  }


  /// Distance that the icon's anchor is moved from its original placement.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate"><code>icon-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set iconTranslation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconTranslation_, value.ref.pointer);

  }


  /// Controls the frame of reference for `iconTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `iconTranslation` is non-`nil`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-icon-translate-anchor"><code>icon-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNIconTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: Icons are translated relative to the map.
/// `viewport`: Icons are translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set iconTranslationAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setIconTranslationAnchor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `iconTranslation` property.
/// 
/// This property corresponds to the `icon-translate-transition` property in the style JSON file format.
  set iconTranslationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setIconTranslationTransition_, value);

  }


  /// If true, the icon may be flipped to prevent it from being rendered upside-down.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`, and
/// `iconRotationAlignment` is set to an expression that evaluates to `map`, and
/// `symbolPlacement` is set to an expression that evaluates to either
/// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
/// ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-icon-keep-upright"><code>icon-keep-upright</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set keepsIconUpright(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setKeepsIconUpright_, value.ref.pointer);

  }


  /// If true, the text may be flipped vertically to prevent it from being rendered
/// upside-down.
/// 
/// The default value of this property is an expression that evaluates to `YES`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `textRotationAlignment` is set to an expression that evaluates to `map`, and
/// `symbolPlacement` is set to an expression that evaluates to either
/// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
/// ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-keep-upright"><code>text-keep-upright</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set keepsTextUpright(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setKeepsTextUpright_, value.ref.pointer);

  }


  /// Maximum angle change between adjacent characters.
/// 
/// This property is measured in degrees.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `45`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `symbolPlacement` is set to an expression that evaluates to either
/// `MLNSymbolPlacementLine` or `MLNSymbolPlacementLineCenter`. Otherwise, it is
/// ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-angle"><code>text-max-angle</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set maximumTextAngle(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMaximumTextAngle_, value.ref.pointer);

  }


  /// The maximum line width for text wrapping.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `10`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-max-width"><code>text-max-width</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set maximumTextWidth(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMaximumTextWidth_, value.ref.pointer);

  }


  /// setSymbolAvoidEdges:
  set symbolAvoidEdges(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSymbolAvoidEdges_, value.ref.pointer);

  }


  /// Whether symbols in this layer avoid colliding with symbols in adjacent tiles.
/// 
/// If this property is set to `true`, symbols in this layer avoid crossing the
/// edge of a tile. You should set this property to `true` if the backing vector
/// tiles dont have enough padding to prevent collisions, or if this layers
/// `symbolPlacement` property is set to
/// ``MLNSymbolPlacement/MLNSymbolPlacementPoint`` but this layer is above a symbol
/// layer whose `symbolPlacement` property is set to
/// ``MLNSymbolPlacement/MLNSymbolPlacementPoint``. You do not need to enable this
/// property to prevent clipped labels at tile boundaries.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-symbol-avoid-edges"><code>symbol-avoid-edges</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set symbolAvoidsEdges(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSymbolAvoidsEdges_, value.ref.pointer);

  }


  /// Label placement relative to its geometry.
/// 
/// The default value of this property is an expression that evaluates to `point`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNSymbolPlacement` values
/// Any of the following constant string values:
/// `point`: The label is placed at the point where the geometry is located.
/// `line`: The label is placed along the line of the geometry. Can only be
/// used on `LineString` and `Polygon` geometries.
/// `line-center`: The label is placed at the center of the line of the
/// geometry. Can only be used on `LineString` and `Polygon` geometries. Note that
/// a single feature in a vector tile may contain multiple line geometries.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set symbolPlacement(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSymbolPlacement_, value.ref.pointer);

  }


  /// Internal use only
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set symbolScreenSpace(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSymbolScreenSpace_, value.ref.pointer);

  }


  /// Sorts features in ascending order based on this value. Features with lower sort
/// keys are drawn and placed first.  When `iconAllowsOverlap` or
/// `textAllowsOverlap` is `false`, features with a lower sort key will have
/// priority during placement. When `iconAllowsOverlap` or `textAllowsOverlap` is
/// set to `YES`, features with a higher sort key will overlap over features with a
/// lower sort key.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set symbolSortKey(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSymbolSortKey_, value.ref.pointer);

  }


  /// Distance between two symbol anchors.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `250`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `symbolPlacement` is set to an
/// expression that evaluates to `line`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 1
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set symbolSpacing(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSymbolSpacing_, value.ref.pointer);

  }


  /// Determines whether overlapping symbols in the same layer are rendered in the
/// order that they appear in the data source or by their y-position relative to
/// the viewport. To control the order and prioritization of symbols otherwise, use
/// `symbolSortKey`.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNSymbolZOrder` values
/// Any of the following constant string values:
/// `auto`: Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols
/// by their y-position relative to the viewport if `icon-allow-overlap` or
/// `text-allow-overlap` is set to `true` or `icon-ignore-placement` or
/// `text-ignore-placement` is `false`.
/// `viewport-y`: Specify this z order if symbols appearance relies on lower
/// features overlapping higher features. For example, symbols with a pin-like
/// appearance would require this z order.
/// `source`: Specify this z order if the order in which features appear in the
/// source is significant.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set symbolZOrder(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setSymbolZOrder_, value.ref.pointer);

  }


  /// Value to use for a text label.
/// 
/// Within a constant string value, a feature attribute name enclosed in curly
/// braces (e.g., `{token}`) is replaced with the value of the named attribute.
/// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
/// and key path expressions.
/// 
/// The default value of this property is an expression that evaluates to the empty
/// string. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-field"><code>text-field</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Formatted expressions.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
/// 
/// #### Related examples
/// See the <a href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster
/// point data</a> and <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
/// images to cluster point data</a> to learn how to use an expression to set this
/// attribute to the number of markers within a cluster.
  set text(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setText_, value.ref.pointer);

  }


  /// setTextAllowOverlap:
  set textAllowOverlap(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextAllowOverlap_, value.ref.pointer);

  }


  /// If true, the text will be visible even if it collides with other previously
/// drawn symbols.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-allow-overlap"><code>text-allow-overlap</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set textAllowsOverlap(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextAllowsOverlap_, value.ref.pointer);

  }


  /// Part of the text placed closest to the anchor.
/// 
/// The default value of this property is an expression that evaluates to `center`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `textVariableAnchor` is set to `nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextAnchor` values
/// Any of the following constant string values:
/// `center`: The center of the text is placed closest to the anchor.
/// `left`: The left side of the text is placed closest to the anchor.
/// `right`: The right side of the text is placed closest to the anchor.
/// `top`: The top of the text is placed closest to the anchor.
/// `bottom`: The bottom of the text is placed closest to the anchor.
/// `top-left`: The top left corner of the text is placed closest to the
/// anchor.
/// `top-right`: The top right corner of the text is placed closest to the
/// anchor.
/// `bottom-left`: The bottom left corner of the text is placed closest to the
/// anchor.
/// `bottom-right`: The bottom right corner of the text is placed closest to
/// the anchor.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextAnchor_, value.ref.pointer);

  }


  /// The color with which the text will be drawn.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `textColor` property.
/// 
/// This property corresponds to the `text-color-transition` property in the style JSON file format.
  set textColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setTextColorTransition_, value);

  }


  /// setTextField:
  set textField(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextField_, value.ref.pointer);

  }


  /// setTextFont:
  set textFont(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextFont_, value.ref.pointer);

  }


  /// An array of font face names used to display the text.
/// 
/// The first font named in the array is applied to the text. For each character in
/// the text, if the first font lacks a glyph for the character, the next font is
/// applied as a fallback, and so on.
/// 
/// See the [Customizing Fonts](doc:Customizing_Fonts) guide for details on how
/// this SDK chooses and renders fonts based on the value of this property.
/// 
/// The default value of this property is an expression that evaluates to the array
/// `Open Sans Regular`, `Arial Unicode MS Regular`. Set this property to `nil` to
/// reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-font"><code>text-font</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant array values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textFontNames(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextFontNames_, value.ref.pointer);

  }


  /// Font size.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `16`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-size"><code>text-size</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textFontSize(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextFontSize_, value.ref.pointer);

  }


  /// The halo's fadeout distance towards the outside.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textHaloBlur(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextHaloBlur_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `textHaloBlur` property.
/// 
/// This property corresponds to the `text-halo-blur-transition` property in the style JSON file format.
  set textHaloBlurTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setTextHaloBlurTransition_, value);

  }


  /// The color of the text's halo, which helps it stand out from backgrounds.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.clearColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textHaloColor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextHaloColor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `textHaloColor` property.
/// 
/// This property corresponds to the `text-halo-color-transition` property in the style JSON file format.
  set textHaloColorTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setTextHaloColorTransition_, value);

  }


  /// Distance of halo to the font outline. Max text halo width is 1/4 of the
/// font-size.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textHaloWidth(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextHaloWidth_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `textHaloWidth` property.
/// 
/// This property corresponds to the `text-halo-width-transition` property in the style JSON file format.
  set textHaloWidthTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setTextHaloWidthTransition_, value);

  }


  /// setTextIgnorePlacement:
  set textIgnorePlacement(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextIgnorePlacement_, value.ref.pointer);

  }


  /// If true, other symbols can be visible even if they collide with the text.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-ignore-placement"><code>text-ignore-placement</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set textIgnoresPlacement(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextIgnoresPlacement_, value.ref.pointer);

  }


  /// Text justification options.
/// 
/// The default value of this property is an expression that evaluates to `center`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-justify"><code>text-justify</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextJustification` values
/// Any of the following constant string values:
/// `auto`: The text is aligned towards the anchor position.
/// `left`: The text is aligned to the left.
/// `center`: The text is centered.
/// `right`: The text is aligned to the right.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textJustification(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextJustification_, value.ref.pointer);

  }


  /// setTextJustify:
  set textJustify(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextJustify_, value.ref.pointer);

  }


  /// setTextKeepUpright:
  set textKeepUpright(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextKeepUpright_, value.ref.pointer);

  }


  /// Text tracking amount.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textLetterSpacing(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextLetterSpacing_, value.ref.pointer);

  }


  /// Text leading value for multi-line text.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1.2`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set textLineHeight(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextLineHeight_, value.ref.pointer);

  }


  /// setTextMaxAngle:
  set textMaxAngle(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextMaxAngle_, value.ref.pointer);

  }


  /// setTextMaxWidth:
  set textMaxWidth(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextMaxWidth_, value.ref.pointer);

  }


  /// Offset distance of text from its anchor.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 ems rightward and 0
/// ems downward. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `textRadialOffset` is set to `nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textOffset(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextOffset_, value.ref.pointer);

  }


  /// The opacity at which the text will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textOpacity(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextOpacity_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `textOpacity` property.
/// 
/// This property corresponds to the `text-opacity-transition` property in the style JSON file format.
  set textOpacityTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setTextOpacityTransition_, value);

  }


  /// If true, icons will display without their corresponding text when the text
/// collides with other symbols and the icon does not.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `iconImageName` is non-`nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set isTextOptional(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextOptional_, value.ref.pointer);

  }


  /// Size of the additional area around the text bounding box used for detecting
/// symbol collisions.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `2`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set textPadding(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextPadding_, value.ref.pointer);

  }


  /// Orientation of text when map is pitched.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextPitchAlignment` values
/// Any of the following constant string values:
/// `map`: The text is aligned to the plane of the map.
/// `viewport`: The text is aligned to the plane of the viewport.
/// `auto`: Automatically matches the value of `text-rotation-alignment`.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set textPitchAlignment(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextPitchAlignment_, value.ref.pointer);

  }


  /// Radial offset of text, in the direction of the symbol's anchor. Useful in
/// combination with `textVariableAnchor`, which defaults to using the
/// two-dimensional `textOffset` if present.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textRadialOffset(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextRadialOffset_, value.ref.pointer);

  }


  /// setTextRotate:
  set textRotate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextRotate_, value.ref.pointer);

  }


  /// Rotates the text clockwise.
/// 
/// This property is measured in degrees.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-rotate"><code>text-rotate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textRotation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextRotation_, value.ref.pointer);

  }


  /// In combination with `symbolPlacement`, determines the rotation behavior of the
/// individual glyphs forming the text.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextRotationAlignment` values
/// Any of the following constant string values:
/// `map`: When `symbol-placement` is set to `point`, aligns text east-west.
/// When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes
/// with the line.
/// `viewport`: Produces glyphs whose x-axes are aligned with the x-axis of the
/// viewport, regardless of the value of `symbol-placement`.
/// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
/// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
/// equivalent to `map`.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set textRotationAlignment(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextRotationAlignment_, value.ref.pointer);

  }


  /// setTextSize:
  set textSize(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextSize_, value.ref.pointer);

  }


  /// Specifies how to capitalize text.
/// 
/// The default value of this property is an expression that evaluates to `none`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextTransform` values
/// Any of the following constant string values:
/// `none`: The text is not altered.
/// `uppercase`: Forces all letters to be displayed in uppercase.
/// `lowercase`: Forces all letters to be displayed in lowercase.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textTransform(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextTransform_, value.ref.pointer);

  }


  /// setTextTranslate:
  set textTranslate(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextTranslate_, value.ref.pointer);

  }


  /// setTextTranslateAnchor:
  set textTranslateAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextTranslateAnchor_, value.ref.pointer);

  }


  /// Distance that the text's anchor is moved from its original placement.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate"><code>text-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  set textTranslation(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextTranslation_, value.ref.pointer);

  }


  /// Controls the frame of reference for `textTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `textTranslation` is non-`nil`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate-anchor"><code>text-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The text is translated relative to the map.
/// `viewport`: The text is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set textTranslationAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextTranslationAnchor_, value.ref.pointer);

  }


  /// The transition affecting any changes to this layers `textTranslation` property.
/// 
/// This property corresponds to the `text-translate-transition` property in the style JSON file format.
  set textTranslationTransition(MLNTransition value) {
_objc_msgSend_z7lywk(object$.ref.pointer, _sel_setTextTranslationTransition_, value);

  }


  /// To increase the chance of placing high-priority labels on the map, you can
/// provide an array of `textAnchor` locations: the renderer will attempt to place
/// the label at each location, in order, before moving onto the next label. Use
/// `textJustify: auto` to choose justification based on anchor position. To apply
/// an offset, use the `textRadialOffset` or the two-dimensional `textOffset`.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `symbolPlacement` is set to an expression that evaluates to or
/// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant ``MLNTextAnchor`` array values
/// Constant array, in which each element is any of the following constant string
/// values:
/// `center`: The center of the text is placed closest to the anchor.
/// `left`: The left side of the text is placed closest to the anchor.
/// `right`: The right side of the text is placed closest to the anchor.
/// `top`: The top of the text is placed closest to the anchor.
/// `bottom`: The bottom of the text is placed closest to the anchor.
/// `top-left`: The top left corner of the text is placed closest to the
/// anchor.
/// `top-right`: The top right corner of the text is placed closest to the
/// anchor.
/// `bottom-left`: The bottom left corner of the text is placed closest to the
/// anchor.
/// `bottom-right`: The bottom right corner of the text is placed closest to
/// the anchor.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set textVariableAnchor(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextVariableAnchor_, value.ref.pointer);

  }


  /// To increase the chance of placing high-priority labels on the map, you can
/// provide an array of `textAnchor` locations, each paired with an offset value.
/// The renderer will attempt to place the label at each location, in order, before
/// moving on to the next location+offset. Use `textJustify: auto` to choose
/// justification based on anchor position. 
/// 
/// The length of the array must be even, and must alternate between enum and
/// point entries. i.e., each anchor location must be accompanied by a point, and
/// that point defines the offset when the corresponding anchor location is used.
/// Positive offset values indicate right and down, while negative values indicate
/// left and up. Anchor locations may repeat, allowing the renderer to try multiple
/// offsets to try and place a label using the same anchor. 
/// 
/// When present, this property takes precedence over `textAnchor`,
/// `textVariableAnchor`, `textOffset`, and `textRadialOffset`. 
/// 
/// ```json 
/// { "text-variable-anchor-offset": ["top", [0, 4], "left", [3,0], "bottom", [1,
/// 1]] } 
/// ``` 
/// 
/// When the renderer chooses the `top` anchor, `[0, 4]` will be used for
/// `textOffset`; the text will be shifted down by 4 ems. 
/// 
/// When the renderer chooses the `left` anchor, `[3, 0]` will be used for
/// `textOffset`; the text will be shifted right by 3 ems.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `symbolPlacement` is set to an expression that evaluates to or
/// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant interleaved `MLNTextAnchor` and `CGVector` array values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  set textVariableAnchorOffset(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextVariableAnchorOffset_, value.ref.pointer);

  }


  /// setTextWritingMode:
  set textWritingMode(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextWritingMode_, value.ref.pointer);

  }


  /// The property allows control over a symbol's orientation. Note that the property
/// values act as a hint, so that a symbol whose language doesnt support the
/// provided orientation will be laid out in its natural orientation. Example:
/// English point symbol will be rendered horizontally even if array value contains
/// single 'vertical' enum value. The order of elements in an array define priority
/// order for the placement of an orientation variant.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `symbolPlacement` is set to an expression that evaluates to or
/// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-writing-mode"><code>text-writing-mode</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant ``MLNTextWritingMode`` array values
/// Constant array, in which each element is any of the following constant string
/// values:
/// `horizontal`: If a text's language supports horizontal writing mode,
/// symbols with point placement would be laid out horizontally.
/// `vertical`: If a text's language supports vertical writing mode, symbols
/// with point placement would be laid out vertically.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  set textWritingModes(NSExpression value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTextWritingModes_, value.ref.pointer);

  }


  /// symbolAvoidEdges
  NSExpression get symbolAvoidEdges {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_symbolAvoidEdges);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Whether symbols in this layer avoid colliding with symbols in adjacent tiles.
/// 
/// If this property is set to `true`, symbols in this layer avoid crossing the
/// edge of a tile. You should set this property to `true` if the backing vector
/// tiles dont have enough padding to prevent collisions, or if this layers
/// `symbolPlacement` property is set to
/// ``MLNSymbolPlacement/MLNSymbolPlacementPoint`` but this layer is above a symbol
/// layer whose `symbolPlacement` property is set to
/// ``MLNSymbolPlacement/MLNSymbolPlacementPoint``. You do not need to enable this
/// property to prevent clipped labels at tile boundaries.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-symbol-avoid-edges"><code>symbol-avoid-edges</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get symbolAvoidsEdges {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_symbolAvoidsEdges);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Label placement relative to its geometry.
/// 
/// The default value of this property is an expression that evaluates to `point`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNSymbolPlacement` values
/// Any of the following constant string values:
/// `point`: The label is placed at the point where the geometry is located.
/// `line`: The label is placed along the line of the geometry. Can only be
/// used on `LineString` and `Polygon` geometries.
/// `line-center`: The label is placed at the center of the line of the
/// geometry. Can only be used on `LineString` and `Polygon` geometries. Note that
/// a single feature in a vector tile may contain multiple line geometries.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get symbolPlacement {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_symbolPlacement);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Internal use only
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get symbolScreenSpace {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_symbolScreenSpace);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Sorts features in ascending order based on this value. Features with lower sort
/// keys are drawn and placed first.  When `iconAllowsOverlap` or
/// `textAllowsOverlap` is `false`, features with a lower sort key will have
/// priority during placement. When `iconAllowsOverlap` or `textAllowsOverlap` is
/// set to `YES`, features with a higher sort key will overlap over features with a
/// lower sort key.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get symbolSortKey {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_symbolSortKey);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Distance between two symbol anchors.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `250`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `symbolPlacement` is set to an
/// expression that evaluates to `line`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 1
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get symbolSpacing {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_symbolSpacing);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Determines whether overlapping symbols in the same layer are rendered in the
/// order that they appear in the data source or by their y-position relative to
/// the viewport. To control the order and prioritization of symbols otherwise, use
/// `symbolSortKey`.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNSymbolZOrder` values
/// Any of the following constant string values:
/// `auto`: Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols
/// by their y-position relative to the viewport if `icon-allow-overlap` or
/// `text-allow-overlap` is set to `true` or `icon-ignore-placement` or
/// `text-ignore-placement` is `false`.
/// `viewport-y`: Specify this z order if symbols appearance relies on lower
/// features overlapping higher features. For example, symbols with a pin-like
/// appearance would require this z order.
/// `source`: Specify this z order if the order in which features appear in the
/// source is significant.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get symbolZOrder {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_symbolZOrder);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Value to use for a text label.
/// 
/// Within a constant string value, a feature attribute name enclosed in curly
/// braces (e.g., `{token}`) is replaced with the value of the named attribute.
/// Tokens inside non-constant expressions are ignored; instead, use `mgl_join:`
/// and key path expressions.
/// 
/// The default value of this property is an expression that evaluates to the empty
/// string. Set this property to `nil` to reset it to the default value.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-field"><code>text-field</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant string values
/// Formatted expressions.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
/// 
/// #### Related examples
/// See the <a href="https://docs.mapbox.com/ios/maps/examples/clustering/">Cluster
/// point data</a> and <a
/// href="https://docs.mapbox.com/ios/maps/examples/clustering-with-images/">Use
/// images to cluster point data</a> to learn how to use an expression to set this
/// attribute to the number of markers within a cluster.
  NSExpression get text {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_text);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textAllowOverlap
  NSExpression get textAllowOverlap {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textAllowOverlap);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// If true, the text will be visible even if it collides with other previously
/// drawn symbols.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `iconImageName` is non-`nil`.
/// Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-allow-overlap"><code>text-allow-overlap</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get textAllowsOverlap {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textAllowsOverlap);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Part of the text placed closest to the anchor.
/// 
/// The default value of this property is an expression that evaluates to `center`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `textVariableAnchor` is set to `nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextAnchor` values
/// Any of the following constant string values:
/// `center`: The center of the text is placed closest to the anchor.
/// `left`: The left side of the text is placed closest to the anchor.
/// `right`: The right side of the text is placed closest to the anchor.
/// `top`: The top of the text is placed closest to the anchor.
/// `bottom`: The bottom of the text is placed closest to the anchor.
/// `top-left`: The top left corner of the text is placed closest to the
/// anchor.
/// `top-right`: The top right corner of the text is placed closest to the
/// anchor.
/// `bottom-left`: The bottom left corner of the text is placed closest to the
/// anchor.
/// `bottom-right`: The bottom right corner of the text is placed closest to
/// the anchor.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The color with which the text will be drawn.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.blackColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `textColor` property.
/// 
/// This property corresponds to the `text-color-transition` property in the style JSON file format.
  MLNTransition get textColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_textColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_textColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// textField
  NSExpression get textField {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textField);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textFont
  NSExpression get textFont {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textFont);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// An array of font face names used to display the text.
/// 
/// The first font named in the array is applied to the text. For each character in
/// the text, if the first font lacks a glyph for the character, the next font is
/// applied as a fallback, and so on.
/// 
/// See the [Customizing Fonts](doc:Customizing_Fonts) guide for details on how
/// this SDK chooses and renders fonts based on the value of this property.
/// 
/// The default value of this property is an expression that evaluates to the array
/// `Open Sans Regular`, `Arial Unicode MS Regular`. Set this property to `nil` to
/// reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-font"><code>text-font</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant array values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textFontNames {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textFontNames);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Font size.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `16`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-size"><code>text-size</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textFontSize {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textFontSize);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The halo's fadeout distance towards the outside.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textHaloBlur {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textHaloBlur);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `textHaloBlur` property.
/// 
/// This property corresponds to the `text-halo-blur-transition` property in the style JSON file format.
  MLNTransition get textHaloBlurTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_textHaloBlurTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_textHaloBlurTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// The color of the text's halo, which helps it stand out from backgrounds.
/// 
/// The default value of this property is an expression that evaluates to
/// `UIColor.clearColor`. Set this property to `nil` to reset it to the default
/// value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `UIColor` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textHaloColor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textHaloColor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `textHaloColor` property.
/// 
/// This property corresponds to the `text-halo-color-transition` property in the style JSON file format.
  MLNTransition get textHaloColorTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_textHaloColorTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_textHaloColorTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Distance of halo to the font outline. Max text halo width is 1/4 of the
/// font-size.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textHaloWidth {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textHaloWidth);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `textHaloWidth` property.
/// 
/// This property corresponds to the `text-halo-width-transition` property in the style JSON file format.
  MLNTransition get textHaloWidthTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_textHaloWidthTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_textHaloWidthTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// textIgnorePlacement
  NSExpression get textIgnorePlacement {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textIgnorePlacement);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// If true, other symbols can be visible even if they collide with the text.
/// 
/// The default value of this property is an expression that evaluates to `NO`. Set
/// this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-ignore-placement"><code>text-ignore-placement</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant Boolean values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get textIgnoresPlacement {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textIgnoresPlacement);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Text justification options.
/// 
/// The default value of this property is an expression that evaluates to `center`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-justify"><code>text-justify</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextJustification` values
/// Any of the following constant string values:
/// `auto`: The text is aligned towards the anchor position.
/// `left`: The text is aligned to the left.
/// `center`: The text is centered.
/// `right`: The text is aligned to the right.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textJustification {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textJustification);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textJustify
  NSExpression get textJustify {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textJustify);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textKeepUpright
  NSExpression get textKeepUpright {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textKeepUpright);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Text tracking amount.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textLetterSpacing {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textLetterSpacing);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Text leading value for multi-line text.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1.2`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get textLineHeight {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textLineHeight);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textMaxAngle
  NSExpression get textMaxAngle {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textMaxAngle);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textMaxWidth
  NSExpression get textMaxWidth {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textMaxWidth);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Offset distance of text from its anchor.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 ems rightward and 0
/// ems downward. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `textRadialOffset` is set to `nil`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textOffset {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textOffset);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The opacity at which the text will be drawn.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `1`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values between 0 and 1 inclusive
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textOpacity {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textOpacity);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `textOpacity` property.
/// 
/// This property corresponds to the `text-opacity-transition` property in the style JSON file format.
  MLNTransition get textOpacityTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_textOpacityTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_textOpacityTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// Size of the additional area around the text bounding box used for detecting
/// symbol collisions.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `2`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values no less than 0
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get textPadding {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textPadding);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Orientation of text when map is pitched.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextPitchAlignment` values
/// Any of the following constant string values:
/// `map`: The text is aligned to the plane of the map.
/// `viewport`: The text is aligned to the plane of the viewport.
/// `auto`: Automatically matches the value of `text-rotation-alignment`.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get textPitchAlignment {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textPitchAlignment);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Radial offset of text, in the direction of the symbol's anchor. Useful in
/// combination with `textVariableAnchor`, which defaults to using the
/// two-dimensional `textOffset` if present.
/// 
/// This property is measured in ems.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textRadialOffset {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textRadialOffset);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textRotate
  NSExpression get textRotate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textRotate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Rotates the text clockwise.
/// 
/// This property is measured in degrees.
/// 
/// The default value of this property is an expression that evaluates to the float
/// `0`. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-rotate"><code>text-rotate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant numeric values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textRotation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textRotation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// In combination with `symbolPlacement`, determines the rotation behavior of the
/// individual glyphs forming the text.
/// 
/// The default value of this property is an expression that evaluates to `auto`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextRotationAlignment` values
/// Any of the following constant string values:
/// `map`: When `symbol-placement` is set to `point`, aligns text east-west.
/// When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes
/// with the line.
/// `viewport`: Produces glyphs whose x-axes are aligned with the x-axis of the
/// viewport, regardless of the value of `symbol-placement`.
/// `auto`: When `symbol-placement` is set to `point`, this is equivalent to
/// `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is
/// equivalent to `map`.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get textRotationAlignment {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textRotationAlignment);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textSize
  NSExpression get textSize {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textSize);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Specifies how to capitalize text.
/// 
/// The default value of this property is an expression that evaluates to `none`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextTransform` values
/// Any of the following constant string values:
/// `none`: The text is not altered.
/// `uppercase`: Forces all letters to be displayed in uppercase.
/// `lowercase`: Forces all letters to be displayed in lowercase.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textTransform {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textTransform);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textTranslate
  NSExpression get textTranslate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textTranslate);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textTranslateAnchor
  NSExpression get textTranslateAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textTranslateAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Distance that the text's anchor is moved from its original placement.
/// 
/// This property is measured in points.
/// 
/// The default value of this property is an expression that evaluates to an
/// `NSValue` object containing a `CGVector` struct set to 0 points rightward and 0
/// points downward. Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`. Otherwise,
/// it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate"><code>text-translate</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `CGVector` values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation or step functions to
/// feature attributes.
  NSExpression get textTranslation {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textTranslation);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// Controls the frame of reference for `textTranslation`.
/// 
/// The default value of this property is an expression that evaluates to `map`.
/// Set this property to `nil` to reset it to the default value.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `textTranslation` is non-`nil`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#paint-text-translate-anchor"><code>text-translate-anchor</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant `MLNTextTranslationAnchor` values
/// Any of the following constant string values:
/// `map`: The text is translated relative to the map.
/// `viewport`: The text is translated relative to the viewport.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get textTranslationAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textTranslationAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The transition affecting any changes to this layers `textTranslation` property.
/// 
/// This property corresponds to the `text-translate-transition` property in the style JSON file format.
  MLNTransition get textTranslationTransition {
    final $ptr = pkg_ffi.calloc<MLNTransition>();
    objc.useMsgSendVariants ? _objc_msgSend_1i0p3hyStret($ptr, object$.ref.pointer, _sel_textTranslationTransition) : $ptr.ref = _objc_msgSend_1i0p3hy(object$.ref.pointer, _sel_textTranslationTransition);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNTransition>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNTransition>(
        $finalizable);

  }


  /// To increase the chance of placing high-priority labels on the map, you can
/// provide an array of `textAnchor` locations: the renderer will attempt to place
/// the label at each location, in order, before moving onto the next label. Use
/// `textJustify: auto` to choose justification based on anchor position. To apply
/// an offset, use the `textRadialOffset` or the two-dimensional `textOffset`.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `symbolPlacement` is set to an expression that evaluates to or
/// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant ``MLNTextAnchor`` array values
/// Constant array, in which each element is any of the following constant string
/// values:
/// `center`: The center of the text is placed closest to the anchor.
/// `left`: The left side of the text is placed closest to the anchor.
/// `right`: The right side of the text is placed closest to the anchor.
/// `top`: The top of the text is placed closest to the anchor.
/// `bottom`: The bottom of the text is placed closest to the anchor.
/// `top-left`: The top left corner of the text is placed closest to the
/// anchor.
/// `top-right`: The top right corner of the text is placed closest to the
/// anchor.
/// `bottom-left`: The bottom left corner of the text is placed closest to the
/// anchor.
/// `bottom-right`: The bottom right corner of the text is placed closest to
/// the anchor.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get textVariableAnchor {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textVariableAnchor);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// To increase the chance of placing high-priority labels on the map, you can
/// provide an array of `textAnchor` locations, each paired with an offset value.
/// The renderer will attempt to place the label at each location, in order, before
/// moving on to the next location+offset. Use `textJustify: auto` to choose
/// justification based on anchor position. 
/// 
/// The length of the array must be even, and must alternate between enum and
/// point entries. i.e., each anchor location must be accompanied by a point, and
/// that point defines the offset when the corresponding anchor location is used.
/// Positive offset values indicate right and down, while negative values indicate
/// left and up. Anchor locations may repeat, allowing the renderer to try multiple
/// offsets to try and place a label using the same anchor. 
/// 
/// When present, this property takes precedence over `textAnchor`,
/// `textVariableAnchor`, `textOffset`, and `textRadialOffset`. 
/// 
/// ```json 
/// { "text-variable-anchor-offset": ["top", [0, 4], "left", [3,0], "bottom", [1,
/// 1]] } 
/// ``` 
/// 
/// When the renderer chooses the `top` anchor, `[0, 4]` will be used for
/// `textOffset`; the text will be shifted down by 4 ems. 
/// 
/// When the renderer chooses the `left` anchor, `[3, 0]` will be used for
/// `textOffset`; the text will be shifted right by 3 ems.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `symbolPlacement` is set to an expression that evaluates to or
/// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant interleaved `MLNTextAnchor` and `CGVector` array values
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Interpolation and step functions applied to the `$zoomLevel` variable and/or
/// feature attributes
  NSExpression get textVariableAnchorOffset {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textVariableAnchorOffset);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// textWritingMode
  NSExpression get textWritingMode {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textWritingMode);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// The property allows control over a symbol's orientation. Note that the property
/// values act as a hint, so that a symbol whose language doesnt support the
/// provided orientation will be laid out in its natural orientation. Example:
/// English point symbol will be rendered horizontally even if array value contains
/// single 'vertical' enum value. The order of elements in an array define priority
/// order for the placement of an orientation variant.
/// 
/// This property is only applied to the style if `text` is non-`nil`, and
/// `symbolPlacement` is set to an expression that evaluates to or
/// `MLNSymbolPlacementPoint`. Otherwise, it is ignored.
/// 
/// This attribute corresponds to the <a
/// href="https://maplibre.org/maplibre-style-spec/#layout-symbol-text-writing-mode"><code>text-writing-mode</code></a>
/// layout property in the MapLibre Style Spec.
/// 
/// You can set this property to an expression containing any of the following:
/// 
/// Constant ``MLNTextWritingMode`` array values
/// Constant array, in which each element is any of the following constant string
/// values:
/// `horizontal`: If a text's language supports horizontal writing mode,
/// symbols with point placement would be laid out horizontally.
/// `vertical`: If a text's language supports vertical writing mode, symbols
/// with point placement would be laid out vertically.
/// Predefined functions, including mathematical and string operators
/// Conditional expressions
/// Variable assignments and references to assigned variables
/// Step functions applied to the `$zoomLevel` variable
/// 
/// This property does not support applying interpolation functions to the
/// `$zoomLevel` variable or applying interpolation or step functions to feature
/// attributes.
  NSExpression get textWritingModes {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textWritingModes);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }

}

/// The attribution info is represented in the longest format available.
sealed class MLNAttributionInfoStyle {
  /// Specifies a short attribution info style.
  static const MLNAttributionInfoStyleShort = 1;
  /// Specifies a medium attribution info style.
  static const MLNAttributionInfoStyleMedium = 2;
  /// Specifies a long attribution info style.
  static const MLNAttributionInfoStyleLong = 3;}

late final _class_MLNAttributionInfo = objc.getClass("MLNAttributionInfo");
late final _sel_initWithTitle_URL_ = objc.registerName("initWithTitle:URL:");
late final _sel_isFeedbackLink = objc.registerName("isFeedbackLink");
late final _sel_setFeedbackLink_ = objc.registerName("setFeedbackLink:");
late final _sel_titleWithStyle_ = objc.registerName("titleWithStyle:");
final _objc_msgSend_1sadrrm = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// Information about an attribution statement, usually a copyright or trademark
/// statement, associated with a map content source.
extension type MLNAttributionInfo._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNAttributionInfo] that points to the same underlying object as [other].
  MLNAttributionInfo.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNAttributionInfo] that wraps the given raw object pointer.
  MLNAttributionInfo.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNAttributionInfo].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNAttributionInfo);

  /// alloc
  static MLNAttributionInfo alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNAttributionInfo, _sel_alloc);
    return MLNAttributionInfo.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNAttributionInfo allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNAttributionInfo, _sel_allocWithZone_, zone);
    return MLNAttributionInfo.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNAttributionInfo new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNAttributionInfo, _sel_new);
    return MLNAttributionInfo.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNAttributionInfo constructed with the default `new` method.
  MLNAttributionInfo() : this.as(new$().object$);

}

extension MLNAttributionInfo$Methods on MLNAttributionInfo {

  /// The URL to more information about the entity named in the attribution.
/// 
/// If this property is set, the attribution statement should be displayed as a
/// hyperlink or action button. Otherwise, if it is `nil`, the attribution
/// statement should be displayed as plain text.
  objc.NSURL? get URL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0 ? null : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNAttributionInfo init() {
  objc.checkOsVersionInternal('MLNAttributionInfo.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNAttributionInfo.fromPointer($ret, retain: false, release: true);
  }


  /// Returns an initialized attribution info object with the given title and URL.
/// 
/// @param title The attribution statements title.
/// @param URL A URL to more information about the entity named in the attribution.
/// @return An initialized attribution info object.
  MLNAttributionInfo initWithTitle(objc.NSAttributedString title, {objc.NSURL? URL}) {
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithTitle_URL_, title.ref.pointer, URL?.ref.pointer ?? ffi.nullptr);
    return MLNAttributionInfo.fromPointer($ret, retain: false, release: true);
  }


  /// A Boolean value indicating whether the attribution statement is a shortcut to a
/// feedback tool.
/// 
/// If this property is set, the statement should be treated as a way for the user
/// to provide feedback rather than an attribution statement.
  bool get isFeedbackLink {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFeedbackLink);

  }


  /// A Boolean value indicating whether the attribution statement is a shortcut to a
/// feedback tool.
/// 
/// If this property is set, the statement should be treated as a way for the user
/// to provide feedback rather than an attribution statement.
  set isFeedbackLink(bool value) {
_objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setFeedbackLink_, value);

  }


  /// The attribution statements attributed title text.
  set title(objc.NSAttributedString value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setTitle_, value.ref.pointer);

  }


  /// The URL to more information about the entity named in the attribution.
/// 
/// If this property is set, the attribution statement should be displayed as a
/// hyperlink or action button. Otherwise, if it is `nil`, the attribution
/// statement should be displayed as plain text.
  set URL(objc.NSURL? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// The attribution statements attributed title text.
  objc.NSAttributedString get title {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// Returns a copy of the current `title` formatted accordingly to `style`.
/// 
/// Example: If the `style` property is set to ``MLNAttributionInfoStyle/MLNAttributionInfoStyleShort``
/// and the `title` property is set to `OpenStreetMap`, then this method returns `OSM`.
/// 
/// @param style The attribution info style.
/// 
/// @return The `NSAttributedString` styled title.
  objc.NSAttributedString titleWithStyle(int style) {
    final $ret = _objc_msgSend_1sadrrm(object$.ref.pointer, _sel_titleWithStyle_, style);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_MLNOfflinePack = objc.getClass("MLNOfflinePack");
late final _protocol_MLNOfflineRegion = objc.getProtocol("MapLibre.MLNOfflineRegion");

/// MLNOfflineRegion
extension type MLNOfflineRegion._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [MLNOfflineRegion] that points to the same underlying object as [other].
  MLNOfflineRegion.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNOfflineRegion] that wraps the given raw object pointer.
  MLNOfflineRegion.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNOfflineRegion].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNOfflineRegion);
  }
}

extension MLNOfflineRegion$Methods on MLNOfflineRegion {

}

  interface class MLNOfflineRegion$Builder {
  
    /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_MLNOfflineRegion.cast());

  /// Builds an object that implements the MLNOfflineRegion protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNOfflineRegion implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNOfflineRegion');
    
    builder.addProtocol($protocol);
    return MLNOfflineRegion.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNOfflineRegion protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder, {bool $keepIsolateAlive = true}) {
    
    builder.addProtocol($protocol);
  }

  
  
}
late final _sel_region = objc.registerName("region");
late final _sel_setContext_completionHandler_ = objc.registerName("setContext:completionHandler:");
/// The state an offline pack is currently in.
sealed class MLNOfflinePackState {
  /// It is unknown whether the pack is inactive, active, or complete.
  /// 
  /// This is the initial state of a pack. The state of a pack becomes known by
  /// the time the shared ``MLNOfflineStorage`` object sends the first
  /// ``MLNOfflinePackProgressChangedNotification`` about the pack. For inactive
  /// packs, you must explicitly request a progress update using the
  /// ``MLNOfflinePack/requestProgress`` method.
  /// 
  /// An invalid pack always has a state of ``MLNOfflinePackStateInvalid``, never
  /// ``MLNOfflinePackState/MLNOfflinePackStateUnknown``.
  static const MLNOfflinePackStateUnknown = 0;
  /// The pack is incomplete and is not currently downloading.
  /// 
  /// This is the initial state of a pack that is created using the
  /// ``MLNOfflineStorage/addPackForRegion:withContext:completionHandler:``
  /// method, as well as after the ``MLNOfflinePack/suspend`` method is
  /// called.
  static const MLNOfflinePackStateInactive = 1;
  /// The pack is incomplete and is currently downloading.
  /// 
  /// This is the state of a pack after the ``MLNOfflinePack/resume`` method is
  /// called.
  static const MLNOfflinePackStateActive = 2;
  /// The pack has downloaded to completion.
  static const MLNOfflinePackStateComplete = 3;
  /// The pack has been removed using the
  /// ``MLNOfflineStorage/removePack:withCompletionHandler:`` method. Sending
  /// any message to the pack will raise an exception.
  static const MLNOfflinePackStateInvalid = 4;}

final _objc_msgSend_6gfr3p = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
/// A structure containing information about an offline packs current download
/// progress.
final class MLNOfflinePackProgress extends ffi.Struct{
  /// The number of resources, including tiles, that have been completely
  /// downloaded and are ready to use offline.
  @ffi.Uint64()
  external int countOfResourcesCompleted;

  /// The cumulative size of the downloaded resources on disk, including tiles,
  /// measured in bytes.
  @ffi.Uint64()
  external int countOfBytesCompleted;

  /// The number of tiles that have been completely downloaded and are ready
  /// to use offline.
  @ffi.Uint64()
  external int countOfTilesCompleted;

  /// The cumulative size of the downloaded tiles on disk, measured in bytes.
  @ffi.Uint64()
  external int countOfTileBytesCompleted;

  /// The minimum number of resources that must be downloaded in order to view
  /// the packs full region without any omissions.
  /// 
  /// At the beginning of a download, this count is a lower bound; the number of
  /// expected resources may increase as the download progresses.
  @ffi.Uint64()
  external int countOfResourcesExpected;

  /// The maximum number of resources that must be downloaded in order to view
  /// the packs full region without any omissions.
  /// 
  /// At the beginning of a download, when the exact number of required resources
  /// is unknown, this field is set to `UINT64_MAX`. Thus this count is always an
  /// upper bound.
  @ffi.Uint64()
  external int maximumResourcesExpected;

}

late final _sel_progress = objc.registerName("progress");
final _objc_msgSend_oftva = objc.msgSendPointer.cast<ffi.NativeFunction<MLNOfflinePackProgress Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<MLNOfflinePackProgress Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
final _objc_msgSend_oftvaStret = objc.msgSendStretPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MLNOfflinePackProgress> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<MLNOfflinePackProgress> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_resume = objc.registerName("resume");
late final _sel_suspend = objc.registerName("suspend");
late final _sel_requestProgress = objc.registerName("requestProgress");

/// MLNOfflinePack
extension type MLNOfflinePack._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNOfflinePack] that points to the same underlying object as [other].
  MLNOfflinePack.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNOfflinePack] that wraps the given raw object pointer.
  MLNOfflinePack.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNOfflinePack].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNOfflinePack);

  /// alloc
  static MLNOfflinePack alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNOfflinePack, _sel_alloc);
    return MLNOfflinePack.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNOfflinePack allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNOfflinePack, _sel_allocWithZone_, zone);
    return MLNOfflinePack.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNOfflinePack new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNOfflinePack, _sel_new);
    return MLNOfflinePack.fromPointer($ret, retain: false, release: true);
  }
  /// Returns a new instance of MLNOfflinePack constructed with the default `new` method.
  MLNOfflinePack() : this.as(new$().object$);

}

extension MLNOfflinePack$Methods on MLNOfflinePack {

  /// Arbitrary data stored alongside the downloaded resources.
/// 
/// The context typically holds application-specific information for identifying
/// the pack, such as a user-selected name.
/// 
/// To change the value of this property, use the `-setContext:completionHandler:`
/// method. If you access this property after calling that method but before its
/// completion handler is called, this propertys value may not reflect the new
/// value that you specify.
  objc.NSData get context {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_context);
    return objc.NSData.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNOfflinePack init() {
  objc.checkOsVersionInternal('MLNOfflinePack.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNOfflinePack.fromPointer($ret, retain: false, release: true);
  }


  /// The packs current progress.
/// 
/// The progress of an inactive or completed pack is computed lazily, and all its
/// fields are set to 0 by default. To request the packs progress, use the
/// `-requestProgress` method. To get notified when the progress becomes
/// known and when it changes, observe KVO change notifications on this packs
/// `state` key path. Alternatively, you can add an observer for
/// ``MLNOfflinePackProgressChangedNotification``s about this pack that come from the
/// default notification center.
  MLNOfflinePackProgress get progress {
    final $ptr = pkg_ffi.calloc<MLNOfflinePackProgress>();
    objc.useMsgSendVariants ? _objc_msgSend_oftvaStret($ptr, object$.ref.pointer, _sel_progress) : $ptr.ref = _objc_msgSend_oftva(object$.ref.pointer, _sel_progress);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNOfflinePackProgress>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNOfflinePackProgress>(
        $finalizable);

  }


  /// The region for which the pack manages resources.
  MLNOfflineRegion get region {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_region);
    return MLNOfflineRegion.fromPointer($ret, retain: true, release: true);
  }


  /// Request an asynchronous update to the packs `state` and `progress` properties.
/// 
/// The state and progress of an inactive or completed pack are computed lazily. If
/// you need the state or progress of a pack whose `state` property is currently
/// set to ``MLNOfflinePackState/MLNOfflinePackStateUnknown``, observe KVO change notifications on this
/// packs `state` key path, then call this method. Alternatively, you can add an
/// observer for ``MLNOfflinePackProgressChangedNotification`` about this pack that
/// come from the default notification center.
  void requestProgress() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_requestProgress);

  }


  /// Resumes downloading if the pack is inactive.
/// 
/// When a pack resumes after being suspended, it may begin by iterating over the
/// already downloaded resources. As a result, the `progress` structures
/// `countOfResourcesCompleted` field may revert to 0 before rapidly returning to
/// the level of progress at the time the pack was suspended.
/// 
/// To temporarily suspend downloading, call the `-suspend` method.
  void resume() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_resume);

  }


  /// Associates arbitrary contextual data with the offline pack, replacing any
/// context that was previously associated with the offline pack.
/// 
/// Setting the context is asynchronous. The `context` property may not be updated
/// until the completion handler is called.
/// 
/// @param context The new context to associate with the offline pack.
/// @param completion The completion handler to call when the context has been
/// updated. If there is an error setting the context, the error is passed into
/// the completion handler.
  void setContext(objc.NSData context, {objc.ObjCBlock<ffi.Void Function(objc.NSError?)>? completionHandler}) {
_objc_msgSend_o762yo(object$.ref.pointer, _sel_setContext_completionHandler_, context.ref.pointer, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// The packs current state.
/// 
/// The state of an inactive or completed pack is computed lazily and is set to
/// ``MLNOfflinePackState/MLNOfflinePackStateUnknown`` by default. To request the packs status, use
/// the
/// `-requestProgress` method. To get notified when the state becomes known and
/// when it changes, observe KVO change notifications on this packs `state` key
/// path. Alternatively, you can add an observer for
/// ``MLNOfflinePackProgressChangedNotification``s about this pack that come from the
/// default notification center.
  int get state {
    return _objc_msgSend_6gfr3p(object$.ref.pointer, _sel_state);

  }


  /// Temporarily stops downloading if the pack is active.
/// 
/// A pack suspends asynchronously, so some network requests may be sent after this
/// method is called. Regardless, the `progress` property will not be updated until
/// `-resume` is called.
/// 
/// If the pack previously reached a higher level of progress before being
/// suspended, it may wait to suspend until it returns to that level.
/// 
/// To resume downloading, call the `-resume` method.
  void suspend() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_suspend);

  }

}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_MLNOfflinePack_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> fromFunction(void Function(MLNOfflinePack? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : MLNOfflinePack.fromPointer(arg0, retain: true, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> listener(void Function(MLNOfflinePack? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : MLNOfflinePack.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> blocking(void Function(MLNOfflinePack? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : MLNOfflinePack.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : MLNOfflinePack.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_MLNOfflinePack_NSError$CallExtension on objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)> {
  void call(MLNOfflinePack? arg0, objc.NSError? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSArray_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> fromFunction(void Function(objc.NSURL , objc.NSArray? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(objc.NSURL.fromPointer(arg0, retain: true, release: true), arg1.address == 0 ? null : objc.NSArray.fromPointer(arg1, retain: true, release: true), arg2.address == 0 ? null : objc.NSError.fromPointer(arg2, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> listener(void Function(objc.NSURL , objc.NSArray? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(objc.NSURL.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSArray.fromPointer(arg1, retain: false, release: true), arg2.address == 0 ? null : objc.NSError.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_r8gdi7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> blocking(void Function(objc.NSURL , objc.NSArray? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(objc.NSURL.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSArray.fromPointer(arg1, retain: false, release: true), arg2.address == 0 ? null : objc.NSError.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(objc.NSURL.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSArray.fromPointer(arg1, retain: false, release: true), arg2.address == 0 ? null : objc.NSError.fromPointer(arg2, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_r8gdi7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSArray_NSError$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)> {
  void call(objc.NSURL arg0, objc.NSArray? arg1, objc.NSError? arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer, arg1?.ref.pointer ?? ffi.nullptr, arg2?.ref.pointer ?? ffi.nullptr);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> fromFunction(void Function(objc.NSURL , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(objc.NSURL.fromPointer(arg0, retain: true, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> listener(void Function(objc.NSURL , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(objc.NSURL.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> blocking(void Function(objc.NSURL , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(objc.NSURL.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(objc.NSURL.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSError$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)> {
  void call(objc.NSURL arg0, objc.NSError? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0.ref.pointer, arg1?.ref.pointer ?? ffi.nullptr);
}

/// The type of resource that is requested.
sealed class MLNResourceKind {
  /// Unknown type
  static const MLNResourceKindUnknown = 0;
  /// Style sheet JSON file
  static const MLNResourceKindStyle = 1;
  /// TileJSON file as specified in https://maplibre.org/maplibre-style-spec/root/#sources
  static const MLNResourceKindSource = 2;
  /// A vector or raster tile as described in the style sheet at
  /// https://maplibre.org/maplibre-style-spec/sources/
  static const MLNResourceKindTile = 3;
  /// Signed distance field glyphs for text rendering. These are the URLs specified in the style
  /// in https://maplibre.org/maplibre-style-spec/root/#glyphs
  static const MLNResourceKindGlyphs = 4;
  /// Image part of a sprite sheet. It is constructed of the prefix in
  /// https://maplibre.org/maplibre-style-spec/root/#sprite and a PNG file extension.
  static const MLNResourceKindSpriteImage = 5;
  /// JSON part of a sprite sheet. It is constructed of the prefix in
  /// https://maplibre.org/maplibre-style-spec/root/#sprite and a JSON file extension.
  static const MLNResourceKindSpriteJSON = 6;
  /// Image data for a georeferenced image source.
  static const MLNResourceKindImage = 7;}

late final _class_MLNOfflineStorage = objc.getClass("MLNOfflineStorage");
late final _sel_sharedOfflineStorage = objc.registerName("sharedOfflineStorage");
late final _protocol_MLNOfflineStorageDelegate = objc.getProtocol("MLNOfflineStorageDelegate");
late final _sel_offlineStorage_URLForResourceOfKind_withURL_ = objc.registerName("offlineStorage:URLForResourceOfKind:withURL:");
final _objc_msgSend_1kgthoa = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>`.
abstract final class ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.UnsignedLong arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3)>> ptr) =>
      objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)> fromFunction(objc.NSURL Function(ffi.Pointer<ffi.Void> , MLNOfflineStorage , int , objc.NSURL ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, int arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) => fn(arg0, MLNOfflineStorage.fromPointer(arg1, retain: true, release: true), arg2, objc.NSURL.fromPointer(arg3, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, int arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.UnsignedLong arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, int arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)>`.
extension ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL$CallExtension on objc.ObjCBlock<objc.NSURL Function(ffi.Pointer<ffi.Void>, MLNOfflineStorage, ffi.UnsignedLong, objc.NSURL)> {
  objc.NSURL call(ffi.Pointer<ffi.Void> arg0, MLNOfflineStorage arg1, int arg2, objc.NSURL arg3) =>objc.NSURL.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.UnsignedLong arg2, ffi.Pointer<objc.ObjCObjectImpl> arg3)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2, arg3.ref.pointer), retain: true, release: true);
}


/// The ``MLNOfflineStorageDelegate`` protocol defines methods that a delegate of an
/// ``MLNOfflineStorage`` object can optionally implement to transform various types
/// of URLs before downloading them via the internet.
extension type MLNOfflineStorageDelegate._(objc.ObjCProtocol object$) implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [MLNOfflineStorageDelegate] that points to the same underlying object as [other].
  MLNOfflineStorageDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLNOfflineStorageDelegate] that wraps the given raw object pointer.
  MLNOfflineStorageDelegate.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
      object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MLNOfflineStorageDelegate].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MLNOfflineStorageDelegate);
  }
}

extension MLNOfflineStorageDelegate$Methods on MLNOfflineStorageDelegate {

  /// Sent whenever a URL needs to be transformed.
/// 
/// @param storage The storage object processing the download.
/// @param kind The kind of URL to be transformed.
/// @param url The original URL to be transformed.
/// @return A URL that will now be downloaded.
  objc.NSURL offlineStorage(MLNOfflineStorage storage, {required int URLForResourceOfKind,required objc.NSURL withURL}) {
    final $ret = _objc_msgSend_1kgthoa(object$.ref.pointer, _sel_offlineStorage_URLForResourceOfKind_withURL_, storage.ref.pointer, URLForResourceOfKind, withURL.ref.pointer);
    return objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

}

  interface class MLNOfflineStorageDelegate$Builder {
  
    /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_MLNOfflineStorageDelegate.cast());

  /// Builds an object that implements the MLNOfflineStorageDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MLNOfflineStorageDelegate implement({required objc.NSURL Function(MLNOfflineStorage , int , objc.NSURL ) offlineStorage_URLForResourceOfKind_withURL_, bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MLNOfflineStorageDelegate');
        MLNOfflineStorageDelegate$Builder.offlineStorage_URLForResourceOfKind_withURL_.implement(builder, offlineStorage_URLForResourceOfKind_withURL_);
    builder.addProtocol($protocol);
    return MLNOfflineStorageDelegate.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MLNOfflineStorageDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder, {required objc.NSURL Function(MLNOfflineStorage , int , objc.NSURL ) offlineStorage_URLForResourceOfKind_withURL_, bool $keepIsolateAlive = true}) {
        MLNOfflineStorageDelegate$Builder.offlineStorage_URLForResourceOfKind_withURL_.implement(builder, offlineStorage_URLForResourceOfKind_withURL_);
    builder.addProtocol($protocol);
  }

  
  /// Sent whenever a URL needs to be transformed.
/// 
/// @param storage The storage object processing the download.
/// @param kind The kind of URL to be transformed.
/// @param url The original URL to be transformed.
/// @return A URL that will now be downloaded.
static final offlineStorage_URLForResourceOfKind_withURL_ = objc.ObjCProtocolMethod<objc.NSURL Function(MLNOfflineStorage , int , objc.NSURL )>(
      _protocol_MLNOfflineStorageDelegate,
      _sel_offlineStorage_URLForResourceOfKind_withURL_,
      ffi.Native.addressOf<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>>(_NativeLibrary_protocolTrampoline_1fy0zqa).cast(),
      objc.getProtocolMethodSignature(
          _protocol_MLNOfflineStorageDelegate,
          _sel_offlineStorage_URLForResourceOfKind_withURL_,
          isRequired: true,
          isInstanceMethod: true,
      ),
      (objc.NSURL Function(MLNOfflineStorage , int , objc.NSURL ) func) => ObjCBlock_NSURL_ffiVoid_MLNOfflineStorage_MLNResourceKind_NSURL.fromFunction((ffi.Pointer<ffi.Void> _, MLNOfflineStorage arg1, int arg2, objc.NSURL arg3) => func(arg1, arg2, arg3)),
      
    );

}
late final _sel_databasePath = objc.registerName("databasePath");
late final _sel_databaseURL = objc.registerName("databaseURL");
late final _sel_addContentsOfFile_withCompletionHandler_ = objc.registerName("addContentsOfFile:withCompletionHandler:");
late final _sel_addContentsOfURL_withCompletionHandler_ = objc.registerName("addContentsOfURL:withCompletionHandler:");
late final _sel_packs = objc.registerName("packs");
late final _sel_addPackForRegion_withContext_completionHandler_ = objc.registerName("addPackForRegion:withContext:completionHandler:");
final _objc_msgSend_18qun1e = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_removePack_withCompletionHandler_ = objc.registerName("removePack:withCompletionHandler:");
late final _sel_invalidatePack_withCompletionHandler_ = objc.registerName("invalidatePack:withCompletionHandler:");
late final _sel_reloadPacks = objc.registerName("reloadPacks");
late final _sel_setMaximumAllowedMapboxTiles_ = objc.registerName("setMaximumAllowedMapboxTiles:");
final _objc_msgSend_1xsl7ae = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Uint64 )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_countOfBytesCompleted = objc.registerName("countOfBytesCompleted");
final _objc_msgSend_1p4gbjy = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_setMaximumAmbientCacheSize_withCompletionHandler_ = objc.registerName("setMaximumAmbientCacheSize:withCompletionHandler:");
final _objc_msgSend_1sq2aut = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , ffi.Pointer<objc.ObjCBlockImpl> )>();
late final _sel_invalidateAmbientCacheWithCompletionHandler_ = objc.registerName("invalidateAmbientCacheWithCompletionHandler:");
late final _sel_clearAmbientCacheWithCompletionHandler_ = objc.registerName("clearAmbientCacheWithCompletionHandler:");
late final _sel_resetDatabaseWithCompletionHandler_ = objc.registerName("resetDatabaseWithCompletionHandler:");
late final _sel_preloadData_forURL_modificationDate_expirationDate_eTag_mustRevalidate_ = objc.registerName("preloadData:forURL:modificationDate:expirationDate:eTag:mustRevalidate:");
final _objc_msgSend_1xt2lpz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , bool )>();
late final _sel_putResourceWithUrl_data_modified_expires_etag_mustRevalidate_ = objc.registerName("putResourceWithUrl:data:modified:expires:etag:mustRevalidate:");
late final _sel_preloadData_forURL_modificationDate_expirationDate_eTag_mustRevalidate_completionHandler_ = objc.registerName("preloadData:forURL:modificationDate:expirationDate:eTag:mustRevalidate:completionHandler:");
final _objc_msgSend_899qho = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , bool , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// MLNOfflineStorage implements a singleton (shared object) that manages offline
/// packs and ambient caching. All of this classs instance methods are asynchronous,
/// reflecting the fact that offline resources are stored in a database. The shared
/// object maintains a canonical collection of offline packs in its `packs` property.
/// 
/// Mapbox resources downloaded via this API are subject to separate Vector Tile and
/// Raster Tile API pricing and are not included in the Maps SDKs unlimited requests.
/// See <a href="https://www.mapbox.com/pricing/">our pricing page</a> for more
/// information.
/// 
/// #### Related examples
/// - <doc:OfflinePackExample>
/// - <doc:ManageOfflineRegionsExample>
extension type MLNOfflineStorage._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MLNOfflineStorage] that points to the same underlying object as [other].
  MLNOfflineStorage.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNOfflineStorage] that wraps the given raw object pointer.
  MLNOfflineStorage.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNOfflineStorage].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNOfflineStorage);

  /// alloc
  static MLNOfflineStorage alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNOfflineStorage, _sel_alloc);
    return MLNOfflineStorage.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNOfflineStorage allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNOfflineStorage, _sel_allocWithZone_, zone);
    return MLNOfflineStorage.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNOfflineStorage new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNOfflineStorage, _sel_new);
    return MLNOfflineStorage.fromPointer($ret, retain: false, release: true);
  }


  /// Returns the shared offline storage object.
  static MLNOfflineStorage getSharedOfflineStorage() {
    final $ret = _objc_msgSend_151sglz(_class_MLNOfflineStorage, _sel_sharedOfflineStorage);
    return MLNOfflineStorage.fromPointer($ret, retain: true, release: true);
  }
  /// Returns a new instance of MLNOfflineStorage constructed with the default `new` method.
  MLNOfflineStorage() : this.as(new$().object$);

}

extension MLNOfflineStorage$Methods on MLNOfflineStorage {

  /// Adds the offline packs located at the given file path to offline storage.
/// 
/// The file must be a valid offline pack database bundled with the application or
/// downloaded separately.
/// 
/// The resulting packs are added or updated to the shared offline storage objects
/// `packs` property, then the `completion` block is executed.
/// 
/// @param filePath A string representation of the file path. The file path must be
/// writable as schema updates may be perfomed.
/// @param completion The completion handler to call once the contents of the given
/// file has been added to offline storage. This handler is executed
/// asynchronously on the main queue.
  void addContentsOfFile(objc.NSString filePath, {objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>? withCompletionHandler}) {
_objc_msgSend_o762yo(object$.ref.pointer, _sel_addContentsOfFile_withCompletionHandler_, filePath.ref.pointer, withCompletionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Adds the offline packs located at the given URL to offline storage.
/// 
/// The file must be a valid offline pack database bundled with the application or
/// downloaded separately.
/// 
/// The resulting packs are added or updated to the shared offline storage objects
/// `packs` property, then the `completion` block is executed.
/// 
/// @param fileURL A file URL specifying the file to add. The URL should be a valid
/// system path. The URL must be writable as schema updates may be performed.
/// @param completion The completion handler to call once the contents of the given
/// file has been added to offline storage. This handler is executed
/// asynchronously on the main queue.
  void addContentsOfURL(objc.NSURL fileURL, {objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSArray?, objc.NSError?)>? withCompletionHandler}) {
_objc_msgSend_o762yo(object$.ref.pointer, _sel_addContentsOfURL_withCompletionHandler_, fileURL.ref.pointer, withCompletionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Creates and registers an offline pack that downloads the resources needed to
/// use the given region offline.
/// 
/// The resulting pack is added to the shared offline storage objects `packs`
/// property, then the `completion` block is executed with that pack passed in.
/// 
/// The pack has an initial state of ``MLNOfflinePackState/MLNOfflinePackStateInactive``. To begin
/// downloading resources, call ``MLNOfflinePack/resume`` on the pack from within
/// the completion handler. To monitor download progress, add an observer for
/// ``MLNOfflinePackProgressChangedNotification``s about that pack.
/// 
/// To detect when any call to this method results in a new pack, observe KVO
/// change notifications on the shared offline storage objects `packs` key path.
/// Additions to that array result in an `NSKeyValueChangeInsertion` change.
/// 
/// @param region A region to download.
/// @param context Arbitrary data to store alongside the downloaded resources.
/// @param completion The completion handler to call once the pack has been added.
/// This handler is executed asynchronously on the main queue.
  void addPackForRegion(MLNOfflineRegion region, {required objc.NSData withContext,objc.ObjCBlock<ffi.Void Function(MLNOfflinePack?, objc.NSError?)>? completionHandler}) {
_objc_msgSend_18qun1e(object$.ref.pointer, _sel_addPackForRegion_withContext_completionHandler_, region.ref.pointer, withContext.ref.pointer, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Clears the ambient cache by deleting resources. This method does not affect
/// resources shared with offline regions.
/// 
/// @param completion The completion handler to call once resources from the
/// ambient cache have been cleared. This handler is executed asynchronously on
/// the main queue.
  void clearAmbientCacheWithCompletionHandler(objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completion) {
_objc_msgSend_f167m6(object$.ref.pointer, _sel_clearAmbientCacheWithCompletionHandler_, completion.ref.pointer);

  }


  /// The cumulative size, measured in bytes, of all downloaded resources on disk.
/// 
/// The returned value includes all resources, including tiles, whether downloaded
/// as part of an offline pack or due to caching during normal use of ``MLNMapView``.
  int get countOfBytesCompleted {
    return _objc_msgSend_1p4gbjy(object$.ref.pointer, _sel_countOfBytesCompleted);

  }


  /// The file path at which offline packs and the ambient cache are stored.
/// 
/// To customize this path, specify the
/// `MLNOfflineStorageDatabasePath`
/// key in Info.plist, see <doc:Info.plist_Keys>.
  objc.NSString get databasePath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_databasePath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// The file URL at which offline packs and the ambient cache are stored.
/// 
/// To customize this path, specify the
/// `MLNOfflineStorageDatabasePath` key in Info.plist, see <doc:Info.plist_Keys>.
  objc.NSURL get databaseURL {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_databaseURL);
    return objc.NSURL.fromPointer($ret, retain: true, release: true);
  }


  /// The receivers delegate.
/// 
/// An offline storage object sends messages to its delegate to allow it to
/// transform URLs before they are requested from the internet. This can be used
/// add or remove custom parameters, or reroute certain requests to other servers
/// or endpoints.
  MLNOfflineStorageDelegate? get delegate {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_delegate);
    return $ret.address == 0 ? null : MLNOfflineStorageDelegate.fromPointer($ret, retain: true, release: true);
  }


  /// init
  MLNOfflineStorage init() {
  objc.checkOsVersionInternal('MLNOfflineStorage.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNOfflineStorage.fromPointer($ret, retain: false, release: true);
  }


  /// Invalidates the ambient cache. This method checks that the tiles in the
/// ambient cache match those from the server. If the local tiles do not match
/// those on the server, they are re-downloaded.
/// 
/// This is recommended over clearing the cache or resetting the database
/// because valid local tiles will not be downloaded again.
/// 
/// Resources shared with offline packs will not be affected by this method.
/// 
/// @param completion The completion handler to call once the ambient cache has
/// been revalidated. This handler is executed asynchronously on the main queue.
  void invalidateAmbientCacheWithCompletionHandler(objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completion) {
_objc_msgSend_f167m6(object$.ref.pointer, _sel_invalidateAmbientCacheWithCompletionHandler_, completion.ref.pointer);

  }


  /// Invalidates the specified offline pack. This method checks that the tiles
/// in the specified offline pack match those from the server. Local tiles that
/// do not match the latest version on the server are updated.
/// 
/// This is more efficient than deleting the offline pack and downloading it
/// again. If the data stored locally matches that on the server, new data will
/// not be downloaded.
/// 
/// @param pack The offline pack to be invalidated.
/// @param completion The completion handler to call once the pack has been
/// removed. This handler is executed asynchronously on the main queue.
  void invalidatePack(MLNOfflinePack pack, {required objc.ObjCBlock<ffi.Void Function(objc.NSError?)> withCompletionHandler}) {
_objc_msgSend_o762yo(object$.ref.pointer, _sel_invalidatePack_withCompletionHandler_, pack.ref.pointer, withCompletionHandler.ref.pointer);

  }


  /// An array of all known offline packs, in the order in which they were created.
/// 
/// This property is set to `nil`, indicating that the receiver does not yet know
/// the existing packs, for an undefined amount of time starting from the moment
/// the shared offline storage object is initialized until the packs are fetched
/// from the database. After that point, this property is always non-nil, but it
/// may be empty to indicate that no packs are present.
/// 
/// To detect when the shared offline storage object has finished loading its
/// `packs` property, observe KVO change notifications on the `packs` key path.
/// The initial load results in an `NSKeyValueChangeSetting` change.
  objc.NSArray? get packs {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_packs);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// Inserts the provided resource into the ambient cache.
/// 
/// This method mimics the caching that would take place if the equivalent resource
/// were requested in the process of map rendering. Use this method to pre-warm the
/// cache with resources you know will be requested.
/// 
/// This method is asynchronous; the data may not be immediately available for
/// in-progress requests, though subsequent requests should have access to the
/// cached data.
/// 
/// To find out when the resource is ready to retrieve from the cache, use the
/// ``MLNOfflineStorage/preloadData:forURL:modificationDate:expirationDate:eTag:mustRevalidate:completionHandler:``
/// method.
/// 
/// @param data Response data to store for this resource. The data is expected to
/// be uncompressed; internally, the cache will compress data as necessary.
/// @param url The URL at which the data can normally be found.
/// @param modified The date the resource was last modified.
/// @param expires The date after which the resource is no longer valid.
/// @param eTag An HTTP entity tag.
/// @param mustRevalidate A Boolean value indicating whether the data is still
/// usable past the expiration date.
  void preloadData(objc.NSData data, {required objc.NSURL forURL,objc.NSDate? modificationDate,objc.NSDate? expirationDate,objc.NSString? eTag,required bool mustRevalidate}) {
_objc_msgSend_1xt2lpz(object$.ref.pointer, _sel_preloadData_forURL_modificationDate_expirationDate_eTag_mustRevalidate_, data.ref.pointer, forURL.ref.pointer, modificationDate?.ref.pointer ?? ffi.nullptr, expirationDate?.ref.pointer ?? ffi.nullptr, eTag?.ref.pointer ?? ffi.nullptr, mustRevalidate);

  }


  /// Inserts the provided resource into the ambient cache, calling a completion
/// handler when finished.
/// 
/// This method is asynchronous. The data is available for in-progress requests as
/// soon as the completion handler is called.
/// 
/// This method is asynchronous; the data may not be immediately available for
/// in-progress requests, though subsequent requests should have access to the
/// cached data.
/// 
/// @param data Response data to store for this resource. The data is expected to
/// be uncompressed; internally, the cache will compress data as necessary.
/// @param url The URL at which the data can normally be found.
/// @param modified The date the resource was last modified.
/// @param expires The date after which the resource is no longer valid.
/// @param eTag An HTTP entity tag.
/// @param mustRevalidate A Boolean value indicating whether the data is still
/// usable past the expiration date.
/// @param completion The completion handler to call once the data has been
/// preloaded. This handler is executed asynchronously on the main queue.
  void preloadData$1(objc.NSData data, {required objc.NSURL forURL,objc.NSDate? modificationDate,objc.NSDate? expirationDate,objc.NSString? eTag,required bool mustRevalidate,objc.ObjCBlock<ffi.Void Function(objc.NSURL, objc.NSError?)>? completionHandler}) {
_objc_msgSend_899qho(object$.ref.pointer, _sel_preloadData_forURL_modificationDate_expirationDate_eTag_mustRevalidate_completionHandler_, data.ref.pointer, forURL.ref.pointer, modificationDate?.ref.pointer ?? ffi.nullptr, expirationDate?.ref.pointer ?? ffi.nullptr, eTag?.ref.pointer ?? ffi.nullptr, mustRevalidate, completionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// putResourceWithUrl:data:modified:expires:etag:mustRevalidate:
  void putResourceWithUrl(objc.NSURL url, {required objc.NSData data,objc.NSDate? modified,objc.NSDate? expires,objc.NSString? etag,required bool mustRevalidate}) {
_objc_msgSend_1xt2lpz(object$.ref.pointer, _sel_putResourceWithUrl_data_modified_expires_etag_mustRevalidate_, url.ref.pointer, data.ref.pointer, modified?.ref.pointer ?? ffi.nullptr, expires?.ref.pointer ?? ffi.nullptr, etag?.ref.pointer ?? ffi.nullptr, mustRevalidate);

  }


  /// Forcibly, asynchronously reloads the `packs` property. At some point after this
/// method is called, the pointer values of the ``MLNOfflinePack`` objects in the
/// `packs` property change, even if the underlying data for these packs has not
/// changed. If this method is called while a pack is actively downloading, the
/// behavior is undefined.
/// 
/// You typically do not need to call this method.
/// 
/// To detect when the shared offline storage object has finished reloading its
/// `packs` property, observe KVO change notifications on the `packs` key path.
/// A reload results in an `NSKeyValueChangeSetting` change.
  void reloadPacks() {
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_reloadPacks);

  }


  /// Unregisters the given offline pack and allows resources that are no longer
/// required by any remaining packs to be potentially freed.
/// 
/// As soon as this method is called on a pack, the pack becomes invalid; any
/// attempt to send it a message will result in an exception being thrown. If an
/// error occurs and the pack cannot be removed, do not attempt to reuse the pack
/// object. Instead, if you need continued access to the pack, suspend all packs
/// and use the ``MLNOfflineStorage/reloadPacks`` method to obtain valid pointers to all the packs.
/// 
/// To detect when any call to this method results in a pack being removed, observe
/// KVO change notifications on the shared offline storage objects `packs` key
/// path. Removals from that array result in an `NSKeyValueChangeRemoval` change.
/// 
/// When you remove an offline pack, any resources that are required by that pack,
/// but not other packs, become eligible for deletion from offline storage. Because
/// the backing store used for offline storage is also used as a general purpose
/// cache for map resources, such resources may not be immediately removed if the
/// implementation determines that they remain useful for general performance of
/// the map.
/// 
/// @param pack The offline pack to remove.
/// @param completion The completion handler to call once the pack has been
/// removed. This handler is executed asynchronously on the main queue.
  void removePack(MLNOfflinePack pack, {objc.ObjCBlock<ffi.Void Function(objc.NSError?)>? withCompletionHandler}) {
_objc_msgSend_o762yo(object$.ref.pointer, _sel_removePack_withCompletionHandler_, pack.ref.pointer, withCompletionHandler?.ref.pointer ?? ffi.nullptr);

  }


  /// Deletes the existing database, which includes both the ambient cache and
/// offline packs, then reinitializes it.
/// 
/// You typically do not need to call this method.
/// 
/// @param completion The completion handler to call once the pack has database has
/// been reset. This handler is executed asynchronously on the main queue.
  void resetDatabaseWithCompletionHandler(objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completion) {
_objc_msgSend_f167m6(object$.ref.pointer, _sel_resetDatabaseWithCompletionHandler_, completion.ref.pointer);

  }


  /// The receivers delegate.
/// 
/// An offline storage object sends messages to its delegate to allow it to
/// transform URLs before they are requested from the internet. This can be used
/// add or remove custom parameters, or reroute certain requests to other servers
/// or endpoints.
  set delegate(MLNOfflineStorageDelegate? value) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// Sets the maximum number of tiles that may be downloaded and
/// stored on the current device.
/// 
/// Once this limit is reached, an
/// ``MLNOfflinePackMaximumMapboxTilesReachedNotification`` is posted for every
/// attempt to download additional tiles until already downloaded tiles are removed
/// by calling the ``MLNOfflineStorage/removePack:withCompletionHandler:`` method.
/// 
/// @param maximumCount The maximum number of tiles allowed to be downloaded.
  void setMaximumAllowedMapboxTiles(int maximumCount) {
_objc_msgSend_1xsl7ae(object$.ref.pointer, _sel_setMaximumAllowedMapboxTiles_, maximumCount);

  }


  /// Sets the maximum ambient cache size in bytes. The default maximum cache
/// size is 50 MB. To disable ambient caching, set the maximum ambient cache size
/// to `0`. Setting the maximum ambient cache size does not impact the maximum size
/// of offline packs.
/// 
/// This method does not limit the space available to offline packs, and data in
/// offline packs does not count towards this limit. If you set the maximum ambient
/// cache size to 30 MB then download 20 MB of offline packs, 30 MB will remain
/// available for the ambient cache.
/// 
/// This method should be called before the map and map style have been loaded.
/// 
/// This method is potentially expensive, as the database will trim cached data
/// in order to prevent the ambient cache from being larger than the
/// specified amount.
/// 
/// @param cacheSize The maximum size in bytes for the ambient cache.
/// @param completion The completion handler to call once the maximum ambient cache
/// size has been set. This handler is executed synchronously on the main queue.
  void setMaximumAmbientCacheSize(int cacheSize, {required objc.ObjCBlock<ffi.Void Function(objc.NSError?)> withCompletionHandler}) {
_objc_msgSend_1sq2aut(object$.ref.pointer, _sel_setMaximumAmbientCacheSize_withCompletionHandler_, cacheSize, withCompletionHandler.ref.pointer);

  }

}

late final _class_MLNTilePyramidOfflineRegion = objc.getClass("MLNTilePyramidOfflineRegion");
late final _sel_initWithStyleURL_bounds_fromZoomLevel_toZoomLevel_ = objc.registerName("initWithStyleURL:bounds:fromZoomLevel:toZoomLevel:");
final _objc_msgSend_s3spq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , MLNCoordinateBounds , ffi.Double , ffi.Double )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , MLNCoordinateBounds , double , double )>();

/// An offline region defined by a style URL, geographic coordinate bounds, and
/// range of zoom levels.
/// 
/// To minimize the resources required by an irregularly shaped offline region,
/// use the MLNShapeOfflineRegion class instead.
/// 
/// ### Example
/// ```swift
/// let northeast = CLLocationCoordinate2D(latitude: 40.989329, longitude: -102.062592)
/// let southwest = CLLocationCoordinate2D(latitude: 36.986207, longitude: -109.049896)
/// let bbox = MLNCoordinateBounds(sw: southwest, ne: northeast)
/// 
/// let region = MLNTilePyramidOfflineRegion(styleURL: MLNStyle.lightStyleURL, bounds: bbox,
/// fromZoomLevel: 11, toZoomLevel: 14) let context = "Tile Pyramid Region".data(using: .utf8)
/// MLNOfflineStorage.shared.addPack(for: region, withContext: context!)
/// ```
/// 
/// #### Related examples
/// TODO: Download an offline map, learn how to define an offline region
/// to be downloaded to a user's device.
extension type MLNTilePyramidOfflineRegion._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,MLNOfflineRegion,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [MLNTilePyramidOfflineRegion] that points to the same underlying object as [other].
  MLNTilePyramidOfflineRegion.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MLNTilePyramidOfflineRegion] that wraps the given raw object pointer.
  MLNTilePyramidOfflineRegion.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MLNTilePyramidOfflineRegion].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MLNTilePyramidOfflineRegion);

  /// alloc
  static MLNTilePyramidOfflineRegion alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MLNTilePyramidOfflineRegion, _sel_alloc);
    return MLNTilePyramidOfflineRegion.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MLNTilePyramidOfflineRegion allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MLNTilePyramidOfflineRegion, _sel_allocWithZone_, zone);
    return MLNTilePyramidOfflineRegion.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static MLNTilePyramidOfflineRegion new$() {
    final $ret = _objc_msgSend_151sglz(_class_MLNTilePyramidOfflineRegion, _sel_new);
    return MLNTilePyramidOfflineRegion.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_MLNTilePyramidOfflineRegion, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of MLNTilePyramidOfflineRegion constructed with the default `new` method.
  MLNTilePyramidOfflineRegion() : this.as(new$().object$);

}

extension MLNTilePyramidOfflineRegion$Methods on MLNTilePyramidOfflineRegion {

  /// The coordinate bounds for the geographic region covered by the downloaded
/// tiles.
  MLNCoordinateBounds get bounds {
    final $ptr = pkg_ffi.calloc<MLNCoordinateBounds>();
    objc.useMsgSendVariants ? _objc_msgSend_ygoa6aStret($ptr, object$.ref.pointer, _sel_bounds) : $ptr.ref = _objc_msgSend_ygoa6a(object$.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<MLNCoordinateBounds>(), finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<MLNCoordinateBounds>(
        $finalizable);

  }


  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// init
  MLNTilePyramidOfflineRegion init() {
  objc.checkOsVersionInternal('MLNTilePyramidOfflineRegion.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MLNTilePyramidOfflineRegion.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  MLNTilePyramidOfflineRegion? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : MLNTilePyramidOfflineRegion.fromPointer($ret, retain: false, release: true);
  }


  /// Initializes a newly created offline region with the given style URL, geographic
/// coordinate bounds, and range of zoom levels.
/// 
/// This is the designated initializer for ``MLNTilePyramidOfflineRegion``.
/// 
/// @param styleURL URL of the map style for which to download resources. The URL
/// may be a full HTTP or HTTPS URL or a canonical style URL.
/// Specify `nil` for the default style.
/// Relative file URLs cannot be used as offline style URLs. To download the
/// online resources required by a local style, specify a URL to an online copy
/// of the style.
/// @param bounds The coordinate bounds for the geographic region to be covered by
/// the downloaded tiles.
/// @param minimumZoomLevel The minimum zoom level to be covered by the downloaded
/// tiles. This parameter should be set to at least 0 but no greater than the
/// value of the `maximumZoomLevel` parameter. For each required tile source, if
/// this parameter is set to a value less than the tile sources minimum zoom
/// level, the download covers zoom levels down to the tile sources minimum
/// zoom level.
/// @param maximumZoomLevel The maximum zoom level to be covered by the downloaded
/// tiles. This parameter should be set to at least the value of the
/// `minimumZoomLevel` parameter. For each required tile source, if this
/// parameter is set to a value greater than the tile sources minimum zoom
/// level, the download covers zoom levels up to the tile sources maximum zoom
/// level.
  MLNTilePyramidOfflineRegion initWithStyleURL(objc.NSURL? styleURL, {required MLNCoordinateBounds bounds,required double fromZoomLevel,required double toZoomLevel}) {
    final $ret = _objc_msgSend_s3spq(object$.ref.retainAndReturnPointer(), _sel_initWithStyleURL_bounds_fromZoomLevel_toZoomLevel_, styleURL?.ref.pointer ?? ffi.nullptr, bounds, fromZoomLevel, toZoomLevel);
    return MLNTilePyramidOfflineRegion.fromPointer($ret, retain: false, release: true);
  }


  /// The maximum zoom level for which to download tiles and other resources.
/// 
/// For more information about zoom levels, ``MLNMapView/zoomLevel``.
  double get maximumZoomLevel {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_maximumZoomLevel) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_maximumZoomLevel);

  }


  /// The minimum zoom level for which to download tiles and other resources.
/// 
/// For more information about zoom levels, ``MLNMapView/zoomLevel``.
  double get minimumZoomLevel {
    return objc.useMsgSendVariants ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_minimumZoomLevel) : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_minimumZoomLevel);

  }

}

