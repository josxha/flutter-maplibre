// ignore_for_file: type=lint, unused_element, unused_field
// dart format off

// AUTO GENERATED FILE, DO NOT EDIT.
// 
// Generated by `package:ffigen`.
// ignore_for_file: unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;
@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1a22wz(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1a22wz(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<instancetype Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external instancetype _NativeLibrary_protocolTrampoline_xr62hr(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> )>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(ffi.Pointer<objc.ObjCObjectImpl> target,
ffi.Pointer<ffi.Void> arg0,
ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_lmc3p5(ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.DOBJC_Context> )>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_lmc3p5(ffi.Pointer<objc.ObjCBlockImpl> block,
ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
ffi.Pointer<objc.DOBJC_Context> context,
);

late final _class_NSString = objc.getClass("NSString");
late final _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_ = objc.registerName("stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:");
final _objc_msgSend_1q2ox4r = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<ffi.Bool> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<ffi.Bool> )>();

/// NSStringEncodingDetection
extension NSStringEncodingDetection on objc.NSString {

  /// stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:
  static int stringEncodingForData(objc.NSData data, {objc.NSDictionary? encodingOptions,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> convertedString,required ffi.Pointer<ffi.Bool> usedLossyConversion}) {
  objc.checkOsVersionInternal('NSString.stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
    return _objc_msgSend_1q2ox4r(_class_NSString, _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_, data.ref.pointer, encodingOptions?.ref.pointer ?? ffi.nullptr, convertedString, usedLossyConversion);

  }

}

late final _sel_readableTypeIdentifiersForItemProvider = objc.registerName("readableTypeIdentifiersForItemProvider");
final _objc_msgSend_151sglz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunction(objc.NSArray Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid$CallExtension on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) =>objc.NSArray.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0), retain: true, release: true);
}

typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_objectWithItemProviderData_typeIdentifier_error_ = objc.registerName("objectWithItemProviderData:typeIdentifier:error:");
final _objc_msgSend_1pnyuds = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)> fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void> , objc.NSData , objc.NSString , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3) => fn(arg0, objc.NSData.fromPointer(arg1, retain: true, release: true), objc.NSString.fromPointer(arg2, retain: true, release: true), arg3)?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSData arg1, objc.NSString arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3).address == 0 ? null : objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3), retain: true, release: true);
}

late final _sel_writableTypeIdentifiersForItemProvider = objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ = objc.registerName("itemProviderVisibilityForRepresentationWithTypeIdentifier:");
final _objc_msgSend_16fy0up = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(int Function(ffi.Pointer<ffi.Void> , objc.NSString ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSString.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  static int _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<int Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline , 0).cast();
  static int _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline , 0).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString$CallExtension on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  int call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}


/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(void Function(objc.NSData? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: true, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> listener(void Function(objc.NSData? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> blocking(void Function(objc.NSData? , objc.NSError? ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true), arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ = objc.registerName("loadDataWithTypeIdentifier:forItemProviderCompletionHandler:");
final _objc_msgSend_r0bo0s = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// Construction methods for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>> ptr) =>
      objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> fromFunction(objc.NSProgress? Function(ffi.Pointer<ffi.Void> , objc.NSString , objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) => fn(arg0, objc.NSString.fromPointer(arg1, retain: true, release: true), ObjCBlock_ffiVoid_NSData_NSError.fromPointer(arg2, retain: true, release: true))?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError$CallExtension on objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> {
  objc.NSProgress? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer).address == 0 ? null : objc.NSProgress.fromPointer(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer), retain: true, release: true);
}


/// NSItemProvider
extension NSItemProvider on objc.NSString {

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  int itemProviderVisibilityForRepresentationWithTypeIdentifier(objc.NSString typeIdentifier) {
  objc.checkOsVersionInternal('NSString.itemProviderVisibilityForRepresentationWithTypeIdentifier:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSString', 'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    return _objc_msgSend_16fy0up(object$.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_, typeIdentifier.ref.pointer);

  }


  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  objc.NSProgress? loadDataWithTypeIdentifier(objc.NSString typeIdentifier, {required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> forItemProviderCompletionHandler}) {
  objc.checkOsVersionInternal('NSString.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_r0bo0s(object$.ref.pointer, _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_, typeIdentifier.ref.pointer, forItemProviderCompletionHandler.ref.pointer);
    return $ret.address == 0 ? null : objc.NSProgress.fromPointer($ret, retain: true, release: true);
  }


  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider {
  objc.checkOsVersionInternal('NSString.writableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException('NSString', 'writableTypeIdentifiersForItemProvider');
    }
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static int itemProviderVisibilityForRepresentationWithTypeIdentifier$1(objc.NSString typeIdentifier) {
  objc.checkOsVersionInternal('NSString.itemProviderVisibilityForRepresentationWithTypeIdentifier:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(_class_NSString, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSString', 'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    return _objc_msgSend_16fy0up(_class_NSString, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_, typeIdentifier.ref.pointer);

  }


  /// objectWithItemProviderData:typeIdentifier:error:
  static objc.NSString? objectWithItemProviderData(objc.NSData data, {required objc.NSString typeIdentifier}) {
  objc.checkOsVersionInternal('NSString.objectWithItemProviderData:typeIdentifier:error:', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1pnyuds(_class_NSString, _sel_objectWithItemProviderData_typeIdentifier_error_, data.ref.pointer, typeIdentifier.ref.pointer, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
  objc.checkOsVersionInternal('NSString.readableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider$1() {
  objc.checkOsVersionInternal('NSString.writableTypeIdentifiersForItemProvider', iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_propertyList = objc.registerName("propertyList");
late final _sel_propertyListFromStringsFileFormat = objc.registerName("propertyListFromStringsFileFormat");

/// NSExtendedStringPropertyListParsing
extension NSExtendedStringPropertyListParsing on objc.NSString {

  /// propertyList
  objc.ObjCObject propertyList() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_propertyList);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// propertyListFromStringsFileFormat
  objc.NSDictionary? propertyListFromStringsFileFormat() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_propertyListFromStringsFileFormat);
    return $ret.address == 0 ? null : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_cString = objc.registerName("cString");
final _objc_msgSend_1fuqfwb = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_lossyCString = objc.registerName("lossyCString");
late final _sel_cStringLength = objc.registerName("cStringLength");
final _objc_msgSend_xw2lbc = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_getCString_ = objc.registerName("getCString:");
final _objc_msgSend_1r7ue5f = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> )>();
late final _sel_getCString_maxLength_ = objc.registerName("getCString:maxLength:");
final _objc_msgSend_1h3mito = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int )>();
late final _sel_getCString_maxLength_range_remainingRange_ = objc.registerName("getCString:maxLength:range:remainingRange:");
final _objc_msgSend_3gpdva = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong , objc.NSRange , ffi.Pointer<objc.NSRange> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int , objc.NSRange , ffi.Pointer<objc.NSRange> )>();
late final _sel_writeToFile_atomically_ = objc.registerName("writeToFile:atomically:");
final _objc_msgSend_1iyq28l = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Bool )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , bool )>();
late final _sel_writeToURL_atomically_ = objc.registerName("writeToURL:atomically:");
late final _sel_initWithContentsOfFile_ = objc.registerName("initWithContentsOfFile:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_initWithContentsOfURL_ = objc.registerName("initWithContentsOfURL:");
late final _sel_stringWithContentsOfFile_ = objc.registerName("stringWithContentsOfFile:");
late final _sel_stringWithContentsOfURL_ = objc.registerName("stringWithContentsOfURL:");
late final _sel_initWithCStringNoCopy_length_freeWhenDone_ = objc.registerName("initWithCStringNoCopy:length:freeWhenDone:");
final _objc_msgSend_1ojrli4 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong , ffi.Bool )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int , bool )>();
late final _sel_initWithCString_length_ = objc.registerName("initWithCString:length:");
final _objc_msgSend_erqryg = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int )>();
late final _sel_initWithCString_ = objc.registerName("initWithCString:");
final _objc_msgSend_56zxyn = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> )>();
late final _sel_stringWithCString_length_ = objc.registerName("stringWithCString:length:");
late final _sel_stringWithCString_ = objc.registerName("stringWithCString:");
late final _sel_getCharacters_ = objc.registerName("getCharacters:");
final _objc_msgSend_g3kdhc = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.UnsignedShort> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.UnsignedShort> )>();

/// NSStringDeprecated
extension NSStringDeprecated on objc.NSString {

  /// cString
  ffi.Pointer<ffi.Char> cString() {
  objc.checkOsVersionInternal('NSString.cString', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1fuqfwb(object$.ref.pointer, _sel_cString);

  }


  /// cStringLength
  int cStringLength() {
  objc.checkOsVersionInternal('NSString.cStringLength', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_cStringLength);

  }


  /// getCString:
  void getCString(ffi.Pointer<ffi.Char> bytes) {
  objc.checkOsVersionInternal('NSString.getCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_1r7ue5f(object$.ref.pointer, _sel_getCString_, bytes);

  }


  /// getCString:maxLength:
  void getCString$1(ffi.Pointer<ffi.Char> bytes, {required int maxLength}) {
  objc.checkOsVersionInternal('NSString.getCString:maxLength:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_1h3mito(object$.ref.pointer, _sel_getCString_maxLength_, bytes, maxLength);

  }


  /// getCString:maxLength:range:remainingRange:
  void getCString$2(ffi.Pointer<ffi.Char> bytes, {required int maxLength,required objc.NSRange range,required ffi.Pointer<objc.NSRange> remainingRange}) {
  objc.checkOsVersionInternal('NSString.getCString:maxLength:range:remainingRange:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
_objc_msgSend_3gpdva(object$.ref.pointer, _sel_getCString_maxLength_range_remainingRange_, bytes, maxLength, range, remainingRange);

  }


  /// getCharacters:
  void getCharacters(ffi.Pointer<ffi.UnsignedShort> buffer) {
_objc_msgSend_g3kdhc(object$.ref.pointer, _sel_getCharacters_, buffer);

  }


  /// initWithCString:
  objc.ObjCObject? initWithCString(ffi.Pointer<ffi.Char> bytes) {
  objc.checkOsVersionInternal('NSString.initWithCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_56zxyn(object$.ref.retainAndReturnPointer(), _sel_initWithCString_, bytes);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// initWithCString:length:
  objc.ObjCObject? initWithCString$1(ffi.Pointer<ffi.Char> bytes, {required int length}) {
  objc.checkOsVersionInternal('NSString.initWithCString:length:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_erqryg(object$.ref.retainAndReturnPointer(), _sel_initWithCString_length_, bytes, length);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// initWithCStringNoCopy:length:freeWhenDone:
  objc.ObjCObject? initWithCStringNoCopy(ffi.Pointer<ffi.Char> bytes, {required int length,required bool freeWhenDone}) {
  objc.checkOsVersionInternal('NSString.initWithCStringNoCopy:length:freeWhenDone:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1ojrli4(object$.ref.retainAndReturnPointer(), _sel_initWithCStringNoCopy_length_freeWhenDone_, bytes, length, freeWhenDone);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// initWithContentsOfFile:
  objc.ObjCObject? initWithContentsOfFile(objc.NSString path) {
  objc.checkOsVersionInternal('NSString.initWithContentsOfFile:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// initWithContentsOfURL:
  objc.ObjCObject? initWithContentsOfURL(objc.NSURL url) {
  objc.checkOsVersionInternal('NSString.initWithContentsOfURL:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithContentsOfURL_, url.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }


  /// lossyCString
  ffi.Pointer<ffi.Char> lossyCString() {
  objc.checkOsVersionInternal('NSString.lossyCString', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1fuqfwb(object$.ref.pointer, _sel_lossyCString);

  }


  /// writeToFile:atomically:
  bool writeToFile(objc.NSString path, {required bool atomically}) {
  objc.checkOsVersionInternal('NSString.writeToFile:atomically:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(object$.ref.pointer, _sel_writeToFile_atomically_, path.ref.pointer, atomically);

  }


  /// writeToURL:atomically:
  bool writeToURL(objc.NSURL url, {required bool atomically}) {
  objc.checkOsVersionInternal('NSString.writeToURL:atomically:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(object$.ref.pointer, _sel_writeToURL_atomically_, url.ref.pointer, atomically);

  }


  /// stringWithCString:
  static objc.ObjCObject? stringWithCString(ffi.Pointer<ffi.Char> bytes) {
  objc.checkOsVersionInternal('NSString.stringWithCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_56zxyn(_class_NSString, _sel_stringWithCString_, bytes);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// stringWithCString:length:
  static objc.ObjCObject? stringWithCString$1(ffi.Pointer<ffi.Char> bytes, {required int length}) {
  objc.checkOsVersionInternal('NSString.stringWithCString:length:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_erqryg(_class_NSString, _sel_stringWithCString_length_, bytes, length);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// stringWithContentsOfFile:
  static objc.ObjCObject? stringWithContentsOfFile(objc.NSString path) {
  objc.checkOsVersionInternal('NSString.stringWithContentsOfFile:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSString, _sel_stringWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// stringWithContentsOfURL:
  static objc.ObjCObject? stringWithContentsOfURL(objc.NSURL url) {
  objc.checkOsVersionInternal('NSString.stringWithContentsOfURL:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSString, _sel_stringWithContentsOfURL_, url.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }

}

late final _sel_variantFittingPresentationWidth_ = objc.registerName("variantFittingPresentationWidth:");
final _objc_msgSend_qugqlf = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Long )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();

/// NSBundleExtensionMethods
extension NSBundleExtensionMethods on objc.NSString {

  /// variantFittingPresentationWidth:
  objc.NSString variantFittingPresentationWidth(int width) {
  objc.checkOsVersionInternal('NSString.variantFittingPresentationWidth:', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ret = _objc_msgSend_qugqlf(object$.ref.pointer, _sel_variantFittingPresentationWidth_, width);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_NSAttributedString = objc.getClass("NSAttributedString");
late final _sel_length = objc.registerName("length");
late final _sel_attribute_atIndex_effectiveRange_ = objc.registerName("attribute:atIndex:effectiveRange:");
final _objc_msgSend_7km9vu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.NSRange> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.NSRange> )>();
late final _sel_attributedSubstringFromRange_ = objc.registerName("attributedSubstringFromRange:");
final _objc_msgSend_1k1o1s7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange )>();
late final _sel_attributesAtIndex_longestEffectiveRange_inRange_ = objc.registerName("attributesAtIndex:longestEffectiveRange:inRange:");
final _objc_msgSend_1pp2gs8 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong , ffi.Pointer<objc.NSRange> , objc.NSRange )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int , ffi.Pointer<objc.NSRange> , objc.NSRange )>();
late final _sel_attribute_atIndex_longestEffectiveRange_inRange_ = objc.registerName("attribute:atIndex:longestEffectiveRange:inRange:");
final _objc_msgSend_1k1akuq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.NSRange> , objc.NSRange )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.NSRange> , objc.NSRange )>();
late final _sel_isEqualToAttributedString_ = objc.registerName("isEqualToAttributedString:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_initWithString_ = objc.registerName("initWithString:");
late final _sel_initWithString_attributes_ = objc.registerName("initWithString:attributes:");
final _objc_msgSend_15qeuct = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_initWithAttributedString_ = objc.registerName("initWithAttributedString:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSDictionary_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunction(void Function(objc.NSDictionary , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(objc.NSDictionary.fromPointer(arg0, retain: true, release: true), arg1, arg2), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> listener(void Function(objc.NSDictionary , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(objc.NSDictionary.fromPointer(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1a22wz(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> blocking(void Function(objc.NSDictionary , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(objc.NSDictionary.fromPointer(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(objc.NSDictionary.fromPointer(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1a22wz(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSDictionary_NSRange_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> {
  void call(objc.NSDictionary arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(
    ref.pointer, arg0.ref.pointer, arg1, arg2);
}

late final _sel_enumerateAttributesInRange_options_usingBlock_ = objc.registerName("enumerateAttributesInRange:options:usingBlock:");
final _objc_msgSend_1kok4b = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , int , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObjectImpl_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunction(void Function(objc.ObjCObject? , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: true, release: true), arg1, arg2), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> listener(void Function(objc.ObjCObject? , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1a22wz(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> blocking(void Function(objc.ObjCObject? , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: false, release: true), arg1, arg2), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_1a22wz(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_objcObjCObjectImpl_NSRange_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> {
  void call(objc.ObjCObject? arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, ffi.Pointer<ffi.Bool> arg2)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2);
}

late final _sel_enumerateAttribute_inRange_options_usingBlock_ = objc.registerName("enumerateAttribute:inRange:options:usingBlock:");
final _objc_msgSend_ipgwfh = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , ffi.UnsignedLong , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , int , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// NSExtendedAttributedString
extension NSExtendedAttributedString on objc.NSAttributedString {

  /// attribute:atIndex:effectiveRange:
  objc.ObjCObject? attribute(objc.NSString attrName, {required int atIndex,required ffi.Pointer<objc.NSRange> effectiveRange}) {
  objc.checkOsVersionInternal('NSAttributedString.attribute:atIndex:effectiveRange:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_7km9vu(object$.ref.pointer, _sel_attribute_atIndex_effectiveRange_, attrName.ref.pointer, atIndex, effectiveRange);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// attribute:atIndex:longestEffectiveRange:inRange:
  objc.ObjCObject? attribute$1(objc.NSString attrName, {required int atIndex,required ffi.Pointer<objc.NSRange> longestEffectiveRange,required objc.NSRange inRange}) {
  objc.checkOsVersionInternal('NSAttributedString.attribute:atIndex:longestEffectiveRange:inRange:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1k1akuq(object$.ref.pointer, _sel_attribute_atIndex_longestEffectiveRange_inRange_, attrName.ref.pointer, atIndex, longestEffectiveRange, inRange);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// attributedSubstringFromRange:
  objc.NSAttributedString attributedSubstringFromRange(objc.NSRange range) {
  objc.checkOsVersionInternal('NSAttributedString.attributedSubstringFromRange:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1k1o1s7(object$.ref.pointer, _sel_attributedSubstringFromRange_, range);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// attributesAtIndex:longestEffectiveRange:inRange:
  objc.NSDictionary attributesAtIndex$1(int location, {required ffi.Pointer<objc.NSRange> longestEffectiveRange,required objc.NSRange inRange}) {
  objc.checkOsVersionInternal('NSAttributedString.attributesAtIndex:longestEffectiveRange:inRange:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1pp2gs8(object$.ref.pointer, _sel_attributesAtIndex_longestEffectiveRange_inRange_, location, longestEffectiveRange, inRange);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// enumerateAttribute:inRange:options:usingBlock:
  void enumerateAttribute(objc.NSString attrName, {required objc.NSRange inRange,required int options,required objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSRange, ffi.Pointer<ffi.Bool>)> usingBlock}) {
  objc.checkOsVersionInternal('NSAttributedString.enumerateAttribute:inRange:options:usingBlock:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
_objc_msgSend_ipgwfh(object$.ref.pointer, _sel_enumerateAttribute_inRange_options_usingBlock_, attrName.ref.pointer, inRange, options, usingBlock.ref.pointer);

  }


  /// enumerateAttributesInRange:options:usingBlock:
  void enumerateAttributesInRange(objc.NSRange enumerationRange, {required int options,required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary, objc.NSRange, ffi.Pointer<ffi.Bool>)> usingBlock}) {
  objc.checkOsVersionInternal('NSAttributedString.enumerateAttributesInRange:options:usingBlock:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
_objc_msgSend_1kok4b(object$.ref.pointer, _sel_enumerateAttributesInRange_options_usingBlock_, enumerationRange, options, usingBlock.ref.pointer);

  }


  /// initWithAttributedString:
  objc.NSAttributedString initWithAttributedString(objc.NSAttributedString attrStr) {
  objc.checkOsVersionInternal('NSAttributedString.initWithAttributedString:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithAttributedString_, attrStr.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// initWithString:
  objc.NSAttributedString initWithString(objc.NSString str) {
  objc.checkOsVersionInternal('NSAttributedString.initWithString:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithString_, str.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// initWithString:attributes:
  objc.NSAttributedString initWithString$1(objc.NSString str, {objc.NSDictionary? attributes}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithString:attributes:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(object$.ref.retainAndReturnPointer(), _sel_initWithString_attributes_, str.ref.pointer, attributes?.ref.pointer ?? ffi.nullptr);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// isEqualToAttributedString:
  bool isEqualToAttributedString(objc.NSAttributedString other) {
  objc.checkOsVersionInternal('NSAttributedString.isEqualToAttributedString:', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_isEqualToAttributedString_, other.ref.pointer);

  }


  /// length
  int get length {
  objc.checkOsVersionInternal('NSAttributedString.length', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_length);

  }

}

late final _sel_initWithContentsOfMarkdownFileAtURL_options_baseURL_error_ = objc.registerName("initWithContentsOfMarkdownFileAtURL:options:baseURL:error:");
final _objc_msgSend_1k0ezzm = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();
late final _sel_initWithMarkdown_options_baseURL_error_ = objc.registerName("initWithMarkdown:options:baseURL:error:");
late final _sel_initWithMarkdownString_options_baseURL_error_ = objc.registerName("initWithMarkdownString:options:baseURL:error:");

/// NSAttributedStringCreateFromMarkdown
extension NSAttributedStringCreateFromMarkdown on objc.NSAttributedString {

  /// initWithContentsOfMarkdownFileAtURL:options:baseURL:error:
  objc.NSAttributedString? initWithContentsOfMarkdownFileAtURL(objc.NSURL markdownFile, {objc.NSAttributedStringMarkdownParsingOptions? options,objc.NSURL? baseURL}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithContentsOfMarkdownFileAtURL:options:baseURL:error:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1k0ezzm(object$.ref.retainAndReturnPointer(), _sel_initWithContentsOfMarkdownFileAtURL_options_baseURL_error_, markdownFile.ref.pointer, options?.ref.pointer ?? ffi.nullptr, baseURL?.ref.pointer ?? ffi.nullptr, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// initWithMarkdown:options:baseURL:error:
  objc.NSAttributedString? initWithMarkdown(objc.NSData markdown, {objc.NSAttributedStringMarkdownParsingOptions? options,objc.NSURL? baseURL}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithMarkdown:options:baseURL:error:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1k0ezzm(object$.ref.retainAndReturnPointer(), _sel_initWithMarkdown_options_baseURL_error_, markdown.ref.pointer, options?.ref.pointer ?? ffi.nullptr, baseURL?.ref.pointer ?? ffi.nullptr, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }


  /// initWithMarkdownString:options:baseURL:error:
  objc.NSAttributedString? initWithMarkdownString(objc.NSString markdownString, {objc.NSAttributedStringMarkdownParsingOptions? options,objc.NSURL? baseURL}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithMarkdownString:options:baseURL:error:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
    final $ret = _objc_msgSend_1k0ezzm(object$.ref.retainAndReturnPointer(), _sel_initWithMarkdownString_options_baseURL_error_, markdownString.ref.pointer, options?.ref.pointer ?? ffi.nullptr, baseURL?.ref.pointer ?? ffi.nullptr, $err);
    objc.NSErrorException.checkErrorPointer($err.value);
    return $ret.address == 0 ? null : objc.NSAttributedString.fromPointer($ret, retain: false, release: true);    } finally {
      pkg_ffi.calloc.free($err);
    }

  }

}

late final _sel_initWithFormat_options_locale_ = objc.registerName("initWithFormat:options:locale:");
final _objc_msgSend_187k8ck = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_localizedAttributedStringWithFormat_ = objc.registerName("localizedAttributedStringWithFormat:");
late final _sel_localizedAttributedStringWithFormat_options_ = objc.registerName("localizedAttributedStringWithFormat:options:");
final _objc_msgSend_s058d2 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int )>();
late final _sel_initWithFormat_options_locale_context_ = objc.registerName("initWithFormat:options:locale:context:");
final _objc_msgSend_3fn4ca = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_localizedAttributedStringWithFormat_context_ = objc.registerName("localizedAttributedStringWithFormat:context:");
late final _sel_localizedAttributedStringWithFormat_options_context_ = objc.registerName("localizedAttributedStringWithFormat:options:context:");

/// NSAttributedStringFormatting
extension NSAttributedStringFormatting on objc.NSAttributedString {

  /// initWithFormat:options:locale:
  objc.NSAttributedString initWithFormat(objc.NSAttributedString format, {required int options,objc.NSLocale? locale}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithFormat:options:locale:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_187k8ck(object$.ref.retainAndReturnPointer(), _sel_initWithFormat_options_locale_, format.ref.pointer, options, locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// initWithFormat:options:locale:context:
  objc.NSAttributedString initWithFormat$1(objc.NSAttributedString format, {required int options,objc.NSLocale? locale,required objc.NSDictionary context}) {
  objc.checkOsVersionInternal('NSAttributedString.initWithFormat:options:locale:context:', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_3fn4ca(object$.ref.retainAndReturnPointer(), _sel_initWithFormat_options_locale_context_, format.ref.pointer, options, locale?.ref.pointer ?? ffi.nullptr, context.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: false, release: true);
  }


  /// localizedAttributedStringWithFormat:
  static objc.NSAttributedString localizedAttributedStringWithFormat(objc.NSAttributedString format) {
  objc.checkOsVersionInternal('NSAttributedString.localizedAttributedStringWithFormat:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSAttributedString, _sel_localizedAttributedStringWithFormat_, format.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// localizedAttributedStringWithFormat:context:
  static objc.NSAttributedString localizedAttributedStringWithFormat$1(objc.NSAttributedString format, {required objc.NSDictionary context}) {
  objc.checkOsVersionInternal('NSAttributedString.localizedAttributedStringWithFormat:context:', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSAttributedString, _sel_localizedAttributedStringWithFormat_context_, format.ref.pointer, context.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// localizedAttributedStringWithFormat:options:
  static objc.NSAttributedString localizedAttributedStringWithFormat$2(objc.NSAttributedString format, {required int options}) {
  objc.checkOsVersionInternal('NSAttributedString.localizedAttributedStringWithFormat:options:', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_s058d2(_class_NSAttributedString, _sel_localizedAttributedStringWithFormat_options_, format.ref.pointer, options);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }


  /// localizedAttributedStringWithFormat:options:context:
  static objc.NSAttributedString localizedAttributedStringWithFormat$3(objc.NSAttributedString format, {required int options,required objc.NSDictionary context}) {
  objc.checkOsVersionInternal('NSAttributedString.localizedAttributedStringWithFormat:options:context:', iOS: (false, (17, 0, 0)), macOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_187k8ck(_class_NSAttributedString, _sel_localizedAttributedStringWithFormat_options_context_, format.ref.pointer, options, context.ref.pointer);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_attributedStringByInflectingString = objc.registerName("attributedStringByInflectingString");

/// NSMorphology
extension NSMorphology on objc.NSAttributedString {

  /// attributedStringByInflectingString
  objc.NSAttributedString attributedStringByInflectingString() {
  objc.checkOsVersionInternal('NSAttributedString.attributedStringByInflectingString', iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_attributedStringByInflectingString);
    return objc.NSAttributedString.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_pathWithComponents_ = objc.registerName("pathWithComponents:");
late final _sel_pathComponents = objc.registerName("pathComponents");
late final _sel_isAbsolutePath = objc.registerName("isAbsolutePath");
final _objc_msgSend_91o635 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_lastPathComponent = objc.registerName("lastPathComponent");
late final _sel_stringByDeletingLastPathComponent = objc.registerName("stringByDeletingLastPathComponent");
late final _sel_stringByAppendingPathComponent_ = objc.registerName("stringByAppendingPathComponent:");
late final _sel_pathExtension = objc.registerName("pathExtension");
late final _sel_stringByDeletingPathExtension = objc.registerName("stringByDeletingPathExtension");
late final _sel_stringByAppendingPathExtension_ = objc.registerName("stringByAppendingPathExtension:");
late final _sel_stringByAbbreviatingWithTildeInPath = objc.registerName("stringByAbbreviatingWithTildeInPath");
late final _sel_stringByExpandingTildeInPath = objc.registerName("stringByExpandingTildeInPath");
late final _sel_stringByStandardizingPath = objc.registerName("stringByStandardizingPath");
late final _sel_stringByResolvingSymlinksInPath = objc.registerName("stringByResolvingSymlinksInPath");
late final _sel_stringsByAppendingPaths_ = objc.registerName("stringsByAppendingPaths:");
late final _sel_completePathIntoString_caseSensitive_matchesIntoArray_filterTypes_ = objc.registerName("completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:");
final _objc_msgSend_8mvqcu = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Bool , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , bool , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_fileSystemRepresentation = objc.registerName("fileSystemRepresentation");
late final _sel_getFileSystemRepresentation_maxLength_ = objc.registerName("getFileSystemRepresentation:maxLength:");
final _objc_msgSend_8cymbm = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , ffi.UnsignedLong )>>().asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<ffi.Char> , int )>();

/// NSStringPathExtensions
extension NSStringPathExtensions on objc.NSString {

  /// completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:
  int completePathIntoString(ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> outputName, {required bool caseSensitive,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> matchesIntoArray,objc.NSArray? filterTypes}) {
    return _objc_msgSend_8mvqcu(object$.ref.pointer, _sel_completePathIntoString_caseSensitive_matchesIntoArray_filterTypes_, outputName, caseSensitive, matchesIntoArray, filterTypes?.ref.pointer ?? ffi.nullptr);

  }


  /// fileSystemRepresentation
  ffi.Pointer<ffi.Char> get fileSystemRepresentation {
    return _objc_msgSend_1fuqfwb(object$.ref.pointer, _sel_fileSystemRepresentation);

  }


  /// getFileSystemRepresentation:maxLength:
  bool getFileSystemRepresentation(ffi.Pointer<ffi.Char> cname, {required int maxLength}) {
    return _objc_msgSend_8cymbm(object$.ref.pointer, _sel_getFileSystemRepresentation_maxLength_, cname, maxLength);

  }


  /// isAbsolutePath
  bool get isAbsolutePath {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isAbsolutePath);

  }


  /// lastPathComponent
  objc.NSString get lastPathComponent {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_lastPathComponent);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// pathComponents
  objc.NSArray get pathComponents {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_pathComponents);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// pathExtension
  objc.NSString get pathExtension {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_pathExtension);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByAbbreviatingWithTildeInPath
  objc.NSString get stringByAbbreviatingWithTildeInPath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByAbbreviatingWithTildeInPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByAppendingPathComponent:
  objc.NSString stringByAppendingPathComponent(objc.NSString str) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_stringByAppendingPathComponent_, str.ref.pointer);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByAppendingPathExtension:
  objc.NSString? stringByAppendingPathExtension(objc.NSString str) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_stringByAppendingPathExtension_, str.ref.pointer);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByDeletingLastPathComponent
  objc.NSString get stringByDeletingLastPathComponent {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByDeletingLastPathComponent);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByDeletingPathExtension
  objc.NSString get stringByDeletingPathExtension {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByDeletingPathExtension);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByExpandingTildeInPath
  objc.NSString get stringByExpandingTildeInPath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByExpandingTildeInPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByResolvingSymlinksInPath
  objc.NSString get stringByResolvingSymlinksInPath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByResolvingSymlinksInPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByStandardizingPath
  objc.NSString get stringByStandardizingPath {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByStandardizingPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringsByAppendingPaths:
  objc.NSArray stringsByAppendingPaths(objc.NSArray paths) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_stringsByAppendingPaths_, paths.ref.pointer);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// pathWithComponents:
  static objc.NSString pathWithComponents(objc.NSArray components) {
    final $ret = _objc_msgSend_1sotr3r(_class_NSString, _sel_pathWithComponents_, components.ref.pointer);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_stringByAddingPercentEncodingWithAllowedCharacters_ = objc.registerName("stringByAddingPercentEncodingWithAllowedCharacters:");
late final _sel_stringByRemovingPercentEncoding = objc.registerName("stringByRemovingPercentEncoding");
late final _sel_stringByAddingPercentEscapesUsingEncoding_ = objc.registerName("stringByAddingPercentEscapesUsingEncoding:");
final _objc_msgSend_14hpxwa = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_stringByReplacingPercentEscapesUsingEncoding_ = objc.registerName("stringByReplacingPercentEscapesUsingEncoding:");

/// NSURLUtilities
extension NSURLUtilities on objc.NSString {

  /// stringByAddingPercentEncodingWithAllowedCharacters:
  objc.NSString? stringByAddingPercentEncodingWithAllowedCharacters(objc.NSCharacterSet allowedCharacters) {
  objc.checkOsVersionInternal('NSString.stringByAddingPercentEncodingWithAllowedCharacters:', iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_stringByAddingPercentEncodingWithAllowedCharacters_, allowedCharacters.ref.pointer);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByAddingPercentEscapesUsingEncoding:
  objc.NSString? stringByAddingPercentEscapesUsingEncoding(int enc) {
  objc.checkOsVersionInternal('NSString.stringByAddingPercentEscapesUsingEncoding:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_14hpxwa(object$.ref.pointer, _sel_stringByAddingPercentEscapesUsingEncoding_, enc);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByRemovingPercentEncoding
  objc.NSString? get stringByRemovingPercentEncoding {
  objc.checkOsVersionInternal('NSString.stringByRemovingPercentEncoding', iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringByRemovingPercentEncoding);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// stringByReplacingPercentEscapesUsingEncoding:
  objc.NSString? stringByReplacingPercentEscapesUsingEncoding(int enc) {
  objc.checkOsVersionInternal('NSString.stringByReplacingPercentEscapesUsingEncoding:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_14hpxwa(object$.ref.pointer, _sel_stringByReplacingPercentEscapesUsingEncoding_, enc);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}


/// WARNING: NSOrthography is a stub. To generate bindings for this class, include
/// NSOrthography in your config's objc-interfaces list.
///
/// NSOrthography
extension type NSOrthography._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSCopying,objc.NSSecureCoding {
  /// Constructs a [NSOrthography] that points to the same underlying object as [other].
  NSOrthography.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSOrthography', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
  }

  /// Constructs a [NSOrthography] that wraps the given raw object pointer.
  NSOrthography.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSOrthography', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
  }


}


/// WARNING: NSPredicate is a stub. To generate bindings for this class, include
/// NSPredicate in your config's objc-interfaces list.
///
/// NSPredicate
extension type NSPredicate._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [NSPredicate] that points to the same underlying object as [other].
  NSPredicate.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSPredicate', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [NSPredicate] that wraps the given raw object pointer.
  NSPredicate.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSPredicate', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
  }


}

sealed class NSExpressionType {
  static const NSConstantValueExpressionType = 0;
  static const NSEvaluatedObjectExpressionType = 1;
  static const NSVariableExpressionType = 2;
  static const NSKeyPathExpressionType = 3;
  static const NSFunctionExpressionType = 4;
  static const NSUnionSetExpressionType = 5;
  static const NSIntersectSetExpressionType = 6;
  static const NSMinusSetExpressionType = 7;
  static const NSSubqueryExpressionType = 13;
  static const NSAggregateExpressionType = 14;
  static const NSAnyKeyExpressionType = 15;
  static const NSBlockExpressionType = 19;
  static const NSConditionalExpressionType = 20;}

late final _class_NSExpression = objc.getClass("NSExpression");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
late final _sel_expressionWithFormat_argumentArray_ = objc.registerName("expressionWithFormat:argumentArray:");
late final _sel_expressionWithFormat_ = objc.registerName("expressionWithFormat:");
late final _sel_expressionForConstantValue_ = objc.registerName("expressionForConstantValue:");
late final _sel_expressionForEvaluatedObject = objc.registerName("expressionForEvaluatedObject");
late final _sel_expressionForVariable_ = objc.registerName("expressionForVariable:");
late final _sel_expressionForKeyPath_ = objc.registerName("expressionForKeyPath:");
late final _sel_expressionForFunction_arguments_ = objc.registerName("expressionForFunction:arguments:");
late final _sel_expressionForAggregate_ = objc.registerName("expressionForAggregate:");
late final _sel_expressionForUnionSet_with_ = objc.registerName("expressionForUnionSet:with:");
late final _sel_expressionForIntersectSet_with_ = objc.registerName("expressionForIntersectSet:with:");
late final _sel_expressionForMinusSet_with_ = objc.registerName("expressionForMinusSet:with:");
late final _sel_expressionForSubquery_usingIteratorVariable_predicate_ = objc.registerName("expressionForSubquery:usingIteratorVariable:predicate:");
final _objc_msgSend_11spmsz = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_expressionForFunction_selectorName_arguments_ = objc.registerName("expressionForFunction:selectorName:arguments:");
late final _sel_expressionForAnyKey = objc.registerName("expressionForAnyKey");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_objcObjCObjectImpl_NSArray_NSMutableDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>> ptr) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> fromFunction(objc.ObjCObject Function(objc.ObjCObject? , objc.NSArray , objc.NSMutableDictionary? ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) => fn(arg0.address == 0 ? null : objc.ObjCObject(arg0, retain: true, release: true), objc.NSArray.fromPointer(arg1, retain: true, release: true), arg2.address == 0 ? null : objc.NSMutableDictionary.fromPointer(arg2, retain: true, release: true)).ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false, release: true);

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
              .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2) =>
      (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)>`.
extension ObjCBlock_objcObjCObjectImpl_objcObjCObjectImpl_NSArray_NSMutableDictionary$CallExtension on objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> {
  objc.ObjCObject call(objc.ObjCObject? arg0, objc.NSArray arg1, objc.NSMutableDictionary? arg2) =>objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCObjectImpl> arg2)>>()
  .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1.ref.pointer, arg2?.ref.pointer ?? ffi.nullptr), retain: true, release: true);
}

late final _sel_expressionForBlock_arguments_ = objc.registerName("expressionForBlock:arguments:");
final _objc_msgSend_27lb7c = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_expressionForConditional_trueExpression_falseExpression_ = objc.registerName("expressionForConditional:trueExpression:falseExpression:");
late final _sel_initWithExpressionType_ = objc.registerName("initWithExpressionType:");
final _objc_msgSend_1rz5npq = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.UnsignedLong )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void> , objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true))?.ref.retainAndReturnPointer() ?? ffi.nullptr, keepIsolateAlive),
          retain: false, release: true);

  static instancetype _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static instancetype _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension on objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer).address == 0 ? null : objc.ObjCObject(ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer), retain: false, release: true);
}

late final _sel_expressionType = objc.registerName("expressionType");
final _objc_msgSend_1ts4niw = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_constantValue = objc.registerName("constantValue");
late final _sel_keyPath = objc.registerName("keyPath");
late final _sel_function = objc.registerName("function");
late final _sel_variable = objc.registerName("variable");
late final _sel_operand = objc.registerName("operand");
late final _sel_arguments = objc.registerName("arguments");
late final _sel_collection = objc.registerName("collection");
late final _sel_predicate = objc.registerName("predicate");
late final _sel_leftExpression = objc.registerName("leftExpression");
late final _sel_rightExpression = objc.registerName("rightExpression");
late final _sel_trueExpression = objc.registerName("trueExpression");
late final _sel_falseExpression = objc.registerName("falseExpression");
late final _sel_expressionBlock = objc.registerName("expressionBlock");
final _objc_msgSend_uwvaik = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_expressionValueWithObject_context_ = objc.registerName("expressionValueWithObject:context:");
late final _sel_allowEvaluation = objc.registerName("allowEvaluation");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> )>();
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.NSZone> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.NSZone> )>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_supportsSecureCoding = objc.registerName("supportsSecureCoding");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>> ptr) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(bool Function(ffi.Pointer<ffi.Void> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false, release: true);

  static bool _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<bool Function(ffi.Pointer<ffi.Void> )>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_fnPtrTrampoline , false).cast();
  static bool _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void> ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>(_closureTrampoline , false).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
  .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> )>()(
    ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(void Function(ffi.Pointer<ffi.Void> , objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true)), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> listener(void Function(ffi.Pointer<ffi.Void> , objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> blocking(void Function(ffi.Pointer<ffi.Void> , objc.NSCoder ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(arg0, objc.NSCoder.fromPointer(arg1, retain: false, release: true)), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
              .asFunction<void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> )>()(
    ref.pointer, arg0, arg1.ref.pointer);
}


/// NSExpression
extension type NSExpression._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject,objc.NSSecureCoding,objc.NSCopying {
  /// Constructs a [NSExpression] that points to the same underlying object as [other].
  NSExpression.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    assert(isA(object$));
  }

  /// Constructs a [NSExpression] that wraps the given raw object pointer.
  NSExpression.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSExpression].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_NSExpression);

  /// alloc
  static NSExpression alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_alloc);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static NSExpression allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_NSExpression, _sel_allocWithZone_, zone);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// expressionForAggregate:
  static NSExpression expressionForAggregate(objc.NSArray subexpressions) {
  objc.checkOsVersionInternal('NSExpression.expressionForAggregate:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionForAggregate_, subexpressions.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForAnyKey
  static NSExpression expressionForAnyKey() {
  objc.checkOsVersionInternal('NSExpression.expressionForAnyKey', iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_expressionForAnyKey);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForBlock:arguments:
  static NSExpression expressionForBlock(objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> block, {objc.NSArray? arguments}) {
  objc.checkOsVersionInternal('NSExpression.expressionForBlock:arguments:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final $ret = _objc_msgSend_27lb7c(_class_NSExpression, _sel_expressionForBlock_arguments_, block.ref.pointer, arguments?.ref.pointer ?? ffi.nullptr);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForConditional:trueExpression:falseExpression:
  static NSExpression expressionForConditional(NSPredicate predicate, {required NSExpression trueExpression,required NSExpression falseExpression}) {
  objc.checkOsVersionInternal('NSExpression.expressionForConditional:trueExpression:falseExpression:', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_expressionForConditional_trueExpression_falseExpression_, predicate.ref.pointer, trueExpression.ref.pointer, falseExpression.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForConstantValue:
  static NSExpression expressionForConstantValue(objc.ObjCObject? obj) {
  objc.checkOsVersionInternal('NSExpression.expressionForConstantValue:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionForConstantValue_, obj?.ref.pointer ?? ffi.nullptr);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForEvaluatedObject
  static NSExpression expressionForEvaluatedObject() {
  objc.checkOsVersionInternal('NSExpression.expressionForEvaluatedObject', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_expressionForEvaluatedObject);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForFunction:arguments:
  static NSExpression expressionForFunction(objc.NSString name, {required objc.NSArray arguments}) {
  objc.checkOsVersionInternal('NSExpression.expressionForFunction:arguments:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionForFunction_arguments_, name.ref.pointer, arguments.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForFunction:selectorName:arguments:
  static NSExpression expressionForFunction$1(NSExpression target, {required objc.NSString selectorName,objc.NSArray? arguments}) {
  objc.checkOsVersionInternal('NSExpression.expressionForFunction:selectorName:arguments:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_expressionForFunction_selectorName_arguments_, target.ref.pointer, selectorName.ref.pointer, arguments?.ref.pointer ?? ffi.nullptr);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForIntersectSet:with:
  static NSExpression expressionForIntersectSet(NSExpression left, {required NSExpression with$}) {
  objc.checkOsVersionInternal('NSExpression.expressionForIntersectSet:with:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionForIntersectSet_with_, left.ref.pointer, with$.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForKeyPath:
  static NSExpression expressionForKeyPath(objc.NSString keyPath) {
  objc.checkOsVersionInternal('NSExpression.expressionForKeyPath:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionForKeyPath_, keyPath.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForMinusSet:with:
  static NSExpression expressionForMinusSet(NSExpression left, {required NSExpression with$}) {
  objc.checkOsVersionInternal('NSExpression.expressionForMinusSet:with:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionForMinusSet_with_, left.ref.pointer, with$.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForSubquery:usingIteratorVariable:predicate:
  static NSExpression expressionForSubquery(NSExpression expression, {required objc.NSString usingIteratorVariable,required NSPredicate predicate}) {
  objc.checkOsVersionInternal('NSExpression.expressionForSubquery:usingIteratorVariable:predicate:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_11spmsz(_class_NSExpression, _sel_expressionForSubquery_usingIteratorVariable_predicate_, expression.ref.pointer, usingIteratorVariable.ref.pointer, predicate.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForUnionSet:with:
  static NSExpression expressionForUnionSet(NSExpression left, {required NSExpression with$}) {
  objc.checkOsVersionInternal('NSExpression.expressionForUnionSet:with:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionForUnionSet_with_, left.ref.pointer, with$.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionForVariable:
  static NSExpression expressionForVariable(objc.NSString string) {
  objc.checkOsVersionInternal('NSExpression.expressionForVariable:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionForVariable_, string.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionWithFormat:
  static NSExpression expressionWithFormat(objc.NSString expressionFormat) {
  objc.checkOsVersionInternal('NSExpression.expressionWithFormat:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSExpression, _sel_expressionWithFormat_, expressionFormat.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// expressionWithFormat:argumentArray:
  static NSExpression expressionWithFormat$1(objc.NSString expressionFormat, {required objc.NSArray argumentArray}) {
  objc.checkOsVersionInternal('NSExpression.expressionWithFormat:argumentArray:', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final $ret = _objc_msgSend_15qeuct(_class_NSExpression, _sel_expressionWithFormat_argumentArray_, expressionFormat.ref.pointer, argumentArray.ref.pointer);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// new
  static NSExpression new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSExpression, _sel_new);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSExpression, _sel_supportsSecureCoding);

  }
  /// Returns a new instance of NSExpression constructed with the default `new` method.
  NSExpression() : this.as(new$().object$);

}

extension NSExpression$Methods on NSExpression {

  /// allowEvaluation
  void allowEvaluation() {
  objc.checkOsVersionInternal('NSExpression.allowEvaluation', iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
_objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_allowEvaluation);

  }


  /// arguments
  objc.NSArray? get arguments {
  objc.checkOsVersionInternal('NSExpression.arguments', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_arguments);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }


  /// collection
  objc.ObjCObject get collection {
  objc.checkOsVersionInternal('NSExpression.collection', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_collection);
    return objc.ObjCObject($ret, retain: true, release: true);
  }


  /// constantValue
  objc.ObjCObject? get constantValue {
  objc.checkOsVersionInternal('NSExpression.constantValue', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_constantValue);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
_objc_msgSend_xtuoz7(object$.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);

  }


  /// expressionBlock
  objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSArray, objc.NSMutableDictionary?)> get expressionBlock {
  objc.checkOsVersionInternal('NSExpression.expressionBlock', iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final $ret = _objc_msgSend_uwvaik(object$.ref.pointer, _sel_expressionBlock);
    return ObjCBlock_objcObjCObjectImpl_objcObjCObjectImpl_NSArray_NSMutableDictionary.fromPointer($ret, retain: true, release: true);
  }


  /// expressionType
  int get expressionType {
  objc.checkOsVersionInternal('NSExpression.expressionType', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    return _objc_msgSend_1ts4niw(object$.ref.pointer, _sel_expressionType);

  }


  /// expressionValueWithObject:context:
  objc.ObjCObject? expressionValueWithObject(objc.ObjCObject? object, {objc.NSMutableDictionary? context}) {
  objc.checkOsVersionInternal('NSExpression.expressionValueWithObject:context:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_15qeuct(object$.ref.pointer, _sel_expressionValueWithObject_context_, object?.ref.pointer ?? ffi.nullptr, context?.ref.pointer ?? ffi.nullptr);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// falseExpression
  NSExpression get falseExpression {
  objc.checkOsVersionInternal('NSExpression.falseExpression', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_falseExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// function
  objc.NSString get function {
  objc.checkOsVersionInternal('NSExpression.function', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_function);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// init
  NSExpression init() {
  objc.checkOsVersionInternal('NSExpression.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// initWithCoder:
  NSExpression? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// initWithExpressionType:
  NSExpression initWithExpressionType(int type) {
  objc.checkOsVersionInternal('NSExpression.initWithExpressionType:', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_1rz5npq(object$.ref.retainAndReturnPointer(), _sel_initWithExpressionType_, type);
    return NSExpression.fromPointer($ret, retain: false, release: true);
  }


  /// keyPath
  objc.NSString get keyPath {
  objc.checkOsVersionInternal('NSExpression.keyPath', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_keyPath);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }


  /// leftExpression
  NSExpression get leftExpression {
  objc.checkOsVersionInternal('NSExpression.leftExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leftExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// operand
  NSExpression get operand {
  objc.checkOsVersionInternal('NSExpression.operand', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_operand);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// predicate
  NSPredicate get predicate {
  objc.checkOsVersionInternal('NSExpression.predicate', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_predicate);
    return NSPredicate.fromPointer($ret, retain: true, release: true);
  }


  /// rightExpression
  NSExpression get rightExpression {
  objc.checkOsVersionInternal('NSExpression.rightExpression', iOS: (false, (3, 0, 0)), macOS: (false, (10, 5, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rightExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// trueExpression
  NSExpression get trueExpression {
  objc.checkOsVersionInternal('NSExpression.trueExpression', iOS: (false, (9, 0, 0)), macOS: (false, (10, 11, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_trueExpression);
    return NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// variable
  objc.NSString get variable {
  objc.checkOsVersionInternal('NSExpression.variable', iOS: (false, (3, 0, 0)), macOS: (false, (10, 4, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_variable);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

}

late final _sel_linguisticTagsInRange_scheme_options_orthography_tokenRanges_ = objc.registerName("linguisticTagsInRange:scheme:options:orthography:tokenRanges:");
final _objc_msgSend_1l09uru = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> )>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
      {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>> ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
          retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunction(void Function(objc.NSString? , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(objc.newClosureBlock(_closureCallable, (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: true, release: true), arg1, arg2, arg3), keepIsolateAlive),
          retain: false, release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> listener(void Function(objc.NSString? , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2, arg3), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_lmc3p5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> blocking(void Function(objc.NSString? , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2, arg3), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) => fn(arg0.address == 0 ? null : objc.NSString.fromPointer(arg0, retain: false, release: true), arg1, arg2, arg3), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapBlockingBlock_lmc3p5(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(_listenerTrampoline )
          ..keepIsolateAlive = false;
  static void _blockingTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>.isolateLocal(
          _blockingTrampoline )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )> _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<ffi.Void> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>.listener(
          _blockingTrampoline )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>
          block.ref.target.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>>()
              .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_fnPtrTrampoline ).cast();
  static void _closureTrampoline(
      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>(_closureTrampoline ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> {
  void call(objc.NSString? arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3) =>ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObjectImpl> arg0, objc.NSRange arg1, objc.NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>>()
  .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl> , ffi.Pointer<objc.ObjCObjectImpl> , objc.NSRange , objc.NSRange , ffi.Pointer<ffi.Bool> )>()(
    ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2, arg3);
}

late final _sel_enumerateLinguisticTagsInRange_scheme_options_orthography_usingBlock_ = objc.registerName("enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:");
final _objc_msgSend_vij4rw = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , ffi.UnsignedLong , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , objc.NSRange , ffi.Pointer<objc.ObjCObjectImpl> , int , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCBlockImpl> )>();

/// NSLinguisticAnalysis
extension NSLinguisticAnalysis on objc.NSString {

  /// enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:
  void enumerateLinguisticTagsInRange(objc.NSRange range, {required objc.NSString scheme,required int options,NSOrthography? orthography,required objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> usingBlock}) {
  objc.checkOsVersionInternal('NSString.enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:', iOS: (false, (5, 0, 0)), macOS: (false, (10, 7, 0)));
_objc_msgSend_vij4rw(object$.ref.pointer, _sel_enumerateLinguisticTagsInRange_scheme_options_orthography_usingBlock_, range, scheme.ref.pointer, options, orthography?.ref.pointer ?? ffi.nullptr, usingBlock.ref.pointer);

  }


  /// linguisticTagsInRange:scheme:options:orthography:tokenRanges:
  objc.NSArray linguisticTagsInRange(objc.NSRange range, {required objc.NSString scheme,required int options,NSOrthography? orthography,required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> tokenRanges}) {
  objc.checkOsVersionInternal('NSString.linguisticTagsInRange:scheme:options:orthography:tokenRanges:', iOS: (false, (5, 0, 0)), macOS: (false, (10, 7, 0)));
    final $ret = _objc_msgSend_1l09uru(object$.ref.pointer, _sel_linguisticTagsInRange_scheme_options_orthography_tokenRanges_, range, scheme.ref.pointer, options, orthography?.ref.pointer ?? ffi.nullptr, tokenRanges);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

}

late final _class_Helpers = objc.getClass("Helpers");
late final _sel_addImageToStyleWithTarget_field_expression_ = objc.registerName("addImageToStyleWithTarget:field:expression:");
final _objc_msgSend_r8gdi7 = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>>().asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCObjectImpl> )>();
late final _sel_setExpressionWithTarget_field_expression_ = objc.registerName("setExpressionWithTarget:field:expression:");
late final _sel_parseExpressionWithPropertyName_expression_ = objc.registerName("parseExpressionWithPropertyName:expression:");

/// Helpers
extension type Helpers._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [Helpers] that points to the same underlying object as [other].
  Helpers.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [Helpers] that wraps the given raw object pointer.
  Helpers.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [Helpers].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_Helpers);

  /// addImageToStyleWithTarget:field:expression:
  static void addImageToStyleWithTarget(objc.NSObject target, {required objc.NSString field,required NSExpression expression}) {
_objc_msgSend_r8gdi7(_class_Helpers, _sel_addImageToStyleWithTarget_field_expression_, target.ref.pointer, field.ref.pointer, expression.ref.pointer);

  }


  /// alloc
  static Helpers alloc() {
    final $ret = _objc_msgSend_151sglz(_class_Helpers, _sel_alloc);
    return Helpers.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static Helpers allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_Helpers, _sel_allocWithZone_, zone);
    return Helpers.fromPointer($ret, retain: false, release: true);
  }


  /// new
  static Helpers new$() {
    final $ret = _objc_msgSend_151sglz(_class_Helpers, _sel_new);
    return Helpers.fromPointer($ret, retain: false, release: true);
  }


  /// parseExpressionWithPropertyName:expression:
  static NSExpression? parseExpressionWithPropertyName(objc.NSString propertyName, {required objc.NSString expression}) {
    final $ret = _objc_msgSend_15qeuct(_class_Helpers, _sel_parseExpressionWithPropertyName_expression_, propertyName.ref.pointer, expression.ref.pointer);
    return $ret.address == 0 ? null : NSExpression.fromPointer($ret, retain: true, release: true);
  }


  /// setExpressionWithTarget:field:expression:
  static void setExpressionWithTarget(objc.NSObject target, {required objc.NSString field,required NSExpression expression}) {
_objc_msgSend_r8gdi7(_class_Helpers, _sel_setExpressionWithTarget_field_expression_, target.ref.pointer, field.ref.pointer, expression.ref.pointer);

  }
  /// Returns a new instance of Helpers constructed with the default `new` method.
  Helpers() : this.as(new$().object$);

}

extension Helpers$Methods on Helpers {

  /// init
  Helpers init() {
  objc.checkOsVersionInternal('Helpers.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return Helpers.fromPointer($ret, retain: false, release: true);
  }

}

late final _class_MapLibreRegistry = objc.getClass("MapLibreRegistry");
late final _sel_getMapWithViewId_ = objc.registerName("getMapWithViewId:");
final _objc_msgSend_1ya1kjn = objc.msgSendPointer.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , ffi.Int64 )>>().asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl> , ffi.Pointer<objc.ObjCSelector> , int )>();
late final _sel_activity = objc.registerName("activity");
late final _sel_setActivity_ = objc.registerName("setActivity:");
late final _sel_context = objc.registerName("context");
late final _sel_setContext_ = objc.registerName("setContext:");

/// MapLibreRegistry
extension type MapLibreRegistry._(objc.ObjCObject object$) implements objc.ObjCObject,objc.NSObject {
  /// Constructs a [MapLibreRegistry] that points to the same underlying object as [other].
  MapLibreRegistry.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [MapLibreRegistry] that wraps the given raw object pointer.
  MapLibreRegistry.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false}) :
          object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [MapLibreRegistry].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_MapLibreRegistry);

  /// activity
  static objc.ObjCObject? getActivity() {
    final $ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_activity);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// alloc
  static MapLibreRegistry alloc() {
    final $ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_alloc);
    return MapLibreRegistry.fromPointer($ret, retain: false, release: true);
  }


  /// allocWithZone:
  static MapLibreRegistry allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_MapLibreRegistry, _sel_allocWithZone_, zone);
    return MapLibreRegistry.fromPointer($ret, retain: false, release: true);
  }


  /// context
  static objc.ObjCObject? getContext() {
    final $ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_context);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// getMapWithViewId:
  static objc.ObjCObject? getMapWithViewId(int viewId) {
    final $ret = _objc_msgSend_1ya1kjn(_class_MapLibreRegistry, _sel_getMapWithViewId_, viewId);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }


  /// new
  static MapLibreRegistry new$() {
    final $ret = _objc_msgSend_151sglz(_class_MapLibreRegistry, _sel_new);
    return MapLibreRegistry.fromPointer($ret, retain: false, release: true);
  }


  /// setActivity:
  static void setActivity(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(_class_MapLibreRegistry, _sel_setActivity_, value?.ref.pointer ?? ffi.nullptr);

  }


  /// setContext:
  static void setContext(objc.ObjCObject? value) {
_objc_msgSend_xtuoz7(_class_MapLibreRegistry, _sel_setContext_, value?.ref.pointer ?? ffi.nullptr);

  }
  /// Returns a new instance of MapLibreRegistry constructed with the default `new` method.
  MapLibreRegistry() : this.as(new$().object$);

}

extension MapLibreRegistry$Methods on MapLibreRegistry {

  /// init
  MapLibreRegistry init() {
  objc.checkOsVersionInternal('MapLibreRegistry.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return MapLibreRegistry.fromPointer($ret, retain: false, release: true);
  }

}

