// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: document_ignores
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'DefaultStyle.dart' as defaultstyle$_;

/// from: `org.maplibre.android.util.TileServerOptions`
class TileServerOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<TileServerOptions> $type;

  @jni$_.internal
  TileServerOptions.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/util/TileServerOptions',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $TileServerOptions$NullableType();
  static const type = $TileServerOptions$Type();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.JObjectNullableType());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;[Lorg/maplibre/android/util/DefaultStyle;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6, java.lang.String string7, java.lang.String string8, java.lang.String string9, java.lang.String string10, java.lang.String string11, java.lang.String string12, java.lang.String string13, java.lang.String string14, java.lang.String string15, java.lang.String string16, java.lang.String string17, boolean z, java.lang.String string18, org.maplibre.android.util.DefaultStyle[] defaultStyles)`
  /// The returned object must be released after use, by calling the [release] method.
  factory TileServerOptions(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
    jni$_.JString? string4,
    jni$_.JString? string5,
    jni$_.JString? string6,
    jni$_.JString? string7,
    jni$_.JString? string8,
    jni$_.JString? string9,
    jni$_.JString? string10,
    jni$_.JString? string11,
    jni$_.JString? string12,
    jni$_.JString? string13,
    jni$_.JString? string14,
    jni$_.JString? string15,
    jni$_.JString? string16,
    jni$_.JString? string17,
    bool z,
    jni$_.JString? string18,
    jni$_.JArray<defaultstyle$_.DefaultStyle?>? defaultStyles,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    final _$string4 = string4?.reference ?? jni$_.jNullReference;
    final _$string5 = string5?.reference ?? jni$_.jNullReference;
    final _$string6 = string6?.reference ?? jni$_.jNullReference;
    final _$string7 = string7?.reference ?? jni$_.jNullReference;
    final _$string8 = string8?.reference ?? jni$_.jNullReference;
    final _$string9 = string9?.reference ?? jni$_.jNullReference;
    final _$string10 = string10?.reference ?? jni$_.jNullReference;
    final _$string11 = string11?.reference ?? jni$_.jNullReference;
    final _$string12 = string12?.reference ?? jni$_.jNullReference;
    final _$string13 = string13?.reference ?? jni$_.jNullReference;
    final _$string14 = string14?.reference ?? jni$_.jNullReference;
    final _$string15 = string15?.reference ?? jni$_.jNullReference;
    final _$string16 = string16?.reference ?? jni$_.jNullReference;
    final _$string17 = string17?.reference ?? jni$_.jNullReference;
    final _$string18 = string18?.reference ?? jni$_.jNullReference;
    final _$defaultStyles = defaultStyles?.reference ?? jni$_.jNullReference;
    return TileServerOptions.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        _$string2.pointer,
        _$string3.pointer,
        _$string4.pointer,
        _$string5.pointer,
        _$string6.pointer,
        _$string7.pointer,
        _$string8.pointer,
        _$string9.pointer,
        _$string10.pointer,
        _$string11.pointer,
        _$string12.pointer,
        _$string13.pointer,
        _$string14.pointer,
        _$string15.pointer,
        _$string16.pointer,
        _$string17.pointer,
        z ? 1 : 0,
        _$string18.pointer,
        _$defaultStyles.pointer,
      ).reference,
    );
  }

  static final _id_setBaseURL = _class.instanceMethodId(
    r'setBaseURL',
    r'(Ljava/lang/String;)V',
  );

  static final _setBaseURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setBaseURL(java.lang.String string)`
  void setBaseURL(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setBaseURL(
      reference.pointer,
      _id_setBaseURL as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getBaseURL = _class.instanceMethodId(
    r'getBaseURL',
    r'()Ljava/lang/String;',
  );

  static final _getBaseURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getBaseURL()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getBaseURL() {
    return _getBaseURL(
      reference.pointer,
      _id_getBaseURL as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setUriSchemeAlias = _class.instanceMethodId(
    r'setUriSchemeAlias',
    r'(Ljava/lang/String;)V',
  );

  static final _setUriSchemeAlias =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setUriSchemeAlias(java.lang.String string)`
  void setUriSchemeAlias(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setUriSchemeAlias(
      reference.pointer,
      _id_setUriSchemeAlias as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getUriSchemeAlias = _class.instanceMethodId(
    r'getUriSchemeAlias',
    r'()Ljava/lang/String;',
  );

  static final _getUriSchemeAlias =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getUriSchemeAlias()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUriSchemeAlias() {
    return _getUriSchemeAlias(
      reference.pointer,
      _id_getUriSchemeAlias as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setSourceTemplate = _class.instanceMethodId(
    r'setSourceTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setSourceTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setSourceTemplate(java.lang.String string)`
  void setSourceTemplate(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSourceTemplate(
      reference.pointer,
      _id_setSourceTemplate as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getSourceTemplate = _class.instanceMethodId(
    r'getSourceTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getSourceTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getSourceTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSourceTemplate() {
    return _getSourceTemplate(
      reference.pointer,
      _id_getSourceTemplate as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setSourceDomainName = _class.instanceMethodId(
    r'setSourceDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setSourceDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setSourceDomainName(java.lang.String string)`
  void setSourceDomainName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSourceDomainName(
      reference.pointer,
      _id_setSourceDomainName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getSourceDomainName = _class.instanceMethodId(
    r'getSourceDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getSourceDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getSourceDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSourceDomainName() {
    return _getSourceDomainName(
      reference.pointer,
      _id_getSourceDomainName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setSourceVersionPrefix = _class.instanceMethodId(
    r'setSourceVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setSourceVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setSourceVersionPrefix(java.lang.String string)`
  void setSourceVersionPrefix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSourceVersionPrefix(
      reference.pointer,
      _id_setSourceVersionPrefix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getSourceVersionPrefix = _class.instanceMethodId(
    r'getSourceVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getSourceVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getSourceVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSourceVersionPrefix() {
    return _getSourceVersionPrefix(
      reference.pointer,
      _id_getSourceVersionPrefix as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setStyleTemplate = _class.instanceMethodId(
    r'setStyleTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyleTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStyleTemplate(java.lang.String string)`
  void setStyleTemplate(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setStyleTemplate(
      reference.pointer,
      _id_setStyleTemplate as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getStyleTemplate = _class.instanceMethodId(
    r'getStyleTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getStyleTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getStyleTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getStyleTemplate() {
    return _getStyleTemplate(
      reference.pointer,
      _id_getStyleTemplate as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setStyleDomainName = _class.instanceMethodId(
    r'setStyleDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyleDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStyleDomainName(java.lang.String string)`
  void setStyleDomainName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setStyleDomainName(
      reference.pointer,
      _id_setStyleDomainName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getStyleDomainName = _class.instanceMethodId(
    r'getStyleDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getStyleDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getStyleDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getStyleDomainName() {
    return _getStyleDomainName(
      reference.pointer,
      _id_getStyleDomainName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setStyleVersionPrefix = _class.instanceMethodId(
    r'setStyleVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyleVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStyleVersionPrefix(java.lang.String string)`
  void setStyleVersionPrefix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setStyleVersionPrefix(
      reference.pointer,
      _id_setStyleVersionPrefix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getStyleVersionPrefix = _class.instanceMethodId(
    r'getStyleVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getStyleVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getStyleVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getStyleVersionPrefix() {
    return _getStyleVersionPrefix(
      reference.pointer,
      _id_getStyleVersionPrefix as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setSpritesTemplate = _class.instanceMethodId(
    r'setSpritesTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setSpritesTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setSpritesTemplate(java.lang.String string)`
  void setSpritesTemplate(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSpritesTemplate(
      reference.pointer,
      _id_setSpritesTemplate as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getSpritesTemplate = _class.instanceMethodId(
    r'getSpritesTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getSpritesTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getSpritesTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSpritesTemplate() {
    return _getSpritesTemplate(
      reference.pointer,
      _id_getSpritesTemplate as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setSpritesDomainName = _class.instanceMethodId(
    r'setSpritesDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setSpritesDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setSpritesDomainName(java.lang.String string)`
  void setSpritesDomainName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSpritesDomainName(
      reference.pointer,
      _id_setSpritesDomainName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getSpritesDomainName = _class.instanceMethodId(
    r'getSpritesDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getSpritesDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getSpritesDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSpritesDomainName() {
    return _getSpritesDomainName(
      reference.pointer,
      _id_getSpritesDomainName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setSpritesVersionPrefix = _class.instanceMethodId(
    r'setSpritesVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setSpritesVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setSpritesVersionPrefix(java.lang.String string)`
  void setSpritesVersionPrefix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSpritesVersionPrefix(
      reference.pointer,
      _id_setSpritesVersionPrefix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getSpritesVersionPrefix = _class.instanceMethodId(
    r'getSpritesVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getSpritesVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getSpritesVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSpritesVersionPrefix() {
    return _getSpritesVersionPrefix(
      reference.pointer,
      _id_getSpritesVersionPrefix as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setGlyphsTemplate = _class.instanceMethodId(
    r'setGlyphsTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setGlyphsTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setGlyphsTemplate(java.lang.String string)`
  void setGlyphsTemplate(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setGlyphsTemplate(
      reference.pointer,
      _id_setGlyphsTemplate as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getGlyphsTemplate = _class.instanceMethodId(
    r'getGlyphsTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getGlyphsTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getGlyphsTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getGlyphsTemplate() {
    return _getGlyphsTemplate(
      reference.pointer,
      _id_getGlyphsTemplate as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setGlyphsDomainName = _class.instanceMethodId(
    r'setGlyphsDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setGlyphsDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setGlyphsDomainName(java.lang.String string)`
  void setGlyphsDomainName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setGlyphsDomainName(
      reference.pointer,
      _id_setGlyphsDomainName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getGlyphsDomainName = _class.instanceMethodId(
    r'getGlyphsDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getGlyphsDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getGlyphsDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getGlyphsDomainName() {
    return _getGlyphsDomainName(
      reference.pointer,
      _id_getGlyphsDomainName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setGlyphsVersionPrefix = _class.instanceMethodId(
    r'setGlyphsVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setGlyphsVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setGlyphsVersionPrefix(java.lang.String string)`
  void setGlyphsVersionPrefix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setGlyphsVersionPrefix(
      reference.pointer,
      _id_setGlyphsVersionPrefix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getGlyphsVersionPrefix = _class.instanceMethodId(
    r'getGlyphsVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getGlyphsVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getGlyphsVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getGlyphsVersionPrefix() {
    return _getGlyphsVersionPrefix(
      reference.pointer,
      _id_getGlyphsVersionPrefix as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setTileTemplate = _class.instanceMethodId(
    r'setTileTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setTileTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTileTemplate(java.lang.String string)`
  void setTileTemplate(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTileTemplate(
      reference.pointer,
      _id_setTileTemplate as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getTileTemplate = _class.instanceMethodId(
    r'getTileTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getTileTemplate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getTileTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTileTemplate() {
    return _getTileTemplate(
      reference.pointer,
      _id_getTileTemplate as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setTileDomainName = _class.instanceMethodId(
    r'setTileDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setTileDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTileDomainName(java.lang.String string)`
  void setTileDomainName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTileDomainName(
      reference.pointer,
      _id_setTileDomainName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getTileDomainName = _class.instanceMethodId(
    r'getTileDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getTileDomainName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getTileDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTileDomainName() {
    return _getTileDomainName(
      reference.pointer,
      _id_getTileDomainName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setTileVersionPrefix = _class.instanceMethodId(
    r'setTileVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setTileVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTileVersionPrefix(java.lang.String string)`
  void setTileVersionPrefix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTileVersionPrefix(
      reference.pointer,
      _id_setTileVersionPrefix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getTileVersionPrefix = _class.instanceMethodId(
    r'getTileVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getTileVersionPrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getTileVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTileVersionPrefix() {
    return _getTileVersionPrefix(
      reference.pointer,
      _id_getTileVersionPrefix as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setApiKeyParameterName = _class.instanceMethodId(
    r'setApiKeyParameterName',
    r'(Ljava/lang/String;)V',
  );

  static final _setApiKeyParameterName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setApiKeyParameterName(java.lang.String string)`
  void setApiKeyParameterName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setApiKeyParameterName(
      reference.pointer,
      _id_setApiKeyParameterName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getApiKeyParameterName = _class.instanceMethodId(
    r'getApiKeyParameterName',
    r'()Ljava/lang/String;',
  );

  static final _getApiKeyParameterName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getApiKeyParameterName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getApiKeyParameterName() {
    return _getApiKeyParameterName(
      reference.pointer,
      _id_getApiKeyParameterName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setApiKeyRequired = _class.instanceMethodId(
    r'setApiKeyRequired',
    r'(Z)V',
  );

  static final _setApiKeyRequired =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setApiKeyRequired(boolean z)`
  void setApiKeyRequired(bool z) {
    _setApiKeyRequired(
      reference.pointer,
      _id_setApiKeyRequired as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getApiKeyRequired = _class.instanceMethodId(
    r'getApiKeyRequired',
    r'()Z',
  );

  static final _getApiKeyRequired =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getApiKeyRequired()`
  bool getApiKeyRequired() {
    return _getApiKeyRequired(
      reference.pointer,
      _id_getApiKeyRequired as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setDefaultStyles = _class.instanceMethodId(
    r'setDefaultStyles',
    r'([Lorg/maplibre/android/util/DefaultStyle;)V',
  );

  static final _setDefaultStyles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDefaultStyles(org.maplibre.android.util.DefaultStyle[] defaultStyles)`
  void setDefaultStyles(
    jni$_.JArray<defaultstyle$_.DefaultStyle?>? defaultStyles,
  ) {
    final _$defaultStyles = defaultStyles?.reference ?? jni$_.jNullReference;
    _setDefaultStyles(
      reference.pointer,
      _id_setDefaultStyles as jni$_.JMethodIDPtr,
      _$defaultStyles.pointer,
    ).check();
  }

  static final _id_getDefaultStyles = _class.instanceMethodId(
    r'getDefaultStyles',
    r'()[Lorg/maplibre/android/util/DefaultStyle;',
  );

  static final _getDefaultStyles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.util.DefaultStyle[] getDefaultStyles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<defaultstyle$_.DefaultStyle?>? getDefaultStyles() {
    return _getDefaultStyles(
      reference.pointer,
      _id_getDefaultStyles as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<defaultstyle$_.DefaultStyle?>?>(
      const jni$_.JArrayNullableType<defaultstyle$_.DefaultStyle?>(
        defaultstyle$_.$DefaultStyle$NullableType(),
      ),
    );
  }

  static final _id_setDefaultStyle = _class.instanceMethodId(
    r'setDefaultStyle',
    r'(Ljava/lang/String;)V',
  );

  static final _setDefaultStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDefaultStyle(java.lang.String string)`
  void setDefaultStyle(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDefaultStyle(
      reference.pointer,
      _id_setDefaultStyle as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getDefaultStyle = _class.instanceMethodId(
    r'getDefaultStyle',
    r'()Ljava/lang/String;',
  );

  static final _getDefaultStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDefaultStyle()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDefaultStyle() {
    return _getDefaultStyle(
      reference.pointer,
      _id_getDefaultStyle as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject parcel, int i) {
    final _$parcel = parcel.reference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }

  static final _id_get = _class.staticMethodId(
    r'get',
    r'(Lorg/maplibre/android/WellKnownTileServer;)Lorg/maplibre/android/util/TileServerOptions;',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.maplibre.android.util.TileServerOptions get(org.maplibre.android.WellKnownTileServer wellKnownTileServer)`
  /// The returned object must be released after use, by calling the [release] method.
  static TileServerOptions? get(jni$_.JObject? wellKnownTileServer) {
    final _$wellKnownTileServer =
        wellKnownTileServer?.reference ?? jni$_.jNullReference;
    return _get(
      _class.reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$wellKnownTileServer.pointer,
    ).object<TileServerOptions?>(const $TileServerOptions$NullableType());
  }
}

final class $TileServerOptions$NullableType
    extends jni$_.JObjType<TileServerOptions?> {
  @jni$_.internal
  const $TileServerOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/util/TileServerOptions;';

  @jni$_.internal
  @core$_.override
  TileServerOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : TileServerOptions.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TileServerOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TileServerOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TileServerOptions$NullableType) &&
        other is $TileServerOptions$NullableType;
  }
}

final class $TileServerOptions$Type extends jni$_.JObjType<TileServerOptions> {
  @jni$_.internal
  const $TileServerOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/util/TileServerOptions;';

  @jni$_.internal
  @core$_.override
  TileServerOptions fromReference(jni$_.JReference reference) =>
      TileServerOptions.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TileServerOptions?> get nullableType =>
      const $TileServerOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TileServerOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TileServerOptions$Type) &&
        other is $TileServerOptions$Type;
  }
}
