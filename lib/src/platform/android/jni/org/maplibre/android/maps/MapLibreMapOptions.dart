// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: document_ignores
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../camera/CameraPosition.dart' as cameraposition$_;

/// from: `org.maplibre.android.maps.MapLibreMapOptions`
class MapLibreMapOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMapOptions> $type;

  @jni$_.internal
  MapLibreMapOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/maplibre/android/maps/MapLibreMapOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMapOptions$NullableType();
  static const type = $MapLibreMapOptions$Type();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.JObjectNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MapLibreMapOptions() {
    return MapLibreMapOptions.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_createFromAttributes = _class.staticMethodId(
    r'createFromAttributes',
    r'(Landroid/content/Context;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _createFromAttributes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.maplibre.android.maps.MapLibreMapOptions createFromAttributes(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static MapLibreMapOptions createFromAttributes(
    jni$_.JObject context,
  ) {
    final _$context = context.reference;
    return _createFromAttributes(_class.reference.pointer,
            _id_createFromAttributes as jni$_.JMethodIDPtr, _$context.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_createFromAttributes$1 = _class.staticMethodId(
    r'createFromAttributes',
    r'(Landroid/content/Context;Landroid/util/AttributeSet;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _createFromAttributes$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.maplibre.android.maps.MapLibreMapOptions createFromAttributes(android.content.Context context, android.util.AttributeSet attributeSet)`
  /// The returned object must be released after use, by calling the [release] method.
  static MapLibreMapOptions createFromAttributes$1(
    jni$_.JObject context,
    jni$_.JObject? attributeSet,
  ) {
    final _$context = context.reference;
    final _$attributeSet = attributeSet?.reference ?? jni$_.jNullReference;
    return _createFromAttributes$1(
            _class.reference.pointer,
            _id_createFromAttributes$1 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$attributeSet.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_apiBaseUrl = _class.instanceMethodId(
    r'apiBaseUrl',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _apiBaseUrl = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions apiBaseUrl(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions apiBaseUrl(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _apiBaseUrl(reference.pointer, _id_apiBaseUrl as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_apiBaseUri = _class.instanceMethodId(
    r'apiBaseUri',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _apiBaseUri = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions apiBaseUri(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions apiBaseUri(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _apiBaseUri(reference.pointer, _id_apiBaseUri as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_camera = _class.instanceMethodId(
    r'camera',
    r'(Lorg/maplibre/android/camera/CameraPosition;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _camera = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions camera(org.maplibre.android.camera.CameraPosition cameraPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions camera(
    cameraposition$_.CameraPosition? cameraPosition,
  ) {
    final _$cameraPosition = cameraPosition?.reference ?? jni$_.jNullReference;
    return _camera(reference.pointer, _id_camera as jni$_.JMethodIDPtr,
            _$cameraPosition.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_debugActive = _class.instanceMethodId(
    r'debugActive',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _debugActive = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions debugActive(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions debugActive(
    bool z,
  ) {
    return _debugActive(
            reference.pointer, _id_debugActive as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_minZoomPreference = _class.instanceMethodId(
    r'minZoomPreference',
    r'(D)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _minZoomPreference = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions minZoomPreference(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions minZoomPreference(
    double d,
  ) {
    return _minZoomPreference(
            reference.pointer, _id_minZoomPreference as jni$_.JMethodIDPtr, d)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_maxZoomPreference = _class.instanceMethodId(
    r'maxZoomPreference',
    r'(D)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _maxZoomPreference = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions maxZoomPreference(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions maxZoomPreference(
    double d,
  ) {
    return _maxZoomPreference(
            reference.pointer, _id_maxZoomPreference as jni$_.JMethodIDPtr, d)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_minPitchPreference = _class.instanceMethodId(
    r'minPitchPreference',
    r'(D)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _minPitchPreference = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions minPitchPreference(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions minPitchPreference(
    double d,
  ) {
    return _minPitchPreference(
            reference.pointer, _id_minPitchPreference as jni$_.JMethodIDPtr, d)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_maxPitchPreference = _class.instanceMethodId(
    r'maxPitchPreference',
    r'(D)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _maxPitchPreference = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions maxPitchPreference(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions maxPitchPreference(
    double d,
  ) {
    return _maxPitchPreference(
            reference.pointer, _id_maxPitchPreference as jni$_.JMethodIDPtr, d)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_compassEnabled = _class.instanceMethodId(
    r'compassEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassEnabled(
    bool z,
  ) {
    return _compassEnabled(reference.pointer,
            _id_compassEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_compassGravity = _class.instanceMethodId(
    r'compassGravity',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassGravity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassGravity(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassGravity(
    int i,
  ) {
    return _compassGravity(
            reference.pointer, _id_compassGravity as jni$_.JMethodIDPtr, i)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_compassMargins = _class.instanceMethodId(
    r'compassMargins',
    r'([I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassMargins = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassMargins(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassMargins(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _compassMargins(reference.pointer,
            _id_compassMargins as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_compassFadesWhenFacingNorth = _class.instanceMethodId(
    r'compassFadesWhenFacingNorth',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassFadesWhenFacingNorth =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassFadesWhenFacingNorth(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassFadesWhenFacingNorth(
    bool z,
  ) {
    return _compassFadesWhenFacingNorth(reference.pointer,
            _id_compassFadesWhenFacingNorth as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_compassImage = _class.instanceMethodId(
    r'compassImage',
    r'(Landroid/graphics/drawable/Drawable;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassImage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassImage(android.graphics.drawable.Drawable drawable)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassImage(
    jni$_.JObject? drawable,
  ) {
    final _$drawable = drawable?.reference ?? jni$_.jNullReference;
    return _compassImage(reference.pointer,
            _id_compassImage as jni$_.JMethodIDPtr, _$drawable.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_logoEnabled = _class.instanceMethodId(
    r'logoEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _logoEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions logoEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions logoEnabled(
    bool z,
  ) {
    return _logoEnabled(
            reference.pointer, _id_logoEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_logoGravity = _class.instanceMethodId(
    r'logoGravity',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _logoGravity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions logoGravity(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions logoGravity(
    int i,
  ) {
    return _logoGravity(
            reference.pointer, _id_logoGravity as jni$_.JMethodIDPtr, i)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_logoMargins = _class.instanceMethodId(
    r'logoMargins',
    r'([I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _logoMargins = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions logoMargins(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions logoMargins(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _logoMargins(reference.pointer,
            _id_logoMargins as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_attributionEnabled = _class.instanceMethodId(
    r'attributionEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _attributionEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions attributionEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions attributionEnabled(
    bool z,
  ) {
    return _attributionEnabled(reference.pointer,
            _id_attributionEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_attributionGravity = _class.instanceMethodId(
    r'attributionGravity',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _attributionGravity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions attributionGravity(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions attributionGravity(
    int i,
  ) {
    return _attributionGravity(
            reference.pointer, _id_attributionGravity as jni$_.JMethodIDPtr, i)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_attributionMargins = _class.instanceMethodId(
    r'attributionMargins',
    r'([I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _attributionMargins = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions attributionMargins(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions attributionMargins(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _attributionMargins(reference.pointer,
            _id_attributionMargins as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_attributionTintColor = _class.instanceMethodId(
    r'attributionTintColor',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _attributionTintColor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions attributionTintColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions attributionTintColor(
    int i,
  ) {
    return _attributionTintColor(reference.pointer,
            _id_attributionTintColor as jni$_.JMethodIDPtr, i)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_rotateGesturesEnabled = _class.instanceMethodId(
    r'rotateGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _rotateGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions rotateGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions rotateGesturesEnabled(
    bool z,
  ) {
    return _rotateGesturesEnabled(reference.pointer,
            _id_rotateGesturesEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_scrollGesturesEnabled = _class.instanceMethodId(
    r'scrollGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _scrollGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions scrollGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions scrollGesturesEnabled(
    bool z,
  ) {
    return _scrollGesturesEnabled(reference.pointer,
            _id_scrollGesturesEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_horizontalScrollGesturesEnabled = _class.instanceMethodId(
    r'horizontalScrollGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _horizontalScrollGesturesEnabled =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions horizontalScrollGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions horizontalScrollGesturesEnabled(
    bool z,
  ) {
    return _horizontalScrollGesturesEnabled(
            reference.pointer,
            _id_horizontalScrollGesturesEnabled as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_tiltGesturesEnabled = _class.instanceMethodId(
    r'tiltGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _tiltGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions tiltGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions tiltGesturesEnabled(
    bool z,
  ) {
    return _tiltGesturesEnabled(reference.pointer,
            _id_tiltGesturesEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_zoomGesturesEnabled = _class.instanceMethodId(
    r'zoomGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _zoomGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions zoomGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions zoomGesturesEnabled(
    bool z,
  ) {
    return _zoomGesturesEnabled(reference.pointer,
            _id_zoomGesturesEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_doubleTapGesturesEnabled = _class.instanceMethodId(
    r'doubleTapGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _doubleTapGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions doubleTapGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions doubleTapGesturesEnabled(
    bool z,
  ) {
    return _doubleTapGesturesEnabled(reference.pointer,
            _id_doubleTapGesturesEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_quickZoomGesturesEnabled = _class.instanceMethodId(
    r'quickZoomGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _quickZoomGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions quickZoomGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions quickZoomGesturesEnabled(
    bool z,
  ) {
    return _quickZoomGesturesEnabled(reference.pointer,
            _id_quickZoomGesturesEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_textureMode = _class.instanceMethodId(
    r'textureMode',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _textureMode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions textureMode(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions textureMode(
    bool z,
  ) {
    return _textureMode(
            reference.pointer, _id_textureMode as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_translucentTextureSurface = _class.instanceMethodId(
    r'translucentTextureSurface',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _translucentTextureSurface = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions translucentTextureSurface(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions translucentTextureSurface(
    bool z,
  ) {
    return _translucentTextureSurface(reference.pointer,
            _id_translucentTextureSurface as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_foregroundLoadColor = _class.instanceMethodId(
    r'foregroundLoadColor',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _foregroundLoadColor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions foregroundLoadColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions foregroundLoadColor(
    int i,
  ) {
    return _foregroundLoadColor(
            reference.pointer, _id_foregroundLoadColor as jni$_.JMethodIDPtr, i)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_setPrefetchesTiles = _class.instanceMethodId(
    r'setPrefetchesTiles',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _setPrefetchesTiles = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions setPrefetchesTiles(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions setPrefetchesTiles(
    bool z,
  ) {
    return _setPrefetchesTiles(reference.pointer,
            _id_setPrefetchesTiles as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_setPrefetchZoomDelta = _class.instanceMethodId(
    r'setPrefetchZoomDelta',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _setPrefetchZoomDelta = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions setPrefetchZoomDelta(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions setPrefetchZoomDelta(
    int i,
  ) {
    return _setPrefetchZoomDelta(reference.pointer,
            _id_setPrefetchZoomDelta as jni$_.JMethodIDPtr, i)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_crossSourceCollisions = _class.instanceMethodId(
    r'crossSourceCollisions',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _crossSourceCollisions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions crossSourceCollisions(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions crossSourceCollisions(
    bool z,
  ) {
    return _crossSourceCollisions(reference.pointer,
            _id_crossSourceCollisions as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_localIdeographFontFamilyEnabled = _class.instanceMethodId(
    r'localIdeographFontFamilyEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _localIdeographFontFamilyEnabled =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions localIdeographFontFamilyEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions localIdeographFontFamilyEnabled(
    bool z,
  ) {
    return _localIdeographFontFamilyEnabled(
            reference.pointer,
            _id_localIdeographFontFamilyEnabled as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_localIdeographFontFamily = _class.instanceMethodId(
    r'localIdeographFontFamily',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _localIdeographFontFamily = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions localIdeographFontFamily(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions localIdeographFontFamily(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _localIdeographFontFamily(
            reference.pointer,
            _id_localIdeographFontFamily as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_localIdeographFontFamily$1 = _class.instanceMethodId(
    r'localIdeographFontFamily',
    r'([Ljava/lang/String;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _localIdeographFontFamily$1 =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions localIdeographFontFamily(java.lang.String[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions localIdeographFontFamily$1(
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return _localIdeographFontFamily$1(
            reference.pointer,
            _id_localIdeographFontFamily$1 as jni$_.JMethodIDPtr,
            _$strings.pointer)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_pixelRatio = _class.instanceMethodId(
    r'pixelRatio',
    r'(F)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _pixelRatio = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions pixelRatio(float f)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions pixelRatio(
    double f,
  ) {
    return _pixelRatio(
            reference.pointer, _id_pixelRatio as jni$_.JMethodIDPtr, f)
        .object<MapLibreMapOptions>(const $MapLibreMapOptions$Type());
  }

  static final _id_getPrefetchesTiles = _class.instanceMethodId(
    r'getPrefetchesTiles',
    r'()Z',
  );

  static final _getPrefetchesTiles = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getPrefetchesTiles()`
  bool getPrefetchesTiles() {
    return _getPrefetchesTiles(
            reference.pointer, _id_getPrefetchesTiles as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getPrefetchZoomDelta = _class.instanceMethodId(
    r'getPrefetchZoomDelta',
    r'()I',
  );

  static final _getPrefetchZoomDelta = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getPrefetchZoomDelta()`
  int getPrefetchZoomDelta() {
    return _getPrefetchZoomDelta(
            reference.pointer, _id_getPrefetchZoomDelta as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getCrossSourceCollisions = _class.instanceMethodId(
    r'getCrossSourceCollisions',
    r'()Z',
  );

  static final _getCrossSourceCollisions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getCrossSourceCollisions()`
  bool getCrossSourceCollisions() {
    return _getCrossSourceCollisions(reference.pointer,
            _id_getCrossSourceCollisions as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_renderSurfaceOnTop = _class.instanceMethodId(
    r'renderSurfaceOnTop',
    r'(Z)V',
  );

  static final _renderSurfaceOnTop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void renderSurfaceOnTop(boolean z)`
  void renderSurfaceOnTop(
    bool z,
  ) {
    _renderSurfaceOnTop(reference.pointer,
            _id_renderSurfaceOnTop as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getRenderSurfaceOnTop = _class.instanceMethodId(
    r'getRenderSurfaceOnTop',
    r'()Z',
  );

  static final _getRenderSurfaceOnTop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getRenderSurfaceOnTop()`
  bool getRenderSurfaceOnTop() {
    return _getRenderSurfaceOnTop(
            reference.pointer, _id_getRenderSurfaceOnTop as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getApiBaseUrl = _class.instanceMethodId(
    r'getApiBaseUrl',
    r'()Ljava/lang/String;',
  );

  static final _getApiBaseUrl = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getApiBaseUrl()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getApiBaseUrl() {
    return _getApiBaseUrl(
            reference.pointer, _id_getApiBaseUrl as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getApiBaseUri = _class.instanceMethodId(
    r'getApiBaseUri',
    r'()Ljava/lang/String;',
  );

  static final _getApiBaseUri = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getApiBaseUri()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getApiBaseUri() {
    return _getApiBaseUri(
            reference.pointer, _id_getApiBaseUri as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getCamera = _class.instanceMethodId(
    r'getCamera',
    r'()Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCamera = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCamera()`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCamera() {
    return _getCamera(reference.pointer, _id_getCamera as jni$_.JMethodIDPtr)
        .object<cameraposition$_.CameraPosition?>(
            const cameraposition$_.$CameraPosition$NullableType());
  }

  static final _id_getMinZoomPreference = _class.instanceMethodId(
    r'getMinZoomPreference',
    r'()D',
  );

  static final _getMinZoomPreference = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public double getMinZoomPreference()`
  double getMinZoomPreference() {
    return _getMinZoomPreference(
            reference.pointer, _id_getMinZoomPreference as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getMaxZoomPreference = _class.instanceMethodId(
    r'getMaxZoomPreference',
    r'()D',
  );

  static final _getMaxZoomPreference = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public double getMaxZoomPreference()`
  double getMaxZoomPreference() {
    return _getMaxZoomPreference(
            reference.pointer, _id_getMaxZoomPreference as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getMinPitchPreference = _class.instanceMethodId(
    r'getMinPitchPreference',
    r'()D',
  );

  static final _getMinPitchPreference = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public double getMinPitchPreference()`
  double getMinPitchPreference() {
    return _getMinPitchPreference(
            reference.pointer, _id_getMinPitchPreference as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getMaxPitchPreference = _class.instanceMethodId(
    r'getMaxPitchPreference',
    r'()D',
  );

  static final _getMaxPitchPreference = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public double getMaxPitchPreference()`
  double getMaxPitchPreference() {
    return _getMaxPitchPreference(
            reference.pointer, _id_getMaxPitchPreference as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getCompassEnabled = _class.instanceMethodId(
    r'getCompassEnabled',
    r'()Z',
  );

  static final _getCompassEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getCompassEnabled()`
  bool getCompassEnabled() {
    return _getCompassEnabled(
            reference.pointer, _id_getCompassEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getCompassGravity = _class.instanceMethodId(
    r'getCompassGravity',
    r'()I',
  );

  static final _getCompassGravity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getCompassGravity()`
  int getCompassGravity() {
    return _getCompassGravity(
            reference.pointer, _id_getCompassGravity as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getCompassMargins = _class.instanceMethodId(
    r'getCompassMargins',
    r'()[I',
  );

  static final _getCompassMargins = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int[] getCompassMargins()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getCompassMargins() {
    return _getCompassMargins(
            reference.pointer, _id_getCompassMargins as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getCompassFadeFacingNorth = _class.instanceMethodId(
    r'getCompassFadeFacingNorth',
    r'()Z',
  );

  static final _getCompassFadeFacingNorth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getCompassFadeFacingNorth()`
  bool getCompassFadeFacingNorth() {
    return _getCompassFadeFacingNorth(reference.pointer,
            _id_getCompassFadeFacingNorth as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getCompassImage = _class.instanceMethodId(
    r'getCompassImage',
    r'()Landroid/graphics/drawable/Drawable;',
  );

  static final _getCompassImage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.drawable.Drawable getCompassImage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCompassImage() {
    return _getCompassImage(
            reference.pointer, _id_getCompassImage as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getLogoEnabled = _class.instanceMethodId(
    r'getLogoEnabled',
    r'()Z',
  );

  static final _getLogoEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getLogoEnabled()`
  bool getLogoEnabled() {
    return _getLogoEnabled(
            reference.pointer, _id_getLogoEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getLogoGravity = _class.instanceMethodId(
    r'getLogoGravity',
    r'()I',
  );

  static final _getLogoGravity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getLogoGravity()`
  int getLogoGravity() {
    return _getLogoGravity(
            reference.pointer, _id_getLogoGravity as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getLogoMargins = _class.instanceMethodId(
    r'getLogoMargins',
    r'()[I',
  );

  static final _getLogoMargins = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int[] getLogoMargins()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getLogoMargins() {
    return _getLogoMargins(
            reference.pointer, _id_getLogoMargins as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getRotateGesturesEnabled = _class.instanceMethodId(
    r'getRotateGesturesEnabled',
    r'()Z',
  );

  static final _getRotateGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getRotateGesturesEnabled()`
  bool getRotateGesturesEnabled() {
    return _getRotateGesturesEnabled(reference.pointer,
            _id_getRotateGesturesEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getScrollGesturesEnabled = _class.instanceMethodId(
    r'getScrollGesturesEnabled',
    r'()Z',
  );

  static final _getScrollGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getScrollGesturesEnabled()`
  bool getScrollGesturesEnabled() {
    return _getScrollGesturesEnabled(reference.pointer,
            _id_getScrollGesturesEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getHorizontalScrollGesturesEnabled = _class.instanceMethodId(
    r'getHorizontalScrollGesturesEnabled',
    r'()Z',
  );

  static final _getHorizontalScrollGesturesEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean getHorizontalScrollGesturesEnabled()`
  bool getHorizontalScrollGesturesEnabled() {
    return _getHorizontalScrollGesturesEnabled(reference.pointer,
            _id_getHorizontalScrollGesturesEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getTiltGesturesEnabled = _class.instanceMethodId(
    r'getTiltGesturesEnabled',
    r'()Z',
  );

  static final _getTiltGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getTiltGesturesEnabled()`
  bool getTiltGesturesEnabled() {
    return _getTiltGesturesEnabled(
            reference.pointer, _id_getTiltGesturesEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getZoomGesturesEnabled = _class.instanceMethodId(
    r'getZoomGesturesEnabled',
    r'()Z',
  );

  static final _getZoomGesturesEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getZoomGesturesEnabled()`
  bool getZoomGesturesEnabled() {
    return _getZoomGesturesEnabled(
            reference.pointer, _id_getZoomGesturesEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getDoubleTapGesturesEnabled = _class.instanceMethodId(
    r'getDoubleTapGesturesEnabled',
    r'()Z',
  );

  static final _getDoubleTapGesturesEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean getDoubleTapGesturesEnabled()`
  bool getDoubleTapGesturesEnabled() {
    return _getDoubleTapGesturesEnabled(reference.pointer,
            _id_getDoubleTapGesturesEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getQuickZoomGesturesEnabled = _class.instanceMethodId(
    r'getQuickZoomGesturesEnabled',
    r'()Z',
  );

  static final _getQuickZoomGesturesEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean getQuickZoomGesturesEnabled()`
  bool getQuickZoomGesturesEnabled() {
    return _getQuickZoomGesturesEnabled(reference.pointer,
            _id_getQuickZoomGesturesEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAttributionEnabled = _class.instanceMethodId(
    r'getAttributionEnabled',
    r'()Z',
  );

  static final _getAttributionEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getAttributionEnabled()`
  bool getAttributionEnabled() {
    return _getAttributionEnabled(
            reference.pointer, _id_getAttributionEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAttributionGravity = _class.instanceMethodId(
    r'getAttributionGravity',
    r'()I',
  );

  static final _getAttributionGravity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getAttributionGravity()`
  int getAttributionGravity() {
    return _getAttributionGravity(
            reference.pointer, _id_getAttributionGravity as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getAttributionMargins = _class.instanceMethodId(
    r'getAttributionMargins',
    r'()[I',
  );

  static final _getAttributionMargins = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int[] getAttributionMargins()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getAttributionMargins() {
    return _getAttributionMargins(
            reference.pointer, _id_getAttributionMargins as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getAttributionTintColor = _class.instanceMethodId(
    r'getAttributionTintColor',
    r'()I',
  );

  static final _getAttributionTintColor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getAttributionTintColor()`
  int getAttributionTintColor() {
    return _getAttributionTintColor(reference.pointer,
            _id_getAttributionTintColor as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getDebugActive = _class.instanceMethodId(
    r'getDebugActive',
    r'()Z',
  );

  static final _getDebugActive = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getDebugActive()`
  bool getDebugActive() {
    return _getDebugActive(
            reference.pointer, _id_getDebugActive as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getTextureMode = _class.instanceMethodId(
    r'getTextureMode',
    r'()Z',
  );

  static final _getTextureMode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getTextureMode()`
  bool getTextureMode() {
    return _getTextureMode(
            reference.pointer, _id_getTextureMode as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getTranslucentTextureSurface = _class.instanceMethodId(
    r'getTranslucentTextureSurface',
    r'()Z',
  );

  static final _getTranslucentTextureSurface =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean getTranslucentTextureSurface()`
  bool getTranslucentTextureSurface() {
    return _getTranslucentTextureSurface(reference.pointer,
            _id_getTranslucentTextureSurface as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getForegroundLoadColor = _class.instanceMethodId(
    r'getForegroundLoadColor',
    r'()I',
  );

  static final _getForegroundLoadColor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getForegroundLoadColor()`
  int getForegroundLoadColor() {
    return _getForegroundLoadColor(
            reference.pointer, _id_getForegroundLoadColor as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getLocalIdeographFontFamily = _class.instanceMethodId(
    r'getLocalIdeographFontFamily',
    r'()Ljava/lang/String;',
  );

  static final _getLocalIdeographFontFamily =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.String getLocalIdeographFontFamily()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getLocalIdeographFontFamily() {
    return _getLocalIdeographFontFamily(reference.pointer,
            _id_getLocalIdeographFontFamily as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isLocalIdeographFontFamilyEnabled = _class.instanceMethodId(
    r'isLocalIdeographFontFamilyEnabled',
    r'()Z',
  );

  static final _isLocalIdeographFontFamilyEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isLocalIdeographFontFamilyEnabled()`
  bool isLocalIdeographFontFamilyEnabled() {
    return _isLocalIdeographFontFamilyEnabled(reference.pointer,
            _id_isLocalIdeographFontFamilyEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getPixelRatio = _class.instanceMethodId(
    r'getPixelRatio',
    r'()F',
  );

  static final _getPixelRatio = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public float getPixelRatio()`
  double getPixelRatio() {
    return _getPixelRatio(
            reference.pointer, _id_getPixelRatio as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(
    jni$_.JObject parcel,
    int i,
  ) {
    final _$parcel = parcel.reference;
    _writeToParcel(reference.pointer, _id_writeToParcel as jni$_.JMethodIDPtr,
            _$parcel.pointer, i)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $MapLibreMapOptions$NullableType
    extends jni$_.JObjType<MapLibreMapOptions?> {
  @jni$_.internal
  const $MapLibreMapOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/MapLibreMapOptions;';

  @jni$_.internal
  @core$_.override
  MapLibreMapOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMapOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMapOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMapOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMapOptions$NullableType) &&
        other is $MapLibreMapOptions$NullableType;
  }
}

final class $MapLibreMapOptions$Type
    extends jni$_.JObjType<MapLibreMapOptions> {
  @jni$_.internal
  const $MapLibreMapOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/MapLibreMapOptions;';

  @jni$_.internal
  @core$_.override
  MapLibreMapOptions fromReference(jni$_.JReference reference) =>
      MapLibreMapOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMapOptions?> get nullableType =>
      const $MapLibreMapOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMapOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMapOptions$Type) &&
        other is $MapLibreMapOptions$Type;
  }
}
