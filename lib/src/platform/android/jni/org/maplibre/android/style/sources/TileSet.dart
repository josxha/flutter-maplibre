// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: document_ignores
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../geometry/LatLng.dart' as latlng$_;

import '../../geometry/LatLngBounds.dart' as latlngbounds$_;

/// from: `org.maplibre.android.style.sources.TileSet`
class TileSet extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<TileSet> $type;

  @jni$_.internal
  TileSet.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/maplibre/android/style/sources/TileSet');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $TileSet$NullableType();
  static const type = $TileSet$Type();
  static final _id_minZoom = _class.instanceFieldId(
    r'minZoom',
    r'Ljava/lang/Float;',
  );

  /// from: `public java.lang.Float minZoom`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JFloat? get minZoom =>
      _id_minZoom.get(this, const jni$_.JFloatNullableType());

  /// from: `public java.lang.Float minZoom`
  /// The returned object must be released after use, by calling the [release] method.
  set minZoom(jni$_.JFloat? value) =>
      _id_minZoom.set(this, const jni$_.JFloatNullableType(), value);

  static final _id_maxZoom = _class.instanceFieldId(
    r'maxZoom',
    r'Ljava/lang/Float;',
  );

  /// from: `public java.lang.Float maxZoom`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JFloat? get maxZoom =>
      _id_maxZoom.get(this, const jni$_.JFloatNullableType());

  /// from: `public java.lang.Float maxZoom`
  /// The returned object must be released after use, by calling the [release] method.
  set maxZoom(jni$_.JFloat? value) =>
      _id_maxZoom.set(this, const jni$_.JFloatNullableType(), value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;[Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  factory TileSet(
    jni$_.JString string,
    jni$_.JArray<jni$_.JString> strings,
  ) {
    final _$string = string.reference;
    final _$strings = strings.reference;
    return TileSet.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer, _$strings.pointer)
        .reference);
  }

  static final _id_getTilejson = _class.instanceMethodId(
    r'getTilejson',
    r'()Ljava/lang/String;',
  );

  static final _getTilejson = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getTilejson()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTilejson() {
    return _getTilejson(
            reference.pointer, _id_getTilejson as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setName = _class.instanceMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setName(java.lang.String string)`
  void setName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setName(reference.pointer, _id_setName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getDescription = _class.instanceMethodId(
    r'getDescription',
    r'()Ljava/lang/String;',
  );

  static final _getDescription = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getDescription()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDescription() {
    return _getDescription(
            reference.pointer, _id_getDescription as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDescription = _class.instanceMethodId(
    r'setDescription',
    r'(Ljava/lang/String;)V',
  );

  static final _setDescription = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setDescription(java.lang.String string)`
  void setDescription(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDescription(reference.pointer, _id_setDescription as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getVersion = _class.instanceMethodId(
    r'getVersion',
    r'()Ljava/lang/String;',
  );

  static final _getVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getVersion() {
    return _getVersion(reference.pointer, _id_getVersion as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setVersion = _class.instanceMethodId(
    r'setVersion',
    r'(Ljava/lang/String;)V',
  );

  static final _setVersion = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setVersion(java.lang.String string)`
  void setVersion(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setVersion(reference.pointer, _id_setVersion as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getAttribution = _class.instanceMethodId(
    r'getAttribution',
    r'()Ljava/lang/String;',
  );

  static final _getAttribution = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getAttribution()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAttribution() {
    return _getAttribution(
            reference.pointer, _id_getAttribution as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setAttribution = _class.instanceMethodId(
    r'setAttribution',
    r'(Ljava/lang/String;)V',
  );

  static final _setAttribution = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setAttribution(java.lang.String string)`
  void setAttribution(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setAttribution(reference.pointer, _id_setAttribution as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getTemplate = _class.instanceMethodId(
    r'getTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getTemplate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTemplate() {
    return _getTemplate(
            reference.pointer, _id_getTemplate as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setTemplate = _class.instanceMethodId(
    r'setTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setTemplate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setTemplate(java.lang.String string)`
  void setTemplate(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTemplate(reference.pointer, _id_setTemplate as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getLegend = _class.instanceMethodId(
    r'getLegend',
    r'()Ljava/lang/String;',
  );

  static final _getLegend = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getLegend()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getLegend() {
    return _getLegend(reference.pointer, _id_getLegend as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setLegend = _class.instanceMethodId(
    r'setLegend',
    r'(Ljava/lang/String;)V',
  );

  static final _setLegend = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setLegend(java.lang.String string)`
  void setLegend(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setLegend(reference.pointer, _id_setLegend as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getScheme = _class.instanceMethodId(
    r'getScheme',
    r'()Ljava/lang/String;',
  );

  static final _getScheme = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getScheme()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getScheme() {
    return _getScheme(reference.pointer, _id_getScheme as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setScheme = _class.instanceMethodId(
    r'setScheme',
    r'(Ljava/lang/String;)V',
  );

  static final _setScheme = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setScheme(java.lang.String string)`
  void setScheme(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setScheme(reference.pointer, _id_setScheme as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getTiles = _class.instanceMethodId(
    r'getTiles',
    r'()[Ljava/lang/String;',
  );

  static final _getTiles = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String[] getTiles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString> getTiles() {
    return _getTiles(reference.pointer, _id_getTiles as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString>>(
            const jni$_.JArrayType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_getGrids = _class.instanceMethodId(
    r'getGrids',
    r'()[Ljava/lang/String;',
  );

  static final _getGrids = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String[] getGrids()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString>? getGrids() {
    return _getGrids(reference.pointer, _id_getGrids as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString>?>(
            const jni$_.JArrayNullableType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_getData = _class.instanceMethodId(
    r'getData',
    r'()[Ljava/lang/String;',
  );

  static final _getData = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String[] getData()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString>? getData() {
    return _getData(reference.pointer, _id_getData as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString>?>(
            const jni$_.JArrayNullableType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_getBounds = _class.instanceMethodId(
    r'getBounds',
    r'()[Ljava/lang/Float;',
  );

  static final _getBounds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Float[] getBounds()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JFloat>? getBounds() {
    return _getBounds(reference.pointer, _id_getBounds as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JFloat>?>(
            const jni$_.JArrayNullableType<jni$_.JFloat>(jni$_.JFloatType()));
  }

  static final _id_getCenter = _class.instanceMethodId(
    r'getCenter',
    r'()[Ljava/lang/Float;',
  );

  static final _getCenter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Float[] getCenter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JFloat>? getCenter() {
    return _getCenter(reference.pointer, _id_getCenter as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JFloat>?>(
            const jni$_.JArrayNullableType<jni$_.JFloat>(jni$_.JFloatType()));
  }

  static final _id_getEncoding = _class.instanceMethodId(
    r'getEncoding',
    r'()Ljava/lang/String;',
  );

  static final _getEncoding = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getEncoding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEncoding() {
    return _getEncoding(
            reference.pointer, _id_getEncoding as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setEncoding = _class.instanceMethodId(
    r'setEncoding',
    r'(Ljava/lang/String;)V',
  );

  static final _setEncoding = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setEncoding(java.lang.String string)`
  void setEncoding(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setEncoding(reference.pointer, _id_setEncoding as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setGrids = _class.instanceMethodId(
    r'setGrids',
    r'([Ljava/lang/String;)V',
  );

  static final _setGrids = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setGrids(java.lang.String[] strings)`
  void setGrids(
    jni$_.JArray<jni$_.JString> strings,
  ) {
    final _$strings = strings.reference;
    _setGrids(reference.pointer, _id_setGrids as jni$_.JMethodIDPtr,
            _$strings.pointer)
        .check();
  }

  static final _id_setData = _class.instanceMethodId(
    r'setData',
    r'([Ljava/lang/String;)V',
  );

  static final _setData = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setData(java.lang.String[] strings)`
  void setData(
    jni$_.JArray<jni$_.JString> strings,
  ) {
    final _$strings = strings.reference;
    _setData(reference.pointer, _id_setData as jni$_.JMethodIDPtr,
            _$strings.pointer)
        .check();
  }

  static final _id_getMinZoom = _class.instanceMethodId(
    r'getMinZoom',
    r'()F',
  );

  static final _getMinZoom = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final float getMinZoom()`
  double getMinZoom() {
    return _getMinZoom(reference.pointer, _id_getMinZoom as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_setMinZoom = _class.instanceMethodId(
    r'setMinZoom',
    r'(F)V',
  );

  static final _setMinZoom = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public final void setMinZoom(float f)`
  void setMinZoom(
    double f,
  ) {
    _setMinZoom(reference.pointer, _id_setMinZoom as jni$_.JMethodIDPtr, f)
        .check();
  }

  static final _id_getMaxZoom = _class.instanceMethodId(
    r'getMaxZoom',
    r'()F',
  );

  static final _getMaxZoom = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final float getMaxZoom()`
  double getMaxZoom() {
    return _getMaxZoom(reference.pointer, _id_getMaxZoom as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_setMaxZoom = _class.instanceMethodId(
    r'setMaxZoom',
    r'(F)V',
  );

  static final _setMaxZoom = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public final void setMaxZoom(float f)`
  void setMaxZoom(
    double f,
  ) {
    _setMaxZoom(reference.pointer, _id_setMaxZoom as jni$_.JMethodIDPtr, f)
        .check();
  }

  static final _id_setBounds = _class.instanceMethodId(
    r'setBounds',
    r'([F)V',
  );

  static final _setBounds = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setBounds(float[] fs)`
  void setBounds(
    jni$_.JFloatArray fs,
  ) {
    final _$fs = fs.reference;
    _setBounds(reference.pointer, _id_setBounds as jni$_.JMethodIDPtr,
            _$fs.pointer)
        .check();
  }

  static final _id_setBounds$1 = _class.instanceMethodId(
    r'setBounds',
    r'(FFFF)V',
  );

  static final _setBounds$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Double,
                        jni$_.Double,
                        jni$_.Double,
                        jni$_.Double
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, double, double, double, double)>();

  /// from: `public final void setBounds(float f, float f1, float f2, float f3)`
  void setBounds$1(
    double f,
    double f1,
    double f2,
    double f3,
  ) {
    _setBounds$1(reference.pointer, _id_setBounds$1 as jni$_.JMethodIDPtr, f,
            f1, f2, f3)
        .check();
  }

  static final _id_setBounds$2 = _class.instanceMethodId(
    r'setBounds',
    r'([Ljava/lang/Float;)V',
  );

  static final _setBounds$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setBounds(java.lang.Float[] floats)`
  void setBounds$2(
    jni$_.JArray<jni$_.JFloat> floats,
  ) {
    final _$floats = floats.reference;
    _setBounds$2(reference.pointer, _id_setBounds$2 as jni$_.JMethodIDPtr,
            _$floats.pointer)
        .check();
  }

  static final _id_setBounds$3 = _class.instanceMethodId(
    r'setBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;)V',
  );

  static final _setBounds$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds)`
  void setBounds$3(
    latlngbounds$_.LatLngBounds latLngBounds,
  ) {
    final _$latLngBounds = latLngBounds.reference;
    _setBounds$3(reference.pointer, _id_setBounds$3 as jni$_.JMethodIDPtr,
            _$latLngBounds.pointer)
        .check();
  }

  static final _id_setCenter = _class.instanceMethodId(
    r'setCenter',
    r'([F)V',
  );

  static final _setCenter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setCenter(float[] fs)`
  void setCenter(
    jni$_.JFloatArray fs,
  ) {
    final _$fs = fs.reference;
    _setCenter(reference.pointer, _id_setCenter as jni$_.JMethodIDPtr,
            _$fs.pointer)
        .check();
  }

  static final _id_setCenter$1 = _class.instanceMethodId(
    r'setCenter',
    r'(Lorg/maplibre/android/geometry/LatLng;)V',
  );

  static final _setCenter$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setCenter(org.maplibre.android.geometry.LatLng latLng)`
  void setCenter$1(
    latlng$_.LatLng latLng,
  ) {
    final _$latLng = latLng.reference;
    _setCenter$1(reference.pointer, _id_setCenter$1 as jni$_.JMethodIDPtr,
            _$latLng.pointer)
        .check();
  }

  static final _id_toValueObject = _class.instanceMethodId(
    r'toValueObject',
    r'()Ljava/util/Map;',
  );

  static final _toValueObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map toValueObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JObject> toValueObject() {
    return _toValueObject(
            reference.pointer, _id_toValueObject as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, jni$_.JObject>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JObject>(
                jni$_.JStringType(), jni$_.JObjectType()));
  }
}

final class $TileSet$NullableType extends jni$_.JObjType<TileSet?> {
  @jni$_.internal
  const $TileSet$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/style/sources/TileSet;';

  @jni$_.internal
  @core$_.override
  TileSet? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : TileSet.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TileSet?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TileSet$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TileSet$NullableType) &&
        other is $TileSet$NullableType;
  }
}

final class $TileSet$Type extends jni$_.JObjType<TileSet> {
  @jni$_.internal
  const $TileSet$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/style/sources/TileSet;';

  @jni$_.internal
  @core$_.override
  TileSet fromReference(jni$_.JReference reference) => TileSet.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TileSet?> get nullableType => const $TileSet$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TileSet$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TileSet$Type) && other is $TileSet$Type;
  }
}
