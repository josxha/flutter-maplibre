// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: document_ignores
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../../../android/graphics/PointF.dart' as pointf$_;

import '../../geojson/Feature.dart' as feature$_;

import '../camera/CameraPosition.dart' as cameraposition$_;

import '../camera/CameraUpdate.dart' as cameraupdate$_;

import '../geometry/LatLng.dart' as latlng$_;

import '../geometry/LatLngBounds.dart' as latlngbounds$_;

import '../location/LocationComponent.dart' as locationcomponent$_;

import '../offline/OfflineRegionDefinition.dart' as offlineregiondefinition$_;

import 'Projection.dart' as projection$_;

import 'Style.dart' as style$_;

import 'UiSettings.dart' as uisettings$_;

/// from: `org.maplibre.android.maps.MapLibreMap$CancelableCallback`
class MapLibreMap$CancelableCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$CancelableCallback> $type;

  @jni$_.internal
  MapLibreMap$CancelableCallback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$CancelableCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$CancelableCallback$NullableType();
  static const type = $MapLibreMap$CancelableCallback$Type();
  static final _id_onCancel = _class.instanceMethodId(r'onCancel', r'()V');

  static final _onCancel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onCancel()`
  void onCancel() {
    _onCancel(reference.pointer, _id_onCancel as jni$_.JMethodIDPtr).check();
  }

  static final _id_onFinish = _class.instanceMethodId(r'onFinish', r'()V');

  static final _onFinish =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onFinish()`
  void onFinish() {
    _onFinish(reference.pointer, _id_onFinish as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$CancelableCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCancel()V') {
        _$impls[$p]!.onCancel();
        return jni$_.nullptr;
      }
      if ($d == r'onFinish()V') {
        _$impls[$p]!.onFinish();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$CancelableCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$CancelableCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onCancel$async) r'onCancel()V',
        if ($impl.onFinish$async) r'onFinish()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$CancelableCallback.implement(
    $MapLibreMap$CancelableCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$CancelableCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$CancelableCallback {
  factory $MapLibreMap$CancelableCallback({
    required void Function() onCancel,
    bool onCancel$async,
    required void Function() onFinish,
    bool onFinish$async,
  }) = _$MapLibreMap$CancelableCallback;

  void onCancel();
  bool get onCancel$async => false;
  void onFinish();
  bool get onFinish$async => false;
}

final class _$MapLibreMap$CancelableCallback
    with $MapLibreMap$CancelableCallback {
  _$MapLibreMap$CancelableCallback({
    required void Function() onCancel,
    this.onCancel$async = false,
    required void Function() onFinish,
    this.onFinish$async = false,
  }) : _onCancel = onCancel,
       _onFinish = onFinish;

  final void Function() _onCancel;
  final bool onCancel$async;
  final void Function() _onFinish;
  final bool onFinish$async;

  void onCancel() {
    return _onCancel();
  }

  void onFinish() {
    return _onFinish();
  }
}

final class $MapLibreMap$CancelableCallback$NullableType
    extends jni$_.JObjType<MapLibreMap$CancelableCallback?> {
  @jni$_.internal
  const $MapLibreMap$CancelableCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$CancelableCallback? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$CancelableCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$CancelableCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$CancelableCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$CancelableCallback$NullableType) &&
        other is $MapLibreMap$CancelableCallback$NullableType;
  }
}

final class $MapLibreMap$CancelableCallback$Type
    extends jni$_.JObjType<MapLibreMap$CancelableCallback> {
  @jni$_.internal
  const $MapLibreMap$CancelableCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$CancelableCallback fromReference(jni$_.JReference reference) =>
      MapLibreMap$CancelableCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$CancelableCallback?> get nullableType =>
      const $MapLibreMap$CancelableCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$CancelableCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$CancelableCallback$Type) &&
        other is $MapLibreMap$CancelableCallback$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter`
class MapLibreMap$InfoWindowAdapter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$InfoWindowAdapter> $type;

  @jni$_.internal
  MapLibreMap$InfoWindowAdapter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$InfoWindowAdapter',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$InfoWindowAdapter$NullableType();
  static const type = $MapLibreMap$InfoWindowAdapter$Type();
  static final _id_getInfoWindow = _class.instanceMethodId(
    r'getInfoWindow',
    r'(Lorg/maplibre/android/annotations/Marker;)Landroid/view/View;',
  );

  static final _getInfoWindow =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.view.View getInfoWindow(org.maplibre.android.annotations.Marker marker)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getInfoWindow(jni$_.JObject marker) {
    final _$marker = marker.reference;
    return _getInfoWindow(
      reference.pointer,
      _id_getInfoWindow as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$InfoWindowAdapter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'getInfoWindow(Lorg/maplibre/android/annotations/Marker;)Landroid/view/View;') {
        final $r = _$impls[$p]!.getInfoWindow(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$InfoWindowAdapter $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$InfoWindowAdapter.implement(
    $MapLibreMap$InfoWindowAdapter $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$InfoWindowAdapter.fromReference($i.implementReference());
  }
}

abstract base mixin class $MapLibreMap$InfoWindowAdapter {
  factory $MapLibreMap$InfoWindowAdapter({
    required jni$_.JObject? Function(jni$_.JObject marker) getInfoWindow,
  }) = _$MapLibreMap$InfoWindowAdapter;

  jni$_.JObject? getInfoWindow(jni$_.JObject marker);
}

final class _$MapLibreMap$InfoWindowAdapter
    with $MapLibreMap$InfoWindowAdapter {
  _$MapLibreMap$InfoWindowAdapter({
    required jni$_.JObject? Function(jni$_.JObject marker) getInfoWindow,
  }) : _getInfoWindow = getInfoWindow;

  final jni$_.JObject? Function(jni$_.JObject marker) _getInfoWindow;

  jni$_.JObject? getInfoWindow(jni$_.JObject marker) {
    return _getInfoWindow(marker);
  }
}

final class $MapLibreMap$InfoWindowAdapter$NullableType
    extends jni$_.JObjType<MapLibreMap$InfoWindowAdapter?> {
  @jni$_.internal
  const $MapLibreMap$InfoWindowAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$InfoWindowAdapter? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$InfoWindowAdapter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$InfoWindowAdapter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$InfoWindowAdapter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$InfoWindowAdapter$NullableType) &&
        other is $MapLibreMap$InfoWindowAdapter$NullableType;
  }
}

final class $MapLibreMap$InfoWindowAdapter$Type
    extends jni$_.JObjType<MapLibreMap$InfoWindowAdapter> {
  @jni$_.internal
  const $MapLibreMap$InfoWindowAdapter$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$InfoWindowAdapter fromReference(jni$_.JReference reference) =>
      MapLibreMap$InfoWindowAdapter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$InfoWindowAdapter?> get nullableType =>
      const $MapLibreMap$InfoWindowAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$InfoWindowAdapter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$InfoWindowAdapter$Type) &&
        other is $MapLibreMap$InfoWindowAdapter$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener`
class MapLibreMap$OnCameraIdleListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnCameraIdleListener> $type;

  @jni$_.internal
  MapLibreMap$OnCameraIdleListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnCameraIdleListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnCameraIdleListener$NullableType();
  static const type = $MapLibreMap$OnCameraIdleListener$Type();
  static final _id_onCameraIdle = _class.instanceMethodId(
    r'onCameraIdle',
    r'()V',
  );

  static final _onCameraIdle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onCameraIdle()`
  void onCameraIdle() {
    _onCameraIdle(
      reference.pointer,
      _id_onCameraIdle as jni$_.JMethodIDPtr,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnCameraIdleListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraIdle()V') {
        _$impls[$p]!.onCameraIdle();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnCameraIdleListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener',
      $p,
      _$invokePointer,
      [if ($impl.onCameraIdle$async) r'onCameraIdle()V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnCameraIdleListener.implement(
    $MapLibreMap$OnCameraIdleListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnCameraIdleListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnCameraIdleListener {
  factory $MapLibreMap$OnCameraIdleListener({
    required void Function() onCameraIdle,
    bool onCameraIdle$async,
  }) = _$MapLibreMap$OnCameraIdleListener;

  void onCameraIdle();
  bool get onCameraIdle$async => false;
}

final class _$MapLibreMap$OnCameraIdleListener
    with $MapLibreMap$OnCameraIdleListener {
  _$MapLibreMap$OnCameraIdleListener({
    required void Function() onCameraIdle,
    this.onCameraIdle$async = false,
  }) : _onCameraIdle = onCameraIdle;

  final void Function() _onCameraIdle;
  final bool onCameraIdle$async;

  void onCameraIdle() {
    return _onCameraIdle();
  }
}

final class $MapLibreMap$OnCameraIdleListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnCameraIdleListener?> {
  @jni$_.internal
  const $MapLibreMap$OnCameraIdleListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCameraIdleListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnCameraIdleListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCameraIdleListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnCameraIdleListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnCameraIdleListener$NullableType) &&
        other is $MapLibreMap$OnCameraIdleListener$NullableType;
  }
}

final class $MapLibreMap$OnCameraIdleListener$Type
    extends jni$_.JObjType<MapLibreMap$OnCameraIdleListener> {
  @jni$_.internal
  const $MapLibreMap$OnCameraIdleListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCameraIdleListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnCameraIdleListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCameraIdleListener?> get nullableType =>
      const $MapLibreMap$OnCameraIdleListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnCameraIdleListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnCameraIdleListener$Type) &&
        other is $MapLibreMap$OnCameraIdleListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener`
class MapLibreMap$OnCameraMoveCanceledListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnCameraMoveCanceledListener> $type;

  @jni$_.internal
  MapLibreMap$OnCameraMoveCanceledListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnCameraMoveCanceledListener$NullableType();
  static const type = $MapLibreMap$OnCameraMoveCanceledListener$Type();
  static final _id_onCameraMoveCanceled = _class.instanceMethodId(
    r'onCameraMoveCanceled',
    r'()V',
  );

  static final _onCameraMoveCanceled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onCameraMoveCanceled()`
  void onCameraMoveCanceled() {
    _onCameraMoveCanceled(
      reference.pointer,
      _id_onCameraMoveCanceled as jni$_.JMethodIDPtr,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnCameraMoveCanceledListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMoveCanceled()V') {
        _$impls[$p]!.onCameraMoveCanceled();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnCameraMoveCanceledListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener',
      $p,
      _$invokePointer,
      [if ($impl.onCameraMoveCanceled$async) r'onCameraMoveCanceled()V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnCameraMoveCanceledListener.implement(
    $MapLibreMap$OnCameraMoveCanceledListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnCameraMoveCanceledListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnCameraMoveCanceledListener {
  factory $MapLibreMap$OnCameraMoveCanceledListener({
    required void Function() onCameraMoveCanceled,
    bool onCameraMoveCanceled$async,
  }) = _$MapLibreMap$OnCameraMoveCanceledListener;

  void onCameraMoveCanceled();
  bool get onCameraMoveCanceled$async => false;
}

final class _$MapLibreMap$OnCameraMoveCanceledListener
    with $MapLibreMap$OnCameraMoveCanceledListener {
  _$MapLibreMap$OnCameraMoveCanceledListener({
    required void Function() onCameraMoveCanceled,
    this.onCameraMoveCanceled$async = false,
  }) : _onCameraMoveCanceled = onCameraMoveCanceled;

  final void Function() _onCameraMoveCanceled;
  final bool onCameraMoveCanceled$async;

  void onCameraMoveCanceled() {
    return _onCameraMoveCanceled();
  }
}

final class $MapLibreMap$OnCameraMoveCanceledListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnCameraMoveCanceledListener?> {
  @jni$_.internal
  const $MapLibreMap$OnCameraMoveCanceledListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCameraMoveCanceledListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnCameraMoveCanceledListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCameraMoveCanceledListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnCameraMoveCanceledListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnCameraMoveCanceledListener$NullableType) &&
        other is $MapLibreMap$OnCameraMoveCanceledListener$NullableType;
  }
}

final class $MapLibreMap$OnCameraMoveCanceledListener$Type
    extends jni$_.JObjType<MapLibreMap$OnCameraMoveCanceledListener> {
  @jni$_.internal
  const $MapLibreMap$OnCameraMoveCanceledListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCameraMoveCanceledListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnCameraMoveCanceledListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCameraMoveCanceledListener?> get nullableType =>
      const $MapLibreMap$OnCameraMoveCanceledListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnCameraMoveCanceledListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnCameraMoveCanceledListener$Type) &&
        other is $MapLibreMap$OnCameraMoveCanceledListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener`
class MapLibreMap$OnCameraMoveListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnCameraMoveListener> $type;

  @jni$_.internal
  MapLibreMap$OnCameraMoveListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnCameraMoveListener$NullableType();
  static const type = $MapLibreMap$OnCameraMoveListener$Type();
  static final _id_onCameraMove = _class.instanceMethodId(
    r'onCameraMove',
    r'()V',
  );

  static final _onCameraMove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onCameraMove()`
  void onCameraMove() {
    _onCameraMove(
      reference.pointer,
      _id_onCameraMove as jni$_.JMethodIDPtr,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnCameraMoveListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMove()V') {
        _$impls[$p]!.onCameraMove();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnCameraMoveListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener',
      $p,
      _$invokePointer,
      [if ($impl.onCameraMove$async) r'onCameraMove()V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnCameraMoveListener.implement(
    $MapLibreMap$OnCameraMoveListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnCameraMoveListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnCameraMoveListener {
  factory $MapLibreMap$OnCameraMoveListener({
    required void Function() onCameraMove,
    bool onCameraMove$async,
  }) = _$MapLibreMap$OnCameraMoveListener;

  void onCameraMove();
  bool get onCameraMove$async => false;
}

final class _$MapLibreMap$OnCameraMoveListener
    with $MapLibreMap$OnCameraMoveListener {
  _$MapLibreMap$OnCameraMoveListener({
    required void Function() onCameraMove,
    this.onCameraMove$async = false,
  }) : _onCameraMove = onCameraMove;

  final void Function() _onCameraMove;
  final bool onCameraMove$async;

  void onCameraMove() {
    return _onCameraMove();
  }
}

final class $MapLibreMap$OnCameraMoveListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnCameraMoveListener?> {
  @jni$_.internal
  const $MapLibreMap$OnCameraMoveListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCameraMoveListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnCameraMoveListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCameraMoveListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnCameraMoveListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnCameraMoveListener$NullableType) &&
        other is $MapLibreMap$OnCameraMoveListener$NullableType;
  }
}

final class $MapLibreMap$OnCameraMoveListener$Type
    extends jni$_.JObjType<MapLibreMap$OnCameraMoveListener> {
  @jni$_.internal
  const $MapLibreMap$OnCameraMoveListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCameraMoveListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnCameraMoveListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCameraMoveListener?> get nullableType =>
      const $MapLibreMap$OnCameraMoveListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnCameraMoveListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnCameraMoveListener$Type) &&
        other is $MapLibreMap$OnCameraMoveListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener`
class MapLibreMap$OnCameraMoveStartedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnCameraMoveStartedListener> $type;

  @jni$_.internal
  MapLibreMap$OnCameraMoveStartedListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnCameraMoveStartedListener$NullableType();
  static const type = $MapLibreMap$OnCameraMoveStartedListener$Type();

  /// from: `static public final int REASON_API_GESTURE`
  static const REASON_API_GESTURE = 1;

  /// from: `static public final int REASON_DEVELOPER_ANIMATION`
  static const REASON_DEVELOPER_ANIMATION = 2;

  /// from: `static public final int REASON_API_ANIMATION`
  static const REASON_API_ANIMATION = 3;
  static final _id_onCameraMoveStarted = _class.instanceMethodId(
    r'onCameraMoveStarted',
    r'(I)V',
  );

  static final _onCameraMoveStarted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void onCameraMoveStarted(int i)`
  void onCameraMoveStarted(int i) {
    _onCameraMoveStarted(
      reference.pointer,
      _id_onCameraMoveStarted as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnCameraMoveStartedListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMoveStarted(I)V') {
        _$impls[$p]!.onCameraMoveStarted(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnCameraMoveStartedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener',
      $p,
      _$invokePointer,
      [if ($impl.onCameraMoveStarted$async) r'onCameraMoveStarted(I)V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnCameraMoveStartedListener.implement(
    $MapLibreMap$OnCameraMoveStartedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnCameraMoveStartedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnCameraMoveStartedListener {
  factory $MapLibreMap$OnCameraMoveStartedListener({
    required void Function(int i) onCameraMoveStarted,
    bool onCameraMoveStarted$async,
  }) = _$MapLibreMap$OnCameraMoveStartedListener;

  void onCameraMoveStarted(int i);
  bool get onCameraMoveStarted$async => false;
}

final class _$MapLibreMap$OnCameraMoveStartedListener
    with $MapLibreMap$OnCameraMoveStartedListener {
  _$MapLibreMap$OnCameraMoveStartedListener({
    required void Function(int i) onCameraMoveStarted,
    this.onCameraMoveStarted$async = false,
  }) : _onCameraMoveStarted = onCameraMoveStarted;

  final void Function(int i) _onCameraMoveStarted;
  final bool onCameraMoveStarted$async;

  void onCameraMoveStarted(int i) {
    return _onCameraMoveStarted(i);
  }
}

final class $MapLibreMap$OnCameraMoveStartedListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnCameraMoveStartedListener?> {
  @jni$_.internal
  const $MapLibreMap$OnCameraMoveStartedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCameraMoveStartedListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnCameraMoveStartedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCameraMoveStartedListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnCameraMoveStartedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnCameraMoveStartedListener$NullableType) &&
        other is $MapLibreMap$OnCameraMoveStartedListener$NullableType;
  }
}

final class $MapLibreMap$OnCameraMoveStartedListener$Type
    extends jni$_.JObjType<MapLibreMap$OnCameraMoveStartedListener> {
  @jni$_.internal
  const $MapLibreMap$OnCameraMoveStartedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCameraMoveStartedListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnCameraMoveStartedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCameraMoveStartedListener?> get nullableType =>
      const $MapLibreMap$OnCameraMoveStartedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnCameraMoveStartedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnCameraMoveStartedListener$Type) &&
        other is $MapLibreMap$OnCameraMoveStartedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCompassAnimationListener`
class MapLibreMap$OnCompassAnimationListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnCompassAnimationListener> $type;

  @jni$_.internal
  MapLibreMap$OnCompassAnimationListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnCompassAnimationListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnCompassAnimationListener$NullableType();
  static const type = $MapLibreMap$OnCompassAnimationListener$Type();
  static final _id_onCompassAnimation = _class.instanceMethodId(
    r'onCompassAnimation',
    r'()V',
  );

  static final _onCompassAnimation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onCompassAnimation()`
  void onCompassAnimation() {
    _onCompassAnimation(
      reference.pointer,
      _id_onCompassAnimation as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_onCompassAnimationFinished = _class.instanceMethodId(
    r'onCompassAnimationFinished',
    r'()V',
  );

  static final _onCompassAnimationFinished =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onCompassAnimationFinished()`
  void onCompassAnimationFinished() {
    _onCompassAnimationFinished(
      reference.pointer,
      _id_onCompassAnimationFinished as jni$_.JMethodIDPtr,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnCompassAnimationListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCompassAnimation()V') {
        _$impls[$p]!.onCompassAnimation();
        return jni$_.nullptr;
      }
      if ($d == r'onCompassAnimationFinished()V') {
        _$impls[$p]!.onCompassAnimationFinished();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnCompassAnimationListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCompassAnimationListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCompassAnimation$async) r'onCompassAnimation()V',
        if ($impl.onCompassAnimationFinished$async)
          r'onCompassAnimationFinished()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnCompassAnimationListener.implement(
    $MapLibreMap$OnCompassAnimationListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnCompassAnimationListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnCompassAnimationListener {
  factory $MapLibreMap$OnCompassAnimationListener({
    required void Function() onCompassAnimation,
    bool onCompassAnimation$async,
    required void Function() onCompassAnimationFinished,
    bool onCompassAnimationFinished$async,
  }) = _$MapLibreMap$OnCompassAnimationListener;

  void onCompassAnimation();
  bool get onCompassAnimation$async => false;
  void onCompassAnimationFinished();
  bool get onCompassAnimationFinished$async => false;
}

final class _$MapLibreMap$OnCompassAnimationListener
    with $MapLibreMap$OnCompassAnimationListener {
  _$MapLibreMap$OnCompassAnimationListener({
    required void Function() onCompassAnimation,
    this.onCompassAnimation$async = false,
    required void Function() onCompassAnimationFinished,
    this.onCompassAnimationFinished$async = false,
  }) : _onCompassAnimation = onCompassAnimation,
       _onCompassAnimationFinished = onCompassAnimationFinished;

  final void Function() _onCompassAnimation;
  final bool onCompassAnimation$async;
  final void Function() _onCompassAnimationFinished;
  final bool onCompassAnimationFinished$async;

  void onCompassAnimation() {
    return _onCompassAnimation();
  }

  void onCompassAnimationFinished() {
    return _onCompassAnimationFinished();
  }
}

final class $MapLibreMap$OnCompassAnimationListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnCompassAnimationListener?> {
  @jni$_.internal
  const $MapLibreMap$OnCompassAnimationListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCompassAnimationListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCompassAnimationListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnCompassAnimationListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCompassAnimationListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnCompassAnimationListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnCompassAnimationListener$NullableType) &&
        other is $MapLibreMap$OnCompassAnimationListener$NullableType;
  }
}

final class $MapLibreMap$OnCompassAnimationListener$Type
    extends jni$_.JObjType<MapLibreMap$OnCompassAnimationListener> {
  @jni$_.internal
  const $MapLibreMap$OnCompassAnimationListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCompassAnimationListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnCompassAnimationListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnCompassAnimationListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnCompassAnimationListener?> get nullableType =>
      const $MapLibreMap$OnCompassAnimationListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnCompassAnimationListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnCompassAnimationListener$Type) &&
        other is $MapLibreMap$OnCompassAnimationListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnDeveloperAnimationListener`
class MapLibreMap$OnDeveloperAnimationListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnDeveloperAnimationListener> $type;

  @jni$_.internal
  MapLibreMap$OnDeveloperAnimationListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnDeveloperAnimationListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnDeveloperAnimationListener$NullableType();
  static const type = $MapLibreMap$OnDeveloperAnimationListener$Type();
  static final _id_onDeveloperAnimationStarted = _class.instanceMethodId(
    r'onDeveloperAnimationStarted',
    r'()V',
  );

  static final _onDeveloperAnimationStarted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onDeveloperAnimationStarted()`
  void onDeveloperAnimationStarted() {
    _onDeveloperAnimationStarted(
      reference.pointer,
      _id_onDeveloperAnimationStarted as jni$_.JMethodIDPtr,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnDeveloperAnimationListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDeveloperAnimationStarted()V') {
        _$impls[$p]!.onDeveloperAnimationStarted();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnDeveloperAnimationListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnDeveloperAnimationListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onDeveloperAnimationStarted$async)
          r'onDeveloperAnimationStarted()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnDeveloperAnimationListener.implement(
    $MapLibreMap$OnDeveloperAnimationListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnDeveloperAnimationListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnDeveloperAnimationListener {
  factory $MapLibreMap$OnDeveloperAnimationListener({
    required void Function() onDeveloperAnimationStarted,
    bool onDeveloperAnimationStarted$async,
  }) = _$MapLibreMap$OnDeveloperAnimationListener;

  void onDeveloperAnimationStarted();
  bool get onDeveloperAnimationStarted$async => false;
}

final class _$MapLibreMap$OnDeveloperAnimationListener
    with $MapLibreMap$OnDeveloperAnimationListener {
  _$MapLibreMap$OnDeveloperAnimationListener({
    required void Function() onDeveloperAnimationStarted,
    this.onDeveloperAnimationStarted$async = false,
  }) : _onDeveloperAnimationStarted = onDeveloperAnimationStarted;

  final void Function() _onDeveloperAnimationStarted;
  final bool onDeveloperAnimationStarted$async;

  void onDeveloperAnimationStarted() {
    return _onDeveloperAnimationStarted();
  }
}

final class $MapLibreMap$OnDeveloperAnimationListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnDeveloperAnimationListener?> {
  @jni$_.internal
  const $MapLibreMap$OnDeveloperAnimationListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnDeveloperAnimationListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnDeveloperAnimationListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnDeveloperAnimationListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnDeveloperAnimationListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnDeveloperAnimationListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnDeveloperAnimationListener$NullableType) &&
        other is $MapLibreMap$OnDeveloperAnimationListener$NullableType;
  }
}

final class $MapLibreMap$OnDeveloperAnimationListener$Type
    extends jni$_.JObjType<MapLibreMap$OnDeveloperAnimationListener> {
  @jni$_.internal
  const $MapLibreMap$OnDeveloperAnimationListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnDeveloperAnimationListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnDeveloperAnimationListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnDeveloperAnimationListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnDeveloperAnimationListener?> get nullableType =>
      const $MapLibreMap$OnDeveloperAnimationListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnDeveloperAnimationListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnDeveloperAnimationListener$Type) &&
        other is $MapLibreMap$OnDeveloperAnimationListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnFlingListener`
class MapLibreMap$OnFlingListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnFlingListener> $type;

  @jni$_.internal
  MapLibreMap$OnFlingListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnFlingListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnFlingListener$NullableType();
  static const type = $MapLibreMap$OnFlingListener$Type();
  static final _id_onFling = _class.instanceMethodId(r'onFling', r'()V');

  static final _onFling =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onFling()`
  void onFling() {
    _onFling(reference.pointer, _id_onFling as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnFlingListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFling()V') {
        _$impls[$p]!.onFling();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnFlingListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnFlingListener',
      $p,
      _$invokePointer,
      [if ($impl.onFling$async) r'onFling()V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnFlingListener.implement(
    $MapLibreMap$OnFlingListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnFlingListener.fromReference($i.implementReference());
  }
}

abstract base mixin class $MapLibreMap$OnFlingListener {
  factory $MapLibreMap$OnFlingListener({
    required void Function() onFling,
    bool onFling$async,
  }) = _$MapLibreMap$OnFlingListener;

  void onFling();
  bool get onFling$async => false;
}

final class _$MapLibreMap$OnFlingListener with $MapLibreMap$OnFlingListener {
  _$MapLibreMap$OnFlingListener({
    required void Function() onFling,
    this.onFling$async = false,
  }) : _onFling = onFling;

  final void Function() _onFling;
  final bool onFling$async;

  void onFling() {
    return _onFling();
  }
}

final class $MapLibreMap$OnFlingListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnFlingListener?> {
  @jni$_.internal
  const $MapLibreMap$OnFlingListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnFlingListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnFlingListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnFlingListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnFlingListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnFlingListener$NullableType) &&
        other is $MapLibreMap$OnFlingListener$NullableType;
  }
}

final class $MapLibreMap$OnFlingListener$Type
    extends jni$_.JObjType<MapLibreMap$OnFlingListener> {
  @jni$_.internal
  const $MapLibreMap$OnFlingListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnFlingListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnFlingListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnFlingListener?> get nullableType =>
      const $MapLibreMap$OnFlingListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnFlingListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnFlingListener$Type) &&
        other is $MapLibreMap$OnFlingListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener`
class MapLibreMap$OnFpsChangedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnFpsChangedListener> $type;

  @jni$_.internal
  MapLibreMap$OnFpsChangedListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnFpsChangedListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnFpsChangedListener$NullableType();
  static const type = $MapLibreMap$OnFpsChangedListener$Type();
  static final _id_onFpsChanged = _class.instanceMethodId(
    r'onFpsChanged',
    r'(D)V',
  );

  static final _onFpsChanged =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void onFpsChanged(double d)`
  void onFpsChanged(double d) {
    _onFpsChanged(
      reference.pointer,
      _id_onFpsChanged as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnFpsChangedListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFpsChanged(D)V') {
        _$impls[$p]!.onFpsChanged(
          $a![0]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnFpsChangedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener',
      $p,
      _$invokePointer,
      [if ($impl.onFpsChanged$async) r'onFpsChanged(D)V'],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnFpsChangedListener.implement(
    $MapLibreMap$OnFpsChangedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnFpsChangedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnFpsChangedListener {
  factory $MapLibreMap$OnFpsChangedListener({
    required void Function(double d) onFpsChanged,
    bool onFpsChanged$async,
  }) = _$MapLibreMap$OnFpsChangedListener;

  void onFpsChanged(double d);
  bool get onFpsChanged$async => false;
}

final class _$MapLibreMap$OnFpsChangedListener
    with $MapLibreMap$OnFpsChangedListener {
  _$MapLibreMap$OnFpsChangedListener({
    required void Function(double d) onFpsChanged,
    this.onFpsChanged$async = false,
  }) : _onFpsChanged = onFpsChanged;

  final void Function(double d) _onFpsChanged;
  final bool onFpsChanged$async;

  void onFpsChanged(double d) {
    return _onFpsChanged(d);
  }
}

final class $MapLibreMap$OnFpsChangedListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnFpsChangedListener?> {
  @jni$_.internal
  const $MapLibreMap$OnFpsChangedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnFpsChangedListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnFpsChangedListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnFpsChangedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnFpsChangedListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnFpsChangedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnFpsChangedListener$NullableType) &&
        other is $MapLibreMap$OnFpsChangedListener$NullableType;
  }
}

final class $MapLibreMap$OnFpsChangedListener$Type
    extends jni$_.JObjType<MapLibreMap$OnFpsChangedListener> {
  @jni$_.internal
  const $MapLibreMap$OnFpsChangedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnFpsChangedListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnFpsChangedListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnFpsChangedListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnFpsChangedListener?> get nullableType =>
      const $MapLibreMap$OnFpsChangedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnFpsChangedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnFpsChangedListener$Type) &&
        other is $MapLibreMap$OnFpsChangedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener`
class MapLibreMap$OnInfoWindowClickListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnInfoWindowClickListener> $type;

  @jni$_.internal
  MapLibreMap$OnInfoWindowClickListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnInfoWindowClickListener$NullableType();
  static const type = $MapLibreMap$OnInfoWindowClickListener$Type();
  static final _id_onInfoWindowClick = _class.instanceMethodId(
    r'onInfoWindowClick',
    r'(Lorg/maplibre/android/annotations/Marker;)Z',
  );

  static final _onInfoWindowClick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean onInfoWindowClick(org.maplibre.android.annotations.Marker marker)`
  bool onInfoWindowClick(jni$_.JObject marker) {
    final _$marker = marker.reference;
    return _onInfoWindowClick(
      reference.pointer,
      _id_onInfoWindowClick as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnInfoWindowClickListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowClick(Lorg/maplibre/android/annotations/Marker;)Z') {
        final $r = _$impls[$p]!.onInfoWindowClick(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnInfoWindowClickListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnInfoWindowClickListener.implement(
    $MapLibreMap$OnInfoWindowClickListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnInfoWindowClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnInfoWindowClickListener {
  factory $MapLibreMap$OnInfoWindowClickListener({
    required bool Function(jni$_.JObject marker) onInfoWindowClick,
  }) = _$MapLibreMap$OnInfoWindowClickListener;

  bool onInfoWindowClick(jni$_.JObject marker);
}

final class _$MapLibreMap$OnInfoWindowClickListener
    with $MapLibreMap$OnInfoWindowClickListener {
  _$MapLibreMap$OnInfoWindowClickListener({
    required bool Function(jni$_.JObject marker) onInfoWindowClick,
  }) : _onInfoWindowClick = onInfoWindowClick;

  final bool Function(jni$_.JObject marker) _onInfoWindowClick;

  bool onInfoWindowClick(jni$_.JObject marker) {
    return _onInfoWindowClick(marker);
  }
}

final class $MapLibreMap$OnInfoWindowClickListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnInfoWindowClickListener?> {
  @jni$_.internal
  const $MapLibreMap$OnInfoWindowClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnInfoWindowClickListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnInfoWindowClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnInfoWindowClickListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnInfoWindowClickListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnInfoWindowClickListener$NullableType) &&
        other is $MapLibreMap$OnInfoWindowClickListener$NullableType;
  }
}

final class $MapLibreMap$OnInfoWindowClickListener$Type
    extends jni$_.JObjType<MapLibreMap$OnInfoWindowClickListener> {
  @jni$_.internal
  const $MapLibreMap$OnInfoWindowClickListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnInfoWindowClickListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnInfoWindowClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnInfoWindowClickListener?> get nullableType =>
      const $MapLibreMap$OnInfoWindowClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnInfoWindowClickListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnInfoWindowClickListener$Type) &&
        other is $MapLibreMap$OnInfoWindowClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener`
class MapLibreMap$OnInfoWindowCloseListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnInfoWindowCloseListener> $type;

  @jni$_.internal
  MapLibreMap$OnInfoWindowCloseListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnInfoWindowCloseListener$NullableType();
  static const type = $MapLibreMap$OnInfoWindowCloseListener$Type();
  static final _id_onInfoWindowClose = _class.instanceMethodId(
    r'onInfoWindowClose',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _onInfoWindowClose =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onInfoWindowClose(org.maplibre.android.annotations.Marker marker)`
  void onInfoWindowClose(jni$_.JObject marker) {
    final _$marker = marker.reference;
    _onInfoWindowClose(
      reference.pointer,
      _id_onInfoWindowClose as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnInfoWindowCloseListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowClose(Lorg/maplibre/android/annotations/Marker;)V') {
        _$impls[$p]!.onInfoWindowClose(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnInfoWindowCloseListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onInfoWindowClose$async)
          r'onInfoWindowClose(Lorg/maplibre/android/annotations/Marker;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnInfoWindowCloseListener.implement(
    $MapLibreMap$OnInfoWindowCloseListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnInfoWindowCloseListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnInfoWindowCloseListener {
  factory $MapLibreMap$OnInfoWindowCloseListener({
    required void Function(jni$_.JObject marker) onInfoWindowClose,
    bool onInfoWindowClose$async,
  }) = _$MapLibreMap$OnInfoWindowCloseListener;

  void onInfoWindowClose(jni$_.JObject marker);
  bool get onInfoWindowClose$async => false;
}

final class _$MapLibreMap$OnInfoWindowCloseListener
    with $MapLibreMap$OnInfoWindowCloseListener {
  _$MapLibreMap$OnInfoWindowCloseListener({
    required void Function(jni$_.JObject marker) onInfoWindowClose,
    this.onInfoWindowClose$async = false,
  }) : _onInfoWindowClose = onInfoWindowClose;

  final void Function(jni$_.JObject marker) _onInfoWindowClose;
  final bool onInfoWindowClose$async;

  void onInfoWindowClose(jni$_.JObject marker) {
    return _onInfoWindowClose(marker);
  }
}

final class $MapLibreMap$OnInfoWindowCloseListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnInfoWindowCloseListener?> {
  @jni$_.internal
  const $MapLibreMap$OnInfoWindowCloseListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnInfoWindowCloseListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnInfoWindowCloseListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnInfoWindowCloseListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnInfoWindowCloseListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnInfoWindowCloseListener$NullableType) &&
        other is $MapLibreMap$OnInfoWindowCloseListener$NullableType;
  }
}

final class $MapLibreMap$OnInfoWindowCloseListener$Type
    extends jni$_.JObjType<MapLibreMap$OnInfoWindowCloseListener> {
  @jni$_.internal
  const $MapLibreMap$OnInfoWindowCloseListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnInfoWindowCloseListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnInfoWindowCloseListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnInfoWindowCloseListener?> get nullableType =>
      const $MapLibreMap$OnInfoWindowCloseListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnInfoWindowCloseListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnInfoWindowCloseListener$Type) &&
        other is $MapLibreMap$OnInfoWindowCloseListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener`
class MapLibreMap$OnInfoWindowLongClickListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnInfoWindowLongClickListener> $type;

  @jni$_.internal
  MapLibreMap$OnInfoWindowLongClickListener.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnInfoWindowLongClickListener$NullableType();
  static const type = $MapLibreMap$OnInfoWindowLongClickListener$Type();
  static final _id_onInfoWindowLongClick = _class.instanceMethodId(
    r'onInfoWindowLongClick',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _onInfoWindowLongClick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onInfoWindowLongClick(org.maplibre.android.annotations.Marker marker)`
  void onInfoWindowLongClick(jni$_.JObject marker) {
    final _$marker = marker.reference;
    _onInfoWindowLongClick(
      reference.pointer,
      _id_onInfoWindowLongClick as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnInfoWindowLongClickListener>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowLongClick(Lorg/maplibre/android/annotations/Marker;)V') {
        _$impls[$p]!.onInfoWindowLongClick(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnInfoWindowLongClickListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onInfoWindowLongClick$async)
          r'onInfoWindowLongClick(Lorg/maplibre/android/annotations/Marker;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnInfoWindowLongClickListener.implement(
    $MapLibreMap$OnInfoWindowLongClickListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnInfoWindowLongClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnInfoWindowLongClickListener {
  factory $MapLibreMap$OnInfoWindowLongClickListener({
    required void Function(jni$_.JObject marker) onInfoWindowLongClick,
    bool onInfoWindowLongClick$async,
  }) = _$MapLibreMap$OnInfoWindowLongClickListener;

  void onInfoWindowLongClick(jni$_.JObject marker);
  bool get onInfoWindowLongClick$async => false;
}

final class _$MapLibreMap$OnInfoWindowLongClickListener
    with $MapLibreMap$OnInfoWindowLongClickListener {
  _$MapLibreMap$OnInfoWindowLongClickListener({
    required void Function(jni$_.JObject marker) onInfoWindowLongClick,
    this.onInfoWindowLongClick$async = false,
  }) : _onInfoWindowLongClick = onInfoWindowLongClick;

  final void Function(jni$_.JObject marker) _onInfoWindowLongClick;
  final bool onInfoWindowLongClick$async;

  void onInfoWindowLongClick(jni$_.JObject marker) {
    return _onInfoWindowLongClick(marker);
  }
}

final class $MapLibreMap$OnInfoWindowLongClickListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnInfoWindowLongClickListener?> {
  @jni$_.internal
  const $MapLibreMap$OnInfoWindowLongClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnInfoWindowLongClickListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnInfoWindowLongClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnInfoWindowLongClickListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnInfoWindowLongClickListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnInfoWindowLongClickListener$NullableType) &&
        other is $MapLibreMap$OnInfoWindowLongClickListener$NullableType;
  }
}

final class $MapLibreMap$OnInfoWindowLongClickListener$Type
    extends jni$_.JObjType<MapLibreMap$OnInfoWindowLongClickListener> {
  @jni$_.internal
  const $MapLibreMap$OnInfoWindowLongClickListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnInfoWindowLongClickListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnInfoWindowLongClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnInfoWindowLongClickListener?> get nullableType =>
      const $MapLibreMap$OnInfoWindowLongClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnInfoWindowLongClickListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnInfoWindowLongClickListener$Type) &&
        other is $MapLibreMap$OnInfoWindowLongClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMapClickListener`
class MapLibreMap$OnMapClickListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnMapClickListener> $type;

  @jni$_.internal
  MapLibreMap$OnMapClickListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnMapClickListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnMapClickListener$NullableType();
  static const type = $MapLibreMap$OnMapClickListener$Type();
  static final _id_onMapClick = _class.instanceMethodId(
    r'onMapClick',
    r'(Lorg/maplibre/android/geometry/LatLng;)Z',
  );

  static final _onMapClick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean onMapClick(org.maplibre.android.geometry.LatLng latLng)`
  bool onMapClick(latlng$_.LatLng latLng) {
    final _$latLng = latLng.reference;
    return _onMapClick(
      reference.pointer,
      _id_onMapClick as jni$_.JMethodIDPtr,
      _$latLng.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnMapClickListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMapClick(Lorg/maplibre/android/geometry/LatLng;)Z') {
        final $r = _$impls[$p]!.onMapClick(
          $a![0]!.as(const latlng$_.$LatLng$Type(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnMapClickListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnMapClickListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnMapClickListener.implement(
    $MapLibreMap$OnMapClickListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnMapClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnMapClickListener {
  factory $MapLibreMap$OnMapClickListener({
    required bool Function(latlng$_.LatLng latLng) onMapClick,
  }) = _$MapLibreMap$OnMapClickListener;

  bool onMapClick(latlng$_.LatLng latLng);
}

final class _$MapLibreMap$OnMapClickListener
    with $MapLibreMap$OnMapClickListener {
  _$MapLibreMap$OnMapClickListener({
    required bool Function(latlng$_.LatLng latLng) onMapClick,
  }) : _onMapClick = onMapClick;

  final bool Function(latlng$_.LatLng latLng) _onMapClick;

  bool onMapClick(latlng$_.LatLng latLng) {
    return _onMapClick(latLng);
  }
}

final class $MapLibreMap$OnMapClickListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnMapClickListener?> {
  @jni$_.internal
  const $MapLibreMap$OnMapClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnMapClickListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnMapClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnMapClickListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnMapClickListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnMapClickListener$NullableType) &&
        other is $MapLibreMap$OnMapClickListener$NullableType;
  }
}

final class $MapLibreMap$OnMapClickListener$Type
    extends jni$_.JObjType<MapLibreMap$OnMapClickListener> {
  @jni$_.internal
  const $MapLibreMap$OnMapClickListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnMapClickListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnMapClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnMapClickListener?> get nullableType =>
      const $MapLibreMap$OnMapClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnMapClickListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnMapClickListener$Type) &&
        other is $MapLibreMap$OnMapClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener`
class MapLibreMap$OnMapLongClickListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnMapLongClickListener> $type;

  @jni$_.internal
  MapLibreMap$OnMapLongClickListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnMapLongClickListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnMapLongClickListener$NullableType();
  static const type = $MapLibreMap$OnMapLongClickListener$Type();
  static final _id_onMapLongClick = _class.instanceMethodId(
    r'onMapLongClick',
    r'(Lorg/maplibre/android/geometry/LatLng;)Z',
  );

  static final _onMapLongClick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean onMapLongClick(org.maplibre.android.geometry.LatLng latLng)`
  bool onMapLongClick(latlng$_.LatLng latLng) {
    final _$latLng = latLng.reference;
    return _onMapLongClick(
      reference.pointer,
      _id_onMapLongClick as jni$_.JMethodIDPtr,
      _$latLng.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnMapLongClickListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMapLongClick(Lorg/maplibre/android/geometry/LatLng;)Z') {
        final $r = _$impls[$p]!.onMapLongClick(
          $a![0]!.as(const latlng$_.$LatLng$Type(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnMapLongClickListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnMapLongClickListener.implement(
    $MapLibreMap$OnMapLongClickListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnMapLongClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnMapLongClickListener {
  factory $MapLibreMap$OnMapLongClickListener({
    required bool Function(latlng$_.LatLng latLng) onMapLongClick,
  }) = _$MapLibreMap$OnMapLongClickListener;

  bool onMapLongClick(latlng$_.LatLng latLng);
}

final class _$MapLibreMap$OnMapLongClickListener
    with $MapLibreMap$OnMapLongClickListener {
  _$MapLibreMap$OnMapLongClickListener({
    required bool Function(latlng$_.LatLng latLng) onMapLongClick,
  }) : _onMapLongClick = onMapLongClick;

  final bool Function(latlng$_.LatLng latLng) _onMapLongClick;

  bool onMapLongClick(latlng$_.LatLng latLng) {
    return _onMapLongClick(latLng);
  }
}

final class $MapLibreMap$OnMapLongClickListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnMapLongClickListener?> {
  @jni$_.internal
  const $MapLibreMap$OnMapLongClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnMapLongClickListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnMapLongClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnMapLongClickListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnMapLongClickListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnMapLongClickListener$NullableType) &&
        other is $MapLibreMap$OnMapLongClickListener$NullableType;
  }
}

final class $MapLibreMap$OnMapLongClickListener$Type
    extends jni$_.JObjType<MapLibreMap$OnMapLongClickListener> {
  @jni$_.internal
  const $MapLibreMap$OnMapLongClickListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnMapLongClickListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnMapLongClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnMapLongClickListener?> get nullableType =>
      const $MapLibreMap$OnMapLongClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnMapLongClickListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnMapLongClickListener$Type) &&
        other is $MapLibreMap$OnMapLongClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener`
class MapLibreMap$OnMarkerClickListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnMarkerClickListener> $type;

  @jni$_.internal
  MapLibreMap$OnMarkerClickListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnMarkerClickListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnMarkerClickListener$NullableType();
  static const type = $MapLibreMap$OnMarkerClickListener$Type();
  static final _id_onMarkerClick = _class.instanceMethodId(
    r'onMarkerClick',
    r'(Lorg/maplibre/android/annotations/Marker;)Z',
  );

  static final _onMarkerClick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean onMarkerClick(org.maplibre.android.annotations.Marker marker)`
  bool onMarkerClick(jni$_.JObject marker) {
    final _$marker = marker.reference;
    return _onMarkerClick(
      reference.pointer,
      _id_onMarkerClick as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnMarkerClickListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMarkerClick(Lorg/maplibre/android/annotations/Marker;)Z') {
        final $r = _$impls[$p]!.onMarkerClick(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnMarkerClickListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnMarkerClickListener.implement(
    $MapLibreMap$OnMarkerClickListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnMarkerClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnMarkerClickListener {
  factory $MapLibreMap$OnMarkerClickListener({
    required bool Function(jni$_.JObject marker) onMarkerClick,
  }) = _$MapLibreMap$OnMarkerClickListener;

  bool onMarkerClick(jni$_.JObject marker);
}

final class _$MapLibreMap$OnMarkerClickListener
    with $MapLibreMap$OnMarkerClickListener {
  _$MapLibreMap$OnMarkerClickListener({
    required bool Function(jni$_.JObject marker) onMarkerClick,
  }) : _onMarkerClick = onMarkerClick;

  final bool Function(jni$_.JObject marker) _onMarkerClick;

  bool onMarkerClick(jni$_.JObject marker) {
    return _onMarkerClick(marker);
  }
}

final class $MapLibreMap$OnMarkerClickListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnMarkerClickListener?> {
  @jni$_.internal
  const $MapLibreMap$OnMarkerClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMarkerClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnMarkerClickListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnMarkerClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnMarkerClickListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnMarkerClickListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnMarkerClickListener$NullableType) &&
        other is $MapLibreMap$OnMarkerClickListener$NullableType;
  }
}

final class $MapLibreMap$OnMarkerClickListener$Type
    extends jni$_.JObjType<MapLibreMap$OnMarkerClickListener> {
  @jni$_.internal
  const $MapLibreMap$OnMarkerClickListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMarkerClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnMarkerClickListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnMarkerClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnMarkerClickListener?> get nullableType =>
      const $MapLibreMap$OnMarkerClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnMarkerClickListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnMarkerClickListener$Type) &&
        other is $MapLibreMap$OnMarkerClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMoveListener`
class MapLibreMap$OnMoveListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnMoveListener> $type;

  @jni$_.internal
  MapLibreMap$OnMoveListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnMoveListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnMoveListener$NullableType();
  static const type = $MapLibreMap$OnMoveListener$Type();
  static final _id_onMoveBegin = _class.instanceMethodId(
    r'onMoveBegin',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMoveBegin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onMoveBegin(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMoveBegin(jni$_.JObject moveGestureDetector) {
    final _$moveGestureDetector = moveGestureDetector.reference;
    _onMoveBegin(
      reference.pointer,
      _id_onMoveBegin as jni$_.JMethodIDPtr,
      _$moveGestureDetector.pointer,
    ).check();
  }

  static final _id_onMove = _class.instanceMethodId(
    r'onMove',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onMove(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMove(jni$_.JObject moveGestureDetector) {
    final _$moveGestureDetector = moveGestureDetector.reference;
    _onMove(
      reference.pointer,
      _id_onMove as jni$_.JMethodIDPtr,
      _$moveGestureDetector.pointer,
    ).check();
  }

  static final _id_onMoveEnd = _class.instanceMethodId(
    r'onMoveEnd',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMoveEnd =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onMoveEnd(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMoveEnd(jni$_.JObject moveGestureDetector) {
    final _$moveGestureDetector = moveGestureDetector.reference;
    _onMoveEnd(
      reference.pointer,
      _id_onMoveEnd as jni$_.JMethodIDPtr,
      _$moveGestureDetector.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnMoveListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onMoveBegin(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMoveBegin(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onMove(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMove(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onMoveEnd(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMoveEnd(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnMoveListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnMoveListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onMoveBegin$async)
          r'onMoveBegin(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
        if ($impl.onMove$async)
          r'onMove(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
        if ($impl.onMoveEnd$async)
          r'onMoveEnd(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnMoveListener.implement(
    $MapLibreMap$OnMoveListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnMoveListener.fromReference($i.implementReference());
  }
}

abstract base mixin class $MapLibreMap$OnMoveListener {
  factory $MapLibreMap$OnMoveListener({
    required void Function(jni$_.JObject moveGestureDetector) onMoveBegin,
    bool onMoveBegin$async,
    required void Function(jni$_.JObject moveGestureDetector) onMove,
    bool onMove$async,
    required void Function(jni$_.JObject moveGestureDetector) onMoveEnd,
    bool onMoveEnd$async,
  }) = _$MapLibreMap$OnMoveListener;

  void onMoveBegin(jni$_.JObject moveGestureDetector);
  bool get onMoveBegin$async => false;
  void onMove(jni$_.JObject moveGestureDetector);
  bool get onMove$async => false;
  void onMoveEnd(jni$_.JObject moveGestureDetector);
  bool get onMoveEnd$async => false;
}

final class _$MapLibreMap$OnMoveListener with $MapLibreMap$OnMoveListener {
  _$MapLibreMap$OnMoveListener({
    required void Function(jni$_.JObject moveGestureDetector) onMoveBegin,
    this.onMoveBegin$async = false,
    required void Function(jni$_.JObject moveGestureDetector) onMove,
    this.onMove$async = false,
    required void Function(jni$_.JObject moveGestureDetector) onMoveEnd,
    this.onMoveEnd$async = false,
  }) : _onMoveBegin = onMoveBegin,
       _onMove = onMove,
       _onMoveEnd = onMoveEnd;

  final void Function(jni$_.JObject moveGestureDetector) _onMoveBegin;
  final bool onMoveBegin$async;
  final void Function(jni$_.JObject moveGestureDetector) _onMove;
  final bool onMove$async;
  final void Function(jni$_.JObject moveGestureDetector) _onMoveEnd;
  final bool onMoveEnd$async;

  void onMoveBegin(jni$_.JObject moveGestureDetector) {
    return _onMoveBegin(moveGestureDetector);
  }

  void onMove(jni$_.JObject moveGestureDetector) {
    return _onMove(moveGestureDetector);
  }

  void onMoveEnd(jni$_.JObject moveGestureDetector) {
    return _onMoveEnd(moveGestureDetector);
  }
}

final class $MapLibreMap$OnMoveListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnMoveListener?> {
  @jni$_.internal
  const $MapLibreMap$OnMoveListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnMoveListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnMoveListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnMoveListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnMoveListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnMoveListener$NullableType) &&
        other is $MapLibreMap$OnMoveListener$NullableType;
  }
}

final class $MapLibreMap$OnMoveListener$Type
    extends jni$_.JObjType<MapLibreMap$OnMoveListener> {
  @jni$_.internal
  const $MapLibreMap$OnMoveListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnMoveListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnMoveListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnMoveListener?> get nullableType =>
      const $MapLibreMap$OnMoveListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnMoveListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnMoveListener$Type) &&
        other is $MapLibreMap$OnMoveListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener`
class MapLibreMap$OnPolygonClickListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnPolygonClickListener> $type;

  @jni$_.internal
  MapLibreMap$OnPolygonClickListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnPolygonClickListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnPolygonClickListener$NullableType();
  static const type = $MapLibreMap$OnPolygonClickListener$Type();
  static final _id_onPolygonClick = _class.instanceMethodId(
    r'onPolygonClick',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _onPolygonClick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onPolygonClick(org.maplibre.android.annotations.Polygon polygon)`
  void onPolygonClick(jni$_.JObject polygon) {
    final _$polygon = polygon.reference;
    _onPolygonClick(
      reference.pointer,
      _id_onPolygonClick as jni$_.JMethodIDPtr,
      _$polygon.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnPolygonClickListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onPolygonClick(Lorg/maplibre/android/annotations/Polygon;)V') {
        _$impls[$p]!.onPolygonClick(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnPolygonClickListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onPolygonClick$async)
          r'onPolygonClick(Lorg/maplibre/android/annotations/Polygon;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnPolygonClickListener.implement(
    $MapLibreMap$OnPolygonClickListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnPolygonClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnPolygonClickListener {
  factory $MapLibreMap$OnPolygonClickListener({
    required void Function(jni$_.JObject polygon) onPolygonClick,
    bool onPolygonClick$async,
  }) = _$MapLibreMap$OnPolygonClickListener;

  void onPolygonClick(jni$_.JObject polygon);
  bool get onPolygonClick$async => false;
}

final class _$MapLibreMap$OnPolygonClickListener
    with $MapLibreMap$OnPolygonClickListener {
  _$MapLibreMap$OnPolygonClickListener({
    required void Function(jni$_.JObject polygon) onPolygonClick,
    this.onPolygonClick$async = false,
  }) : _onPolygonClick = onPolygonClick;

  final void Function(jni$_.JObject polygon) _onPolygonClick;
  final bool onPolygonClick$async;

  void onPolygonClick(jni$_.JObject polygon) {
    return _onPolygonClick(polygon);
  }
}

final class $MapLibreMap$OnPolygonClickListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnPolygonClickListener?> {
  @jni$_.internal
  const $MapLibreMap$OnPolygonClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnPolygonClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnPolygonClickListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnPolygonClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnPolygonClickListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnPolygonClickListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnPolygonClickListener$NullableType) &&
        other is $MapLibreMap$OnPolygonClickListener$NullableType;
  }
}

final class $MapLibreMap$OnPolygonClickListener$Type
    extends jni$_.JObjType<MapLibreMap$OnPolygonClickListener> {
  @jni$_.internal
  const $MapLibreMap$OnPolygonClickListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnPolygonClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnPolygonClickListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnPolygonClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnPolygonClickListener?> get nullableType =>
      const $MapLibreMap$OnPolygonClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnPolygonClickListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnPolygonClickListener$Type) &&
        other is $MapLibreMap$OnPolygonClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener`
class MapLibreMap$OnPolylineClickListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnPolylineClickListener> $type;

  @jni$_.internal
  MapLibreMap$OnPolylineClickListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnPolylineClickListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapLibreMap$OnPolylineClickListener$NullableType();
  static const type = $MapLibreMap$OnPolylineClickListener$Type();
  static final _id_onPolylineClick = _class.instanceMethodId(
    r'onPolylineClick',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _onPolylineClick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onPolylineClick(org.maplibre.android.annotations.Polyline polyline)`
  void onPolylineClick(jni$_.JObject polyline) {
    final _$polyline = polyline.reference;
    _onPolylineClick(
      reference.pointer,
      _id_onPolylineClick as jni$_.JMethodIDPtr,
      _$polyline.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnPolylineClickListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onPolylineClick(Lorg/maplibre/android/annotations/Polyline;)V') {
        _$impls[$p]!.onPolylineClick(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnPolylineClickListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onPolylineClick$async)
          r'onPolylineClick(Lorg/maplibre/android/annotations/Polyline;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnPolylineClickListener.implement(
    $MapLibreMap$OnPolylineClickListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnPolylineClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$OnPolylineClickListener {
  factory $MapLibreMap$OnPolylineClickListener({
    required void Function(jni$_.JObject polyline) onPolylineClick,
    bool onPolylineClick$async,
  }) = _$MapLibreMap$OnPolylineClickListener;

  void onPolylineClick(jni$_.JObject polyline);
  bool get onPolylineClick$async => false;
}

final class _$MapLibreMap$OnPolylineClickListener
    with $MapLibreMap$OnPolylineClickListener {
  _$MapLibreMap$OnPolylineClickListener({
    required void Function(jni$_.JObject polyline) onPolylineClick,
    this.onPolylineClick$async = false,
  }) : _onPolylineClick = onPolylineClick;

  final void Function(jni$_.JObject polyline) _onPolylineClick;
  final bool onPolylineClick$async;

  void onPolylineClick(jni$_.JObject polyline) {
    return _onPolylineClick(polyline);
  }
}

final class $MapLibreMap$OnPolylineClickListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnPolylineClickListener?> {
  @jni$_.internal
  const $MapLibreMap$OnPolylineClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnPolylineClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnPolylineClickListener? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$OnPolylineClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnPolylineClickListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$OnPolylineClickListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$OnPolylineClickListener$NullableType) &&
        other is $MapLibreMap$OnPolylineClickListener$NullableType;
  }
}

final class $MapLibreMap$OnPolylineClickListener$Type
    extends jni$_.JObjType<MapLibreMap$OnPolylineClickListener> {
  @jni$_.internal
  const $MapLibreMap$OnPolylineClickListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnPolylineClickListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnPolylineClickListener fromReference(
    jni$_.JReference reference,
  ) => MapLibreMap$OnPolylineClickListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnPolylineClickListener?> get nullableType =>
      const $MapLibreMap$OnPolylineClickListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnPolylineClickListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnPolylineClickListener$Type) &&
        other is $MapLibreMap$OnPolylineClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnRotateListener`
class MapLibreMap$OnRotateListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnRotateListener> $type;

  @jni$_.internal
  MapLibreMap$OnRotateListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnRotateListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnRotateListener$NullableType();
  static const type = $MapLibreMap$OnRotateListener$Type();
  static final _id_onRotateBegin = _class.instanceMethodId(
    r'onRotateBegin',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotateBegin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onRotateBegin(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotateBegin(jni$_.JObject rotateGestureDetector) {
    final _$rotateGestureDetector = rotateGestureDetector.reference;
    _onRotateBegin(
      reference.pointer,
      _id_onRotateBegin as jni$_.JMethodIDPtr,
      _$rotateGestureDetector.pointer,
    ).check();
  }

  static final _id_onRotate = _class.instanceMethodId(
    r'onRotate',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onRotate(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotate(jni$_.JObject rotateGestureDetector) {
    final _$rotateGestureDetector = rotateGestureDetector.reference;
    _onRotate(
      reference.pointer,
      _id_onRotate as jni$_.JMethodIDPtr,
      _$rotateGestureDetector.pointer,
    ).check();
  }

  static final _id_onRotateEnd = _class.instanceMethodId(
    r'onRotateEnd',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotateEnd =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onRotateEnd(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotateEnd(jni$_.JObject rotateGestureDetector) {
    final _$rotateGestureDetector = rotateGestureDetector.reference;
    _onRotateEnd(
      reference.pointer,
      _id_onRotateEnd as jni$_.JMethodIDPtr,
      _$rotateGestureDetector.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnRotateListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onRotateBegin(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotateBegin(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onRotate(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotate(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onRotateEnd(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotateEnd(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnRotateListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnRotateListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onRotateBegin$async)
          r'onRotateBegin(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
        if ($impl.onRotate$async)
          r'onRotate(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
        if ($impl.onRotateEnd$async)
          r'onRotateEnd(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnRotateListener.implement(
    $MapLibreMap$OnRotateListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnRotateListener.fromReference($i.implementReference());
  }
}

abstract base mixin class $MapLibreMap$OnRotateListener {
  factory $MapLibreMap$OnRotateListener({
    required void Function(jni$_.JObject rotateGestureDetector) onRotateBegin,
    bool onRotateBegin$async,
    required void Function(jni$_.JObject rotateGestureDetector) onRotate,
    bool onRotate$async,
    required void Function(jni$_.JObject rotateGestureDetector) onRotateEnd,
    bool onRotateEnd$async,
  }) = _$MapLibreMap$OnRotateListener;

  void onRotateBegin(jni$_.JObject rotateGestureDetector);
  bool get onRotateBegin$async => false;
  void onRotate(jni$_.JObject rotateGestureDetector);
  bool get onRotate$async => false;
  void onRotateEnd(jni$_.JObject rotateGestureDetector);
  bool get onRotateEnd$async => false;
}

final class _$MapLibreMap$OnRotateListener with $MapLibreMap$OnRotateListener {
  _$MapLibreMap$OnRotateListener({
    required void Function(jni$_.JObject rotateGestureDetector) onRotateBegin,
    this.onRotateBegin$async = false,
    required void Function(jni$_.JObject rotateGestureDetector) onRotate,
    this.onRotate$async = false,
    required void Function(jni$_.JObject rotateGestureDetector) onRotateEnd,
    this.onRotateEnd$async = false,
  }) : _onRotateBegin = onRotateBegin,
       _onRotate = onRotate,
       _onRotateEnd = onRotateEnd;

  final void Function(jni$_.JObject rotateGestureDetector) _onRotateBegin;
  final bool onRotateBegin$async;
  final void Function(jni$_.JObject rotateGestureDetector) _onRotate;
  final bool onRotate$async;
  final void Function(jni$_.JObject rotateGestureDetector) _onRotateEnd;
  final bool onRotateEnd$async;

  void onRotateBegin(jni$_.JObject rotateGestureDetector) {
    return _onRotateBegin(rotateGestureDetector);
  }

  void onRotate(jni$_.JObject rotateGestureDetector) {
    return _onRotate(rotateGestureDetector);
  }

  void onRotateEnd(jni$_.JObject rotateGestureDetector) {
    return _onRotateEnd(rotateGestureDetector);
  }
}

final class $MapLibreMap$OnRotateListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnRotateListener?> {
  @jni$_.internal
  const $MapLibreMap$OnRotateListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnRotateListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnRotateListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnRotateListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnRotateListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnRotateListener$NullableType) &&
        other is $MapLibreMap$OnRotateListener$NullableType;
  }
}

final class $MapLibreMap$OnRotateListener$Type
    extends jni$_.JObjType<MapLibreMap$OnRotateListener> {
  @jni$_.internal
  const $MapLibreMap$OnRotateListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnRotateListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnRotateListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnRotateListener?> get nullableType =>
      const $MapLibreMap$OnRotateListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnRotateListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnRotateListener$Type) &&
        other is $MapLibreMap$OnRotateListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnScaleListener`
class MapLibreMap$OnScaleListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnScaleListener> $type;

  @jni$_.internal
  MapLibreMap$OnScaleListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnScaleListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnScaleListener$NullableType();
  static const type = $MapLibreMap$OnScaleListener$Type();
  static final _id_onScaleBegin = _class.instanceMethodId(
    r'onScaleBegin',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScaleBegin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onScaleBegin(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScaleBegin(jni$_.JObject standardScaleGestureDetector) {
    final _$standardScaleGestureDetector =
        standardScaleGestureDetector.reference;
    _onScaleBegin(
      reference.pointer,
      _id_onScaleBegin as jni$_.JMethodIDPtr,
      _$standardScaleGestureDetector.pointer,
    ).check();
  }

  static final _id_onScale = _class.instanceMethodId(
    r'onScale',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onScale(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScale(jni$_.JObject standardScaleGestureDetector) {
    final _$standardScaleGestureDetector =
        standardScaleGestureDetector.reference;
    _onScale(
      reference.pointer,
      _id_onScale as jni$_.JMethodIDPtr,
      _$standardScaleGestureDetector.pointer,
    ).check();
  }

  static final _id_onScaleEnd = _class.instanceMethodId(
    r'onScaleEnd',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScaleEnd =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onScaleEnd(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScaleEnd(jni$_.JObject standardScaleGestureDetector) {
    final _$standardScaleGestureDetector =
        standardScaleGestureDetector.reference;
    _onScaleEnd(
      reference.pointer,
      _id_onScaleEnd as jni$_.JMethodIDPtr,
      _$standardScaleGestureDetector.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnScaleListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onScaleBegin(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScaleBegin(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onScale(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScale(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onScaleEnd(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScaleEnd(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnScaleListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnScaleListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onScaleBegin$async)
          r'onScaleBegin(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
        if ($impl.onScale$async)
          r'onScale(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
        if ($impl.onScaleEnd$async)
          r'onScaleEnd(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnScaleListener.implement(
    $MapLibreMap$OnScaleListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnScaleListener.fromReference($i.implementReference());
  }
}

abstract base mixin class $MapLibreMap$OnScaleListener {
  factory $MapLibreMap$OnScaleListener({
    required void Function(jni$_.JObject standardScaleGestureDetector)
    onScaleBegin,
    bool onScaleBegin$async,
    required void Function(jni$_.JObject standardScaleGestureDetector) onScale,
    bool onScale$async,
    required void Function(jni$_.JObject standardScaleGestureDetector)
    onScaleEnd,
    bool onScaleEnd$async,
  }) = _$MapLibreMap$OnScaleListener;

  void onScaleBegin(jni$_.JObject standardScaleGestureDetector);
  bool get onScaleBegin$async => false;
  void onScale(jni$_.JObject standardScaleGestureDetector);
  bool get onScale$async => false;
  void onScaleEnd(jni$_.JObject standardScaleGestureDetector);
  bool get onScaleEnd$async => false;
}

final class _$MapLibreMap$OnScaleListener with $MapLibreMap$OnScaleListener {
  _$MapLibreMap$OnScaleListener({
    required void Function(jni$_.JObject standardScaleGestureDetector)
    onScaleBegin,
    this.onScaleBegin$async = false,
    required void Function(jni$_.JObject standardScaleGestureDetector) onScale,
    this.onScale$async = false,
    required void Function(jni$_.JObject standardScaleGestureDetector)
    onScaleEnd,
    this.onScaleEnd$async = false,
  }) : _onScaleBegin = onScaleBegin,
       _onScale = onScale,
       _onScaleEnd = onScaleEnd;

  final void Function(jni$_.JObject standardScaleGestureDetector) _onScaleBegin;
  final bool onScaleBegin$async;
  final void Function(jni$_.JObject standardScaleGestureDetector) _onScale;
  final bool onScale$async;
  final void Function(jni$_.JObject standardScaleGestureDetector) _onScaleEnd;
  final bool onScaleEnd$async;

  void onScaleBegin(jni$_.JObject standardScaleGestureDetector) {
    return _onScaleBegin(standardScaleGestureDetector);
  }

  void onScale(jni$_.JObject standardScaleGestureDetector) {
    return _onScale(standardScaleGestureDetector);
  }

  void onScaleEnd(jni$_.JObject standardScaleGestureDetector) {
    return _onScaleEnd(standardScaleGestureDetector);
  }
}

final class $MapLibreMap$OnScaleListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnScaleListener?> {
  @jni$_.internal
  const $MapLibreMap$OnScaleListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnScaleListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnScaleListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnScaleListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnScaleListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnScaleListener$NullableType) &&
        other is $MapLibreMap$OnScaleListener$NullableType;
  }
}

final class $MapLibreMap$OnScaleListener$Type
    extends jni$_.JObjType<MapLibreMap$OnScaleListener> {
  @jni$_.internal
  const $MapLibreMap$OnScaleListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnScaleListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnScaleListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnScaleListener?> get nullableType =>
      const $MapLibreMap$OnScaleListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnScaleListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnScaleListener$Type) &&
        other is $MapLibreMap$OnScaleListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnShoveListener`
class MapLibreMap$OnShoveListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$OnShoveListener> $type;

  @jni$_.internal
  MapLibreMap$OnShoveListener.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$OnShoveListener',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$OnShoveListener$NullableType();
  static const type = $MapLibreMap$OnShoveListener$Type();
  static final _id_onShoveBegin = _class.instanceMethodId(
    r'onShoveBegin',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShoveBegin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onShoveBegin(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShoveBegin(jni$_.JObject shoveGestureDetector) {
    final _$shoveGestureDetector = shoveGestureDetector.reference;
    _onShoveBegin(
      reference.pointer,
      _id_onShoveBegin as jni$_.JMethodIDPtr,
      _$shoveGestureDetector.pointer,
    ).check();
  }

  static final _id_onShove = _class.instanceMethodId(
    r'onShove',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onShove(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShove(jni$_.JObject shoveGestureDetector) {
    final _$shoveGestureDetector = shoveGestureDetector.reference;
    _onShove(
      reference.pointer,
      _id_onShove as jni$_.JMethodIDPtr,
      _$shoveGestureDetector.pointer,
    ).check();
  }

  static final _id_onShoveEnd = _class.instanceMethodId(
    r'onShoveEnd',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShoveEnd =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onShoveEnd(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShoveEnd(jni$_.JObject shoveGestureDetector) {
    final _$shoveGestureDetector = shoveGestureDetector.reference;
    _onShoveEnd(
      reference.pointer,
      _id_onShoveEnd as jni$_.JMethodIDPtr,
      _$shoveGestureDetector.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$OnShoveListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onShoveBegin(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShoveBegin(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onShove(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShove(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onShoveEnd(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShoveEnd(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$OnShoveListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnShoveListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onShoveBegin$async)
          r'onShoveBegin(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
        if ($impl.onShove$async)
          r'onShove(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
        if ($impl.onShoveEnd$async)
          r'onShoveEnd(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$OnShoveListener.implement(
    $MapLibreMap$OnShoveListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$OnShoveListener.fromReference($i.implementReference());
  }
}

abstract base mixin class $MapLibreMap$OnShoveListener {
  factory $MapLibreMap$OnShoveListener({
    required void Function(jni$_.JObject shoveGestureDetector) onShoveBegin,
    bool onShoveBegin$async,
    required void Function(jni$_.JObject shoveGestureDetector) onShove,
    bool onShove$async,
    required void Function(jni$_.JObject shoveGestureDetector) onShoveEnd,
    bool onShoveEnd$async,
  }) = _$MapLibreMap$OnShoveListener;

  void onShoveBegin(jni$_.JObject shoveGestureDetector);
  bool get onShoveBegin$async => false;
  void onShove(jni$_.JObject shoveGestureDetector);
  bool get onShove$async => false;
  void onShoveEnd(jni$_.JObject shoveGestureDetector);
  bool get onShoveEnd$async => false;
}

final class _$MapLibreMap$OnShoveListener with $MapLibreMap$OnShoveListener {
  _$MapLibreMap$OnShoveListener({
    required void Function(jni$_.JObject shoveGestureDetector) onShoveBegin,
    this.onShoveBegin$async = false,
    required void Function(jni$_.JObject shoveGestureDetector) onShove,
    this.onShove$async = false,
    required void Function(jni$_.JObject shoveGestureDetector) onShoveEnd,
    this.onShoveEnd$async = false,
  }) : _onShoveBegin = onShoveBegin,
       _onShove = onShove,
       _onShoveEnd = onShoveEnd;

  final void Function(jni$_.JObject shoveGestureDetector) _onShoveBegin;
  final bool onShoveBegin$async;
  final void Function(jni$_.JObject shoveGestureDetector) _onShove;
  final bool onShove$async;
  final void Function(jni$_.JObject shoveGestureDetector) _onShoveEnd;
  final bool onShoveEnd$async;

  void onShoveBegin(jni$_.JObject shoveGestureDetector) {
    return _onShoveBegin(shoveGestureDetector);
  }

  void onShove(jni$_.JObject shoveGestureDetector) {
    return _onShove(shoveGestureDetector);
  }

  void onShoveEnd(jni$_.JObject shoveGestureDetector) {
    return _onShoveEnd(shoveGestureDetector);
  }
}

final class $MapLibreMap$OnShoveListener$NullableType
    extends jni$_.JObjType<MapLibreMap$OnShoveListener?> {
  @jni$_.internal
  const $MapLibreMap$OnShoveListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnShoveListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapLibreMap$OnShoveListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnShoveListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnShoveListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnShoveListener$NullableType) &&
        other is $MapLibreMap$OnShoveListener$NullableType;
  }
}

final class $MapLibreMap$OnShoveListener$Type
    extends jni$_.JObjType<MapLibreMap$OnShoveListener> {
  @jni$_.internal
  const $MapLibreMap$OnShoveListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$OnShoveListener fromReference(jni$_.JReference reference) =>
      MapLibreMap$OnShoveListener.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$OnShoveListener?> get nullableType =>
      const $MapLibreMap$OnShoveListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$OnShoveListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$OnShoveListener$Type) &&
        other is $MapLibreMap$OnShoveListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback`
class MapLibreMap$SnapshotReadyCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap$SnapshotReadyCallback> $type;

  @jni$_.internal
  MapLibreMap$SnapshotReadyCallback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$SnapshotReadyCallback$NullableType();
  static const type = $MapLibreMap$SnapshotReadyCallback$Type();
  static final _id_onSnapshotReady = _class.instanceMethodId(
    r'onSnapshotReady',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onSnapshotReady =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onSnapshotReady(android.graphics.Bitmap bitmap)`
  void onSnapshotReady(jni$_.JObject bitmap) {
    final _$bitmap = bitmap.reference;
    _onSnapshotReady(
      reference.pointer,
      _id_onSnapshotReady as jni$_.JMethodIDPtr,
      _$bitmap.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapLibreMap$SnapshotReadyCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSnapshotReady(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onSnapshotReady(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapLibreMap$SnapshotReadyCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onSnapshotReady$async)
          r'onSnapshotReady(Landroid/graphics/Bitmap;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap$SnapshotReadyCallback.implement(
    $MapLibreMap$SnapshotReadyCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap$SnapshotReadyCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap$SnapshotReadyCallback {
  factory $MapLibreMap$SnapshotReadyCallback({
    required void Function(jni$_.JObject bitmap) onSnapshotReady,
    bool onSnapshotReady$async,
  }) = _$MapLibreMap$SnapshotReadyCallback;

  void onSnapshotReady(jni$_.JObject bitmap);
  bool get onSnapshotReady$async => false;
}

final class _$MapLibreMap$SnapshotReadyCallback
    with $MapLibreMap$SnapshotReadyCallback {
  _$MapLibreMap$SnapshotReadyCallback({
    required void Function(jni$_.JObject bitmap) onSnapshotReady,
    this.onSnapshotReady$async = false,
  }) : _onSnapshotReady = onSnapshotReady;

  final void Function(jni$_.JObject bitmap) _onSnapshotReady;
  final bool onSnapshotReady$async;

  void onSnapshotReady(jni$_.JObject bitmap) {
    return _onSnapshotReady(bitmap);
  }
}

final class $MapLibreMap$SnapshotReadyCallback$NullableType
    extends jni$_.JObjType<MapLibreMap$SnapshotReadyCallback?> {
  @jni$_.internal
  const $MapLibreMap$SnapshotReadyCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$SnapshotReadyCallback? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : MapLibreMap$SnapshotReadyCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$SnapshotReadyCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapLibreMap$SnapshotReadyCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap$SnapshotReadyCallback$NullableType) &&
        other is $MapLibreMap$SnapshotReadyCallback$NullableType;
  }
}

final class $MapLibreMap$SnapshotReadyCallback$Type
    extends jni$_.JObjType<MapLibreMap$SnapshotReadyCallback> {
  @jni$_.internal
  const $MapLibreMap$SnapshotReadyCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback;';

  @jni$_.internal
  @core$_.override
  MapLibreMap$SnapshotReadyCallback fromReference(jni$_.JReference reference) =>
      MapLibreMap$SnapshotReadyCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap$SnapshotReadyCallback?> get nullableType =>
      const $MapLibreMap$SnapshotReadyCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$SnapshotReadyCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$SnapshotReadyCallback$Type) &&
        other is $MapLibreMap$SnapshotReadyCallback$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap`
class MapLibreMap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapLibreMap> $type;

  @jni$_.internal
  MapLibreMap.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/MapLibreMap',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapLibreMap$NullableType();
  static const type = $MapLibreMap$Type();
  static final _id_triggerRepaint = _class.instanceMethodId(
    r'triggerRepaint',
    r'()V',
  );

  static final _triggerRepaint =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void triggerRepaint()`
  void triggerRepaint() {
    _triggerRepaint(
      reference.pointer,
      _id_triggerRepaint as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_setSwapBehaviorFlush = _class.instanceMethodId(
    r'setSwapBehaviorFlush',
    r'(Z)V',
  );

  static final _setSwapBehaviorFlush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSwapBehaviorFlush(boolean z)`
  void setSwapBehaviorFlush(bool z) {
    _setSwapBehaviorFlush(
      reference.pointer,
      _id_setSwapBehaviorFlush as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getStyle = _class.instanceMethodId(
    r'getStyle',
    r'(Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _getStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getStyle(org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void getStyle(style$_.Style$OnStyleLoaded onStyleLoaded) {
    final _$onStyleLoaded = onStyleLoaded.reference;
    _getStyle(
      reference.pointer,
      _id_getStyle as jni$_.JMethodIDPtr,
      _$onStyleLoaded.pointer,
    ).check();
  }

  static final _id_getStyle$1 = _class.instanceMethodId(
    r'getStyle',
    r'()Lorg/maplibre/android/maps/Style;',
  );

  static final _getStyle$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style getStyle()`
  /// The returned object must be released after use, by calling the [release] method.
  style$_.Style? getStyle$1() {
    return _getStyle$1(
      reference.pointer,
      _id_getStyle$1 as jni$_.JMethodIDPtr,
    ).object<style$_.Style?>(const style$_.$Style$NullableType());
  }

  static final _id_setPrefetchesTiles = _class.instanceMethodId(
    r'setPrefetchesTiles',
    r'(Z)V',
  );

  static final _setPrefetchesTiles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setPrefetchesTiles(boolean z)`
  void setPrefetchesTiles(bool z) {
    _setPrefetchesTiles(
      reference.pointer,
      _id_setPrefetchesTiles as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getPrefetchesTiles = _class.instanceMethodId(
    r'getPrefetchesTiles',
    r'()Z',
  );

  static final _getPrefetchesTiles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getPrefetchesTiles()`
  bool getPrefetchesTiles() {
    return _getPrefetchesTiles(
      reference.pointer,
      _id_getPrefetchesTiles as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setPrefetchZoomDelta = _class.instanceMethodId(
    r'setPrefetchZoomDelta',
    r'(I)V',
  );

  static final _setPrefetchZoomDelta =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setPrefetchZoomDelta(int i)`
  void setPrefetchZoomDelta(int i) {
    _setPrefetchZoomDelta(
      reference.pointer,
      _id_setPrefetchZoomDelta as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getPrefetchZoomDelta = _class.instanceMethodId(
    r'getPrefetchZoomDelta',
    r'()I',
  );

  static final _getPrefetchZoomDelta =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPrefetchZoomDelta()`
  int getPrefetchZoomDelta() {
    return _getPrefetchZoomDelta(
      reference.pointer,
      _id_getPrefetchZoomDelta as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setTileCacheEnabled = _class.instanceMethodId(
    r'setTileCacheEnabled',
    r'(Z)V',
  );

  static final _setTileCacheEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTileCacheEnabled(boolean z)`
  void setTileCacheEnabled(bool z) {
    _setTileCacheEnabled(
      reference.pointer,
      _id_setTileCacheEnabled as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getTileCacheEnabled = _class.instanceMethodId(
    r'getTileCacheEnabled',
    r'()Z',
  );

  static final _getTileCacheEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getTileCacheEnabled()`
  bool getTileCacheEnabled() {
    return _getTileCacheEnabled(
      reference.pointer,
      _id_getTileCacheEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setMinZoomPreference = _class.instanceMethodId(
    r'setMinZoomPreference',
    r'(D)V',
  );

  static final _setMinZoomPreference =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setMinZoomPreference(double d)`
  void setMinZoomPreference(double d) {
    _setMinZoomPreference(
      reference.pointer,
      _id_setMinZoomPreference as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_getMinZoomLevel = _class.instanceMethodId(
    r'getMinZoomLevel',
    r'()D',
  );

  static final _getMinZoomLevel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double getMinZoomLevel()`
  double getMinZoomLevel() {
    return _getMinZoomLevel(
      reference.pointer,
      _id_getMinZoomLevel as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_setMaxZoomPreference = _class.instanceMethodId(
    r'setMaxZoomPreference',
    r'(D)V',
  );

  static final _setMaxZoomPreference =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setMaxZoomPreference(double d)`
  void setMaxZoomPreference(double d) {
    _setMaxZoomPreference(
      reference.pointer,
      _id_setMaxZoomPreference as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_getMaxZoomLevel = _class.instanceMethodId(
    r'getMaxZoomLevel',
    r'()D',
  );

  static final _getMaxZoomLevel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double getMaxZoomLevel()`
  double getMaxZoomLevel() {
    return _getMaxZoomLevel(
      reference.pointer,
      _id_getMaxZoomLevel as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_setMinPitchPreference = _class.instanceMethodId(
    r'setMinPitchPreference',
    r'(D)V',
  );

  static final _setMinPitchPreference =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setMinPitchPreference(double d)`
  void setMinPitchPreference(double d) {
    _setMinPitchPreference(
      reference.pointer,
      _id_setMinPitchPreference as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_getMinPitch = _class.instanceMethodId(
    r'getMinPitch',
    r'()D',
  );

  static final _getMinPitch =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double getMinPitch()`
  double getMinPitch() {
    return _getMinPitch(
      reference.pointer,
      _id_getMinPitch as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_setMaxPitchPreference = _class.instanceMethodId(
    r'setMaxPitchPreference',
    r'(D)V',
  );

  static final _setMaxPitchPreference =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setMaxPitchPreference(double d)`
  void setMaxPitchPreference(double d) {
    _setMaxPitchPreference(
      reference.pointer,
      _id_setMaxPitchPreference as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_getMaxPitch = _class.instanceMethodId(
    r'getMaxPitch',
    r'()D',
  );

  static final _getMaxPitch =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double getMaxPitch()`
  double getMaxPitch() {
    return _getMaxPitch(
      reference.pointer,
      _id_getMaxPitch as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_getUiSettings = _class.instanceMethodId(
    r'getUiSettings',
    r'()Lorg/maplibre/android/maps/UiSettings;',
  );

  static final _getUiSettings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.maps.UiSettings getUiSettings()`
  /// The returned object must be released after use, by calling the [release] method.
  uisettings$_.UiSettings getUiSettings() {
    return _getUiSettings(
      reference.pointer,
      _id_getUiSettings as jni$_.JMethodIDPtr,
    ).object<uisettings$_.UiSettings>(const uisettings$_.$UiSettings$Type());
  }

  static final _id_getProjection = _class.instanceMethodId(
    r'getProjection',
    r'()Lorg/maplibre/android/maps/Projection;',
  );

  static final _getProjection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.maps.Projection getProjection()`
  /// The returned object must be released after use, by calling the [release] method.
  projection$_.Projection getProjection() {
    return _getProjection(
      reference.pointer,
      _id_getProjection as jni$_.JMethodIDPtr,
    ).object<projection$_.Projection>(const projection$_.$Projection$Type());
  }

  static final _id_cancelTransitions = _class.instanceMethodId(
    r'cancelTransitions',
    r'()V',
  );

  static final _cancelTransitions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void cancelTransitions()`
  void cancelTransitions() {
    _cancelTransitions(
      reference.pointer,
      _id_cancelTransitions as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_getCameraPosition = _class.instanceMethodId(
    r'getCameraPosition',
    r'()Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraPosition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final org.maplibre.android.camera.CameraPosition getCameraPosition()`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition getCameraPosition() {
    return _getCameraPosition(
      reference.pointer,
      _id_getCameraPosition as jni$_.JMethodIDPtr,
    ).object<cameraposition$_.CameraPosition>(
      const cameraposition$_.$CameraPosition$Type(),
    );
  }

  static final _id_setCameraPosition = _class.instanceMethodId(
    r'setCameraPosition',
    r'(Lorg/maplibre/android/camera/CameraPosition;)V',
  );

  static final _setCameraPosition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCameraPosition(org.maplibre.android.camera.CameraPosition cameraPosition)`
  void setCameraPosition(cameraposition$_.CameraPosition cameraPosition) {
    final _$cameraPosition = cameraPosition.reference;
    _setCameraPosition(
      reference.pointer,
      _id_setCameraPosition as jni$_.JMethodIDPtr,
      _$cameraPosition.pointer,
    ).check();
  }

  static final _id_moveCamera = _class.instanceMethodId(
    r'moveCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _moveCamera =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void moveCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void moveCamera(cameraupdate$_.CameraUpdate cameraUpdate) {
    final _$cameraUpdate = cameraUpdate.reference;
    _moveCamera(
      reference.pointer,
      _id_moveCamera as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
    ).check();
  }

  static final _id_moveCamera$1 = _class.instanceMethodId(
    r'moveCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _moveCamera$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void moveCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void moveCamera$1(
    cameraupdate$_.CameraUpdate cameraUpdate,
    MapLibreMap$CancelableCallback? cancelableCallback,
  ) {
    final _$cameraUpdate = cameraUpdate.reference;
    final _$cancelableCallback =
        cancelableCallback?.reference ?? jni$_.jNullReference;
    _moveCamera$1(
      reference.pointer,
      _id_moveCamera$1 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      _$cancelableCallback.pointer,
    ).check();
  }

  static final _id_easeCamera = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _easeCamera =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void easeCamera(cameraupdate$_.CameraUpdate cameraUpdate) {
    final _$cameraUpdate = cameraUpdate.reference;
    _easeCamera(
      reference.pointer,
      _id_easeCamera as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
    ).check();
  }

  static final _id_easeCamera$1 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera$1(
    cameraupdate$_.CameraUpdate cameraUpdate,
    MapLibreMap$CancelableCallback? cancelableCallback,
  ) {
    final _$cameraUpdate = cameraUpdate.reference;
    final _$cancelableCallback =
        cancelableCallback?.reference ?? jni$_.jNullReference;
    _easeCamera$1(
      reference.pointer,
      _id_easeCamera$1 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      _$cancelableCallback.pointer,
    ).check();
  }

  static final _id_easeCamera$2 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;I)V',
  );

  static final _easeCamera$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i)`
  void easeCamera$2(cameraupdate$_.CameraUpdate cameraUpdate, int i) {
    final _$cameraUpdate = cameraUpdate.reference;
    _easeCamera$2(
      reference.pointer,
      _id_easeCamera$2 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      i,
    ).check();
  }

  static final _id_easeCamera$3 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;ILorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera$3(
    cameraupdate$_.CameraUpdate cameraUpdate,
    int i,
    MapLibreMap$CancelableCallback? cancelableCallback,
  ) {
    final _$cameraUpdate = cameraUpdate.reference;
    final _$cancelableCallback =
        cancelableCallback?.reference ?? jni$_.jNullReference;
    _easeCamera$3(
      reference.pointer,
      _id_easeCamera$3 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      i,
      _$cancelableCallback.pointer,
    ).check();
  }

  static final _id_easeCamera$4 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;IZ)V',
  );

  static final _easeCamera$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, boolean z)`
  void easeCamera$4(cameraupdate$_.CameraUpdate cameraUpdate, int i, bool z) {
    final _$cameraUpdate = cameraUpdate.reference;
    _easeCamera$4(
      reference.pointer,
      _id_easeCamera$4 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      i,
      z ? 1 : 0,
    ).check();
  }

  static final _id_easeCamera$5 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;IZLorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, boolean z, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera$5(
    cameraupdate$_.CameraUpdate cameraUpdate,
    int i,
    bool z,
    MapLibreMap$CancelableCallback? cancelableCallback,
  ) {
    final _$cameraUpdate = cameraUpdate.reference;
    final _$cancelableCallback =
        cancelableCallback?.reference ?? jni$_.jNullReference;
    _easeCamera$5(
      reference.pointer,
      _id_easeCamera$5 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      i,
      z ? 1 : 0,
      _$cancelableCallback.pointer,
    ).check();
  }

  static final _id_animateCamera = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _animateCamera =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void animateCamera(cameraupdate$_.CameraUpdate cameraUpdate) {
    final _$cameraUpdate = cameraUpdate.reference;
    _animateCamera(
      reference.pointer,
      _id_animateCamera as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
    ).check();
  }

  static final _id_animateCamera$1 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _animateCamera$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void animateCamera$1(
    cameraupdate$_.CameraUpdate cameraUpdate,
    MapLibreMap$CancelableCallback? cancelableCallback,
  ) {
    final _$cameraUpdate = cameraUpdate.reference;
    final _$cancelableCallback =
        cancelableCallback?.reference ?? jni$_.jNullReference;
    _animateCamera$1(
      reference.pointer,
      _id_animateCamera$1 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      _$cancelableCallback.pointer,
    ).check();
  }

  static final _id_animateCamera$2 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;I)V',
  );

  static final _animateCamera$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i)`
  void animateCamera$2(cameraupdate$_.CameraUpdate cameraUpdate, int i) {
    final _$cameraUpdate = cameraUpdate.reference;
    _animateCamera$2(
      reference.pointer,
      _id_animateCamera$2 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      i,
    ).check();
  }

  static final _id_animateCamera$3 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;ILorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _animateCamera$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void animateCamera$3(
    cameraupdate$_.CameraUpdate cameraUpdate,
    int i,
    MapLibreMap$CancelableCallback? cancelableCallback,
  ) {
    final _$cameraUpdate = cameraUpdate.reference;
    final _$cancelableCallback =
        cancelableCallback?.reference ?? jni$_.jNullReference;
    _animateCamera$3(
      reference.pointer,
      _id_animateCamera$3 as jni$_.JMethodIDPtr,
      _$cameraUpdate.pointer,
      i,
      _$cancelableCallback.pointer,
    ).check();
  }

  static final _id_scrollBy = _class.instanceMethodId(r'scrollBy', r'(FF)V');

  static final _scrollBy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double, jni$_.Double)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              double,
            )
          >();

  /// from: `public void scrollBy(float f, float f1)`
  void scrollBy(double f, double f1) {
    _scrollBy(
      reference.pointer,
      _id_scrollBy as jni$_.JMethodIDPtr,
      f,
      f1,
    ).check();
  }

  static final _id_scrollBy$1 = _class.instanceMethodId(r'scrollBy', r'(FFJ)V');

  static final _scrollBy$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double, jni$_.Double, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              double,
              int,
            )
          >();

  /// from: `public void scrollBy(float f, float f1, long j)`
  void scrollBy$1(double f, double f1, int j) {
    _scrollBy$1(
      reference.pointer,
      _id_scrollBy$1 as jni$_.JMethodIDPtr,
      f,
      f1,
      j,
    ).check();
  }

  static final _id_getZoom = _class.instanceMethodId(r'getZoom', r'()D');

  static final _getZoom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double getZoom()`
  double getZoom() {
    return _getZoom(
      reference.pointer,
      _id_getZoom as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_setZoom = _class.instanceMethodId(
    r'setZoom',
    r'(DLandroid/graphics/PointF;J)V',
  );

  static final _setZoom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Double, jni$_.Pointer<jni$_.Void>, jni$_.Int64)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void setZoom(double d, android.graphics.PointF pointF, long j)`
  void setZoom(double d, pointf$_.PointF pointF, int j) {
    final _$pointF = pointF.reference;
    _setZoom(
      reference.pointer,
      _id_setZoom as jni$_.JMethodIDPtr,
      d,
      _$pointF.pointer,
      j,
    ).check();
  }

  static final _id_resetNorth = _class.instanceMethodId(r'resetNorth', r'()V');

  static final _resetNorth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void resetNorth()`
  void resetNorth() {
    _resetNorth(
      reference.pointer,
      _id_resetNorth as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_setFocalBearing = _class.instanceMethodId(
    r'setFocalBearing',
    r'(DFFJ)V',
  );

  static final _setFocalBearing =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Double, jni$_.Double, jni$_.Double, jni$_.Int64)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              double,
              double,
              int,
            )
          >();

  /// from: `public void setFocalBearing(double d, float f, float f1, long j)`
  void setFocalBearing(double d, double f, double f1, int j) {
    _setFocalBearing(
      reference.pointer,
      _id_setFocalBearing as jni$_.JMethodIDPtr,
      d,
      f,
      f1,
      j,
    ).check();
  }

  static final _id_getHeight = _class.instanceMethodId(r'getHeight', r'()F');

  static final _getHeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getHeight()`
  double getHeight() {
    return _getHeight(
      reference.pointer,
      _id_getHeight as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getWidth = _class.instanceMethodId(r'getWidth', r'()F');

  static final _getWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getWidth()`
  double getWidth() {
    return _getWidth(
      reference.pointer,
      _id_getWidth as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_setOfflineRegionDefinition = _class.instanceMethodId(
    r'setOfflineRegionDefinition',
    r'(Lorg/maplibre/android/offline/OfflineRegionDefinition;)V',
  );

  static final _setOfflineRegionDefinition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOfflineRegionDefinition(org.maplibre.android.offline.OfflineRegionDefinition offlineRegionDefinition)`
  void setOfflineRegionDefinition(
    offlineregiondefinition$_.OfflineRegionDefinition offlineRegionDefinition,
  ) {
    final _$offlineRegionDefinition = offlineRegionDefinition.reference;
    _setOfflineRegionDefinition(
      reference.pointer,
      _id_setOfflineRegionDefinition as jni$_.JMethodIDPtr,
      _$offlineRegionDefinition.pointer,
    ).check();
  }

  static final _id_setOfflineRegionDefinition$1 = _class.instanceMethodId(
    r'setOfflineRegionDefinition',
    r'(Lorg/maplibre/android/offline/OfflineRegionDefinition;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setOfflineRegionDefinition$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOfflineRegionDefinition(org.maplibre.android.offline.OfflineRegionDefinition offlineRegionDefinition, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setOfflineRegionDefinition$1(
    offlineregiondefinition$_.OfflineRegionDefinition offlineRegionDefinition,
    style$_.Style$OnStyleLoaded? onStyleLoaded,
  ) {
    final _$offlineRegionDefinition = offlineRegionDefinition.reference;
    final _$onStyleLoaded = onStyleLoaded?.reference ?? jni$_.jNullReference;
    _setOfflineRegionDefinition$1(
      reference.pointer,
      _id_setOfflineRegionDefinition$1 as jni$_.JMethodIDPtr,
      _$offlineRegionDefinition.pointer,
      _$onStyleLoaded.pointer,
    ).check();
  }

  static final _id_isDebugActive = _class.instanceMethodId(
    r'isDebugActive',
    r'()Z',
  );

  static final _isDebugActive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDebugActive()`
  bool isDebugActive() {
    return _isDebugActive(
      reference.pointer,
      _id_isDebugActive as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setDebugActive = _class.instanceMethodId(
    r'setDebugActive',
    r'(Z)V',
  );

  static final _setDebugActive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDebugActive(boolean z)`
  void setDebugActive(bool z) {
    _setDebugActive(
      reference.pointer,
      _id_setDebugActive as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_cycleDebugOptions = _class.instanceMethodId(
    r'cycleDebugOptions',
    r'()V',
  );

  static final _cycleDebugOptions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void cycleDebugOptions()`
  void cycleDebugOptions() {
    _cycleDebugOptions(
      reference.pointer,
      _id_cycleDebugOptions as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_setStyle = _class.instanceMethodId(
    r'setStyle',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStyle(java.lang.String string)`
  void setStyle(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setStyle(
      reference.pointer,
      _id_setStyle as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_setStyle$1 = _class.instanceMethodId(
    r'setStyle',
    r'(Ljava/lang/String;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setStyle$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStyle(java.lang.String string, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setStyle$1(
    jni$_.JString? string,
    style$_.Style$OnStyleLoaded? onStyleLoaded,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$onStyleLoaded = onStyleLoaded?.reference ?? jni$_.jNullReference;
    _setStyle$1(
      reference.pointer,
      _id_setStyle$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$onStyleLoaded.pointer,
    ).check();
  }

  static final _id_setStyle$2 = _class.instanceMethodId(
    r'setStyle',
    r'(Lorg/maplibre/android/maps/Style$Builder;)V',
  );

  static final _setStyle$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStyle(org.maplibre.android.maps.Style$Builder builder)`
  void setStyle$2(style$_.Style$Builder? builder) {
    final _$builder = builder?.reference ?? jni$_.jNullReference;
    _setStyle$2(
      reference.pointer,
      _id_setStyle$2 as jni$_.JMethodIDPtr,
      _$builder.pointer,
    ).check();
  }

  static final _id_setStyle$3 = _class.instanceMethodId(
    r'setStyle',
    r'(Lorg/maplibre/android/maps/Style$Builder;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setStyle$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStyle(org.maplibre.android.maps.Style$Builder builder, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setStyle$3(
    style$_.Style$Builder? builder,
    style$_.Style$OnStyleLoaded? onStyleLoaded,
  ) {
    final _$builder = builder?.reference ?? jni$_.jNullReference;
    final _$onStyleLoaded = onStyleLoaded?.reference ?? jni$_.jNullReference;
    _setStyle$3(
      reference.pointer,
      _id_setStyle$3 as jni$_.JMethodIDPtr,
      _$builder.pointer,
      _$onStyleLoaded.pointer,
    ).check();
  }

  static final _id_addMarker = _class.instanceMethodId(
    r'addMarker',
    r'(Lorg/maplibre/android/annotations/MarkerOptions;)Lorg/maplibre/android/annotations/Marker;',
  );

  static final _addMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.annotations.Marker addMarker(org.maplibre.android.annotations.MarkerOptions markerOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject addMarker(jni$_.JObject markerOptions) {
    final _$markerOptions = markerOptions.reference;
    return _addMarker(
      reference.pointer,
      _id_addMarker as jni$_.JMethodIDPtr,
      _$markerOptions.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_addMarker$1 = _class.instanceMethodId(
    r'addMarker',
    r'(Lorg/maplibre/android/annotations/BaseMarkerOptions;)Lorg/maplibre/android/annotations/Marker;',
  );

  static final _addMarker$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.annotations.Marker addMarker(org.maplibre.android.annotations.BaseMarkerOptions baseMarkerOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject addMarker$1(jni$_.JObject baseMarkerOptions) {
    final _$baseMarkerOptions = baseMarkerOptions.reference;
    return _addMarker$1(
      reference.pointer,
      _id_addMarker$1 as jni$_.JMethodIDPtr,
      _$baseMarkerOptions.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_addMarkers = _class.instanceMethodId(
    r'addMarkers',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addMarkers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.List addMarkers(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> addMarkers(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _addMarkers(
      reference.pointer,
      _id_addMarkers as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
    );
  }

  static final _id_updateMarker = _class.instanceMethodId(
    r'updateMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _updateMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void updateMarker(org.maplibre.android.annotations.Marker marker)`
  void updateMarker(jni$_.JObject marker) {
    final _$marker = marker.reference;
    _updateMarker(
      reference.pointer,
      _id_updateMarker as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).check();
  }

  static final _id_addPolyline = _class.instanceMethodId(
    r'addPolyline',
    r'(Lorg/maplibre/android/annotations/PolylineOptions;)Lorg/maplibre/android/annotations/Polyline;',
  );

  static final _addPolyline =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.annotations.Polyline addPolyline(org.maplibre.android.annotations.PolylineOptions polylineOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject addPolyline(jni$_.JObject polylineOptions) {
    final _$polylineOptions = polylineOptions.reference;
    return _addPolyline(
      reference.pointer,
      _id_addPolyline as jni$_.JMethodIDPtr,
      _$polylineOptions.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_addPolylines = _class.instanceMethodId(
    r'addPolylines',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addPolylines =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.List addPolylines(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> addPolylines(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _addPolylines(
      reference.pointer,
      _id_addPolylines as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
    );
  }

  static final _id_updatePolyline = _class.instanceMethodId(
    r'updatePolyline',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _updatePolyline =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void updatePolyline(org.maplibre.android.annotations.Polyline polyline)`
  void updatePolyline(jni$_.JObject polyline) {
    final _$polyline = polyline.reference;
    _updatePolyline(
      reference.pointer,
      _id_updatePolyline as jni$_.JMethodIDPtr,
      _$polyline.pointer,
    ).check();
  }

  static final _id_addPolygon = _class.instanceMethodId(
    r'addPolygon',
    r'(Lorg/maplibre/android/annotations/PolygonOptions;)Lorg/maplibre/android/annotations/Polygon;',
  );

  static final _addPolygon =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.annotations.Polygon addPolygon(org.maplibre.android.annotations.PolygonOptions polygonOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject addPolygon(jni$_.JObject polygonOptions) {
    final _$polygonOptions = polygonOptions.reference;
    return _addPolygon(
      reference.pointer,
      _id_addPolygon as jni$_.JMethodIDPtr,
      _$polygonOptions.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_addPolygons = _class.instanceMethodId(
    r'addPolygons',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addPolygons =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.List addPolygons(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> addPolygons(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _addPolygons(
      reference.pointer,
      _id_addPolygons as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
    );
  }

  static final _id_updatePolygon = _class.instanceMethodId(
    r'updatePolygon',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _updatePolygon =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void updatePolygon(org.maplibre.android.annotations.Polygon polygon)`
  void updatePolygon(jni$_.JObject polygon) {
    final _$polygon = polygon.reference;
    _updatePolygon(
      reference.pointer,
      _id_updatePolygon as jni$_.JMethodIDPtr,
      _$polygon.pointer,
    ).check();
  }

  static final _id_removeMarker = _class.instanceMethodId(
    r'removeMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _removeMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeMarker(org.maplibre.android.annotations.Marker marker)`
  void removeMarker(jni$_.JObject marker) {
    final _$marker = marker.reference;
    _removeMarker(
      reference.pointer,
      _id_removeMarker as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).check();
  }

  static final _id_removePolyline = _class.instanceMethodId(
    r'removePolyline',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _removePolyline =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removePolyline(org.maplibre.android.annotations.Polyline polyline)`
  void removePolyline(jni$_.JObject polyline) {
    final _$polyline = polyline.reference;
    _removePolyline(
      reference.pointer,
      _id_removePolyline as jni$_.JMethodIDPtr,
      _$polyline.pointer,
    ).check();
  }

  static final _id_removePolygon = _class.instanceMethodId(
    r'removePolygon',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _removePolygon =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removePolygon(org.maplibre.android.annotations.Polygon polygon)`
  void removePolygon(jni$_.JObject polygon) {
    final _$polygon = polygon.reference;
    _removePolygon(
      reference.pointer,
      _id_removePolygon as jni$_.JMethodIDPtr,
      _$polygon.pointer,
    ).check();
  }

  static final _id_removeAnnotation = _class.instanceMethodId(
    r'removeAnnotation',
    r'(Lorg/maplibre/android/annotations/Annotation;)V',
  );

  static final _removeAnnotation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeAnnotation(org.maplibre.android.annotations.Annotation annotation)`
  void removeAnnotation(jni$_.JObject annotation) {
    final _$annotation = annotation.reference;
    _removeAnnotation(
      reference.pointer,
      _id_removeAnnotation as jni$_.JMethodIDPtr,
      _$annotation.pointer,
    ).check();
  }

  static final _id_removeAnnotation$1 = _class.instanceMethodId(
    r'removeAnnotation',
    r'(J)V',
  );

  static final _removeAnnotation$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void removeAnnotation(long j)`
  void removeAnnotation$1(int j) {
    _removeAnnotation$1(
      reference.pointer,
      _id_removeAnnotation$1 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_removeAnnotations = _class.instanceMethodId(
    r'removeAnnotations',
    r'(Ljava/util/List;)V',
  );

  static final _removeAnnotations =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeAnnotations(java.util.List list)`
  void removeAnnotations(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    _removeAnnotations(
      reference.pointer,
      _id_removeAnnotations as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).check();
  }

  static final _id_removeAnnotations$1 = _class.instanceMethodId(
    r'removeAnnotations',
    r'()V',
  );

  static final _removeAnnotations$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void removeAnnotations()`
  void removeAnnotations$1() {
    _removeAnnotations$1(
      reference.pointer,
      _id_removeAnnotations$1 as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_clear = _class.instanceMethodId(r'clear', r'()V');

  static final _clear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_getAnnotation = _class.instanceMethodId(
    r'getAnnotation',
    r'(J)Lorg/maplibre/android/annotations/Annotation;',
  );

  static final _getAnnotation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.maplibre.android.annotations.Annotation getAnnotation(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAnnotation(int j) {
    return _getAnnotation(
      reference.pointer,
      _id_getAnnotation as jni$_.JMethodIDPtr,
      j,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAnnotations = _class.instanceMethodId(
    r'getAnnotations',
    r'()Ljava/util/List;',
  );

  static final _getAnnotations =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getAnnotations()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getAnnotations() {
    return _getAnnotations(
      reference.pointer,
      _id_getAnnotations as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
    );
  }

  static final _id_getMarkers = _class.instanceMethodId(
    r'getMarkers',
    r'()Ljava/util/List;',
  );

  static final _getMarkers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getMarkers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getMarkers() {
    return _getMarkers(
      reference.pointer,
      _id_getMarkers as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
    );
  }

  static final _id_getPolygons = _class.instanceMethodId(
    r'getPolygons',
    r'()Ljava/util/List;',
  );

  static final _getPolygons =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getPolygons()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getPolygons() {
    return _getPolygons(
      reference.pointer,
      _id_getPolygons as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
    );
  }

  static final _id_getPolylines = _class.instanceMethodId(
    r'getPolylines',
    r'()Ljava/util/List;',
  );

  static final _getPolylines =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getPolylines()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getPolylines() {
    return _getPolylines(
      reference.pointer,
      _id_getPolylines as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
    );
  }

  static final _id_setOnMarkerClickListener = _class.instanceMethodId(
    r'setOnMarkerClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMarkerClickListener;)V',
  );

  static final _setOnMarkerClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOnMarkerClickListener(org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener onMarkerClickListener)`
  void setOnMarkerClickListener(
    MapLibreMap$OnMarkerClickListener? onMarkerClickListener,
  ) {
    final _$onMarkerClickListener =
        onMarkerClickListener?.reference ?? jni$_.jNullReference;
    _setOnMarkerClickListener(
      reference.pointer,
      _id_setOnMarkerClickListener as jni$_.JMethodIDPtr,
      _$onMarkerClickListener.pointer,
    ).check();
  }

  static final _id_setOnPolygonClickListener = _class.instanceMethodId(
    r'setOnPolygonClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnPolygonClickListener;)V',
  );

  static final _setOnPolygonClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOnPolygonClickListener(org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener onPolygonClickListener)`
  void setOnPolygonClickListener(
    MapLibreMap$OnPolygonClickListener? onPolygonClickListener,
  ) {
    final _$onPolygonClickListener =
        onPolygonClickListener?.reference ?? jni$_.jNullReference;
    _setOnPolygonClickListener(
      reference.pointer,
      _id_setOnPolygonClickListener as jni$_.JMethodIDPtr,
      _$onPolygonClickListener.pointer,
    ).check();
  }

  static final _id_setOnPolylineClickListener = _class.instanceMethodId(
    r'setOnPolylineClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnPolylineClickListener;)V',
  );

  static final _setOnPolylineClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOnPolylineClickListener(org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener onPolylineClickListener)`
  void setOnPolylineClickListener(
    MapLibreMap$OnPolylineClickListener? onPolylineClickListener,
  ) {
    final _$onPolylineClickListener =
        onPolylineClickListener?.reference ?? jni$_.jNullReference;
    _setOnPolylineClickListener(
      reference.pointer,
      _id_setOnPolylineClickListener as jni$_.JMethodIDPtr,
      _$onPolylineClickListener.pointer,
    ).check();
  }

  static final _id_selectMarker = _class.instanceMethodId(
    r'selectMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _selectMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void selectMarker(org.maplibre.android.annotations.Marker marker)`
  void selectMarker(jni$_.JObject marker) {
    final _$marker = marker.reference;
    _selectMarker(
      reference.pointer,
      _id_selectMarker as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).check();
  }

  static final _id_deselectMarkers = _class.instanceMethodId(
    r'deselectMarkers',
    r'()V',
  );

  static final _deselectMarkers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void deselectMarkers()`
  void deselectMarkers() {
    _deselectMarkers(
      reference.pointer,
      _id_deselectMarkers as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_deselectMarker = _class.instanceMethodId(
    r'deselectMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _deselectMarker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void deselectMarker(org.maplibre.android.annotations.Marker marker)`
  void deselectMarker(jni$_.JObject marker) {
    final _$marker = marker.reference;
    _deselectMarker(
      reference.pointer,
      _id_deselectMarker as jni$_.JMethodIDPtr,
      _$marker.pointer,
    ).check();
  }

  static final _id_getSelectedMarkers = _class.instanceMethodId(
    r'getSelectedMarkers',
    r'()Ljava/util/List;',
  );

  static final _getSelectedMarkers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getSelectedMarkers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getSelectedMarkers() {
    return _getSelectedMarkers(
      reference.pointer,
      _id_getSelectedMarkers as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
    );
  }

  static final _id_setInfoWindowAdapter = _class.instanceMethodId(
    r'setInfoWindowAdapter',
    r'(Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;)V',
  );

  static final _setInfoWindowAdapter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setInfoWindowAdapter(org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter infoWindowAdapter)`
  void setInfoWindowAdapter(MapLibreMap$InfoWindowAdapter? infoWindowAdapter) {
    final _$infoWindowAdapter =
        infoWindowAdapter?.reference ?? jni$_.jNullReference;
    _setInfoWindowAdapter(
      reference.pointer,
      _id_setInfoWindowAdapter as jni$_.JMethodIDPtr,
      _$infoWindowAdapter.pointer,
    ).check();
  }

  static final _id_getInfoWindowAdapter = _class.instanceMethodId(
    r'getInfoWindowAdapter',
    r'()Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;',
  );

  static final _getInfoWindowAdapter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter getInfoWindowAdapter()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap$InfoWindowAdapter? getInfoWindowAdapter() {
    return _getInfoWindowAdapter(
      reference.pointer,
      _id_getInfoWindowAdapter as jni$_.JMethodIDPtr,
    ).object<MapLibreMap$InfoWindowAdapter?>(
      const $MapLibreMap$InfoWindowAdapter$NullableType(),
    );
  }

  static final _id_setAllowConcurrentMultipleOpenInfoWindows = _class
      .instanceMethodId(r'setAllowConcurrentMultipleOpenInfoWindows', r'(Z)V');

  static final _setAllowConcurrentMultipleOpenInfoWindows =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setAllowConcurrentMultipleOpenInfoWindows(boolean z)`
  void setAllowConcurrentMultipleOpenInfoWindows(bool z) {
    _setAllowConcurrentMultipleOpenInfoWindows(
      reference.pointer,
      _id_setAllowConcurrentMultipleOpenInfoWindows as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_isAllowConcurrentMultipleOpenInfoWindows = _class
      .instanceMethodId(r'isAllowConcurrentMultipleOpenInfoWindows', r'()Z');

  static final _isAllowConcurrentMultipleOpenInfoWindows =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAllowConcurrentMultipleOpenInfoWindows()`
  bool isAllowConcurrentMultipleOpenInfoWindows() {
    return _isAllowConcurrentMultipleOpenInfoWindows(
      reference.pointer,
      _id_isAllowConcurrentMultipleOpenInfoWindows as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setLatLngBoundsForCameraTarget = _class.instanceMethodId(
    r'setLatLngBoundsForCameraTarget',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;)V',
  );

  static final _setLatLngBoundsForCameraTarget =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setLatLngBoundsForCameraTarget(org.maplibre.android.geometry.LatLngBounds latLngBounds)`
  void setLatLngBoundsForCameraTarget(
    latlngbounds$_.LatLngBounds? latLngBounds,
  ) {
    final _$latLngBounds = latLngBounds?.reference ?? jni$_.jNullReference;
    _setLatLngBoundsForCameraTarget(
      reference.pointer,
      _id_setLatLngBoundsForCameraTarget as jni$_.JMethodIDPtr,
      _$latLngBounds.pointer,
    ).check();
  }

  static final _id_getCameraForLatLngBounds = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCameraForLatLngBounds(
    latlngbounds$_.LatLngBounds latLngBounds,
  ) {
    final _$latLngBounds = latLngBounds.reference;
    return _getCameraForLatLngBounds(
      reference.pointer,
      _id_getCameraForLatLngBounds as jni$_.JMethodIDPtr,
      _$latLngBounds.pointer,
    ).object<cameraposition$_.CameraPosition?>(
      const cameraposition$_.$CameraPosition$NullableType(),
    );
  }

  static final _id_getCameraForLatLngBounds$1 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;[I)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCameraForLatLngBounds$1(
    latlngbounds$_.LatLngBounds latLngBounds,
    jni$_.JIntArray is$,
  ) {
    final _$latLngBounds = latLngBounds.reference;
    final _$is$ = is$.reference;
    return _getCameraForLatLngBounds$1(
      reference.pointer,
      _id_getCameraForLatLngBounds$1 as jni$_.JMethodIDPtr,
      _$latLngBounds.pointer,
      _$is$.pointer,
    ).object<cameraposition$_.CameraPosition?>(
      const cameraposition$_.$CameraPosition$NullableType(),
    );
  }

  static final _id_getCameraForLatLngBounds$2 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;DD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Double, jni$_.Double)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
              double,
            )
          >();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCameraForLatLngBounds$2(
    latlngbounds$_.LatLngBounds latLngBounds,
    double d,
    double d1,
  ) {
    final _$latLngBounds = latLngBounds.reference;
    return _getCameraForLatLngBounds$2(
      reference.pointer,
      _id_getCameraForLatLngBounds$2 as jni$_.JMethodIDPtr,
      _$latLngBounds.pointer,
      d,
      d1,
    ).object<cameraposition$_.CameraPosition?>(
      const cameraposition$_.$CameraPosition$NullableType(),
    );
  }

  static final _id_getCameraForLatLngBounds$3 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;[IDD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Double,
                    jni$_.Double,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              double,
              double,
            )
          >();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, int[] is, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCameraForLatLngBounds$3(
    latlngbounds$_.LatLngBounds latLngBounds,
    jni$_.JIntArray is$,
    double d,
    double d1,
  ) {
    final _$latLngBounds = latLngBounds.reference;
    final _$is$ = is$.reference;
    return _getCameraForLatLngBounds$3(
      reference.pointer,
      _id_getCameraForLatLngBounds$3 as jni$_.JMethodIDPtr,
      _$latLngBounds.pointer,
      _$is$.pointer,
      d,
      d1,
    ).object<cameraposition$_.CameraPosition?>(
      const cameraposition$_.$CameraPosition$NullableType(),
    );
  }

  static final _id_getCameraForGeometry = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCameraForGeometry(
    jni$_.JObject geometry,
  ) {
    final _$geometry = geometry.reference;
    return _getCameraForGeometry(
      reference.pointer,
      _id_getCameraForGeometry as jni$_.JMethodIDPtr,
      _$geometry.pointer,
    ).object<cameraposition$_.CameraPosition?>(
      const cameraposition$_.$CameraPosition$NullableType(),
    );
  }

  static final _id_getCameraForGeometry$1 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;[I)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCameraForGeometry$1(
    jni$_.JObject geometry,
    jni$_.JIntArray is$,
  ) {
    final _$geometry = geometry.reference;
    final _$is$ = is$.reference;
    return _getCameraForGeometry$1(
      reference.pointer,
      _id_getCameraForGeometry$1 as jni$_.JMethodIDPtr,
      _$geometry.pointer,
      _$is$.pointer,
    ).object<cameraposition$_.CameraPosition?>(
      const cameraposition$_.$CameraPosition$NullableType(),
    );
  }

  static final _id_getCameraForGeometry$2 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;DD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Double, jni$_.Double)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
              double,
            )
          >();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCameraForGeometry$2(
    jni$_.JObject geometry,
    double d,
    double d1,
  ) {
    final _$geometry = geometry.reference;
    return _getCameraForGeometry$2(
      reference.pointer,
      _id_getCameraForGeometry$2 as jni$_.JMethodIDPtr,
      _$geometry.pointer,
      d,
      d1,
    ).object<cameraposition$_.CameraPosition?>(
      const cameraposition$_.$CameraPosition$NullableType(),
    );
  }

  static final _id_getCameraForGeometry$3 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;[IDD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Double,
                    jni$_.Double,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              double,
              double,
            )
          >();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, int[] is, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition$_.CameraPosition? getCameraForGeometry$3(
    jni$_.JObject geometry,
    jni$_.JIntArray is$,
    double d,
    double d1,
  ) {
    final _$geometry = geometry.reference;
    final _$is$ = is$.reference;
    return _getCameraForGeometry$3(
      reference.pointer,
      _id_getCameraForGeometry$3 as jni$_.JMethodIDPtr,
      _$geometry.pointer,
      _$is$.pointer,
      d,
      d1,
    ).object<cameraposition$_.CameraPosition?>(
      const cameraposition$_.$CameraPosition$NullableType(),
    );
  }

  static final _id_setPadding = _class.instanceMethodId(
    r'setPadding',
    r'(IIII)V',
  );

  static final _setPadding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public void setPadding(int i, int i1, int i2, int i3)`
  void setPadding(int i, int i1, int i2, int i3) {
    _setPadding(
      reference.pointer,
      _id_setPadding as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
    ).check();
  }

  static final _id_getPadding = _class.instanceMethodId(r'getPadding', r'()[I');

  static final _getPadding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int[] getPadding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray getPadding() {
    return _getPadding(
      reference.pointer,
      _id_getPadding as jni$_.JMethodIDPtr,
    ).object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_addOnCameraIdleListener = _class.instanceMethodId(
    r'addOnCameraIdleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;)V',
  );

  static final _addOnCameraIdleListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnCameraIdleListener(org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener onCameraIdleListener)`
  void addOnCameraIdleListener(
    MapLibreMap$OnCameraIdleListener onCameraIdleListener,
  ) {
    final _$onCameraIdleListener = onCameraIdleListener.reference;
    _addOnCameraIdleListener(
      reference.pointer,
      _id_addOnCameraIdleListener as jni$_.JMethodIDPtr,
      _$onCameraIdleListener.pointer,
    ).check();
  }

  static final _id_removeOnCameraIdleListener = _class.instanceMethodId(
    r'removeOnCameraIdleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;)V',
  );

  static final _removeOnCameraIdleListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnCameraIdleListener(org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener onCameraIdleListener)`
  void removeOnCameraIdleListener(
    MapLibreMap$OnCameraIdleListener onCameraIdleListener,
  ) {
    final _$onCameraIdleListener = onCameraIdleListener.reference;
    _removeOnCameraIdleListener(
      reference.pointer,
      _id_removeOnCameraIdleListener as jni$_.JMethodIDPtr,
      _$onCameraIdleListener.pointer,
    ).check();
  }

  static final _id_addOnCameraMoveCancelListener = _class.instanceMethodId(
    r'addOnCameraMoveCancelListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;)V',
  );

  static final _addOnCameraMoveCancelListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnCameraMoveCancelListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener onCameraMoveCanceledListener)`
  void addOnCameraMoveCancelListener(
    MapLibreMap$OnCameraMoveCanceledListener onCameraMoveCanceledListener,
  ) {
    final _$onCameraMoveCanceledListener =
        onCameraMoveCanceledListener.reference;
    _addOnCameraMoveCancelListener(
      reference.pointer,
      _id_addOnCameraMoveCancelListener as jni$_.JMethodIDPtr,
      _$onCameraMoveCanceledListener.pointer,
    ).check();
  }

  static final _id_removeOnCameraMoveCancelListener = _class.instanceMethodId(
    r'removeOnCameraMoveCancelListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;)V',
  );

  static final _removeOnCameraMoveCancelListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnCameraMoveCancelListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener onCameraMoveCanceledListener)`
  void removeOnCameraMoveCancelListener(
    MapLibreMap$OnCameraMoveCanceledListener onCameraMoveCanceledListener,
  ) {
    final _$onCameraMoveCanceledListener =
        onCameraMoveCanceledListener.reference;
    _removeOnCameraMoveCancelListener(
      reference.pointer,
      _id_removeOnCameraMoveCancelListener as jni$_.JMethodIDPtr,
      _$onCameraMoveCanceledListener.pointer,
    ).check();
  }

  static final _id_addOnCameraMoveStartedListener = _class.instanceMethodId(
    r'addOnCameraMoveStartedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;)V',
  );

  static final _addOnCameraMoveStartedListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnCameraMoveStartedListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener onCameraMoveStartedListener)`
  void addOnCameraMoveStartedListener(
    MapLibreMap$OnCameraMoveStartedListener onCameraMoveStartedListener,
  ) {
    final _$onCameraMoveStartedListener = onCameraMoveStartedListener.reference;
    _addOnCameraMoveStartedListener(
      reference.pointer,
      _id_addOnCameraMoveStartedListener as jni$_.JMethodIDPtr,
      _$onCameraMoveStartedListener.pointer,
    ).check();
  }

  static final _id_removeOnCameraMoveStartedListener = _class.instanceMethodId(
    r'removeOnCameraMoveStartedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;)V',
  );

  static final _removeOnCameraMoveStartedListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnCameraMoveStartedListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener onCameraMoveStartedListener)`
  void removeOnCameraMoveStartedListener(
    MapLibreMap$OnCameraMoveStartedListener onCameraMoveStartedListener,
  ) {
    final _$onCameraMoveStartedListener = onCameraMoveStartedListener.reference;
    _removeOnCameraMoveStartedListener(
      reference.pointer,
      _id_removeOnCameraMoveStartedListener as jni$_.JMethodIDPtr,
      _$onCameraMoveStartedListener.pointer,
    ).check();
  }

  static final _id_addOnCameraMoveListener = _class.instanceMethodId(
    r'addOnCameraMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;)V',
  );

  static final _addOnCameraMoveListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnCameraMoveListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener onCameraMoveListener)`
  void addOnCameraMoveListener(
    MapLibreMap$OnCameraMoveListener onCameraMoveListener,
  ) {
    final _$onCameraMoveListener = onCameraMoveListener.reference;
    _addOnCameraMoveListener(
      reference.pointer,
      _id_addOnCameraMoveListener as jni$_.JMethodIDPtr,
      _$onCameraMoveListener.pointer,
    ).check();
  }

  static final _id_removeOnCameraMoveListener = _class.instanceMethodId(
    r'removeOnCameraMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;)V',
  );

  static final _removeOnCameraMoveListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnCameraMoveListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener onCameraMoveListener)`
  void removeOnCameraMoveListener(
    MapLibreMap$OnCameraMoveListener onCameraMoveListener,
  ) {
    final _$onCameraMoveListener = onCameraMoveListener.reference;
    _removeOnCameraMoveListener(
      reference.pointer,
      _id_removeOnCameraMoveListener as jni$_.JMethodIDPtr,
      _$onCameraMoveListener.pointer,
    ).check();
  }

  static final _id_setOnFpsChangedListener = _class.instanceMethodId(
    r'setOnFpsChangedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFpsChangedListener;)V',
  );

  static final _setOnFpsChangedListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOnFpsChangedListener(org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener onFpsChangedListener)`
  void setOnFpsChangedListener(
    MapLibreMap$OnFpsChangedListener? onFpsChangedListener,
  ) {
    final _$onFpsChangedListener =
        onFpsChangedListener?.reference ?? jni$_.jNullReference;
    _setOnFpsChangedListener(
      reference.pointer,
      _id_setOnFpsChangedListener as jni$_.JMethodIDPtr,
      _$onFpsChangedListener.pointer,
    ).check();
  }

  static final _id_addOnFlingListener = _class.instanceMethodId(
    r'addOnFlingListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;)V',
  );

  static final _addOnFlingListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnFlingListener(org.maplibre.android.maps.MapLibreMap$OnFlingListener onFlingListener)`
  void addOnFlingListener(MapLibreMap$OnFlingListener onFlingListener) {
    final _$onFlingListener = onFlingListener.reference;
    _addOnFlingListener(
      reference.pointer,
      _id_addOnFlingListener as jni$_.JMethodIDPtr,
      _$onFlingListener.pointer,
    ).check();
  }

  static final _id_removeOnFlingListener = _class.instanceMethodId(
    r'removeOnFlingListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;)V',
  );

  static final _removeOnFlingListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnFlingListener(org.maplibre.android.maps.MapLibreMap$OnFlingListener onFlingListener)`
  void removeOnFlingListener(MapLibreMap$OnFlingListener onFlingListener) {
    final _$onFlingListener = onFlingListener.reference;
    _removeOnFlingListener(
      reference.pointer,
      _id_removeOnFlingListener as jni$_.JMethodIDPtr,
      _$onFlingListener.pointer,
    ).check();
  }

  static final _id_addOnMoveListener = _class.instanceMethodId(
    r'addOnMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;)V',
  );

  static final _addOnMoveListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnMoveListener(org.maplibre.android.maps.MapLibreMap$OnMoveListener onMoveListener)`
  void addOnMoveListener(MapLibreMap$OnMoveListener onMoveListener) {
    final _$onMoveListener = onMoveListener.reference;
    _addOnMoveListener(
      reference.pointer,
      _id_addOnMoveListener as jni$_.JMethodIDPtr,
      _$onMoveListener.pointer,
    ).check();
  }

  static final _id_removeOnMoveListener = _class.instanceMethodId(
    r'removeOnMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;)V',
  );

  static final _removeOnMoveListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnMoveListener(org.maplibre.android.maps.MapLibreMap$OnMoveListener onMoveListener)`
  void removeOnMoveListener(MapLibreMap$OnMoveListener onMoveListener) {
    final _$onMoveListener = onMoveListener.reference;
    _removeOnMoveListener(
      reference.pointer,
      _id_removeOnMoveListener as jni$_.JMethodIDPtr,
      _$onMoveListener.pointer,
    ).check();
  }

  static final _id_addOnRotateListener = _class.instanceMethodId(
    r'addOnRotateListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;)V',
  );

  static final _addOnRotateListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnRotateListener(org.maplibre.android.maps.MapLibreMap$OnRotateListener onRotateListener)`
  void addOnRotateListener(MapLibreMap$OnRotateListener onRotateListener) {
    final _$onRotateListener = onRotateListener.reference;
    _addOnRotateListener(
      reference.pointer,
      _id_addOnRotateListener as jni$_.JMethodIDPtr,
      _$onRotateListener.pointer,
    ).check();
  }

  static final _id_removeOnRotateListener = _class.instanceMethodId(
    r'removeOnRotateListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;)V',
  );

  static final _removeOnRotateListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnRotateListener(org.maplibre.android.maps.MapLibreMap$OnRotateListener onRotateListener)`
  void removeOnRotateListener(MapLibreMap$OnRotateListener onRotateListener) {
    final _$onRotateListener = onRotateListener.reference;
    _removeOnRotateListener(
      reference.pointer,
      _id_removeOnRotateListener as jni$_.JMethodIDPtr,
      _$onRotateListener.pointer,
    ).check();
  }

  static final _id_addOnScaleListener = _class.instanceMethodId(
    r'addOnScaleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;)V',
  );

  static final _addOnScaleListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnScaleListener(org.maplibre.android.maps.MapLibreMap$OnScaleListener onScaleListener)`
  void addOnScaleListener(MapLibreMap$OnScaleListener onScaleListener) {
    final _$onScaleListener = onScaleListener.reference;
    _addOnScaleListener(
      reference.pointer,
      _id_addOnScaleListener as jni$_.JMethodIDPtr,
      _$onScaleListener.pointer,
    ).check();
  }

  static final _id_removeOnScaleListener = _class.instanceMethodId(
    r'removeOnScaleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;)V',
  );

  static final _removeOnScaleListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnScaleListener(org.maplibre.android.maps.MapLibreMap$OnScaleListener onScaleListener)`
  void removeOnScaleListener(MapLibreMap$OnScaleListener onScaleListener) {
    final _$onScaleListener = onScaleListener.reference;
    _removeOnScaleListener(
      reference.pointer,
      _id_removeOnScaleListener as jni$_.JMethodIDPtr,
      _$onScaleListener.pointer,
    ).check();
  }

  static final _id_addOnShoveListener = _class.instanceMethodId(
    r'addOnShoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;)V',
  );

  static final _addOnShoveListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnShoveListener(org.maplibre.android.maps.MapLibreMap$OnShoveListener onShoveListener)`
  void addOnShoveListener(MapLibreMap$OnShoveListener onShoveListener) {
    final _$onShoveListener = onShoveListener.reference;
    _addOnShoveListener(
      reference.pointer,
      _id_addOnShoveListener as jni$_.JMethodIDPtr,
      _$onShoveListener.pointer,
    ).check();
  }

  static final _id_removeOnShoveListener = _class.instanceMethodId(
    r'removeOnShoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;)V',
  );

  static final _removeOnShoveListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnShoveListener(org.maplibre.android.maps.MapLibreMap$OnShoveListener onShoveListener)`
  void removeOnShoveListener(MapLibreMap$OnShoveListener onShoveListener) {
    final _$onShoveListener = onShoveListener.reference;
    _removeOnShoveListener(
      reference.pointer,
      _id_removeOnShoveListener as jni$_.JMethodIDPtr,
      _$onShoveListener.pointer,
    ).check();
  }

  static final _id_setGesturesManager = _class.instanceMethodId(
    r'setGesturesManager',
    r'(Lorg/maplibre/android/gestures/AndroidGesturesManager;ZZ)V',
  );

  static final _setGesturesManager =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void setGesturesManager(org.maplibre.android.gestures.AndroidGesturesManager androidGesturesManager, boolean z, boolean z1)`
  void setGesturesManager(
    jni$_.JObject androidGesturesManager,
    bool z,
    bool z1,
  ) {
    final _$androidGesturesManager = androidGesturesManager.reference;
    _setGesturesManager(
      reference.pointer,
      _id_setGesturesManager as jni$_.JMethodIDPtr,
      _$androidGesturesManager.pointer,
      z ? 1 : 0,
      z1 ? 1 : 0,
    ).check();
  }

  static final _id_getGesturesManager = _class.instanceMethodId(
    r'getGesturesManager',
    r'()Lorg/maplibre/android/gestures/AndroidGesturesManager;',
  );

  static final _getGesturesManager =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.gestures.AndroidGesturesManager getGesturesManager()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getGesturesManager() {
    return _getGesturesManager(
      reference.pointer,
      _id_getGesturesManager as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_cancelAllVelocityAnimations = _class.instanceMethodId(
    r'cancelAllVelocityAnimations',
    r'()V',
  );

  static final _cancelAllVelocityAnimations =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void cancelAllVelocityAnimations()`
  void cancelAllVelocityAnimations() {
    _cancelAllVelocityAnimations(
      reference.pointer,
      _id_cancelAllVelocityAnimations as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_addOnMapClickListener = _class.instanceMethodId(
    r'addOnMapClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;)V',
  );

  static final _addOnMapClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnMapClickListener(org.maplibre.android.maps.MapLibreMap$OnMapClickListener onMapClickListener)`
  void addOnMapClickListener(
    MapLibreMap$OnMapClickListener onMapClickListener,
  ) {
    final _$onMapClickListener = onMapClickListener.reference;
    _addOnMapClickListener(
      reference.pointer,
      _id_addOnMapClickListener as jni$_.JMethodIDPtr,
      _$onMapClickListener.pointer,
    ).check();
  }

  static final _id_removeOnMapClickListener = _class.instanceMethodId(
    r'removeOnMapClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;)V',
  );

  static final _removeOnMapClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnMapClickListener(org.maplibre.android.maps.MapLibreMap$OnMapClickListener onMapClickListener)`
  void removeOnMapClickListener(
    MapLibreMap$OnMapClickListener onMapClickListener,
  ) {
    final _$onMapClickListener = onMapClickListener.reference;
    _removeOnMapClickListener(
      reference.pointer,
      _id_removeOnMapClickListener as jni$_.JMethodIDPtr,
      _$onMapClickListener.pointer,
    ).check();
  }

  static final _id_addOnMapLongClickListener = _class.instanceMethodId(
    r'addOnMapLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;)V',
  );

  static final _addOnMapLongClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addOnMapLongClickListener(org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener onMapLongClickListener)`
  void addOnMapLongClickListener(
    MapLibreMap$OnMapLongClickListener onMapLongClickListener,
  ) {
    final _$onMapLongClickListener = onMapLongClickListener.reference;
    _addOnMapLongClickListener(
      reference.pointer,
      _id_addOnMapLongClickListener as jni$_.JMethodIDPtr,
      _$onMapLongClickListener.pointer,
    ).check();
  }

  static final _id_removeOnMapLongClickListener = _class.instanceMethodId(
    r'removeOnMapLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;)V',
  );

  static final _removeOnMapLongClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeOnMapLongClickListener(org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener onMapLongClickListener)`
  void removeOnMapLongClickListener(
    MapLibreMap$OnMapLongClickListener onMapLongClickListener,
  ) {
    final _$onMapLongClickListener = onMapLongClickListener.reference;
    _removeOnMapLongClickListener(
      reference.pointer,
      _id_removeOnMapLongClickListener as jni$_.JMethodIDPtr,
      _$onMapLongClickListener.pointer,
    ).check();
  }

  static final _id_setOnInfoWindowClickListener = _class.instanceMethodId(
    r'setOnInfoWindowClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;)V',
  );

  static final _setOnInfoWindowClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOnInfoWindowClickListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener onInfoWindowClickListener)`
  void setOnInfoWindowClickListener(
    MapLibreMap$OnInfoWindowClickListener? onInfoWindowClickListener,
  ) {
    final _$onInfoWindowClickListener =
        onInfoWindowClickListener?.reference ?? jni$_.jNullReference;
    _setOnInfoWindowClickListener(
      reference.pointer,
      _id_setOnInfoWindowClickListener as jni$_.JMethodIDPtr,
      _$onInfoWindowClickListener.pointer,
    ).check();
  }

  static final _id_getOnInfoWindowClickListener = _class.instanceMethodId(
    r'getOnInfoWindowClickListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;',
  );

  static final _getOnInfoWindowClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener getOnInfoWindowClickListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap$OnInfoWindowClickListener? getOnInfoWindowClickListener() {
    return _getOnInfoWindowClickListener(
      reference.pointer,
      _id_getOnInfoWindowClickListener as jni$_.JMethodIDPtr,
    ).object<MapLibreMap$OnInfoWindowClickListener?>(
      const $MapLibreMap$OnInfoWindowClickListener$NullableType(),
    );
  }

  static final _id_setOnInfoWindowLongClickListener = _class.instanceMethodId(
    r'setOnInfoWindowLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;)V',
  );

  static final _setOnInfoWindowLongClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOnInfoWindowLongClickListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener onInfoWindowLongClickListener)`
  void setOnInfoWindowLongClickListener(
    MapLibreMap$OnInfoWindowLongClickListener? onInfoWindowLongClickListener,
  ) {
    final _$onInfoWindowLongClickListener =
        onInfoWindowLongClickListener?.reference ?? jni$_.jNullReference;
    _setOnInfoWindowLongClickListener(
      reference.pointer,
      _id_setOnInfoWindowLongClickListener as jni$_.JMethodIDPtr,
      _$onInfoWindowLongClickListener.pointer,
    ).check();
  }

  static final _id_getOnInfoWindowLongClickListener = _class.instanceMethodId(
    r'getOnInfoWindowLongClickListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;',
  );

  static final _getOnInfoWindowLongClickListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener getOnInfoWindowLongClickListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap$OnInfoWindowLongClickListener?
  getOnInfoWindowLongClickListener() {
    return _getOnInfoWindowLongClickListener(
      reference.pointer,
      _id_getOnInfoWindowLongClickListener as jni$_.JMethodIDPtr,
    ).object<MapLibreMap$OnInfoWindowLongClickListener?>(
      const $MapLibreMap$OnInfoWindowLongClickListener$NullableType(),
    );
  }

  static final _id_setOnInfoWindowCloseListener = _class.instanceMethodId(
    r'setOnInfoWindowCloseListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;)V',
  );

  static final _setOnInfoWindowCloseListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setOnInfoWindowCloseListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener onInfoWindowCloseListener)`
  void setOnInfoWindowCloseListener(
    MapLibreMap$OnInfoWindowCloseListener? onInfoWindowCloseListener,
  ) {
    final _$onInfoWindowCloseListener =
        onInfoWindowCloseListener?.reference ?? jni$_.jNullReference;
    _setOnInfoWindowCloseListener(
      reference.pointer,
      _id_setOnInfoWindowCloseListener as jni$_.JMethodIDPtr,
      _$onInfoWindowCloseListener.pointer,
    ).check();
  }

  static final _id_getOnInfoWindowCloseListener = _class.instanceMethodId(
    r'getOnInfoWindowCloseListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;',
  );

  static final _getOnInfoWindowCloseListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener getOnInfoWindowCloseListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap$OnInfoWindowCloseListener? getOnInfoWindowCloseListener() {
    return _getOnInfoWindowCloseListener(
      reference.pointer,
      _id_getOnInfoWindowCloseListener as jni$_.JMethodIDPtr,
    ).object<MapLibreMap$OnInfoWindowCloseListener?>(
      const $MapLibreMap$OnInfoWindowCloseListener$NullableType(),
    );
  }

  static final _id_snapshot = _class.instanceMethodId(
    r'snapshot',
    r'(Lorg/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback;)V',
  );

  static final _snapshot =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void snapshot(org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback snapshotReadyCallback)`
  void snapshot(MapLibreMap$SnapshotReadyCallback snapshotReadyCallback) {
    final _$snapshotReadyCallback = snapshotReadyCallback.reference;
    _snapshot(
      reference.pointer,
      _id_snapshot as jni$_.JMethodIDPtr,
      _$snapshotReadyCallback.pointer,
    ).check();
  }

  static final _id_queryRenderedFeatures = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/PointF;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.PointF pointF, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<feature$_.Feature?> queryRenderedFeatures(
    pointf$_.PointF pointF,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$pointF = pointF.reference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return _queryRenderedFeatures(
      reference.pointer,
      _id_queryRenderedFeatures as jni$_.JMethodIDPtr,
      _$pointF.pointer,
      _$strings.pointer,
    ).object<jni$_.JList<feature$_.Feature?>>(
      const jni$_.JListType<feature$_.Feature?>(
        feature$_.$Feature$NullableType(),
      ),
    );
  }

  static final _id_queryRenderedFeatures$1 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/PointF;Lorg/maplibre/android/style/expressions/Expression;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.PointF pointF, org.maplibre.android.style.expressions.Expression expression, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<feature$_.Feature?> queryRenderedFeatures$1(
    pointf$_.PointF pointF,
    jni$_.JObject? expression,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$pointF = pointF.reference;
    final _$expression = expression?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return _queryRenderedFeatures$1(
      reference.pointer,
      _id_queryRenderedFeatures$1 as jni$_.JMethodIDPtr,
      _$pointF.pointer,
      _$expression.pointer,
      _$strings.pointer,
    ).object<jni$_.JList<feature$_.Feature?>>(
      const jni$_.JListType<feature$_.Feature?>(
        feature$_.$Feature$NullableType(),
      ),
    );
  }

  static final _id_queryRenderedFeatures$2 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/RectF;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.RectF rectF, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<feature$_.Feature?> queryRenderedFeatures$2(
    jni$_.JObject rectF,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$rectF = rectF.reference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return _queryRenderedFeatures$2(
      reference.pointer,
      _id_queryRenderedFeatures$2 as jni$_.JMethodIDPtr,
      _$rectF.pointer,
      _$strings.pointer,
    ).object<jni$_.JList<feature$_.Feature?>>(
      const jni$_.JListType<feature$_.Feature?>(
        feature$_.$Feature$NullableType(),
      ),
    );
  }

  static final _id_queryRenderedFeatures$3 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/RectF;Lorg/maplibre/android/style/expressions/Expression;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.RectF rectF, org.maplibre.android.style.expressions.Expression expression, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<feature$_.Feature?> queryRenderedFeatures$3(
    jni$_.JObject rectF,
    jni$_.JObject? expression,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$rectF = rectF.reference;
    final _$expression = expression?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return _queryRenderedFeatures$3(
      reference.pointer,
      _id_queryRenderedFeatures$3 as jni$_.JMethodIDPtr,
      _$rectF.pointer,
      _$expression.pointer,
      _$strings.pointer,
    ).object<jni$_.JList<feature$_.Feature?>>(
      const jni$_.JListType<feature$_.Feature?>(
        feature$_.$Feature$NullableType(),
      ),
    );
  }

  static final _id_getLocationComponent = _class.instanceMethodId(
    r'getLocationComponent',
    r'()Lorg/maplibre/android/location/LocationComponent;',
  );

  static final _getLocationComponent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.location.LocationComponent getLocationComponent()`
  /// The returned object must be released after use, by calling the [release] method.
  locationcomponent$_.LocationComponent getLocationComponent() {
    return _getLocationComponent(
      reference.pointer,
      _id_getLocationComponent as jni$_.JMethodIDPtr,
    ).object<locationcomponent$_.LocationComponent>(
      const locationcomponent$_.$LocationComponent$Type(),
    );
  }
}

final class $MapLibreMap$NullableType extends jni$_.JObjType<MapLibreMap?> {
  @jni$_.internal
  const $MapLibreMap$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/MapLibreMap;';

  @jni$_.internal
  @core$_.override
  MapLibreMap? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : MapLibreMap.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$NullableType) &&
        other is $MapLibreMap$NullableType;
  }
}

final class $MapLibreMap$Type extends jni$_.JObjType<MapLibreMap> {
  @jni$_.internal
  const $MapLibreMap$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/MapLibreMap;';

  @jni$_.internal
  @core$_.override
  MapLibreMap fromReference(jni$_.JReference reference) =>
      MapLibreMap.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapLibreMap?> get nullableType =>
      const $MapLibreMap$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapLibreMap$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$Type) &&
        other is $MapLibreMap$Type;
  }
}
