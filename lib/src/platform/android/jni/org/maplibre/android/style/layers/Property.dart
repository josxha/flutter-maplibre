// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: type=lint

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `org.maplibre.android.style.layers.Property$ANCHOR`
class Property$ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$ANCHOR> $type;

  @jni$_.internal
  Property$ANCHOR.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$ANCHOR$NullableType();
  static const type = $Property$ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$ANCHOR> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$ANCHOR.implement($Property$ANCHOR $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$ANCHOR.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$ANCHOR {
  factory $Property$ANCHOR() = _$Property$ANCHOR;
}

final class _$Property$ANCHOR with $Property$ANCHOR {
  _$Property$ANCHOR();
}

final class $Property$ANCHOR$NullableType
    extends jni$_.JObjType<Property$ANCHOR?> {
  @jni$_.internal
  const $Property$ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$ANCHOR? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property$ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ANCHOR?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ANCHOR$NullableType) &&
        other is $Property$ANCHOR$NullableType;
  }
}

final class $Property$ANCHOR$Type extends jni$_.JObjType<Property$ANCHOR> {
  @jni$_.internal
  const $Property$ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$ANCHOR fromReference(jni$_.JReference reference) =>
      Property$ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ANCHOR?> get nullableType =>
      const $Property$ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ANCHOR$Type) &&
        other is $Property$ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_PITCH_ALIGNMENT`
class Property$CIRCLE_PITCH_ALIGNMENT extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$CIRCLE_PITCH_ALIGNMENT> $type;

  @jni$_.internal
  Property$CIRCLE_PITCH_ALIGNMENT.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$CIRCLE_PITCH_ALIGNMENT$NullableType();
  static const type = $Property$CIRCLE_PITCH_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$CIRCLE_PITCH_ALIGNMENT> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$CIRCLE_PITCH_ALIGNMENT $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$CIRCLE_PITCH_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$CIRCLE_PITCH_ALIGNMENT.implement(
    $Property$CIRCLE_PITCH_ALIGNMENT $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$CIRCLE_PITCH_ALIGNMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$CIRCLE_PITCH_ALIGNMENT {
  factory $Property$CIRCLE_PITCH_ALIGNMENT() =
      _$Property$CIRCLE_PITCH_ALIGNMENT;
}

final class _$Property$CIRCLE_PITCH_ALIGNMENT
    with $Property$CIRCLE_PITCH_ALIGNMENT {
  _$Property$CIRCLE_PITCH_ALIGNMENT();
}

final class $Property$CIRCLE_PITCH_ALIGNMENT$NullableType
    extends jni$_.JObjType<Property$CIRCLE_PITCH_ALIGNMENT?> {
  @jni$_.internal
  const $Property$CIRCLE_PITCH_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$CIRCLE_PITCH_ALIGNMENT? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$CIRCLE_PITCH_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$CIRCLE_PITCH_ALIGNMENT?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$CIRCLE_PITCH_ALIGNMENT$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$CIRCLE_PITCH_ALIGNMENT$NullableType) &&
        other is $Property$CIRCLE_PITCH_ALIGNMENT$NullableType;
  }
}

final class $Property$CIRCLE_PITCH_ALIGNMENT$Type
    extends jni$_.JObjType<Property$CIRCLE_PITCH_ALIGNMENT> {
  @jni$_.internal
  const $Property$CIRCLE_PITCH_ALIGNMENT$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$CIRCLE_PITCH_ALIGNMENT fromReference(jni$_.JReference reference) =>
      Property$CIRCLE_PITCH_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$CIRCLE_PITCH_ALIGNMENT?> get nullableType =>
      const $Property$CIRCLE_PITCH_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$CIRCLE_PITCH_ALIGNMENT$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$CIRCLE_PITCH_ALIGNMENT$Type) &&
        other is $Property$CIRCLE_PITCH_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_PITCH_SCALE`
class Property$CIRCLE_PITCH_SCALE extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$CIRCLE_PITCH_SCALE> $type;

  @jni$_.internal
  Property$CIRCLE_PITCH_SCALE.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$CIRCLE_PITCH_SCALE$NullableType();
  static const type = $Property$CIRCLE_PITCH_SCALE$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$CIRCLE_PITCH_SCALE> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$CIRCLE_PITCH_SCALE $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$CIRCLE_PITCH_SCALE',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$CIRCLE_PITCH_SCALE.implement(
    $Property$CIRCLE_PITCH_SCALE $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$CIRCLE_PITCH_SCALE.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$CIRCLE_PITCH_SCALE {
  factory $Property$CIRCLE_PITCH_SCALE() = _$Property$CIRCLE_PITCH_SCALE;
}

final class _$Property$CIRCLE_PITCH_SCALE with $Property$CIRCLE_PITCH_SCALE {
  _$Property$CIRCLE_PITCH_SCALE();
}

final class $Property$CIRCLE_PITCH_SCALE$NullableType
    extends jni$_.JObjType<Property$CIRCLE_PITCH_SCALE?> {
  @jni$_.internal
  const $Property$CIRCLE_PITCH_SCALE$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE;';

  @jni$_.internal
  @core$_.override
  Property$CIRCLE_PITCH_SCALE? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$CIRCLE_PITCH_SCALE.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$CIRCLE_PITCH_SCALE?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$CIRCLE_PITCH_SCALE$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$CIRCLE_PITCH_SCALE$NullableType) &&
        other is $Property$CIRCLE_PITCH_SCALE$NullableType;
  }
}

final class $Property$CIRCLE_PITCH_SCALE$Type
    extends jni$_.JObjType<Property$CIRCLE_PITCH_SCALE> {
  @jni$_.internal
  const $Property$CIRCLE_PITCH_SCALE$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE;';

  @jni$_.internal
  @core$_.override
  Property$CIRCLE_PITCH_SCALE fromReference(jni$_.JReference reference) =>
      Property$CIRCLE_PITCH_SCALE.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$CIRCLE_PITCH_SCALE?> get nullableType =>
      const $Property$CIRCLE_PITCH_SCALE$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$CIRCLE_PITCH_SCALE$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$CIRCLE_PITCH_SCALE$Type) &&
        other is $Property$CIRCLE_PITCH_SCALE$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_TRANSLATE_ANCHOR`
class Property$CIRCLE_TRANSLATE_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$CIRCLE_TRANSLATE_ANCHOR> $type;

  @jni$_.internal
  Property$CIRCLE_TRANSLATE_ANCHOR.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$CIRCLE_TRANSLATE_ANCHOR$NullableType();
  static const type = $Property$CIRCLE_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$CIRCLE_TRANSLATE_ANCHOR> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$CIRCLE_TRANSLATE_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$CIRCLE_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$CIRCLE_TRANSLATE_ANCHOR.implement(
    $Property$CIRCLE_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$CIRCLE_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$CIRCLE_TRANSLATE_ANCHOR {
  factory $Property$CIRCLE_TRANSLATE_ANCHOR() =
      _$Property$CIRCLE_TRANSLATE_ANCHOR;
}

final class _$Property$CIRCLE_TRANSLATE_ANCHOR
    with $Property$CIRCLE_TRANSLATE_ANCHOR {
  _$Property$CIRCLE_TRANSLATE_ANCHOR();
}

final class $Property$CIRCLE_TRANSLATE_ANCHOR$NullableType
    extends jni$_.JObjType<Property$CIRCLE_TRANSLATE_ANCHOR?> {
  @jni$_.internal
  const $Property$CIRCLE_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$CIRCLE_TRANSLATE_ANCHOR? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$CIRCLE_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$CIRCLE_TRANSLATE_ANCHOR?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$CIRCLE_TRANSLATE_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$CIRCLE_TRANSLATE_ANCHOR$NullableType) &&
        other is $Property$CIRCLE_TRANSLATE_ANCHOR$NullableType;
  }
}

final class $Property$CIRCLE_TRANSLATE_ANCHOR$Type
    extends jni$_.JObjType<Property$CIRCLE_TRANSLATE_ANCHOR> {
  @jni$_.internal
  const $Property$CIRCLE_TRANSLATE_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$CIRCLE_TRANSLATE_ANCHOR fromReference(jni$_.JReference reference) =>
      Property$CIRCLE_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$CIRCLE_TRANSLATE_ANCHOR?> get nullableType =>
      const $Property$CIRCLE_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$CIRCLE_TRANSLATE_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$CIRCLE_TRANSLATE_ANCHOR$Type) &&
        other is $Property$CIRCLE_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$FILL_EXTRUSION_TRANSLATE_ANCHOR`
class Property$FILL_EXTRUSION_TRANSLATE_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$FILL_EXTRUSION_TRANSLATE_ANCHOR> $type;

  @jni$_.internal
  Property$FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$NullableType();
  static const type = $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$FILL_EXTRUSION_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$FILL_EXTRUSION_TRANSLATE_ANCHOR.implement(
    $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR {
  factory $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR() =
      _$Property$FILL_EXTRUSION_TRANSLATE_ANCHOR;
}

final class _$Property$FILL_EXTRUSION_TRANSLATE_ANCHOR
    with $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR {
  _$Property$FILL_EXTRUSION_TRANSLATE_ANCHOR();
}

final class $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$NullableType
    extends jni$_.JObjType<Property$FILL_EXTRUSION_TRANSLATE_ANCHOR?> {
  @jni$_.internal
  const $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$FILL_EXTRUSION_TRANSLATE_ANCHOR? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : Property$FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$FILL_EXTRUSION_TRANSLATE_ANCHOR?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$NullableType) &&
        other is $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$NullableType;
  }
}

final class $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$Type
    extends jni$_.JObjType<Property$FILL_EXTRUSION_TRANSLATE_ANCHOR> {
  @jni$_.internal
  const $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$FILL_EXTRUSION_TRANSLATE_ANCHOR fromReference(
    jni$_.JReference reference,
  ) =>
      Property$FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$FILL_EXTRUSION_TRANSLATE_ANCHOR?> get nullableType =>
      const $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$Type) &&
        other is $Property$FILL_EXTRUSION_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$FILL_TRANSLATE_ANCHOR`
class Property$FILL_TRANSLATE_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$FILL_TRANSLATE_ANCHOR> $type;

  @jni$_.internal
  Property$FILL_TRANSLATE_ANCHOR.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$FILL_TRANSLATE_ANCHOR$NullableType();
  static const type = $Property$FILL_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$FILL_TRANSLATE_ANCHOR> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$FILL_TRANSLATE_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$FILL_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$FILL_TRANSLATE_ANCHOR.implement(
    $Property$FILL_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$FILL_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$FILL_TRANSLATE_ANCHOR {
  factory $Property$FILL_TRANSLATE_ANCHOR() = _$Property$FILL_TRANSLATE_ANCHOR;
}

final class _$Property$FILL_TRANSLATE_ANCHOR
    with $Property$FILL_TRANSLATE_ANCHOR {
  _$Property$FILL_TRANSLATE_ANCHOR();
}

final class $Property$FILL_TRANSLATE_ANCHOR$NullableType
    extends jni$_.JObjType<Property$FILL_TRANSLATE_ANCHOR?> {
  @jni$_.internal
  const $Property$FILL_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$FILL_TRANSLATE_ANCHOR? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$FILL_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$FILL_TRANSLATE_ANCHOR?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$FILL_TRANSLATE_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$FILL_TRANSLATE_ANCHOR$NullableType) &&
        other is $Property$FILL_TRANSLATE_ANCHOR$NullableType;
  }
}

final class $Property$FILL_TRANSLATE_ANCHOR$Type
    extends jni$_.JObjType<Property$FILL_TRANSLATE_ANCHOR> {
  @jni$_.internal
  const $Property$FILL_TRANSLATE_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$FILL_TRANSLATE_ANCHOR fromReference(jni$_.JReference reference) =>
      Property$FILL_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$FILL_TRANSLATE_ANCHOR?> get nullableType =>
      const $Property$FILL_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$FILL_TRANSLATE_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$FILL_TRANSLATE_ANCHOR$Type) &&
        other is $Property$FILL_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$HILLSHADE_ILLUMINATION_ANCHOR`
class Property$HILLSHADE_ILLUMINATION_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$HILLSHADE_ILLUMINATION_ANCHOR> $type;

  @jni$_.internal
  Property$HILLSHADE_ILLUMINATION_ANCHOR.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $Property$HILLSHADE_ILLUMINATION_ANCHOR$NullableType();
  static const type = $Property$HILLSHADE_ILLUMINATION_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$HILLSHADE_ILLUMINATION_ANCHOR>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$HILLSHADE_ILLUMINATION_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$HILLSHADE_ILLUMINATION_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$HILLSHADE_ILLUMINATION_ANCHOR.implement(
    $Property$HILLSHADE_ILLUMINATION_ANCHOR $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$HILLSHADE_ILLUMINATION_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$HILLSHADE_ILLUMINATION_ANCHOR {
  factory $Property$HILLSHADE_ILLUMINATION_ANCHOR() =
      _$Property$HILLSHADE_ILLUMINATION_ANCHOR;
}

final class _$Property$HILLSHADE_ILLUMINATION_ANCHOR
    with $Property$HILLSHADE_ILLUMINATION_ANCHOR {
  _$Property$HILLSHADE_ILLUMINATION_ANCHOR();
}

final class $Property$HILLSHADE_ILLUMINATION_ANCHOR$NullableType
    extends jni$_.JObjType<Property$HILLSHADE_ILLUMINATION_ANCHOR?> {
  @jni$_.internal
  const $Property$HILLSHADE_ILLUMINATION_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$HILLSHADE_ILLUMINATION_ANCHOR? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : Property$HILLSHADE_ILLUMINATION_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$HILLSHADE_ILLUMINATION_ANCHOR?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($Property$HILLSHADE_ILLUMINATION_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$HILLSHADE_ILLUMINATION_ANCHOR$NullableType) &&
        other is $Property$HILLSHADE_ILLUMINATION_ANCHOR$NullableType;
  }
}

final class $Property$HILLSHADE_ILLUMINATION_ANCHOR$Type
    extends jni$_.JObjType<Property$HILLSHADE_ILLUMINATION_ANCHOR> {
  @jni$_.internal
  const $Property$HILLSHADE_ILLUMINATION_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$HILLSHADE_ILLUMINATION_ANCHOR fromReference(
    jni$_.JReference reference,
  ) =>
      Property$HILLSHADE_ILLUMINATION_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$HILLSHADE_ILLUMINATION_ANCHOR?> get nullableType =>
      const $Property$HILLSHADE_ILLUMINATION_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$HILLSHADE_ILLUMINATION_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$HILLSHADE_ILLUMINATION_ANCHOR$Type) &&
        other is $Property$HILLSHADE_ILLUMINATION_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_ANCHOR`
class Property$ICON_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$ICON_ANCHOR> $type;

  @jni$_.internal
  Property$ICON_ANCHOR.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$ICON_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$ICON_ANCHOR$NullableType();
  static const type = $Property$ICON_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$ICON_ANCHOR> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$ICON_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$ICON_ANCHOR.implement($Property$ICON_ANCHOR $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$ICON_ANCHOR.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$ICON_ANCHOR {
  factory $Property$ICON_ANCHOR() = _$Property$ICON_ANCHOR;
}

final class _$Property$ICON_ANCHOR with $Property$ICON_ANCHOR {
  _$Property$ICON_ANCHOR();
}

final class $Property$ICON_ANCHOR$NullableType
    extends jni$_.JObjType<Property$ICON_ANCHOR?> {
  @jni$_.internal
  const $Property$ICON_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$ICON_ANCHOR? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property$ICON_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_ANCHOR?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ICON_ANCHOR$NullableType) &&
        other is $Property$ICON_ANCHOR$NullableType;
  }
}

final class $Property$ICON_ANCHOR$Type
    extends jni$_.JObjType<Property$ICON_ANCHOR> {
  @jni$_.internal
  const $Property$ICON_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$ICON_ANCHOR fromReference(jni$_.JReference reference) =>
      Property$ICON_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_ANCHOR?> get nullableType =>
      const $Property$ICON_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ICON_ANCHOR$Type) &&
        other is $Property$ICON_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_PITCH_ALIGNMENT`
class Property$ICON_PITCH_ALIGNMENT extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$ICON_PITCH_ALIGNMENT> $type;

  @jni$_.internal
  Property$ICON_PITCH_ALIGNMENT.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$ICON_PITCH_ALIGNMENT$NullableType();
  static const type = $Property$ICON_PITCH_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$ICON_PITCH_ALIGNMENT> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$ICON_PITCH_ALIGNMENT $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_PITCH_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$ICON_PITCH_ALIGNMENT.implement(
    $Property$ICON_PITCH_ALIGNMENT $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$ICON_PITCH_ALIGNMENT.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$ICON_PITCH_ALIGNMENT {
  factory $Property$ICON_PITCH_ALIGNMENT() = _$Property$ICON_PITCH_ALIGNMENT;
}

final class _$Property$ICON_PITCH_ALIGNMENT
    with $Property$ICON_PITCH_ALIGNMENT {
  _$Property$ICON_PITCH_ALIGNMENT();
}

final class $Property$ICON_PITCH_ALIGNMENT$NullableType
    extends jni$_.JObjType<Property$ICON_PITCH_ALIGNMENT?> {
  @jni$_.internal
  const $Property$ICON_PITCH_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$ICON_PITCH_ALIGNMENT? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$ICON_PITCH_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_PITCH_ALIGNMENT?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_PITCH_ALIGNMENT$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ICON_PITCH_ALIGNMENT$NullableType) &&
        other is $Property$ICON_PITCH_ALIGNMENT$NullableType;
  }
}

final class $Property$ICON_PITCH_ALIGNMENT$Type
    extends jni$_.JObjType<Property$ICON_PITCH_ALIGNMENT> {
  @jni$_.internal
  const $Property$ICON_PITCH_ALIGNMENT$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$ICON_PITCH_ALIGNMENT fromReference(jni$_.JReference reference) =>
      Property$ICON_PITCH_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_PITCH_ALIGNMENT?> get nullableType =>
      const $Property$ICON_PITCH_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_PITCH_ALIGNMENT$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ICON_PITCH_ALIGNMENT$Type) &&
        other is $Property$ICON_PITCH_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_ROTATION_ALIGNMENT`
class Property$ICON_ROTATION_ALIGNMENT extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$ICON_ROTATION_ALIGNMENT> $type;

  @jni$_.internal
  Property$ICON_ROTATION_ALIGNMENT.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$ICON_ROTATION_ALIGNMENT$NullableType();
  static const type = $Property$ICON_ROTATION_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$ICON_ROTATION_ALIGNMENT> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$ICON_ROTATION_ALIGNMENT $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_ROTATION_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$ICON_ROTATION_ALIGNMENT.implement(
    $Property$ICON_ROTATION_ALIGNMENT $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$ICON_ROTATION_ALIGNMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$ICON_ROTATION_ALIGNMENT {
  factory $Property$ICON_ROTATION_ALIGNMENT() =
      _$Property$ICON_ROTATION_ALIGNMENT;
}

final class _$Property$ICON_ROTATION_ALIGNMENT
    with $Property$ICON_ROTATION_ALIGNMENT {
  _$Property$ICON_ROTATION_ALIGNMENT();
}

final class $Property$ICON_ROTATION_ALIGNMENT$NullableType
    extends jni$_.JObjType<Property$ICON_ROTATION_ALIGNMENT?> {
  @jni$_.internal
  const $Property$ICON_ROTATION_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$ICON_ROTATION_ALIGNMENT? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$ICON_ROTATION_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_ROTATION_ALIGNMENT?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_ROTATION_ALIGNMENT$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$ICON_ROTATION_ALIGNMENT$NullableType) &&
        other is $Property$ICON_ROTATION_ALIGNMENT$NullableType;
  }
}

final class $Property$ICON_ROTATION_ALIGNMENT$Type
    extends jni$_.JObjType<Property$ICON_ROTATION_ALIGNMENT> {
  @jni$_.internal
  const $Property$ICON_ROTATION_ALIGNMENT$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$ICON_ROTATION_ALIGNMENT fromReference(jni$_.JReference reference) =>
      Property$ICON_ROTATION_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_ROTATION_ALIGNMENT?> get nullableType =>
      const $Property$ICON_ROTATION_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_ROTATION_ALIGNMENT$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ICON_ROTATION_ALIGNMENT$Type) &&
        other is $Property$ICON_ROTATION_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_TEXT_FIT`
class Property$ICON_TEXT_FIT extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$ICON_TEXT_FIT> $type;

  @jni$_.internal
  Property$ICON_TEXT_FIT.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$ICON_TEXT_FIT',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$ICON_TEXT_FIT$NullableType();
  static const type = $Property$ICON_TEXT_FIT$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$ICON_TEXT_FIT> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$ICON_TEXT_FIT $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_TEXT_FIT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$ICON_TEXT_FIT.implement($Property$ICON_TEXT_FIT $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$ICON_TEXT_FIT.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$ICON_TEXT_FIT {
  factory $Property$ICON_TEXT_FIT() = _$Property$ICON_TEXT_FIT;
}

final class _$Property$ICON_TEXT_FIT with $Property$ICON_TEXT_FIT {
  _$Property$ICON_TEXT_FIT();
}

final class $Property$ICON_TEXT_FIT$NullableType
    extends jni$_.JObjType<Property$ICON_TEXT_FIT?> {
  @jni$_.internal
  const $Property$ICON_TEXT_FIT$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TEXT_FIT;';

  @jni$_.internal
  @core$_.override
  Property$ICON_TEXT_FIT? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property$ICON_TEXT_FIT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_TEXT_FIT?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_TEXT_FIT$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ICON_TEXT_FIT$NullableType) &&
        other is $Property$ICON_TEXT_FIT$NullableType;
  }
}

final class $Property$ICON_TEXT_FIT$Type
    extends jni$_.JObjType<Property$ICON_TEXT_FIT> {
  @jni$_.internal
  const $Property$ICON_TEXT_FIT$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TEXT_FIT;';

  @jni$_.internal
  @core$_.override
  Property$ICON_TEXT_FIT fromReference(jni$_.JReference reference) =>
      Property$ICON_TEXT_FIT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_TEXT_FIT?> get nullableType =>
      const $Property$ICON_TEXT_FIT$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_TEXT_FIT$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ICON_TEXT_FIT$Type) &&
        other is $Property$ICON_TEXT_FIT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_TRANSLATE_ANCHOR`
class Property$ICON_TRANSLATE_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$ICON_TRANSLATE_ANCHOR> $type;

  @jni$_.internal
  Property$ICON_TRANSLATE_ANCHOR.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$ICON_TRANSLATE_ANCHOR$NullableType();
  static const type = $Property$ICON_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$ICON_TRANSLATE_ANCHOR> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$ICON_TRANSLATE_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$ICON_TRANSLATE_ANCHOR.implement(
    $Property$ICON_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$ICON_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$ICON_TRANSLATE_ANCHOR {
  factory $Property$ICON_TRANSLATE_ANCHOR() = _$Property$ICON_TRANSLATE_ANCHOR;
}

final class _$Property$ICON_TRANSLATE_ANCHOR
    with $Property$ICON_TRANSLATE_ANCHOR {
  _$Property$ICON_TRANSLATE_ANCHOR();
}

final class $Property$ICON_TRANSLATE_ANCHOR$NullableType
    extends jni$_.JObjType<Property$ICON_TRANSLATE_ANCHOR?> {
  @jni$_.internal
  const $Property$ICON_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$ICON_TRANSLATE_ANCHOR? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$ICON_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_TRANSLATE_ANCHOR?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_TRANSLATE_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$ICON_TRANSLATE_ANCHOR$NullableType) &&
        other is $Property$ICON_TRANSLATE_ANCHOR$NullableType;
  }
}

final class $Property$ICON_TRANSLATE_ANCHOR$Type
    extends jni$_.JObjType<Property$ICON_TRANSLATE_ANCHOR> {
  @jni$_.internal
  const $Property$ICON_TRANSLATE_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$ICON_TRANSLATE_ANCHOR fromReference(jni$_.JReference reference) =>
      Property$ICON_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$ICON_TRANSLATE_ANCHOR?> get nullableType =>
      const $Property$ICON_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$ICON_TRANSLATE_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$ICON_TRANSLATE_ANCHOR$Type) &&
        other is $Property$ICON_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_CAP`
class Property$LINE_CAP extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$LINE_CAP> $type;

  @jni$_.internal
  Property$LINE_CAP.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$LINE_CAP',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$LINE_CAP$NullableType();
  static const type = $Property$LINE_CAP$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$LINE_CAP> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$LINE_CAP $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$LINE_CAP',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$LINE_CAP.implement($Property$LINE_CAP $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$LINE_CAP.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$LINE_CAP {
  factory $Property$LINE_CAP() = _$Property$LINE_CAP;
}

final class _$Property$LINE_CAP with $Property$LINE_CAP {
  _$Property$LINE_CAP();
}

final class $Property$LINE_CAP$NullableType
    extends jni$_.JObjType<Property$LINE_CAP?> {
  @jni$_.internal
  const $Property$LINE_CAP$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_CAP;';

  @jni$_.internal
  @core$_.override
  Property$LINE_CAP? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property$LINE_CAP.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$LINE_CAP?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$LINE_CAP$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$LINE_CAP$NullableType) &&
        other is $Property$LINE_CAP$NullableType;
  }
}

final class $Property$LINE_CAP$Type extends jni$_.JObjType<Property$LINE_CAP> {
  @jni$_.internal
  const $Property$LINE_CAP$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_CAP;';

  @jni$_.internal
  @core$_.override
  Property$LINE_CAP fromReference(jni$_.JReference reference) =>
      Property$LINE_CAP.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$LINE_CAP?> get nullableType =>
      const $Property$LINE_CAP$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$LINE_CAP$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$LINE_CAP$Type) &&
        other is $Property$LINE_CAP$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_JOIN`
class Property$LINE_JOIN extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$LINE_JOIN> $type;

  @jni$_.internal
  Property$LINE_JOIN.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$LINE_JOIN',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$LINE_JOIN$NullableType();
  static const type = $Property$LINE_JOIN$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$LINE_JOIN> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$LINE_JOIN $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$LINE_JOIN',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$LINE_JOIN.implement($Property$LINE_JOIN $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$LINE_JOIN.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$LINE_JOIN {
  factory $Property$LINE_JOIN() = _$Property$LINE_JOIN;
}

final class _$Property$LINE_JOIN with $Property$LINE_JOIN {
  _$Property$LINE_JOIN();
}

final class $Property$LINE_JOIN$NullableType
    extends jni$_.JObjType<Property$LINE_JOIN?> {
  @jni$_.internal
  const $Property$LINE_JOIN$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_JOIN;';

  @jni$_.internal
  @core$_.override
  Property$LINE_JOIN? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property$LINE_JOIN.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$LINE_JOIN?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$LINE_JOIN$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$LINE_JOIN$NullableType) &&
        other is $Property$LINE_JOIN$NullableType;
  }
}

final class $Property$LINE_JOIN$Type
    extends jni$_.JObjType<Property$LINE_JOIN> {
  @jni$_.internal
  const $Property$LINE_JOIN$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_JOIN;';

  @jni$_.internal
  @core$_.override
  Property$LINE_JOIN fromReference(jni$_.JReference reference) =>
      Property$LINE_JOIN.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$LINE_JOIN?> get nullableType =>
      const $Property$LINE_JOIN$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$LINE_JOIN$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$LINE_JOIN$Type) &&
        other is $Property$LINE_JOIN$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_TRANSLATE_ANCHOR`
class Property$LINE_TRANSLATE_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$LINE_TRANSLATE_ANCHOR> $type;

  @jni$_.internal
  Property$LINE_TRANSLATE_ANCHOR.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$LINE_TRANSLATE_ANCHOR$NullableType();
  static const type = $Property$LINE_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$LINE_TRANSLATE_ANCHOR> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$LINE_TRANSLATE_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$LINE_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$LINE_TRANSLATE_ANCHOR.implement(
    $Property$LINE_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$LINE_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$LINE_TRANSLATE_ANCHOR {
  factory $Property$LINE_TRANSLATE_ANCHOR() = _$Property$LINE_TRANSLATE_ANCHOR;
}

final class _$Property$LINE_TRANSLATE_ANCHOR
    with $Property$LINE_TRANSLATE_ANCHOR {
  _$Property$LINE_TRANSLATE_ANCHOR();
}

final class $Property$LINE_TRANSLATE_ANCHOR$NullableType
    extends jni$_.JObjType<Property$LINE_TRANSLATE_ANCHOR?> {
  @jni$_.internal
  const $Property$LINE_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$LINE_TRANSLATE_ANCHOR? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$LINE_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$LINE_TRANSLATE_ANCHOR?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$LINE_TRANSLATE_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$LINE_TRANSLATE_ANCHOR$NullableType) &&
        other is $Property$LINE_TRANSLATE_ANCHOR$NullableType;
  }
}

final class $Property$LINE_TRANSLATE_ANCHOR$Type
    extends jni$_.JObjType<Property$LINE_TRANSLATE_ANCHOR> {
  @jni$_.internal
  const $Property$LINE_TRANSLATE_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$LINE_TRANSLATE_ANCHOR fromReference(jni$_.JReference reference) =>
      Property$LINE_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$LINE_TRANSLATE_ANCHOR?> get nullableType =>
      const $Property$LINE_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$LINE_TRANSLATE_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$LINE_TRANSLATE_ANCHOR$Type) &&
        other is $Property$LINE_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$RASTER_RESAMPLING`
class Property$RASTER_RESAMPLING extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$RASTER_RESAMPLING> $type;

  @jni$_.internal
  Property$RASTER_RESAMPLING.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$RASTER_RESAMPLING',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$RASTER_RESAMPLING$NullableType();
  static const type = $Property$RASTER_RESAMPLING$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$RASTER_RESAMPLING> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$RASTER_RESAMPLING $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$RASTER_RESAMPLING',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$RASTER_RESAMPLING.implement(
    $Property$RASTER_RESAMPLING $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$RASTER_RESAMPLING.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$RASTER_RESAMPLING {
  factory $Property$RASTER_RESAMPLING() = _$Property$RASTER_RESAMPLING;
}

final class _$Property$RASTER_RESAMPLING with $Property$RASTER_RESAMPLING {
  _$Property$RASTER_RESAMPLING();
}

final class $Property$RASTER_RESAMPLING$NullableType
    extends jni$_.JObjType<Property$RASTER_RESAMPLING?> {
  @jni$_.internal
  const $Property$RASTER_RESAMPLING$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$RASTER_RESAMPLING;';

  @jni$_.internal
  @core$_.override
  Property$RASTER_RESAMPLING? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$RASTER_RESAMPLING.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$RASTER_RESAMPLING?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$RASTER_RESAMPLING$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$RASTER_RESAMPLING$NullableType) &&
        other is $Property$RASTER_RESAMPLING$NullableType;
  }
}

final class $Property$RASTER_RESAMPLING$Type
    extends jni$_.JObjType<Property$RASTER_RESAMPLING> {
  @jni$_.internal
  const $Property$RASTER_RESAMPLING$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$RASTER_RESAMPLING;';

  @jni$_.internal
  @core$_.override
  Property$RASTER_RESAMPLING fromReference(jni$_.JReference reference) =>
      Property$RASTER_RESAMPLING.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$RASTER_RESAMPLING?> get nullableType =>
      const $Property$RASTER_RESAMPLING$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$RASTER_RESAMPLING$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$RASTER_RESAMPLING$Type) &&
        other is $Property$RASTER_RESAMPLING$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$SYMBOL_PLACEMENT`
class Property$SYMBOL_PLACEMENT extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$SYMBOL_PLACEMENT> $type;

  @jni$_.internal
  Property$SYMBOL_PLACEMENT.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$SYMBOL_PLACEMENT$NullableType();
  static const type = $Property$SYMBOL_PLACEMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$SYMBOL_PLACEMENT> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$SYMBOL_PLACEMENT $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$SYMBOL_PLACEMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$SYMBOL_PLACEMENT.implement(
    $Property$SYMBOL_PLACEMENT $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$SYMBOL_PLACEMENT.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$SYMBOL_PLACEMENT {
  factory $Property$SYMBOL_PLACEMENT() = _$Property$SYMBOL_PLACEMENT;
}

final class _$Property$SYMBOL_PLACEMENT with $Property$SYMBOL_PLACEMENT {
  _$Property$SYMBOL_PLACEMENT();
}

final class $Property$SYMBOL_PLACEMENT$NullableType
    extends jni$_.JObjType<Property$SYMBOL_PLACEMENT?> {
  @jni$_.internal
  const $Property$SYMBOL_PLACEMENT$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT;';

  @jni$_.internal
  @core$_.override
  Property$SYMBOL_PLACEMENT? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$SYMBOL_PLACEMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$SYMBOL_PLACEMENT?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$SYMBOL_PLACEMENT$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$SYMBOL_PLACEMENT$NullableType) &&
        other is $Property$SYMBOL_PLACEMENT$NullableType;
  }
}

final class $Property$SYMBOL_PLACEMENT$Type
    extends jni$_.JObjType<Property$SYMBOL_PLACEMENT> {
  @jni$_.internal
  const $Property$SYMBOL_PLACEMENT$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT;';

  @jni$_.internal
  @core$_.override
  Property$SYMBOL_PLACEMENT fromReference(jni$_.JReference reference) =>
      Property$SYMBOL_PLACEMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$SYMBOL_PLACEMENT?> get nullableType =>
      const $Property$SYMBOL_PLACEMENT$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$SYMBOL_PLACEMENT$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$SYMBOL_PLACEMENT$Type) &&
        other is $Property$SYMBOL_PLACEMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$SYMBOL_Z_ORDER`
class Property$SYMBOL_Z_ORDER extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$SYMBOL_Z_ORDER> $type;

  @jni$_.internal
  Property$SYMBOL_Z_ORDER.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$SYMBOL_Z_ORDER$NullableType();
  static const type = $Property$SYMBOL_Z_ORDER$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$SYMBOL_Z_ORDER> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$SYMBOL_Z_ORDER $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$SYMBOL_Z_ORDER',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$SYMBOL_Z_ORDER.implement($Property$SYMBOL_Z_ORDER $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$SYMBOL_Z_ORDER.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$SYMBOL_Z_ORDER {
  factory $Property$SYMBOL_Z_ORDER() = _$Property$SYMBOL_Z_ORDER;
}

final class _$Property$SYMBOL_Z_ORDER with $Property$SYMBOL_Z_ORDER {
  _$Property$SYMBOL_Z_ORDER();
}

final class $Property$SYMBOL_Z_ORDER$NullableType
    extends jni$_.JObjType<Property$SYMBOL_Z_ORDER?> {
  @jni$_.internal
  const $Property$SYMBOL_Z_ORDER$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER;';

  @jni$_.internal
  @core$_.override
  Property$SYMBOL_Z_ORDER? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$SYMBOL_Z_ORDER.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$SYMBOL_Z_ORDER?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$SYMBOL_Z_ORDER$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$SYMBOL_Z_ORDER$NullableType) &&
        other is $Property$SYMBOL_Z_ORDER$NullableType;
  }
}

final class $Property$SYMBOL_Z_ORDER$Type
    extends jni$_.JObjType<Property$SYMBOL_Z_ORDER> {
  @jni$_.internal
  const $Property$SYMBOL_Z_ORDER$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER;';

  @jni$_.internal
  @core$_.override
  Property$SYMBOL_Z_ORDER fromReference(jni$_.JReference reference) =>
      Property$SYMBOL_Z_ORDER.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$SYMBOL_Z_ORDER?> get nullableType =>
      const $Property$SYMBOL_Z_ORDER$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$SYMBOL_Z_ORDER$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$SYMBOL_Z_ORDER$Type) &&
        other is $Property$SYMBOL_Z_ORDER$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_ANCHOR`
class Property$TEXT_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$TEXT_ANCHOR> $type;

  @jni$_.internal
  Property$TEXT_ANCHOR.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$TEXT_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$TEXT_ANCHOR$NullableType();
  static const type = $Property$TEXT_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$TEXT_ANCHOR> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$TEXT_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$TEXT_ANCHOR.implement($Property$TEXT_ANCHOR $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$TEXT_ANCHOR.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$TEXT_ANCHOR {
  factory $Property$TEXT_ANCHOR() = _$Property$TEXT_ANCHOR;
}

final class _$Property$TEXT_ANCHOR with $Property$TEXT_ANCHOR {
  _$Property$TEXT_ANCHOR();
}

final class $Property$TEXT_ANCHOR$NullableType
    extends jni$_.JObjType<Property$TEXT_ANCHOR?> {
  @jni$_.internal
  const $Property$TEXT_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_ANCHOR? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property$TEXT_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_ANCHOR?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_ANCHOR$NullableType) &&
        other is $Property$TEXT_ANCHOR$NullableType;
  }
}

final class $Property$TEXT_ANCHOR$Type
    extends jni$_.JObjType<Property$TEXT_ANCHOR> {
  @jni$_.internal
  const $Property$TEXT_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_ANCHOR fromReference(jni$_.JReference reference) =>
      Property$TEXT_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_ANCHOR?> get nullableType =>
      const $Property$TEXT_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_ANCHOR$Type) &&
        other is $Property$TEXT_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_JUSTIFY`
class Property$TEXT_JUSTIFY extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$TEXT_JUSTIFY> $type;

  @jni$_.internal
  Property$TEXT_JUSTIFY.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$TEXT_JUSTIFY',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$TEXT_JUSTIFY$NullableType();
  static const type = $Property$TEXT_JUSTIFY$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$TEXT_JUSTIFY> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$TEXT_JUSTIFY $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_JUSTIFY',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$TEXT_JUSTIFY.implement($Property$TEXT_JUSTIFY $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$TEXT_JUSTIFY.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$TEXT_JUSTIFY {
  factory $Property$TEXT_JUSTIFY() = _$Property$TEXT_JUSTIFY;
}

final class _$Property$TEXT_JUSTIFY with $Property$TEXT_JUSTIFY {
  _$Property$TEXT_JUSTIFY();
}

final class $Property$TEXT_JUSTIFY$NullableType
    extends jni$_.JObjType<Property$TEXT_JUSTIFY?> {
  @jni$_.internal
  const $Property$TEXT_JUSTIFY$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_JUSTIFY;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_JUSTIFY? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property$TEXT_JUSTIFY.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_JUSTIFY?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_JUSTIFY$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_JUSTIFY$NullableType) &&
        other is $Property$TEXT_JUSTIFY$NullableType;
  }
}

final class $Property$TEXT_JUSTIFY$Type
    extends jni$_.JObjType<Property$TEXT_JUSTIFY> {
  @jni$_.internal
  const $Property$TEXT_JUSTIFY$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_JUSTIFY;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_JUSTIFY fromReference(jni$_.JReference reference) =>
      Property$TEXT_JUSTIFY.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_JUSTIFY?> get nullableType =>
      const $Property$TEXT_JUSTIFY$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_JUSTIFY$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_JUSTIFY$Type) &&
        other is $Property$TEXT_JUSTIFY$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_PITCH_ALIGNMENT`
class Property$TEXT_PITCH_ALIGNMENT extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$TEXT_PITCH_ALIGNMENT> $type;

  @jni$_.internal
  Property$TEXT_PITCH_ALIGNMENT.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$TEXT_PITCH_ALIGNMENT$NullableType();
  static const type = $Property$TEXT_PITCH_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$TEXT_PITCH_ALIGNMENT> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$TEXT_PITCH_ALIGNMENT $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_PITCH_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$TEXT_PITCH_ALIGNMENT.implement(
    $Property$TEXT_PITCH_ALIGNMENT $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$TEXT_PITCH_ALIGNMENT.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$TEXT_PITCH_ALIGNMENT {
  factory $Property$TEXT_PITCH_ALIGNMENT() = _$Property$TEXT_PITCH_ALIGNMENT;
}

final class _$Property$TEXT_PITCH_ALIGNMENT
    with $Property$TEXT_PITCH_ALIGNMENT {
  _$Property$TEXT_PITCH_ALIGNMENT();
}

final class $Property$TEXT_PITCH_ALIGNMENT$NullableType
    extends jni$_.JObjType<Property$TEXT_PITCH_ALIGNMENT?> {
  @jni$_.internal
  const $Property$TEXT_PITCH_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_PITCH_ALIGNMENT? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$TEXT_PITCH_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_PITCH_ALIGNMENT?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_PITCH_ALIGNMENT$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_PITCH_ALIGNMENT$NullableType) &&
        other is $Property$TEXT_PITCH_ALIGNMENT$NullableType;
  }
}

final class $Property$TEXT_PITCH_ALIGNMENT$Type
    extends jni$_.JObjType<Property$TEXT_PITCH_ALIGNMENT> {
  @jni$_.internal
  const $Property$TEXT_PITCH_ALIGNMENT$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_PITCH_ALIGNMENT fromReference(jni$_.JReference reference) =>
      Property$TEXT_PITCH_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_PITCH_ALIGNMENT?> get nullableType =>
      const $Property$TEXT_PITCH_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_PITCH_ALIGNMENT$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_PITCH_ALIGNMENT$Type) &&
        other is $Property$TEXT_PITCH_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_ROTATION_ALIGNMENT`
class Property$TEXT_ROTATION_ALIGNMENT extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$TEXT_ROTATION_ALIGNMENT> $type;

  @jni$_.internal
  Property$TEXT_ROTATION_ALIGNMENT.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$TEXT_ROTATION_ALIGNMENT$NullableType();
  static const type = $Property$TEXT_ROTATION_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$TEXT_ROTATION_ALIGNMENT> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$TEXT_ROTATION_ALIGNMENT $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_ROTATION_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$TEXT_ROTATION_ALIGNMENT.implement(
    $Property$TEXT_ROTATION_ALIGNMENT $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$TEXT_ROTATION_ALIGNMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$TEXT_ROTATION_ALIGNMENT {
  factory $Property$TEXT_ROTATION_ALIGNMENT() =
      _$Property$TEXT_ROTATION_ALIGNMENT;
}

final class _$Property$TEXT_ROTATION_ALIGNMENT
    with $Property$TEXT_ROTATION_ALIGNMENT {
  _$Property$TEXT_ROTATION_ALIGNMENT();
}

final class $Property$TEXT_ROTATION_ALIGNMENT$NullableType
    extends jni$_.JObjType<Property$TEXT_ROTATION_ALIGNMENT?> {
  @jni$_.internal
  const $Property$TEXT_ROTATION_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_ROTATION_ALIGNMENT? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$TEXT_ROTATION_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_ROTATION_ALIGNMENT?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_ROTATION_ALIGNMENT$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$TEXT_ROTATION_ALIGNMENT$NullableType) &&
        other is $Property$TEXT_ROTATION_ALIGNMENT$NullableType;
  }
}

final class $Property$TEXT_ROTATION_ALIGNMENT$Type
    extends jni$_.JObjType<Property$TEXT_ROTATION_ALIGNMENT> {
  @jni$_.internal
  const $Property$TEXT_ROTATION_ALIGNMENT$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_ROTATION_ALIGNMENT fromReference(jni$_.JReference reference) =>
      Property$TEXT_ROTATION_ALIGNMENT.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_ROTATION_ALIGNMENT?> get nullableType =>
      const $Property$TEXT_ROTATION_ALIGNMENT$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_ROTATION_ALIGNMENT$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_ROTATION_ALIGNMENT$Type) &&
        other is $Property$TEXT_ROTATION_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_TRANSFORM`
class Property$TEXT_TRANSFORM extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$TEXT_TRANSFORM> $type;

  @jni$_.internal
  Property$TEXT_TRANSFORM.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$TEXT_TRANSFORM',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$TEXT_TRANSFORM$NullableType();
  static const type = $Property$TEXT_TRANSFORM$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$TEXT_TRANSFORM> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$TEXT_TRANSFORM $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_TRANSFORM',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$TEXT_TRANSFORM.implement($Property$TEXT_TRANSFORM $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$TEXT_TRANSFORM.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$TEXT_TRANSFORM {
  factory $Property$TEXT_TRANSFORM() = _$Property$TEXT_TRANSFORM;
}

final class _$Property$TEXT_TRANSFORM with $Property$TEXT_TRANSFORM {
  _$Property$TEXT_TRANSFORM();
}

final class $Property$TEXT_TRANSFORM$NullableType
    extends jni$_.JObjType<Property$TEXT_TRANSFORM?> {
  @jni$_.internal
  const $Property$TEXT_TRANSFORM$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSFORM;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_TRANSFORM? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$TEXT_TRANSFORM.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_TRANSFORM?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_TRANSFORM$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_TRANSFORM$NullableType) &&
        other is $Property$TEXT_TRANSFORM$NullableType;
  }
}

final class $Property$TEXT_TRANSFORM$Type
    extends jni$_.JObjType<Property$TEXT_TRANSFORM> {
  @jni$_.internal
  const $Property$TEXT_TRANSFORM$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSFORM;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_TRANSFORM fromReference(jni$_.JReference reference) =>
      Property$TEXT_TRANSFORM.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_TRANSFORM?> get nullableType =>
      const $Property$TEXT_TRANSFORM$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_TRANSFORM$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_TRANSFORM$Type) &&
        other is $Property$TEXT_TRANSFORM$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_TRANSLATE_ANCHOR`
class Property$TEXT_TRANSLATE_ANCHOR extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$TEXT_TRANSLATE_ANCHOR> $type;

  @jni$_.internal
  Property$TEXT_TRANSLATE_ANCHOR.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$TEXT_TRANSLATE_ANCHOR$NullableType();
  static const type = $Property$TEXT_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$TEXT_TRANSLATE_ANCHOR> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$TEXT_TRANSLATE_ANCHOR $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$TEXT_TRANSLATE_ANCHOR.implement(
    $Property$TEXT_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$TEXT_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property$TEXT_TRANSLATE_ANCHOR {
  factory $Property$TEXT_TRANSLATE_ANCHOR() = _$Property$TEXT_TRANSLATE_ANCHOR;
}

final class _$Property$TEXT_TRANSLATE_ANCHOR
    with $Property$TEXT_TRANSLATE_ANCHOR {
  _$Property$TEXT_TRANSLATE_ANCHOR();
}

final class $Property$TEXT_TRANSLATE_ANCHOR$NullableType
    extends jni$_.JObjType<Property$TEXT_TRANSLATE_ANCHOR?> {
  @jni$_.internal
  const $Property$TEXT_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_TRANSLATE_ANCHOR? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$TEXT_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_TRANSLATE_ANCHOR?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_TRANSLATE_ANCHOR$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property$TEXT_TRANSLATE_ANCHOR$NullableType) &&
        other is $Property$TEXT_TRANSLATE_ANCHOR$NullableType;
  }
}

final class $Property$TEXT_TRANSLATE_ANCHOR$Type
    extends jni$_.JObjType<Property$TEXT_TRANSLATE_ANCHOR> {
  @jni$_.internal
  const $Property$TEXT_TRANSLATE_ANCHOR$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_TRANSLATE_ANCHOR fromReference(jni$_.JReference reference) =>
      Property$TEXT_TRANSLATE_ANCHOR.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_TRANSLATE_ANCHOR?> get nullableType =>
      const $Property$TEXT_TRANSLATE_ANCHOR$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_TRANSLATE_ANCHOR$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_TRANSLATE_ANCHOR$Type) &&
        other is $Property$TEXT_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_WRITING_MODE`
class Property$TEXT_WRITING_MODE extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$TEXT_WRITING_MODE> $type;

  @jni$_.internal
  Property$TEXT_WRITING_MODE.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$TEXT_WRITING_MODE',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$TEXT_WRITING_MODE$NullableType();
  static const type = $Property$TEXT_WRITING_MODE$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$TEXT_WRITING_MODE> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$TEXT_WRITING_MODE $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_WRITING_MODE',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$TEXT_WRITING_MODE.implement(
    $Property$TEXT_WRITING_MODE $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$TEXT_WRITING_MODE.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$TEXT_WRITING_MODE {
  factory $Property$TEXT_WRITING_MODE() = _$Property$TEXT_WRITING_MODE;
}

final class _$Property$TEXT_WRITING_MODE with $Property$TEXT_WRITING_MODE {
  _$Property$TEXT_WRITING_MODE();
}

final class $Property$TEXT_WRITING_MODE$NullableType
    extends jni$_.JObjType<Property$TEXT_WRITING_MODE?> {
  @jni$_.internal
  const $Property$TEXT_WRITING_MODE$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_WRITING_MODE;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_WRITING_MODE? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Property$TEXT_WRITING_MODE.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_WRITING_MODE?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_WRITING_MODE$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_WRITING_MODE$NullableType) &&
        other is $Property$TEXT_WRITING_MODE$NullableType;
  }
}

final class $Property$TEXT_WRITING_MODE$Type
    extends jni$_.JObjType<Property$TEXT_WRITING_MODE> {
  @jni$_.internal
  const $Property$TEXT_WRITING_MODE$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_WRITING_MODE;';

  @jni$_.internal
  @core$_.override
  Property$TEXT_WRITING_MODE fromReference(jni$_.JReference reference) =>
      Property$TEXT_WRITING_MODE.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$TEXT_WRITING_MODE?> get nullableType =>
      const $Property$TEXT_WRITING_MODE$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$TEXT_WRITING_MODE$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$TEXT_WRITING_MODE$Type) &&
        other is $Property$TEXT_WRITING_MODE$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$VISIBILITY`
class Property$VISIBILITY extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property$VISIBILITY> $type;

  @jni$_.internal
  Property$VISIBILITY.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property$VISIBILITY',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$VISIBILITY$NullableType();
  static const type = $Property$VISIBILITY$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Property$VISIBILITY> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Property$VISIBILITY $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$VISIBILITY',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property$VISIBILITY.implement($Property$VISIBILITY $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Property$VISIBILITY.fromReference($i.implementReference());
  }
}

abstract base mixin class $Property$VISIBILITY {
  factory $Property$VISIBILITY() = _$Property$VISIBILITY;
}

final class _$Property$VISIBILITY with $Property$VISIBILITY {
  _$Property$VISIBILITY();
}

final class $Property$VISIBILITY$NullableType
    extends jni$_.JObjType<Property$VISIBILITY?> {
  @jni$_.internal
  const $Property$VISIBILITY$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$VISIBILITY;';

  @jni$_.internal
  @core$_.override
  Property$VISIBILITY? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property$VISIBILITY.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$VISIBILITY?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$VISIBILITY$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$VISIBILITY$NullableType) &&
        other is $Property$VISIBILITY$NullableType;
  }
}

final class $Property$VISIBILITY$Type
    extends jni$_.JObjType<Property$VISIBILITY> {
  @jni$_.internal
  const $Property$VISIBILITY$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$VISIBILITY;';

  @jni$_.internal
  @core$_.override
  Property$VISIBILITY fromReference(jni$_.JReference reference) =>
      Property$VISIBILITY.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property$VISIBILITY?> get nullableType =>
      const $Property$VISIBILITY$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$VISIBILITY$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$VISIBILITY$Type) &&
        other is $Property$VISIBILITY$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property`
class Property extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Property> $type;

  @jni$_.internal
  Property.fromReference(jni$_.JReference reference)
      : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/style/layers/Property',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Property$NullableType();
  static const type = $Property$Type();
  static final _id_VISIBLE = _class.staticFieldId(
    r'VISIBLE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VISIBLE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VISIBLE =>
      _id_VISIBLE.get(_class, const jni$_.JStringNullableType());

  static final _id_NONE = _class.staticFieldId(r'NONE', r'Ljava/lang/String;');

  /// from: `static public final java.lang.String NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NONE =>
      _id_NONE.get(_class, const jni$_.JStringNullableType());

  static final _id_LINE_CAP_BUTT = _class.staticFieldId(
    r'LINE_CAP_BUTT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_BUTT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LINE_CAP_BUTT =>
      _id_LINE_CAP_BUTT.get(_class, const jni$_.JStringNullableType());

  static final _id_LINE_CAP_ROUND = _class.staticFieldId(
    r'LINE_CAP_ROUND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LINE_CAP_ROUND =>
      _id_LINE_CAP_ROUND.get(_class, const jni$_.JStringNullableType());

  static final _id_LINE_CAP_SQUARE = _class.staticFieldId(
    r'LINE_CAP_SQUARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_SQUARE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LINE_CAP_SQUARE =>
      _id_LINE_CAP_SQUARE.get(_class, const jni$_.JStringNullableType());

  static final _id_LINE_JOIN_BEVEL = _class.staticFieldId(
    r'LINE_JOIN_BEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_BEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LINE_JOIN_BEVEL =>
      _id_LINE_JOIN_BEVEL.get(_class, const jni$_.JStringNullableType());

  static final _id_LINE_JOIN_ROUND = _class.staticFieldId(
    r'LINE_JOIN_ROUND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LINE_JOIN_ROUND =>
      _id_LINE_JOIN_ROUND.get(_class, const jni$_.JStringNullableType());

  static final _id_LINE_JOIN_MITER = _class.staticFieldId(
    r'LINE_JOIN_MITER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_MITER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LINE_JOIN_MITER =>
      _id_LINE_JOIN_MITER.get(_class, const jni$_.JStringNullableType());

  static final _id_SYMBOL_PLACEMENT_POINT = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_POINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_POINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYMBOL_PLACEMENT_POINT =>
      _id_SYMBOL_PLACEMENT_POINT.get(_class, const jni$_.JStringNullableType());

  static final _id_SYMBOL_PLACEMENT_LINE = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_LINE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_LINE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYMBOL_PLACEMENT_LINE =>
      _id_SYMBOL_PLACEMENT_LINE.get(_class, const jni$_.JStringNullableType());

  static final _id_SYMBOL_PLACEMENT_LINE_CENTER = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_LINE_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_LINE_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYMBOL_PLACEMENT_LINE_CENTER =>
      _id_SYMBOL_PLACEMENT_LINE_CENTER.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_SYMBOL_Z_ORDER_AUTO = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYMBOL_Z_ORDER_AUTO =>
      _id_SYMBOL_Z_ORDER_AUTO.get(_class, const jni$_.JStringNullableType());

  static final _id_SYMBOL_Z_ORDER_VIEWPORT_Y = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_VIEWPORT_Y',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_VIEWPORT_Y`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYMBOL_Z_ORDER_VIEWPORT_Y =>
      _id_SYMBOL_Z_ORDER_VIEWPORT_Y.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_SYMBOL_Z_ORDER_SOURCE = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_SOURCE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_SOURCE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYMBOL_Z_ORDER_SOURCE =>
      _id_SYMBOL_Z_ORDER_SOURCE.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ROTATION_ALIGNMENT_MAP = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ROTATION_ALIGNMENT_MAP =>
      _id_ICON_ROTATION_ALIGNMENT_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_ROTATION_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ROTATION_ALIGNMENT_VIEWPORT =>
      _id_ICON_ROTATION_ALIGNMENT_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_ROTATION_ALIGNMENT_AUTO = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ROTATION_ALIGNMENT_AUTO =>
      _id_ICON_ROTATION_ALIGNMENT_AUTO.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_TEXT_FIT_NONE = _class.staticFieldId(
    r'ICON_TEXT_FIT_NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_TEXT_FIT_NONE =>
      _id_ICON_TEXT_FIT_NONE.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_TEXT_FIT_WIDTH = _class.staticFieldId(
    r'ICON_TEXT_FIT_WIDTH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_WIDTH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_TEXT_FIT_WIDTH =>
      _id_ICON_TEXT_FIT_WIDTH.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_TEXT_FIT_HEIGHT = _class.staticFieldId(
    r'ICON_TEXT_FIT_HEIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_HEIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_TEXT_FIT_HEIGHT =>
      _id_ICON_TEXT_FIT_HEIGHT.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_TEXT_FIT_BOTH = _class.staticFieldId(
    r'ICON_TEXT_FIT_BOTH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_BOTH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_TEXT_FIT_BOTH =>
      _id_ICON_TEXT_FIT_BOTH.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ANCHOR_CENTER = _class.staticFieldId(
    r'ICON_ANCHOR_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_CENTER =>
      _id_ICON_ANCHOR_CENTER.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ANCHOR_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_LEFT =>
      _id_ICON_ANCHOR_LEFT.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ANCHOR_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_RIGHT =>
      _id_ICON_ANCHOR_RIGHT.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ANCHOR_TOP = _class.staticFieldId(
    r'ICON_ANCHOR_TOP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_TOP =>
      _id_ICON_ANCHOR_TOP.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ANCHOR_BOTTOM = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_BOTTOM =>
      _id_ICON_ANCHOR_BOTTOM.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ANCHOR_TOP_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_TOP_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_TOP_LEFT =>
      _id_ICON_ANCHOR_TOP_LEFT.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ANCHOR_TOP_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_TOP_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_TOP_RIGHT =>
      _id_ICON_ANCHOR_TOP_RIGHT.get(_class, const jni$_.JStringNullableType());

  static final _id_ICON_ANCHOR_BOTTOM_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_BOTTOM_LEFT =>
      _id_ICON_ANCHOR_BOTTOM_LEFT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_ANCHOR_BOTTOM_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_ANCHOR_BOTTOM_RIGHT =>
      _id_ICON_ANCHOR_BOTTOM_RIGHT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_PITCH_ALIGNMENT_MAP =>
      _id_ICON_PITCH_ALIGNMENT_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_PITCH_ALIGNMENT_VIEWPORT =>
      _id_ICON_PITCH_ALIGNMENT_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_PITCH_ALIGNMENT_AUTO = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_PITCH_ALIGNMENT_AUTO =>
      _id_ICON_PITCH_ALIGNMENT_AUTO.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_PITCH_ALIGNMENT_MAP =>
      _id_TEXT_PITCH_ALIGNMENT_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_PITCH_ALIGNMENT_VIEWPORT =>
      _id_TEXT_PITCH_ALIGNMENT_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_PITCH_ALIGNMENT_AUTO = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_PITCH_ALIGNMENT_AUTO =>
      _id_TEXT_PITCH_ALIGNMENT_AUTO.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_ROTATION_ALIGNMENT_MAP = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ROTATION_ALIGNMENT_MAP =>
      _id_TEXT_ROTATION_ALIGNMENT_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_ROTATION_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ROTATION_ALIGNMENT_VIEWPORT =>
      _id_TEXT_ROTATION_ALIGNMENT_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_ROTATION_ALIGNMENT_AUTO = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ROTATION_ALIGNMENT_AUTO =>
      _id_TEXT_ROTATION_ALIGNMENT_AUTO.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_JUSTIFY_AUTO = _class.staticFieldId(
    r'TEXT_JUSTIFY_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_JUSTIFY_AUTO =>
      _id_TEXT_JUSTIFY_AUTO.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_JUSTIFY_LEFT = _class.staticFieldId(
    r'TEXT_JUSTIFY_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_JUSTIFY_LEFT =>
      _id_TEXT_JUSTIFY_LEFT.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_JUSTIFY_CENTER = _class.staticFieldId(
    r'TEXT_JUSTIFY_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_JUSTIFY_CENTER =>
      _id_TEXT_JUSTIFY_CENTER.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_JUSTIFY_RIGHT = _class.staticFieldId(
    r'TEXT_JUSTIFY_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_JUSTIFY_RIGHT =>
      _id_TEXT_JUSTIFY_RIGHT.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_ANCHOR_CENTER = _class.staticFieldId(
    r'TEXT_ANCHOR_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_CENTER =>
      _id_TEXT_ANCHOR_CENTER.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_ANCHOR_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_LEFT =>
      _id_TEXT_ANCHOR_LEFT.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_ANCHOR_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_RIGHT =>
      _id_TEXT_ANCHOR_RIGHT.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_ANCHOR_TOP = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_TOP =>
      _id_TEXT_ANCHOR_TOP.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_ANCHOR_BOTTOM = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_BOTTOM =>
      _id_TEXT_ANCHOR_BOTTOM.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_ANCHOR_TOP_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_TOP_LEFT =>
      _id_TEXT_ANCHOR_TOP_LEFT.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_ANCHOR_TOP_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_TOP_RIGHT =>
      _id_TEXT_ANCHOR_TOP_RIGHT.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_ANCHOR_BOTTOM_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_BOTTOM_LEFT =>
      _id_TEXT_ANCHOR_BOTTOM_LEFT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_ANCHOR_BOTTOM_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_ANCHOR_BOTTOM_RIGHT =>
      _id_TEXT_ANCHOR_BOTTOM_RIGHT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_TRANSFORM_NONE = _class.staticFieldId(
    r'TEXT_TRANSFORM_NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_TRANSFORM_NONE =>
      _id_TEXT_TRANSFORM_NONE.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_TRANSFORM_UPPERCASE = _class.staticFieldId(
    r'TEXT_TRANSFORM_UPPERCASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_UPPERCASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_TRANSFORM_UPPERCASE =>
      _id_TEXT_TRANSFORM_UPPERCASE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_TRANSFORM_LOWERCASE = _class.staticFieldId(
    r'TEXT_TRANSFORM_LOWERCASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_LOWERCASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_TRANSFORM_LOWERCASE =>
      _id_TEXT_TRANSFORM_LOWERCASE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_FILL_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'FILL_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FILL_TRANSLATE_ANCHOR_MAP =>
      _id_FILL_TRANSLATE_ANCHOR_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_FILL_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'FILL_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FILL_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_FILL_TRANSLATE_ANCHOR_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_LINE_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'LINE_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LINE_TRANSLATE_ANCHOR_MAP =>
      _id_LINE_TRANSLATE_ANCHOR_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_LINE_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'LINE_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LINE_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_LINE_TRANSLATE_ANCHOR_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'ICON_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_TRANSLATE_ANCHOR_MAP =>
      _id_ICON_TRANSLATE_ANCHOR_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ICON_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'ICON_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ICON_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_ICON_TRANSLATE_ANCHOR_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'TEXT_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_TRANSLATE_ANCHOR_MAP =>
      _id_TEXT_TRANSLATE_ANCHOR_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'TEXT_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_TEXT_TRANSLATE_ANCHOR_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_CIRCLE_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'CIRCLE_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CIRCLE_TRANSLATE_ANCHOR_MAP =>
      _id_CIRCLE_TRANSLATE_ANCHOR_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_CIRCLE_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CIRCLE_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_CIRCLE_TRANSLATE_ANCHOR_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_CIRCLE_PITCH_SCALE_MAP = _class.staticFieldId(
    r'CIRCLE_PITCH_SCALE_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_SCALE_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CIRCLE_PITCH_SCALE_MAP =>
      _id_CIRCLE_PITCH_SCALE_MAP.get(_class, const jni$_.JStringNullableType());

  static final _id_CIRCLE_PITCH_SCALE_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_PITCH_SCALE_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_SCALE_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CIRCLE_PITCH_SCALE_VIEWPORT =>
      _id_CIRCLE_PITCH_SCALE_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_CIRCLE_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'CIRCLE_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CIRCLE_PITCH_ALIGNMENT_MAP =>
      _id_CIRCLE_PITCH_ALIGNMENT_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_CIRCLE_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CIRCLE_PITCH_ALIGNMENT_VIEWPORT =>
      _id_CIRCLE_PITCH_ALIGNMENT_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP =>
      _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT =
      _class.staticFieldId(
    r'FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_RASTER_RESAMPLING_LINEAR = _class.staticFieldId(
    r'RASTER_RESAMPLING_LINEAR',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RASTER_RESAMPLING_LINEAR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RASTER_RESAMPLING_LINEAR =>
      _id_RASTER_RESAMPLING_LINEAR.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_RASTER_RESAMPLING_NEAREST = _class.staticFieldId(
    r'RASTER_RESAMPLING_NEAREST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RASTER_RESAMPLING_NEAREST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RASTER_RESAMPLING_NEAREST =>
      _id_RASTER_RESAMPLING_NEAREST.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_HILLSHADE_ILLUMINATION_ANCHOR_MAP = _class.staticFieldId(
    r'HILLSHADE_ILLUMINATION_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HILLSHADE_ILLUMINATION_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HILLSHADE_ILLUMINATION_ANCHOR_MAP =>
      _id_HILLSHADE_ILLUMINATION_ANCHOR_MAP.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT =
      _class.staticFieldId(
    r'HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT =>
      _id_HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ANCHOR_MAP = _class.staticFieldId(
    r'ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ANCHOR_MAP =>
      _id_ANCHOR_MAP.get(_class, const jni$_.JStringNullableType());

  static final _id_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ANCHOR_VIEWPORT =>
      _id_ANCHOR_VIEWPORT.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_WRITING_MODE_HORIZONTAL = _class.staticFieldId(
    r'TEXT_WRITING_MODE_HORIZONTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_WRITING_MODE_HORIZONTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_WRITING_MODE_HORIZONTAL =>
      _id_TEXT_WRITING_MODE_HORIZONTAL.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_WRITING_MODE_VERTICAL = _class.staticFieldId(
    r'TEXT_WRITING_MODE_VERTICAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_WRITING_MODE_VERTICAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_WRITING_MODE_VERTICAL =>
      _id_TEXT_WRITING_MODE_VERTICAL.get(
        _class,
        const jni$_.JStringNullableType(),
      );
}

final class $Property$NullableType extends jni$_.JObjType<Property?> {
  @jni$_.internal
  const $Property$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/style/layers/Property;';

  @jni$_.internal
  @core$_.override
  Property? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Property.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$NullableType) &&
        other is $Property$NullableType;
  }
}

final class $Property$Type extends jni$_.JObjType<Property> {
  @jni$_.internal
  const $Property$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/style/layers/Property;';

  @jni$_.internal
  @core$_.override
  Property fromReference(jni$_.JReference reference) =>
      Property.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Property?> get nullableType => const $Property$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Property$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$Type) && other is $Property$Type;
  }
}
