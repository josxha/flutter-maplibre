// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: document_ignores
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../style/layers/Layer.dart' as layer$_;

import '../style/layers/TransitionOptions.dart' as transitionoptions$_;

import '../style/light/Light.dart' as light$_;

import '../style/sources/Source.dart' as source$_;

import '../util/DefaultStyle.dart' as defaultstyle$_;

import 'Image.dart' as image$_;

import 'ImageContent.dart' as imagecontent$_;

import 'ImageStretches.dart' as imagestretches$_;

/// from: `org.maplibre.android.maps.Style$Builder$ImageWrapper`
class Style$Builder$ImageWrapper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Style$Builder$ImageWrapper> $type;

  @jni$_.internal
  Style$Builder$ImageWrapper.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/Style$Builder$ImageWrapper',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Style$Builder$ImageWrapper$NullableType();
  static const type = $Style$Builder$ImageWrapper$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;Z)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, android.graphics.Bitmap bitmap, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Style$Builder$ImageWrapper(
    jni$_.JString? string,
    jni$_.JObject? bitmap,
    bool z,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return Style$Builder$ImageWrapper.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$bitmap.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;ZLjava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, android.graphics.Bitmap bitmap, boolean z, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Style$Builder$ImageWrapper.new$1(
    jni$_.JString? string,
    jni$_.JObject? bitmap,
    bool z,
    jni$_.JList<imagestretches$_.ImageStretches?>? list,
    jni$_.JList<imagestretches$_.ImageStretches?>? list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    return Style$Builder$ImageWrapper.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$bitmap.pointer,
        z ? 1 : 0,
        _$list.pointer,
        _$list1.pointer,
        _$imageContent.pointer,
      ).reference,
    );
  }

  static final _id_getBitmap = _class.instanceMethodId(
    r'getBitmap',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _getBitmap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Bitmap getBitmap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getBitmap() {
    return _getBitmap(
      reference.pointer,
      _id_getBitmap as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getId() {
    return _getId(
      reference.pointer,
      _id_getId as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isSdf = _class.instanceMethodId(r'isSdf', r'()Z');

  static final _isSdf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isSdf()`
  bool isSdf() {
    return _isSdf(reference.pointer, _id_isSdf as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_getStretchX = _class.instanceMethodId(
    r'getStretchX',
    r'()Ljava/util/List;',
  );

  static final _getStretchX =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getStretchX()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<imagestretches$_.ImageStretches?>? getStretchX() {
    return _getStretchX(
      reference.pointer,
      _id_getStretchX as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<imagestretches$_.ImageStretches?>?>(
      const jni$_.JListNullableType<imagestretches$_.ImageStretches?>(
        imagestretches$_.$ImageStretches$NullableType(),
      ),
    );
  }

  static final _id_getStretchY = _class.instanceMethodId(
    r'getStretchY',
    r'()Ljava/util/List;',
  );

  static final _getStretchY =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getStretchY()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<imagestretches$_.ImageStretches?>? getStretchY() {
    return _getStretchY(
      reference.pointer,
      _id_getStretchY as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<imagestretches$_.ImageStretches?>?>(
      const jni$_.JListNullableType<imagestretches$_.ImageStretches?>(
        imagestretches$_.$ImageStretches$NullableType(),
      ),
    );
  }

  static final _id_getContent = _class.instanceMethodId(
    r'getContent',
    r'()Lorg/maplibre/android/maps/ImageContent;',
  );

  static final _getContent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.maps.ImageContent getContent()`
  /// The returned object must be released after use, by calling the [release] method.
  imagecontent$_.ImageContent? getContent() {
    return _getContent(
      reference.pointer,
      _id_getContent as jni$_.JMethodIDPtr,
    ).object<imagecontent$_.ImageContent?>(
      const imagecontent$_.$ImageContent$NullableType(),
    );
  }

  static final _id_convertToImageArray = _class.staticMethodId(
    r'convertToImageArray',
    r'(Ljava/util/HashMap;Z)[Lorg/maplibre/android/maps/Style$Builder$ImageWrapper;',
  );

  static final _convertToImageArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.lang.Object[] convertToImageArray(java.util.HashMap hashMap, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Style$Builder$ImageWrapper?>? convertToImageArray(
    jni$_.JObject? hashMap,
    bool z,
  ) {
    final _$hashMap = hashMap?.reference ?? jni$_.jNullReference;
    return _convertToImageArray(
      _class.reference.pointer,
      _id_convertToImageArray as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
      z ? 1 : 0,
    ).object<jni$_.JArray<Style$Builder$ImageWrapper?>?>(
      const jni$_.JArrayNullableType<Style$Builder$ImageWrapper?>(
        $Style$Builder$ImageWrapper$NullableType(),
      ),
    );
  }

  static final _id_convertToImageArray$1 = _class.staticMethodId(
    r'convertToImageArray',
    r'(Ljava/util/HashMap;ZLjava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)[Lorg/maplibre/android/maps/Style$Builder$ImageWrapper;',
  );

  static final _convertToImageArray$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object[] convertToImageArray(java.util.HashMap hashMap, boolean z, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Style$Builder$ImageWrapper?>? convertToImageArray$1(
    jni$_.JObject? hashMap,
    bool z,
    jni$_.JList<imagestretches$_.ImageStretches?>? list,
    jni$_.JList<imagestretches$_.ImageStretches?>? list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$hashMap = hashMap?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    return _convertToImageArray$1(
      _class.reference.pointer,
      _id_convertToImageArray$1 as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
      z ? 1 : 0,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).object<jni$_.JArray<Style$Builder$ImageWrapper?>?>(
      const jni$_.JArrayNullableType<Style$Builder$ImageWrapper?>(
        $Style$Builder$ImageWrapper$NullableType(),
      ),
    );
  }
}

final class $Style$Builder$ImageWrapper$NullableType
    extends jni$_.JObjType<Style$Builder$ImageWrapper?> {
  @jni$_.internal
  const $Style$Builder$ImageWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$ImageWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$ImageWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Style$Builder$ImageWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$ImageWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$Builder$ImageWrapper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$ImageWrapper$NullableType) &&
        other is $Style$Builder$ImageWrapper$NullableType;
  }
}

final class $Style$Builder$ImageWrapper$Type
    extends jni$_.JObjType<Style$Builder$ImageWrapper> {
  @jni$_.internal
  const $Style$Builder$ImageWrapper$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$ImageWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$ImageWrapper fromReference(jni$_.JReference reference) =>
      Style$Builder$ImageWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$ImageWrapper?> get nullableType =>
      const $Style$Builder$ImageWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$Builder$ImageWrapper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$ImageWrapper$Type) &&
        other is $Style$Builder$ImageWrapper$Type;
  }
}

/// from: `org.maplibre.android.maps.Style$Builder$LayerAboveWrapper`
class Style$Builder$LayerAboveWrapper extends Style$Builder$LayerWrapper {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Style$Builder$LayerAboveWrapper> $type;

  @jni$_.internal
  Style$Builder$LayerAboveWrapper.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/Style$Builder$LayerAboveWrapper',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Style$Builder$LayerAboveWrapper$NullableType();
  static const type = $Style$Builder$LayerAboveWrapper$Type();
  static final _id_getAboveLayer = _class.instanceMethodId(
    r'getAboveLayer',
    r'()Ljava/lang/String;',
  );

  static final _getAboveLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getAboveLayer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAboveLayer() {
    return _getAboveLayer(
      reference.pointer,
      _id_getAboveLayer as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Style$Builder$LayerAboveWrapper$NullableType
    extends jni$_.JObjType<Style$Builder$LayerAboveWrapper?> {
  @jni$_.internal
  const $Style$Builder$LayerAboveWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$LayerAboveWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$LayerAboveWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Style$Builder$LayerAboveWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $Style$Builder$LayerWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$LayerAboveWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Style$Builder$LayerAboveWrapper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Style$Builder$LayerAboveWrapper$NullableType) &&
        other is $Style$Builder$LayerAboveWrapper$NullableType;
  }
}

final class $Style$Builder$LayerAboveWrapper$Type
    extends jni$_.JObjType<Style$Builder$LayerAboveWrapper> {
  @jni$_.internal
  const $Style$Builder$LayerAboveWrapper$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$LayerAboveWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$LayerAboveWrapper fromReference(jni$_.JReference reference) =>
      Style$Builder$LayerAboveWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $Style$Builder$LayerWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$LayerAboveWrapper?> get nullableType =>
      const $Style$Builder$LayerAboveWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Style$Builder$LayerAboveWrapper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$LayerAboveWrapper$Type) &&
        other is $Style$Builder$LayerAboveWrapper$Type;
  }
}

/// from: `org.maplibre.android.maps.Style$Builder$LayerAtWrapper`
class Style$Builder$LayerAtWrapper extends Style$Builder$LayerWrapper {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Style$Builder$LayerAtWrapper> $type;

  @jni$_.internal
  Style$Builder$LayerAtWrapper.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/Style$Builder$LayerAtWrapper',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Style$Builder$LayerAtWrapper$NullableType();
  static const type = $Style$Builder$LayerAtWrapper$Type();
  static final _id_getIndex = _class.instanceMethodId(r'getIndex', r'()I');

  static final _getIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getIndex()`
  int getIndex() {
    return _getIndex(
      reference.pointer,
      _id_getIndex as jni$_.JMethodIDPtr,
    ).integer;
  }
}

final class $Style$Builder$LayerAtWrapper$NullableType
    extends jni$_.JObjType<Style$Builder$LayerAtWrapper?> {
  @jni$_.internal
  const $Style$Builder$LayerAtWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$LayerAtWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$LayerAtWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Style$Builder$LayerAtWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $Style$Builder$LayerWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$LayerAtWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Style$Builder$LayerAtWrapper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$LayerAtWrapper$NullableType) &&
        other is $Style$Builder$LayerAtWrapper$NullableType;
  }
}

final class $Style$Builder$LayerAtWrapper$Type
    extends jni$_.JObjType<Style$Builder$LayerAtWrapper> {
  @jni$_.internal
  const $Style$Builder$LayerAtWrapper$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$LayerAtWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$LayerAtWrapper fromReference(jni$_.JReference reference) =>
      Style$Builder$LayerAtWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $Style$Builder$LayerWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$LayerAtWrapper?> get nullableType =>
      const $Style$Builder$LayerAtWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Style$Builder$LayerAtWrapper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$LayerAtWrapper$Type) &&
        other is $Style$Builder$LayerAtWrapper$Type;
  }
}

/// from: `org.maplibre.android.maps.Style$Builder$LayerBelowWrapper`
class Style$Builder$LayerBelowWrapper extends Style$Builder$LayerWrapper {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Style$Builder$LayerBelowWrapper> $type;

  @jni$_.internal
  Style$Builder$LayerBelowWrapper.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/Style$Builder$LayerBelowWrapper',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Style$Builder$LayerBelowWrapper$NullableType();
  static const type = $Style$Builder$LayerBelowWrapper$Type();
  static final _id_getBelowLayer = _class.instanceMethodId(
    r'getBelowLayer',
    r'()Ljava/lang/String;',
  );

  static final _getBelowLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getBelowLayer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getBelowLayer() {
    return _getBelowLayer(
      reference.pointer,
      _id_getBelowLayer as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Style$Builder$LayerBelowWrapper$NullableType
    extends jni$_.JObjType<Style$Builder$LayerBelowWrapper?> {
  @jni$_.internal
  const $Style$Builder$LayerBelowWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$LayerBelowWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$LayerBelowWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Style$Builder$LayerBelowWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $Style$Builder$LayerWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$LayerBelowWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Style$Builder$LayerBelowWrapper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Style$Builder$LayerBelowWrapper$NullableType) &&
        other is $Style$Builder$LayerBelowWrapper$NullableType;
  }
}

final class $Style$Builder$LayerBelowWrapper$Type
    extends jni$_.JObjType<Style$Builder$LayerBelowWrapper> {
  @jni$_.internal
  const $Style$Builder$LayerBelowWrapper$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$LayerBelowWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$LayerBelowWrapper fromReference(jni$_.JReference reference) =>
      Style$Builder$LayerBelowWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $Style$Builder$LayerWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$LayerBelowWrapper?> get nullableType =>
      const $Style$Builder$LayerBelowWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Style$Builder$LayerBelowWrapper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$LayerBelowWrapper$Type) &&
        other is $Style$Builder$LayerBelowWrapper$Type;
  }
}

/// from: `org.maplibre.android.maps.Style$Builder$LayerWrapper`
class Style$Builder$LayerWrapper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Style$Builder$LayerWrapper> $type;

  @jni$_.internal
  Style$Builder$LayerWrapper.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/Style$Builder$LayerWrapper',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Style$Builder$LayerWrapper$NullableType();
  static const type = $Style$Builder$LayerWrapper$Type();
  static final _id_getLayer = _class.instanceMethodId(
    r'getLayer',
    r'()Lorg/maplibre/android/style/layers/Layer;',
  );

  static final _getLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.style.layers.Layer getLayer()`
  /// The returned object must be released after use, by calling the [release] method.
  layer$_.Layer? getLayer() {
    return _getLayer(
      reference.pointer,
      _id_getLayer as jni$_.JMethodIDPtr,
    ).object<layer$_.Layer?>(const layer$_.$Layer$NullableType());
  }
}

final class $Style$Builder$LayerWrapper$NullableType
    extends jni$_.JObjType<Style$Builder$LayerWrapper?> {
  @jni$_.internal
  const $Style$Builder$LayerWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$LayerWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$LayerWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Style$Builder$LayerWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$LayerWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$Builder$LayerWrapper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$LayerWrapper$NullableType) &&
        other is $Style$Builder$LayerWrapper$NullableType;
  }
}

final class $Style$Builder$LayerWrapper$Type
    extends jni$_.JObjType<Style$Builder$LayerWrapper> {
  @jni$_.internal
  const $Style$Builder$LayerWrapper$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/Style$Builder$LayerWrapper;';

  @jni$_.internal
  @core$_.override
  Style$Builder$LayerWrapper fromReference(jni$_.JReference reference) =>
      Style$Builder$LayerWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder$LayerWrapper?> get nullableType =>
      const $Style$Builder$LayerWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$Builder$LayerWrapper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$LayerWrapper$Type) &&
        other is $Style$Builder$LayerWrapper$Type;
  }
}

/// from: `org.maplibre.android.maps.Style$Builder`
class Style$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Style$Builder> $type;

  @jni$_.internal
  Style$Builder.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/Style$Builder',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Style$Builder$NullableType();
  static const type = $Style$Builder$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Style$Builder() {
    return Style$Builder.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_fromUrl = _class.instanceMethodId(
    r'fromUrl',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _fromUrl =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder fromUrl(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder fromUrl(jni$_.JString string) {
    final _$string = string.reference;
    return _fromUrl(
      reference.pointer,
      _id_fromUrl as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_fromUri = _class.instanceMethodId(
    r'fromUri',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _fromUri =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder fromUri(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder fromUri(jni$_.JString string) {
    final _$string = string.reference;
    return _fromUri(
      reference.pointer,
      _id_fromUri as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_fromJson = _class.instanceMethodId(
    r'fromJson',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _fromJson =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder fromJson(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder fromJson(jni$_.JString string) {
    final _$string = string.reference;
    return _fromJson(
      reference.pointer,
      _id_fromJson as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withSource = _class.instanceMethodId(
    r'withSource',
    r'(Lorg/maplibre/android/style/sources/Source;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withSource(org.maplibre.android.style.sources.Source source)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withSource(source$_.Source source) {
    final _$source = source.reference;
    return _withSource(
      reference.pointer,
      _id_withSource as jni$_.JMethodIDPtr,
      _$source.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withSources = _class.instanceMethodId(
    r'withSources',
    r'([Lorg/maplibre/android/style/sources/Source;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withSources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withSources(org.maplibre.android.style.sources.Source[] sources)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withSources(jni$_.JArray<source$_.Source?> sources) {
    final _$sources = sources.reference;
    return _withSources(
      reference.pointer,
      _id_withSources as jni$_.JMethodIDPtr,
      _$sources.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withLayer = _class.instanceMethodId(
    r'withLayer',
    r'(Lorg/maplibre/android/style/layers/Layer;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withLayer(org.maplibre.android.style.layers.Layer layer)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withLayer(layer$_.Layer layer) {
    final _$layer = layer.reference;
    return _withLayer(
      reference.pointer,
      _id_withLayer as jni$_.JMethodIDPtr,
      _$layer.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withLayers = _class.instanceMethodId(
    r'withLayers',
    r'([Lorg/maplibre/android/style/layers/Layer;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withLayers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withLayers(org.maplibre.android.style.layers.Layer[] layers)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withLayers(jni$_.JArray<layer$_.Layer?> layers) {
    final _$layers = layers.reference;
    return _withLayers(
      reference.pointer,
      _id_withLayers as jni$_.JMethodIDPtr,
      _$layers.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withLayerAt = _class.instanceMethodId(
    r'withLayerAt',
    r'(Lorg/maplibre/android/style/layers/Layer;I)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withLayerAt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withLayerAt(org.maplibre.android.style.layers.Layer layer, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withLayerAt(layer$_.Layer layer, int i) {
    final _$layer = layer.reference;
    return _withLayerAt(
      reference.pointer,
      _id_withLayerAt as jni$_.JMethodIDPtr,
      _$layer.pointer,
      i,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withLayerAbove = _class.instanceMethodId(
    r'withLayerAbove',
    r'(Lorg/maplibre/android/style/layers/Layer;Ljava/lang/String;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withLayerAbove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withLayerAbove(org.maplibre.android.style.layers.Layer layer, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withLayerAbove(layer$_.Layer layer, jni$_.JString string) {
    final _$layer = layer.reference;
    final _$string = string.reference;
    return _withLayerAbove(
      reference.pointer,
      _id_withLayerAbove as jni$_.JMethodIDPtr,
      _$layer.pointer,
      _$string.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withLayerBelow = _class.instanceMethodId(
    r'withLayerBelow',
    r'(Lorg/maplibre/android/style/layers/Layer;Ljava/lang/String;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withLayerBelow =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withLayerBelow(org.maplibre.android.style.layers.Layer layer, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withLayerBelow(layer$_.Layer layer, jni$_.JString string) {
    final _$layer = layer.reference;
    final _$string = string.reference;
    return _withLayerBelow(
      reference.pointer,
      _id_withLayerBelow as jni$_.JMethodIDPtr,
      _$layer.pointer,
      _$string.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withTransition = _class.instanceMethodId(
    r'withTransition',
    r'(Lorg/maplibre/android/style/layers/TransitionOptions;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withTransition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withTransition(org.maplibre.android.style.layers.TransitionOptions transitionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withTransition(
    transitionoptions$_.TransitionOptions transitionOptions,
  ) {
    final _$transitionOptions = transitionOptions.reference;
    return _withTransition(
      reference.pointer,
      _id_withTransition as jni$_.JMethodIDPtr,
      _$transitionOptions.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withImage = _class.instanceMethodId(
    r'withImage',
    r'(Ljava/lang/String;Landroid/graphics/drawable/Drawable;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withImage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withImage(java.lang.String string, android.graphics.drawable.Drawable drawable)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withImage(jni$_.JString string, jni$_.JObject drawable) {
    final _$string = string.reference;
    final _$drawable = drawable.reference;
    return _withImage(
      reference.pointer,
      _id_withImage as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$drawable.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withImage$1 = _class.instanceMethodId(
    r'withImage',
    r'(Ljava/lang/String;Landroid/graphics/drawable/Drawable;Ljava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withImage$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withImage(java.lang.String string, android.graphics.drawable.Drawable drawable, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withImage$1(
    jni$_.JString string,
    jni$_.JObject drawable,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$drawable = drawable.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    return _withImage$1(
      reference.pointer,
      _id_withImage$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$drawable.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withDrawableImages = _class.instanceMethodId(
    r'withDrawableImages',
    r'([Landroid/util/Pair;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withDrawableImages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withDrawableImages(java.lang.Object[] pairs)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withDrawableImages(jni$_.JArray<jni$_.JObject?> pairs) {
    final _$pairs = pairs.reference;
    return _withDrawableImages(
      reference.pointer,
      _id_withDrawableImages as jni$_.JMethodIDPtr,
      _$pairs.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withImage$2 = _class.instanceMethodId(
    r'withImage',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withImage$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withImage(java.lang.String string, android.graphics.Bitmap bitmap)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withImage$2(jni$_.JString string, jni$_.JObject bitmap) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    return _withImage$2(
      reference.pointer,
      _id_withImage$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withImage$3 = _class.instanceMethodId(
    r'withImage',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;Ljava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withImage$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withImage(java.lang.String string, android.graphics.Bitmap bitmap, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withImage$3(
    jni$_.JString string,
    jni$_.JObject bitmap,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    return _withImage$3(
      reference.pointer,
      _id_withImage$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withBitmapImages = _class.instanceMethodId(
    r'withBitmapImages',
    r'([Landroid/util/Pair;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withBitmapImages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withBitmapImages(java.lang.Object[] pairs)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withBitmapImages(jni$_.JArray<jni$_.JObject?> pairs) {
    final _$pairs = pairs.reference;
    return _withBitmapImages(
      reference.pointer,
      _id_withBitmapImages as jni$_.JMethodIDPtr,
      _$pairs.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withImage$4 = _class.instanceMethodId(
    r'withImage',
    r'(Ljava/lang/String;Landroid/graphics/drawable/Drawable;Z)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withImage$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withImage(java.lang.String string, android.graphics.drawable.Drawable drawable, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withImage$4(
    jni$_.JString string,
    jni$_.JObject drawable,
    bool z,
  ) {
    final _$string = string.reference;
    final _$drawable = drawable.reference;
    return _withImage$4(
      reference.pointer,
      _id_withImage$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$drawable.pointer,
      z ? 1 : 0,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withImage$5 = _class.instanceMethodId(
    r'withImage',
    r'(Ljava/lang/String;Landroid/graphics/drawable/Drawable;ZLjava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withImage$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withImage(java.lang.String string, android.graphics.drawable.Drawable drawable, boolean z, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withImage$5(
    jni$_.JString string,
    jni$_.JObject drawable,
    bool z,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$drawable = drawable.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    return _withImage$5(
      reference.pointer,
      _id_withImage$5 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$drawable.pointer,
      z ? 1 : 0,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withDrawableImages$1 = _class.instanceMethodId(
    r'withDrawableImages',
    r'(Z[Landroid/util/Pair;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withDrawableImages$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withDrawableImages(boolean z, java.lang.Object[] pairs)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withDrawableImages$1(
    bool z,
    jni$_.JArray<jni$_.JObject?> pairs,
  ) {
    final _$pairs = pairs.reference;
    return _withDrawableImages$1(
      reference.pointer,
      _id_withDrawableImages$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      _$pairs.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withImage$6 = _class.instanceMethodId(
    r'withImage',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;Z)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withImage$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withImage(java.lang.String string, android.graphics.Bitmap bitmap, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withImage$6(
    jni$_.JString string,
    jni$_.JObject bitmap,
    bool z,
  ) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    return _withImage$6(
      reference.pointer,
      _id_withImage$6 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      z ? 1 : 0,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withImage$7 = _class.instanceMethodId(
    r'withImage',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;ZLjava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withImage$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withImage(java.lang.String string, android.graphics.Bitmap bitmap, boolean z, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withImage$7(
    jni$_.JString string,
    jni$_.JObject bitmap,
    bool z,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    return _withImage$7(
      reference.pointer,
      _id_withImage$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      z ? 1 : 0,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_withBitmapImages$1 = _class.instanceMethodId(
    r'withBitmapImages',
    r'(Z[Landroid/util/Pair;)Lorg/maplibre/android/maps/Style$Builder;',
  );

  static final _withBitmapImages$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.maps.Style$Builder withBitmapImages(boolean z, java.lang.Object[] pairs)`
  /// The returned object must be released after use, by calling the [release] method.
  Style$Builder withBitmapImages$1(bool z, jni$_.JArray<jni$_.JObject?> pairs) {
    final _$pairs = pairs.reference;
    return _withBitmapImages$1(
      reference.pointer,
      _id_withBitmapImages$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      _$pairs.pointer,
    ).object<Style$Builder>(const $Style$Builder$Type());
  }

  static final _id_getUri = _class.instanceMethodId(
    r'getUri',
    r'()Ljava/lang/String;',
  );

  static final _getUri =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getUri()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUri() {
    return _getUri(
      reference.pointer,
      _id_getUri as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getJson = _class.instanceMethodId(
    r'getJson',
    r'()Ljava/lang/String;',
  );

  static final _getJson =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getJson()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getJson() {
    return _getJson(
      reference.pointer,
      _id_getJson as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getSources = _class.instanceMethodId(
    r'getSources',
    r'()Ljava/util/List;',
  );

  static final _getSources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getSources()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<source$_.Source?>? getSources() {
    return _getSources(
      reference.pointer,
      _id_getSources as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<source$_.Source?>?>(
      const jni$_.JListNullableType<source$_.Source?>(
        source$_.$Source$NullableType(),
      ),
    );
  }

  static final _id_getLayers = _class.instanceMethodId(
    r'getLayers',
    r'()Ljava/util/List;',
  );

  static final _getLayers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getLayers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<Style$Builder$LayerWrapper?>? getLayers() {
    return _getLayers(
      reference.pointer,
      _id_getLayers as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<Style$Builder$LayerWrapper?>?>(
      const jni$_.JListNullableType<Style$Builder$LayerWrapper?>(
        $Style$Builder$LayerWrapper$NullableType(),
      ),
    );
  }

  static final _id_getImages = _class.instanceMethodId(
    r'getImages',
    r'()Ljava/util/List;',
  );

  static final _getImages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getImages()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<Style$Builder$ImageWrapper?>? getImages() {
    return _getImages(
      reference.pointer,
      _id_getImages as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<Style$Builder$ImageWrapper?>?>(
      const jni$_.JListNullableType<Style$Builder$ImageWrapper?>(
        $Style$Builder$ImageWrapper$NullableType(),
      ),
    );
  }
}

final class $Style$Builder$NullableType extends jni$_.JObjType<Style$Builder?> {
  @jni$_.internal
  const $Style$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/Style$Builder;';

  @jni$_.internal
  @core$_.override
  Style$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Style$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$Builder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$NullableType) &&
        other is $Style$Builder$NullableType;
  }
}

final class $Style$Builder$Type extends jni$_.JObjType<Style$Builder> {
  @jni$_.internal
  const $Style$Builder$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/Style$Builder;';

  @jni$_.internal
  @core$_.override
  Style$Builder fromReference(jni$_.JReference reference) =>
      Style$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$Builder?> get nullableType =>
      const $Style$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$Builder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Builder$Type) &&
        other is $Style$Builder$Type;
  }
}

/// from: `org.maplibre.android.maps.Style$OnStyleLoaded`
class Style$OnStyleLoaded extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Style$OnStyleLoaded> $type;

  @jni$_.internal
  Style$OnStyleLoaded.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/Style$OnStyleLoaded',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Style$OnStyleLoaded$NullableType();
  static const type = $Style$OnStyleLoaded$Type();
  static final _id_onStyleLoaded = _class.instanceMethodId(
    r'onStyleLoaded',
    r'(Lorg/maplibre/android/maps/Style;)V',
  );

  static final _onStyleLoaded =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onStyleLoaded(org.maplibre.android.maps.Style style)`
  void onStyleLoaded(Style style) {
    final _$style = style.reference;
    _onStyleLoaded(
      reference.pointer,
      _id_onStyleLoaded as jni$_.JMethodIDPtr,
      _$style.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Style$OnStyleLoaded> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onStyleLoaded(Lorg/maplibre/android/maps/Style;)V') {
        _$impls[$p]!.onStyleLoaded(
          $a![0]!.as(const $Style$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Style$OnStyleLoaded $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.Style$OnStyleLoaded',
      $p,
      _$invokePointer,
      [
        if ($impl.onStyleLoaded$async)
          r'onStyleLoaded(Lorg/maplibre/android/maps/Style;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Style$OnStyleLoaded.implement($Style$OnStyleLoaded $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Style$OnStyleLoaded.fromReference($i.implementReference());
  }
}

abstract base mixin class $Style$OnStyleLoaded {
  factory $Style$OnStyleLoaded({
    required void Function(Style style) onStyleLoaded,
    bool onStyleLoaded$async,
  }) = _$Style$OnStyleLoaded;

  void onStyleLoaded(Style style);
  bool get onStyleLoaded$async => false;
}

final class _$Style$OnStyleLoaded with $Style$OnStyleLoaded {
  _$Style$OnStyleLoaded({
    required void Function(Style style) onStyleLoaded,
    this.onStyleLoaded$async = false,
  }) : _onStyleLoaded = onStyleLoaded;

  final void Function(Style style) _onStyleLoaded;
  final bool onStyleLoaded$async;

  void onStyleLoaded(Style style) {
    return _onStyleLoaded(style);
  }
}

final class $Style$OnStyleLoaded$NullableType
    extends jni$_.JObjType<Style$OnStyleLoaded?> {
  @jni$_.internal
  const $Style$OnStyleLoaded$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/Style$OnStyleLoaded;';

  @jni$_.internal
  @core$_.override
  Style$OnStyleLoaded? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Style$OnStyleLoaded.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$OnStyleLoaded?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$OnStyleLoaded$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$OnStyleLoaded$NullableType) &&
        other is $Style$OnStyleLoaded$NullableType;
  }
}

final class $Style$OnStyleLoaded$Type
    extends jni$_.JObjType<Style$OnStyleLoaded> {
  @jni$_.internal
  const $Style$OnStyleLoaded$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/Style$OnStyleLoaded;';

  @jni$_.internal
  @core$_.override
  Style$OnStyleLoaded fromReference(jni$_.JReference reference) =>
      Style$OnStyleLoaded.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style$OnStyleLoaded?> get nullableType =>
      const $Style$OnStyleLoaded$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$OnStyleLoaded$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$OnStyleLoaded$Type) &&
        other is $Style$OnStyleLoaded$Type;
  }
}

/// from: `org.maplibre.android.maps.Style`
class Style extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Style> $type;

  @jni$_.internal
  Style.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/maps/Style',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Style$NullableType();
  static const type = $Style$Type();
  static final _id_getUrl = _class.instanceMethodId(
    r'getUrl',
    r'()Ljava/lang/String;',
  );

  static final _getUrl =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getUrl()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getUrl() {
    return _getUrl(
      reference.pointer,
      _id_getUrl as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getUri = _class.instanceMethodId(
    r'getUri',
    r'()Ljava/lang/String;',
  );

  static final _getUri =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getUri()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getUri() {
    return _getUri(
      reference.pointer,
      _id_getUri as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getJson = _class.instanceMethodId(
    r'getJson',
    r'()Ljava/lang/String;',
  );

  static final _getJson =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getJson()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getJson() {
    return _getJson(
      reference.pointer,
      _id_getJson as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getSources = _class.instanceMethodId(
    r'getSources',
    r'()Ljava/util/List;',
  );

  static final _getSources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getSources()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<source$_.Source?> getSources() {
    return _getSources(
      reference.pointer,
      _id_getSources as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<source$_.Source?>>(
      const jni$_.JListType<source$_.Source?>(source$_.$Source$NullableType()),
    );
  }

  static final _id_addSource = _class.instanceMethodId(
    r'addSource',
    r'(Lorg/maplibre/android/style/sources/Source;)V',
  );

  static final _addSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addSource(org.maplibre.android.style.sources.Source source)`
  void addSource(source$_.Source source) {
    final _$source = source.reference;
    _addSource(
      reference.pointer,
      _id_addSource as jni$_.JMethodIDPtr,
      _$source.pointer,
    ).check();
  }

  static final _id_getSource = _class.instanceMethodId(
    r'getSource',
    r'(Ljava/lang/String;)Lorg/maplibre/android/style/sources/Source;',
  );

  static final _getSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.style.sources.Source getSource(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  source$_.Source? getSource(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getSource(
      reference.pointer,
      _id_getSource as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<source$_.Source?>(const source$_.$Source$NullableType());
  }

  static final _id_getSourceAs = _class.instanceMethodId(
    r'getSourceAs',
    r'(Ljava/lang/String;)Lorg/maplibre/android/style/sources/Source;',
  );

  static final _getSourceAs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T getSourceAs(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getSourceAs<$T extends jni$_.JObject?>(
    jni$_.JString string, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string.reference;
    return _getSourceAs(
      reference.pointer,
      _id_getSourceAs as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_removeSource = _class.instanceMethodId(
    r'removeSource',
    r'(Ljava/lang/String;)Z',
  );

  static final _removeSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean removeSource(java.lang.String string)`
  bool removeSource(jni$_.JString string) {
    final _$string = string.reference;
    return _removeSource(
      reference.pointer,
      _id_removeSource as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_removeSource$1 = _class.instanceMethodId(
    r'removeSource',
    r'(Lorg/maplibre/android/style/sources/Source;)Z',
  );

  static final _removeSource$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean removeSource(org.maplibre.android.style.sources.Source source)`
  bool removeSource$1(source$_.Source source) {
    final _$source = source.reference;
    return _removeSource$1(
      reference.pointer,
      _id_removeSource$1 as jni$_.JMethodIDPtr,
      _$source.pointer,
    ).boolean;
  }

  static final _id_addLayer = _class.instanceMethodId(
    r'addLayer',
    r'(Lorg/maplibre/android/style/layers/Layer;)V',
  );

  static final _addLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addLayer(org.maplibre.android.style.layers.Layer layer)`
  void addLayer(layer$_.Layer layer) {
    final _$layer = layer.reference;
    _addLayer(
      reference.pointer,
      _id_addLayer as jni$_.JMethodIDPtr,
      _$layer.pointer,
    ).check();
  }

  static final _id_addLayerBelow = _class.instanceMethodId(
    r'addLayerBelow',
    r'(Lorg/maplibre/android/style/layers/Layer;Ljava/lang/String;)V',
  );

  static final _addLayerBelow =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addLayerBelow(org.maplibre.android.style.layers.Layer layer, java.lang.String string)`
  void addLayerBelow(layer$_.Layer layer, jni$_.JString string) {
    final _$layer = layer.reference;
    final _$string = string.reference;
    _addLayerBelow(
      reference.pointer,
      _id_addLayerBelow as jni$_.JMethodIDPtr,
      _$layer.pointer,
      _$string.pointer,
    ).check();
  }

  static final _id_addLayerAbove = _class.instanceMethodId(
    r'addLayerAbove',
    r'(Lorg/maplibre/android/style/layers/Layer;Ljava/lang/String;)V',
  );

  static final _addLayerAbove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addLayerAbove(org.maplibre.android.style.layers.Layer layer, java.lang.String string)`
  void addLayerAbove(layer$_.Layer layer, jni$_.JString string) {
    final _$layer = layer.reference;
    final _$string = string.reference;
    _addLayerAbove(
      reference.pointer,
      _id_addLayerAbove as jni$_.JMethodIDPtr,
      _$layer.pointer,
      _$string.pointer,
    ).check();
  }

  static final _id_addLayerAt = _class.instanceMethodId(
    r'addLayerAt',
    r'(Lorg/maplibre/android/style/layers/Layer;I)V',
  );

  static final _addLayerAt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void addLayerAt(org.maplibre.android.style.layers.Layer layer, int i)`
  void addLayerAt(layer$_.Layer layer, int i) {
    final _$layer = layer.reference;
    _addLayerAt(
      reference.pointer,
      _id_addLayerAt as jni$_.JMethodIDPtr,
      _$layer.pointer,
      i,
    ).check();
  }

  static final _id_getLayer = _class.instanceMethodId(
    r'getLayer',
    r'(Ljava/lang/String;)Lorg/maplibre/android/style/layers/Layer;',
  );

  static final _getLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.maplibre.android.style.layers.Layer getLayer(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  layer$_.Layer? getLayer(jni$_.JString string) {
    final _$string = string.reference;
    return _getLayer(
      reference.pointer,
      _id_getLayer as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<layer$_.Layer?>(const layer$_.$Layer$NullableType());
  }

  static final _id_getLayerAs = _class.instanceMethodId(
    r'getLayerAs',
    r'(Ljava/lang/String;)Lorg/maplibre/android/style/layers/Layer;',
  );

  static final _getLayerAs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T getLayerAs(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getLayerAs<$T extends jni$_.JObject?>(
    jni$_.JString string, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string.reference;
    return _getLayerAs(
      reference.pointer,
      _id_getLayerAs as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_getLayers = _class.instanceMethodId(
    r'getLayers',
    r'()Ljava/util/List;',
  );

  static final _getLayers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List getLayers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<layer$_.Layer?> getLayers() {
    return _getLayers(
      reference.pointer,
      _id_getLayers as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<layer$_.Layer?>>(
      const jni$_.JListType<layer$_.Layer?>(layer$_.$Layer$NullableType()),
    );
  }

  static final _id_removeLayer = _class.instanceMethodId(
    r'removeLayer',
    r'(Ljava/lang/String;)Z',
  );

  static final _removeLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean removeLayer(java.lang.String string)`
  bool removeLayer(jni$_.JString string) {
    final _$string = string.reference;
    return _removeLayer(
      reference.pointer,
      _id_removeLayer as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_removeLayer$1 = _class.instanceMethodId(
    r'removeLayer',
    r'(Lorg/maplibre/android/style/layers/Layer;)Z',
  );

  static final _removeLayer$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean removeLayer(org.maplibre.android.style.layers.Layer layer)`
  bool removeLayer$1(layer$_.Layer layer) {
    final _$layer = layer.reference;
    return _removeLayer$1(
      reference.pointer,
      _id_removeLayer$1 as jni$_.JMethodIDPtr,
      _$layer.pointer,
    ).boolean;
  }

  static final _id_removeLayerAt = _class.instanceMethodId(
    r'removeLayerAt',
    r'(I)Z',
  );

  static final _removeLayerAt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean removeLayerAt(int i)`
  bool removeLayerAt(int i) {
    return _removeLayerAt(
      reference.pointer,
      _id_removeLayerAt as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_addImage = _class.instanceMethodId(
    r'addImage',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;)V',
  );

  static final _addImage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImage(java.lang.String string, android.graphics.Bitmap bitmap)`
  void addImage(jni$_.JString string, jni$_.JObject bitmap) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    _addImage(
      reference.pointer,
      _id_addImage as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
    ).check();
  }

  static final _id_addImage$1 = _class.instanceMethodId(
    r'addImage',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;Ljava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImage$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImage(java.lang.String string, android.graphics.Bitmap bitmap, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImage$1(
    jni$_.JString string,
    jni$_.JObject bitmap,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImage$1(
      reference.pointer,
      _id_addImage$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImage$2 = _class.instanceMethodId(
    r'addImage',
    r'(Ljava/lang/String;Landroid/graphics/drawable/Drawable;)V',
  );

  static final _addImage$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImage(java.lang.String string, android.graphics.drawable.Drawable drawable)`
  void addImage$2(jni$_.JString string, jni$_.JObject drawable) {
    final _$string = string.reference;
    final _$drawable = drawable.reference;
    _addImage$2(
      reference.pointer,
      _id_addImage$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$drawable.pointer,
    ).check();
  }

  static final _id_addImage$3 = _class.instanceMethodId(
    r'addImage',
    r'(Ljava/lang/String;Landroid/graphics/drawable/Drawable;Ljava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImage$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImage(java.lang.String string, android.graphics.drawable.Drawable drawable, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImage$3(
    jni$_.JString string,
    jni$_.JObject drawable,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$drawable = drawable.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImage$3(
      reference.pointer,
      _id_addImage$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$drawable.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImage$4 = _class.instanceMethodId(
    r'addImage',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;Z)V',
  );

  static final _addImage$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void addImage(java.lang.String string, android.graphics.Bitmap bitmap, boolean z)`
  void addImage$4(jni$_.JString string, jni$_.JObject bitmap, bool z) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    _addImage$4(
      reference.pointer,
      _id_addImage$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_addImage$5 = _class.instanceMethodId(
    r'addImage',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;ZLjava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImage$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImage(java.lang.String string, android.graphics.Bitmap bitmap, boolean z, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImage$5(
    jni$_.JString string,
    jni$_.JObject bitmap,
    bool z,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImage$5(
      reference.pointer,
      _id_addImage$5 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      z ? 1 : 0,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImageAsync = _class.instanceMethodId(
    r'addImageAsync',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;)V',
  );

  static final _addImageAsync =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImageAsync(java.lang.String string, android.graphics.Bitmap bitmap)`
  void addImageAsync(jni$_.JString string, jni$_.JObject bitmap) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    _addImageAsync(
      reference.pointer,
      _id_addImageAsync as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
    ).check();
  }

  static final _id_addImageAsync$1 = _class.instanceMethodId(
    r'addImageAsync',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;Ljava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImageAsync$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImageAsync(java.lang.String string, android.graphics.Bitmap bitmap, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImageAsync$1(
    jni$_.JString string,
    jni$_.JObject bitmap,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImageAsync$1(
      reference.pointer,
      _id_addImageAsync$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImageAsync$2 = _class.instanceMethodId(
    r'addImageAsync',
    r'(Ljava/lang/String;Landroid/graphics/drawable/Drawable;)V',
  );

  static final _addImageAsync$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImageAsync(java.lang.String string, android.graphics.drawable.Drawable drawable)`
  void addImageAsync$2(jni$_.JString string, jni$_.JObject drawable) {
    final _$string = string.reference;
    final _$drawable = drawable.reference;
    _addImageAsync$2(
      reference.pointer,
      _id_addImageAsync$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$drawable.pointer,
    ).check();
  }

  static final _id_addImageAsync$3 = _class.instanceMethodId(
    r'addImageAsync',
    r'(Ljava/lang/String;Landroid/graphics/drawable/Drawable;Ljava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImageAsync$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImageAsync(java.lang.String string, android.graphics.drawable.Drawable drawable, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImageAsync$3(
    jni$_.JString string,
    jni$_.JObject drawable,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$drawable = drawable.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImageAsync$3(
      reference.pointer,
      _id_addImageAsync$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$drawable.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImageAsync$4 = _class.instanceMethodId(
    r'addImageAsync',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;Z)V',
  );

  static final _addImageAsync$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void addImageAsync(java.lang.String string, android.graphics.Bitmap bitmap, boolean z)`
  void addImageAsync$4(jni$_.JString string, jni$_.JObject bitmap, bool z) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    _addImageAsync$4(
      reference.pointer,
      _id_addImageAsync$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_addImageAsync$5 = _class.instanceMethodId(
    r'addImageAsync',
    r'(Ljava/lang/String;Landroid/graphics/Bitmap;ZLjava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImageAsync$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImageAsync(java.lang.String string, android.graphics.Bitmap bitmap, boolean z, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImageAsync$5(
    jni$_.JString string,
    jni$_.JObject bitmap,
    bool z,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$string = string.reference;
    final _$bitmap = bitmap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImageAsync$5(
      reference.pointer,
      _id_addImageAsync$5 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bitmap.pointer,
      z ? 1 : 0,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImages = _class.instanceMethodId(
    r'addImages',
    r'(Ljava/util/HashMap;)V',
  );

  static final _addImages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImages(java.util.HashMap hashMap)`
  void addImages(jni$_.JObject hashMap) {
    final _$hashMap = hashMap.reference;
    _addImages(
      reference.pointer,
      _id_addImages as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
    ).check();
  }

  static final _id_addImages$1 = _class.instanceMethodId(
    r'addImages',
    r'(Ljava/util/HashMap;Ljava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImages$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImages(java.util.HashMap hashMap, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImages$1(
    jni$_.JObject hashMap,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$hashMap = hashMap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImages$1(
      reference.pointer,
      _id_addImages$1 as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImages$2 = _class.instanceMethodId(
    r'addImages',
    r'(Ljava/util/HashMap;Z)V',
  );

  static final _addImages$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void addImages(java.util.HashMap hashMap, boolean z)`
  void addImages$2(jni$_.JObject hashMap, bool z) {
    final _$hashMap = hashMap.reference;
    _addImages$2(
      reference.pointer,
      _id_addImages$2 as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_addImages$3 = _class.instanceMethodId(
    r'addImages',
    r'(Ljava/util/HashMap;ZLjava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImages$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImages(java.util.HashMap hashMap, boolean z, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImages$3(
    jni$_.JObject hashMap,
    bool z,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$hashMap = hashMap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImages$3(
      reference.pointer,
      _id_addImages$3 as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
      z ? 1 : 0,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImagesAsync = _class.instanceMethodId(
    r'addImagesAsync',
    r'(Ljava/util/HashMap;)V',
  );

  static final _addImagesAsync =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImagesAsync(java.util.HashMap hashMap)`
  void addImagesAsync(jni$_.JObject hashMap) {
    final _$hashMap = hashMap.reference;
    _addImagesAsync(
      reference.pointer,
      _id_addImagesAsync as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
    ).check();
  }

  static final _id_addImagesAsync$1 = _class.instanceMethodId(
    r'addImagesAsync',
    r'(Ljava/util/HashMap;Ljava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImagesAsync$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImagesAsync(java.util.HashMap hashMap, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImagesAsync$1(
    jni$_.JObject hashMap,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$hashMap = hashMap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImagesAsync$1(
      reference.pointer,
      _id_addImagesAsync$1 as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_addImagesAsync$2 = _class.instanceMethodId(
    r'addImagesAsync',
    r'(Ljava/util/HashMap;Z)V',
  );

  static final _addImagesAsync$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void addImagesAsync(java.util.HashMap hashMap, boolean z)`
  void addImagesAsync$2(jni$_.JObject hashMap, bool z) {
    final _$hashMap = hashMap.reference;
    _addImagesAsync$2(
      reference.pointer,
      _id_addImagesAsync$2 as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_addImagesAsync$3 = _class.instanceMethodId(
    r'addImagesAsync',
    r'(Ljava/util/HashMap;ZLjava/util/List;Ljava/util/List;Lorg/maplibre/android/maps/ImageContent;)V',
  );

  static final _addImagesAsync$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addImagesAsync(java.util.HashMap hashMap, boolean z, java.util.List list, java.util.List list1, org.maplibre.android.maps.ImageContent imageContent)`
  void addImagesAsync$3(
    jni$_.JObject hashMap,
    bool z,
    jni$_.JList<imagestretches$_.ImageStretches?> list,
    jni$_.JList<imagestretches$_.ImageStretches?> list1,
    imagecontent$_.ImageContent? imageContent,
  ) {
    final _$hashMap = hashMap.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$imageContent = imageContent?.reference ?? jni$_.jNullReference;
    _addImagesAsync$3(
      reference.pointer,
      _id_addImagesAsync$3 as jni$_.JMethodIDPtr,
      _$hashMap.pointer,
      z ? 1 : 0,
      _$list.pointer,
      _$list1.pointer,
      _$imageContent.pointer,
    ).check();
  }

  static final _id_removeImage = _class.instanceMethodId(
    r'removeImage',
    r'(Ljava/lang/String;)V',
  );

  static final _removeImage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void removeImage(java.lang.String string)`
  void removeImage(jni$_.JString string) {
    final _$string = string.reference;
    _removeImage(
      reference.pointer,
      _id_removeImage as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getImage = _class.instanceMethodId(
    r'getImage',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap;',
  );

  static final _getImage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.Bitmap getImage(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getImage(jni$_.JString string) {
    final _$string = string.reference;
    return _getImage(
      reference.pointer,
      _id_getImage as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setTransition = _class.instanceMethodId(
    r'setTransition',
    r'(Lorg/maplibre/android/style/layers/TransitionOptions;)V',
  );

  static final _setTransition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTransition(org.maplibre.android.style.layers.TransitionOptions transitionOptions)`
  void setTransition(transitionoptions$_.TransitionOptions transitionOptions) {
    final _$transitionOptions = transitionOptions.reference;
    _setTransition(
      reference.pointer,
      _id_setTransition as jni$_.JMethodIDPtr,
      _$transitionOptions.pointer,
    ).check();
  }

  static final _id_getTransition = _class.instanceMethodId(
    r'getTransition',
    r'()Lorg/maplibre/android/style/layers/TransitionOptions;',
  );

  static final _getTransition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.style.layers.TransitionOptions getTransition()`
  /// The returned object must be released after use, by calling the [release] method.
  transitionoptions$_.TransitionOptions getTransition() {
    return _getTransition(
      reference.pointer,
      _id_getTransition as jni$_.JMethodIDPtr,
    ).object<transitionoptions$_.TransitionOptions>(
      const transitionoptions$_.$TransitionOptions$Type(),
    );
  }

  static final _id_getLight = _class.instanceMethodId(
    r'getLight',
    r'()Lorg/maplibre/android/style/light/Light;',
  );

  static final _getLight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.maplibre.android.style.light.Light getLight()`
  /// The returned object must be released after use, by calling the [release] method.
  light$_.Light? getLight() {
    return _getLight(
      reference.pointer,
      _id_getLight as jni$_.JMethodIDPtr,
    ).object<light$_.Light?>(const light$_.$Light$NullableType());
  }

  static final _id_isFullyLoaded = _class.instanceMethodId(
    r'isFullyLoaded',
    r'()Z',
  );

  static final _isFullyLoaded =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isFullyLoaded()`
  bool isFullyLoaded() {
    return _isFullyLoaded(
      reference.pointer,
      _id_isFullyLoaded as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_toImage = _class.staticMethodId(
    r'toImage',
    r'(Lorg/maplibre/android/maps/Style$Builder$ImageWrapper;)Lorg/maplibre/android/maps/Image;',
  );

  static final _toImage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.maplibre.android.maps.Image toImage(org.maplibre.android.maps.Style$Builder$ImageWrapper imageWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  static image$_.Image? toImage(Style$Builder$ImageWrapper? imageWrapper) {
    final _$imageWrapper = imageWrapper?.reference ?? jni$_.jNullReference;
    return _toImage(
      _class.reference.pointer,
      _id_toImage as jni$_.JMethodIDPtr,
      _$imageWrapper.pointer,
    ).object<image$_.Image?>(const image$_.$Image$NullableType());
  }

  static final _id_getPredefinedStyles = _class.staticMethodId(
    r'getPredefinedStyles',
    r'()[Lorg/maplibre/android/util/DefaultStyle;',
  );

  static final _getPredefinedStyles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public org.maplibre.android.util.DefaultStyle[] getPredefinedStyles()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<defaultstyle$_.DefaultStyle?>? getPredefinedStyles() {
    return _getPredefinedStyles(
      _class.reference.pointer,
      _id_getPredefinedStyles as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<defaultstyle$_.DefaultStyle?>?>(
      const jni$_.JArrayNullableType<defaultstyle$_.DefaultStyle?>(
        defaultstyle$_.$DefaultStyle$NullableType(),
      ),
    );
  }

  static final _id_getPredefinedStyle = _class.staticMethodId(
    r'getPredefinedStyle',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getPredefinedStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String getPredefinedStyle(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString getPredefinedStyle(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getPredefinedStyle(
      _class.reference.pointer,
      _id_getPredefinedStyle as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $Style$NullableType extends jni$_.JObjType<Style?> {
  @jni$_.internal
  const $Style$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/Style;';

  @jni$_.internal
  @core$_.override
  Style? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Style.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$NullableType) &&
        other is $Style$NullableType;
  }
}

final class $Style$Type extends jni$_.JObjType<Style> {
  @jni$_.internal
  const $Style$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/Style;';

  @jni$_.internal
  @core$_.override
  Style fromReference(jni$_.JReference reference) =>
      Style.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Style?> get nullableType => const $Style$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Style$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Style$Type) && other is $Style$Type;
  }
}
