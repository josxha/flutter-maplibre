// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: document_ignores
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'MapLibreMapOptions.dart' as maplibremapoptions$_;

import 'OnMapReadyCallback.dart' as onmapreadycallback$_;

import 'renderer/MapRenderer.dart' as maprenderer$_;

/// from: `org.maplibre.android.maps.MapView$OnCameraDidChangeListener`
class MapView$OnCameraDidChangeListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnCameraDidChangeListener> $type;

  @jni$_.internal
  MapView$OnCameraDidChangeListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnCameraDidChangeListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnCameraDidChangeListener$NullableType();
  static const type = $MapView$OnCameraDidChangeListener$Type();
  static final _id_onCameraDidChange = _class.instanceMethodId(
    r'onCameraDidChange',
    r'(Z)V',
  );

  static final _onCameraDidChange = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract void onCameraDidChange(boolean z)`
  void onCameraDidChange(
    bool z,
  ) {
    _onCameraDidChange(reference.pointer,
            _id_onCameraDidChange as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnCameraDidChangeListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraDidChange(Z)V') {
        _$impls[$p]!.onCameraDidChange(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnCameraDidChangeListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnCameraDidChangeListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCameraDidChange$async) r'onCameraDidChange(Z)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnCameraDidChangeListener.implement(
    $MapView$OnCameraDidChangeListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnCameraDidChangeListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnCameraDidChangeListener {
  factory $MapView$OnCameraDidChangeListener({
    required void Function(bool z) onCameraDidChange,
    bool onCameraDidChange$async,
  }) = _$MapView$OnCameraDidChangeListener;

  void onCameraDidChange(bool z);
  bool get onCameraDidChange$async => false;
}

final class _$MapView$OnCameraDidChangeListener
    with $MapView$OnCameraDidChangeListener {
  _$MapView$OnCameraDidChangeListener({
    required void Function(bool z) onCameraDidChange,
    this.onCameraDidChange$async = false,
  }) : _onCameraDidChange = onCameraDidChange;

  final void Function(bool z) _onCameraDidChange;
  final bool onCameraDidChange$async;

  void onCameraDidChange(bool z) {
    return _onCameraDidChange(z);
  }
}

final class $MapView$OnCameraDidChangeListener$NullableType
    extends jni$_.JObjType<MapView$OnCameraDidChangeListener?> {
  @jni$_.internal
  const $MapView$OnCameraDidChangeListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnCameraDidChangeListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnCameraDidChangeListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnCameraDidChangeListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnCameraDidChangeListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnCameraDidChangeListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnCameraDidChangeListener$NullableType) &&
        other is $MapView$OnCameraDidChangeListener$NullableType;
  }
}

final class $MapView$OnCameraDidChangeListener$Type
    extends jni$_.JObjType<MapView$OnCameraDidChangeListener> {
  @jni$_.internal
  const $MapView$OnCameraDidChangeListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnCameraDidChangeListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnCameraDidChangeListener fromReference(jni$_.JReference reference) =>
      MapView$OnCameraDidChangeListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnCameraDidChangeListener?> get nullableType =>
      const $MapView$OnCameraDidChangeListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnCameraDidChangeListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnCameraDidChangeListener$Type) &&
        other is $MapView$OnCameraDidChangeListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnCameraIsChangingListener`
class MapView$OnCameraIsChangingListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnCameraIsChangingListener> $type;

  @jni$_.internal
  MapView$OnCameraIsChangingListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnCameraIsChangingListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnCameraIsChangingListener$NullableType();
  static const type = $MapView$OnCameraIsChangingListener$Type();
  static final _id_onCameraIsChanging = _class.instanceMethodId(
    r'onCameraIsChanging',
    r'()V',
  );

  static final _onCameraIsChanging = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCameraIsChanging()`
  void onCameraIsChanging() {
    _onCameraIsChanging(
            reference.pointer, _id_onCameraIsChanging as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnCameraIsChangingListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraIsChanging()V') {
        _$impls[$p]!.onCameraIsChanging();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnCameraIsChangingListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnCameraIsChangingListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCameraIsChanging$async) r'onCameraIsChanging()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnCameraIsChangingListener.implement(
    $MapView$OnCameraIsChangingListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnCameraIsChangingListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnCameraIsChangingListener {
  factory $MapView$OnCameraIsChangingListener({
    required void Function() onCameraIsChanging,
    bool onCameraIsChanging$async,
  }) = _$MapView$OnCameraIsChangingListener;

  void onCameraIsChanging();
  bool get onCameraIsChanging$async => false;
}

final class _$MapView$OnCameraIsChangingListener
    with $MapView$OnCameraIsChangingListener {
  _$MapView$OnCameraIsChangingListener({
    required void Function() onCameraIsChanging,
    this.onCameraIsChanging$async = false,
  }) : _onCameraIsChanging = onCameraIsChanging;

  final void Function() _onCameraIsChanging;
  final bool onCameraIsChanging$async;

  void onCameraIsChanging() {
    return _onCameraIsChanging();
  }
}

final class $MapView$OnCameraIsChangingListener$NullableType
    extends jni$_.JObjType<MapView$OnCameraIsChangingListener?> {
  @jni$_.internal
  const $MapView$OnCameraIsChangingListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnCameraIsChangingListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnCameraIsChangingListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnCameraIsChangingListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnCameraIsChangingListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnCameraIsChangingListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnCameraIsChangingListener$NullableType) &&
        other is $MapView$OnCameraIsChangingListener$NullableType;
  }
}

final class $MapView$OnCameraIsChangingListener$Type
    extends jni$_.JObjType<MapView$OnCameraIsChangingListener> {
  @jni$_.internal
  const $MapView$OnCameraIsChangingListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnCameraIsChangingListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnCameraIsChangingListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnCameraIsChangingListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnCameraIsChangingListener?> get nullableType =>
      const $MapView$OnCameraIsChangingListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnCameraIsChangingListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnCameraIsChangingListener$Type) &&
        other is $MapView$OnCameraIsChangingListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnCameraWillChangeListener`
class MapView$OnCameraWillChangeListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnCameraWillChangeListener> $type;

  @jni$_.internal
  MapView$OnCameraWillChangeListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnCameraWillChangeListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnCameraWillChangeListener$NullableType();
  static const type = $MapView$OnCameraWillChangeListener$Type();
  static final _id_onCameraWillChange = _class.instanceMethodId(
    r'onCameraWillChange',
    r'(Z)V',
  );

  static final _onCameraWillChange = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract void onCameraWillChange(boolean z)`
  void onCameraWillChange(
    bool z,
  ) {
    _onCameraWillChange(reference.pointer,
            _id_onCameraWillChange as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnCameraWillChangeListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraWillChange(Z)V') {
        _$impls[$p]!.onCameraWillChange(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnCameraWillChangeListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnCameraWillChangeListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCameraWillChange$async) r'onCameraWillChange(Z)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnCameraWillChangeListener.implement(
    $MapView$OnCameraWillChangeListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnCameraWillChangeListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnCameraWillChangeListener {
  factory $MapView$OnCameraWillChangeListener({
    required void Function(bool z) onCameraWillChange,
    bool onCameraWillChange$async,
  }) = _$MapView$OnCameraWillChangeListener;

  void onCameraWillChange(bool z);
  bool get onCameraWillChange$async => false;
}

final class _$MapView$OnCameraWillChangeListener
    with $MapView$OnCameraWillChangeListener {
  _$MapView$OnCameraWillChangeListener({
    required void Function(bool z) onCameraWillChange,
    this.onCameraWillChange$async = false,
  }) : _onCameraWillChange = onCameraWillChange;

  final void Function(bool z) _onCameraWillChange;
  final bool onCameraWillChange$async;

  void onCameraWillChange(bool z) {
    return _onCameraWillChange(z);
  }
}

final class $MapView$OnCameraWillChangeListener$NullableType
    extends jni$_.JObjType<MapView$OnCameraWillChangeListener?> {
  @jni$_.internal
  const $MapView$OnCameraWillChangeListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnCameraWillChangeListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnCameraWillChangeListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnCameraWillChangeListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnCameraWillChangeListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnCameraWillChangeListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnCameraWillChangeListener$NullableType) &&
        other is $MapView$OnCameraWillChangeListener$NullableType;
  }
}

final class $MapView$OnCameraWillChangeListener$Type
    extends jni$_.JObjType<MapView$OnCameraWillChangeListener> {
  @jni$_.internal
  const $MapView$OnCameraWillChangeListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnCameraWillChangeListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnCameraWillChangeListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnCameraWillChangeListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnCameraWillChangeListener?> get nullableType =>
      const $MapView$OnCameraWillChangeListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnCameraWillChangeListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnCameraWillChangeListener$Type) &&
        other is $MapView$OnCameraWillChangeListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnCanRemoveUnusedStyleImageListener`
class MapView$OnCanRemoveUnusedStyleImageListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnCanRemoveUnusedStyleImageListener> $type;

  @jni$_.internal
  MapView$OnCanRemoveUnusedStyleImageListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnCanRemoveUnusedStyleImageListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnCanRemoveUnusedStyleImageListener$NullableType();
  static const type = $MapView$OnCanRemoveUnusedStyleImageListener$Type();
  static final _id_onCanRemoveUnusedStyleImage = _class.instanceMethodId(
    r'onCanRemoveUnusedStyleImage',
    r'(Ljava/lang/String;)Z',
  );

  static final _onCanRemoveUnusedStyleImage =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean onCanRemoveUnusedStyleImage(java.lang.String string)`
  bool onCanRemoveUnusedStyleImage(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _onCanRemoveUnusedStyleImage(
            reference.pointer,
            _id_onCanRemoveUnusedStyleImage as jni$_.JMethodIDPtr,
            _$string.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnCanRemoveUnusedStyleImageListener>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCanRemoveUnusedStyleImage(Ljava/lang/String;)Z') {
        final $r = _$impls[$p]!.onCanRemoveUnusedStyleImage(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnCanRemoveUnusedStyleImageListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnCanRemoveUnusedStyleImageListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnCanRemoveUnusedStyleImageListener.implement(
    $MapView$OnCanRemoveUnusedStyleImageListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnCanRemoveUnusedStyleImageListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnCanRemoveUnusedStyleImageListener {
  factory $MapView$OnCanRemoveUnusedStyleImageListener({
    required bool Function(jni$_.JString string) onCanRemoveUnusedStyleImage,
  }) = _$MapView$OnCanRemoveUnusedStyleImageListener;

  bool onCanRemoveUnusedStyleImage(jni$_.JString string);
}

final class _$MapView$OnCanRemoveUnusedStyleImageListener
    with $MapView$OnCanRemoveUnusedStyleImageListener {
  _$MapView$OnCanRemoveUnusedStyleImageListener({
    required bool Function(jni$_.JString string) onCanRemoveUnusedStyleImage,
  }) : _onCanRemoveUnusedStyleImage = onCanRemoveUnusedStyleImage;

  final bool Function(jni$_.JString string) _onCanRemoveUnusedStyleImage;

  bool onCanRemoveUnusedStyleImage(jni$_.JString string) {
    return _onCanRemoveUnusedStyleImage(string);
  }
}

final class $MapView$OnCanRemoveUnusedStyleImageListener$NullableType
    extends jni$_.JObjType<MapView$OnCanRemoveUnusedStyleImageListener?> {
  @jni$_.internal
  const $MapView$OnCanRemoveUnusedStyleImageListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnCanRemoveUnusedStyleImageListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnCanRemoveUnusedStyleImageListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnCanRemoveUnusedStyleImageListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnCanRemoveUnusedStyleImageListener?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnCanRemoveUnusedStyleImageListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnCanRemoveUnusedStyleImageListener$NullableType) &&
        other is $MapView$OnCanRemoveUnusedStyleImageListener$NullableType;
  }
}

final class $MapView$OnCanRemoveUnusedStyleImageListener$Type
    extends jni$_.JObjType<MapView$OnCanRemoveUnusedStyleImageListener> {
  @jni$_.internal
  const $MapView$OnCanRemoveUnusedStyleImageListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnCanRemoveUnusedStyleImageListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnCanRemoveUnusedStyleImageListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnCanRemoveUnusedStyleImageListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnCanRemoveUnusedStyleImageListener?>
      get nullableType =>
          const $MapView$OnCanRemoveUnusedStyleImageListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnCanRemoveUnusedStyleImageListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnCanRemoveUnusedStyleImageListener$Type) &&
        other is $MapView$OnCanRemoveUnusedStyleImageListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnDidBecomeIdleListener`
class MapView$OnDidBecomeIdleListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnDidBecomeIdleListener> $type;

  @jni$_.internal
  MapView$OnDidBecomeIdleListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnDidBecomeIdleListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnDidBecomeIdleListener$NullableType();
  static const type = $MapView$OnDidBecomeIdleListener$Type();
  static final _id_onDidBecomeIdle = _class.instanceMethodId(
    r'onDidBecomeIdle',
    r'()V',
  );

  static final _onDidBecomeIdle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onDidBecomeIdle()`
  void onDidBecomeIdle() {
    _onDidBecomeIdle(
            reference.pointer, _id_onDidBecomeIdle as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnDidBecomeIdleListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDidBecomeIdle()V') {
        _$impls[$p]!.onDidBecomeIdle();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnDidBecomeIdleListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnDidBecomeIdleListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onDidBecomeIdle$async) r'onDidBecomeIdle()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnDidBecomeIdleListener.implement(
    $MapView$OnDidBecomeIdleListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnDidBecomeIdleListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnDidBecomeIdleListener {
  factory $MapView$OnDidBecomeIdleListener({
    required void Function() onDidBecomeIdle,
    bool onDidBecomeIdle$async,
  }) = _$MapView$OnDidBecomeIdleListener;

  void onDidBecomeIdle();
  bool get onDidBecomeIdle$async => false;
}

final class _$MapView$OnDidBecomeIdleListener
    with $MapView$OnDidBecomeIdleListener {
  _$MapView$OnDidBecomeIdleListener({
    required void Function() onDidBecomeIdle,
    this.onDidBecomeIdle$async = false,
  }) : _onDidBecomeIdle = onDidBecomeIdle;

  final void Function() _onDidBecomeIdle;
  final bool onDidBecomeIdle$async;

  void onDidBecomeIdle() {
    return _onDidBecomeIdle();
  }
}

final class $MapView$OnDidBecomeIdleListener$NullableType
    extends jni$_.JObjType<MapView$OnDidBecomeIdleListener?> {
  @jni$_.internal
  const $MapView$OnDidBecomeIdleListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidBecomeIdleListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidBecomeIdleListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnDidBecomeIdleListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidBecomeIdleListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnDidBecomeIdleListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidBecomeIdleListener$NullableType) &&
        other is $MapView$OnDidBecomeIdleListener$NullableType;
  }
}

final class $MapView$OnDidBecomeIdleListener$Type
    extends jni$_.JObjType<MapView$OnDidBecomeIdleListener> {
  @jni$_.internal
  const $MapView$OnDidBecomeIdleListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidBecomeIdleListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidBecomeIdleListener fromReference(jni$_.JReference reference) =>
      MapView$OnDidBecomeIdleListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidBecomeIdleListener?> get nullableType =>
      const $MapView$OnDidBecomeIdleListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnDidBecomeIdleListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnDidBecomeIdleListener$Type) &&
        other is $MapView$OnDidBecomeIdleListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnDidFailLoadingMapListener`
class MapView$OnDidFailLoadingMapListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnDidFailLoadingMapListener> $type;

  @jni$_.internal
  MapView$OnDidFailLoadingMapListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnDidFailLoadingMapListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnDidFailLoadingMapListener$NullableType();
  static const type = $MapView$OnDidFailLoadingMapListener$Type();
  static final _id_onDidFailLoadingMap = _class.instanceMethodId(
    r'onDidFailLoadingMap',
    r'(Ljava/lang/String;)V',
  );

  static final _onDidFailLoadingMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onDidFailLoadingMap(java.lang.String string)`
  void onDidFailLoadingMap(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onDidFailLoadingMap(reference.pointer,
            _id_onDidFailLoadingMap as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnDidFailLoadingMapListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDidFailLoadingMap(Ljava/lang/String;)V') {
        _$impls[$p]!.onDidFailLoadingMap(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnDidFailLoadingMapListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnDidFailLoadingMapListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onDidFailLoadingMap$async)
          r'onDidFailLoadingMap(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnDidFailLoadingMapListener.implement(
    $MapView$OnDidFailLoadingMapListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnDidFailLoadingMapListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnDidFailLoadingMapListener {
  factory $MapView$OnDidFailLoadingMapListener({
    required void Function(jni$_.JString? string) onDidFailLoadingMap,
    bool onDidFailLoadingMap$async,
  }) = _$MapView$OnDidFailLoadingMapListener;

  void onDidFailLoadingMap(jni$_.JString? string);
  bool get onDidFailLoadingMap$async => false;
}

final class _$MapView$OnDidFailLoadingMapListener
    with $MapView$OnDidFailLoadingMapListener {
  _$MapView$OnDidFailLoadingMapListener({
    required void Function(jni$_.JString? string) onDidFailLoadingMap,
    this.onDidFailLoadingMap$async = false,
  }) : _onDidFailLoadingMap = onDidFailLoadingMap;

  final void Function(jni$_.JString? string) _onDidFailLoadingMap;
  final bool onDidFailLoadingMap$async;

  void onDidFailLoadingMap(jni$_.JString? string) {
    return _onDidFailLoadingMap(string);
  }
}

final class $MapView$OnDidFailLoadingMapListener$NullableType
    extends jni$_.JObjType<MapView$OnDidFailLoadingMapListener?> {
  @jni$_.internal
  const $MapView$OnDidFailLoadingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFailLoadingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFailLoadingMapListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnDidFailLoadingMapListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFailLoadingMapListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnDidFailLoadingMapListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidFailLoadingMapListener$NullableType) &&
        other is $MapView$OnDidFailLoadingMapListener$NullableType;
  }
}

final class $MapView$OnDidFailLoadingMapListener$Type
    extends jni$_.JObjType<MapView$OnDidFailLoadingMapListener> {
  @jni$_.internal
  const $MapView$OnDidFailLoadingMapListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFailLoadingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFailLoadingMapListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnDidFailLoadingMapListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFailLoadingMapListener?> get nullableType =>
      const $MapView$OnDidFailLoadingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnDidFailLoadingMapListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnDidFailLoadingMapListener$Type) &&
        other is $MapView$OnDidFailLoadingMapListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnDidFinishLoadingMapListener`
class MapView$OnDidFinishLoadingMapListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnDidFinishLoadingMapListener> $type;

  @jni$_.internal
  MapView$OnDidFinishLoadingMapListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnDidFinishLoadingMapListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnDidFinishLoadingMapListener$NullableType();
  static const type = $MapView$OnDidFinishLoadingMapListener$Type();
  static final _id_onDidFinishLoadingMap = _class.instanceMethodId(
    r'onDidFinishLoadingMap',
    r'()V',
  );

  static final _onDidFinishLoadingMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onDidFinishLoadingMap()`
  void onDidFinishLoadingMap() {
    _onDidFinishLoadingMap(
            reference.pointer, _id_onDidFinishLoadingMap as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnDidFinishLoadingMapListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDidFinishLoadingMap()V') {
        _$impls[$p]!.onDidFinishLoadingMap();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnDidFinishLoadingMapListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnDidFinishLoadingMapListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onDidFinishLoadingMap$async) r'onDidFinishLoadingMap()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnDidFinishLoadingMapListener.implement(
    $MapView$OnDidFinishLoadingMapListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnDidFinishLoadingMapListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnDidFinishLoadingMapListener {
  factory $MapView$OnDidFinishLoadingMapListener({
    required void Function() onDidFinishLoadingMap,
    bool onDidFinishLoadingMap$async,
  }) = _$MapView$OnDidFinishLoadingMapListener;

  void onDidFinishLoadingMap();
  bool get onDidFinishLoadingMap$async => false;
}

final class _$MapView$OnDidFinishLoadingMapListener
    with $MapView$OnDidFinishLoadingMapListener {
  _$MapView$OnDidFinishLoadingMapListener({
    required void Function() onDidFinishLoadingMap,
    this.onDidFinishLoadingMap$async = false,
  }) : _onDidFinishLoadingMap = onDidFinishLoadingMap;

  final void Function() _onDidFinishLoadingMap;
  final bool onDidFinishLoadingMap$async;

  void onDidFinishLoadingMap() {
    return _onDidFinishLoadingMap();
  }
}

final class $MapView$OnDidFinishLoadingMapListener$NullableType
    extends jni$_.JObjType<MapView$OnDidFinishLoadingMapListener?> {
  @jni$_.internal
  const $MapView$OnDidFinishLoadingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFinishLoadingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFinishLoadingMapListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnDidFinishLoadingMapListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFinishLoadingMapListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnDidFinishLoadingMapListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidFinishLoadingMapListener$NullableType) &&
        other is $MapView$OnDidFinishLoadingMapListener$NullableType;
  }
}

final class $MapView$OnDidFinishLoadingMapListener$Type
    extends jni$_.JObjType<MapView$OnDidFinishLoadingMapListener> {
  @jni$_.internal
  const $MapView$OnDidFinishLoadingMapListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFinishLoadingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFinishLoadingMapListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnDidFinishLoadingMapListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFinishLoadingMapListener?> get nullableType =>
      const $MapView$OnDidFinishLoadingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnDidFinishLoadingMapListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnDidFinishLoadingMapListener$Type) &&
        other is $MapView$OnDidFinishLoadingMapListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnDidFinishLoadingStyleListener`
class MapView$OnDidFinishLoadingStyleListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnDidFinishLoadingStyleListener> $type;

  @jni$_.internal
  MapView$OnDidFinishLoadingStyleListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnDidFinishLoadingStyleListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnDidFinishLoadingStyleListener$NullableType();
  static const type = $MapView$OnDidFinishLoadingStyleListener$Type();
  static final _id_onDidFinishLoadingStyle = _class.instanceMethodId(
    r'onDidFinishLoadingStyle',
    r'()V',
  );

  static final _onDidFinishLoadingStyle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onDidFinishLoadingStyle()`
  void onDidFinishLoadingStyle() {
    _onDidFinishLoadingStyle(reference.pointer,
            _id_onDidFinishLoadingStyle as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnDidFinishLoadingStyleListener>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDidFinishLoadingStyle()V') {
        _$impls[$p]!.onDidFinishLoadingStyle();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnDidFinishLoadingStyleListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnDidFinishLoadingStyleListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onDidFinishLoadingStyle$async) r'onDidFinishLoadingStyle()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnDidFinishLoadingStyleListener.implement(
    $MapView$OnDidFinishLoadingStyleListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnDidFinishLoadingStyleListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnDidFinishLoadingStyleListener {
  factory $MapView$OnDidFinishLoadingStyleListener({
    required void Function() onDidFinishLoadingStyle,
    bool onDidFinishLoadingStyle$async,
  }) = _$MapView$OnDidFinishLoadingStyleListener;

  void onDidFinishLoadingStyle();
  bool get onDidFinishLoadingStyle$async => false;
}

final class _$MapView$OnDidFinishLoadingStyleListener
    with $MapView$OnDidFinishLoadingStyleListener {
  _$MapView$OnDidFinishLoadingStyleListener({
    required void Function() onDidFinishLoadingStyle,
    this.onDidFinishLoadingStyle$async = false,
  }) : _onDidFinishLoadingStyle = onDidFinishLoadingStyle;

  final void Function() _onDidFinishLoadingStyle;
  final bool onDidFinishLoadingStyle$async;

  void onDidFinishLoadingStyle() {
    return _onDidFinishLoadingStyle();
  }
}

final class $MapView$OnDidFinishLoadingStyleListener$NullableType
    extends jni$_.JObjType<MapView$OnDidFinishLoadingStyleListener?> {
  @jni$_.internal
  const $MapView$OnDidFinishLoadingStyleListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFinishLoadingStyleListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFinishLoadingStyleListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnDidFinishLoadingStyleListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFinishLoadingStyleListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnDidFinishLoadingStyleListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidFinishLoadingStyleListener$NullableType) &&
        other is $MapView$OnDidFinishLoadingStyleListener$NullableType;
  }
}

final class $MapView$OnDidFinishLoadingStyleListener$Type
    extends jni$_.JObjType<MapView$OnDidFinishLoadingStyleListener> {
  @jni$_.internal
  const $MapView$OnDidFinishLoadingStyleListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFinishLoadingStyleListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFinishLoadingStyleListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnDidFinishLoadingStyleListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFinishLoadingStyleListener?> get nullableType =>
      const $MapView$OnDidFinishLoadingStyleListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnDidFinishLoadingStyleListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidFinishLoadingStyleListener$Type) &&
        other is $MapView$OnDidFinishLoadingStyleListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnDidFinishRenderingFrameListener`
class MapView$OnDidFinishRenderingFrameListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnDidFinishRenderingFrameListener> $type;

  @jni$_.internal
  MapView$OnDidFinishRenderingFrameListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnDidFinishRenderingFrameListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnDidFinishRenderingFrameListener$NullableType();
  static const type = $MapView$OnDidFinishRenderingFrameListener$Type();
  static final _id_onDidFinishRenderingFrame = _class.instanceMethodId(
    r'onDidFinishRenderingFrame',
    r'(ZDD)V',
  );

  static final _onDidFinishRenderingFrame = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Double,
                        jni$_.Double
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, double, double)>();

  /// from: `public abstract void onDidFinishRenderingFrame(boolean z, double d, double d1)`
  void onDidFinishRenderingFrame(
    bool z,
    double d,
    double d1,
  ) {
    _onDidFinishRenderingFrame(
            reference.pointer,
            _id_onDidFinishRenderingFrame as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            d,
            d1)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnDidFinishRenderingFrameListener>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDidFinishRenderingFrame(ZDD)V') {
        _$impls[$p]!.onDidFinishRenderingFrame(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnDidFinishRenderingFrameListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnDidFinishRenderingFrameListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onDidFinishRenderingFrame$async)
          r'onDidFinishRenderingFrame(ZDD)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnDidFinishRenderingFrameListener.implement(
    $MapView$OnDidFinishRenderingFrameListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnDidFinishRenderingFrameListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnDidFinishRenderingFrameListener {
  factory $MapView$OnDidFinishRenderingFrameListener({
    required void Function(bool z, double d, double d1)
        onDidFinishRenderingFrame,
    bool onDidFinishRenderingFrame$async,
  }) = _$MapView$OnDidFinishRenderingFrameListener;

  void onDidFinishRenderingFrame(bool z, double d, double d1);
  bool get onDidFinishRenderingFrame$async => false;
}

final class _$MapView$OnDidFinishRenderingFrameListener
    with $MapView$OnDidFinishRenderingFrameListener {
  _$MapView$OnDidFinishRenderingFrameListener({
    required void Function(bool z, double d, double d1)
        onDidFinishRenderingFrame,
    this.onDidFinishRenderingFrame$async = false,
  }) : _onDidFinishRenderingFrame = onDidFinishRenderingFrame;

  final void Function(bool z, double d, double d1) _onDidFinishRenderingFrame;
  final bool onDidFinishRenderingFrame$async;

  void onDidFinishRenderingFrame(bool z, double d, double d1) {
    return _onDidFinishRenderingFrame(z, d, d1);
  }
}

final class $MapView$OnDidFinishRenderingFrameListener$NullableType
    extends jni$_.JObjType<MapView$OnDidFinishRenderingFrameListener?> {
  @jni$_.internal
  const $MapView$OnDidFinishRenderingFrameListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFinishRenderingFrameListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFinishRenderingFrameListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnDidFinishRenderingFrameListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFinishRenderingFrameListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnDidFinishRenderingFrameListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidFinishRenderingFrameListener$NullableType) &&
        other is $MapView$OnDidFinishRenderingFrameListener$NullableType;
  }
}

final class $MapView$OnDidFinishRenderingFrameListener$Type
    extends jni$_.JObjType<MapView$OnDidFinishRenderingFrameListener> {
  @jni$_.internal
  const $MapView$OnDidFinishRenderingFrameListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFinishRenderingFrameListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFinishRenderingFrameListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnDidFinishRenderingFrameListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFinishRenderingFrameListener?> get nullableType =>
      const $MapView$OnDidFinishRenderingFrameListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnDidFinishRenderingFrameListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidFinishRenderingFrameListener$Type) &&
        other is $MapView$OnDidFinishRenderingFrameListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnDidFinishRenderingMapListener`
class MapView$OnDidFinishRenderingMapListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnDidFinishRenderingMapListener> $type;

  @jni$_.internal
  MapView$OnDidFinishRenderingMapListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnDidFinishRenderingMapListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnDidFinishRenderingMapListener$NullableType();
  static const type = $MapView$OnDidFinishRenderingMapListener$Type();
  static final _id_onDidFinishRenderingMap = _class.instanceMethodId(
    r'onDidFinishRenderingMap',
    r'(Z)V',
  );

  static final _onDidFinishRenderingMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract void onDidFinishRenderingMap(boolean z)`
  void onDidFinishRenderingMap(
    bool z,
  ) {
    _onDidFinishRenderingMap(reference.pointer,
            _id_onDidFinishRenderingMap as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnDidFinishRenderingMapListener>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDidFinishRenderingMap(Z)V') {
        _$impls[$p]!.onDidFinishRenderingMap(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnDidFinishRenderingMapListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnDidFinishRenderingMapListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onDidFinishRenderingMap$async) r'onDidFinishRenderingMap(Z)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnDidFinishRenderingMapListener.implement(
    $MapView$OnDidFinishRenderingMapListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnDidFinishRenderingMapListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnDidFinishRenderingMapListener {
  factory $MapView$OnDidFinishRenderingMapListener({
    required void Function(bool z) onDidFinishRenderingMap,
    bool onDidFinishRenderingMap$async,
  }) = _$MapView$OnDidFinishRenderingMapListener;

  void onDidFinishRenderingMap(bool z);
  bool get onDidFinishRenderingMap$async => false;
}

final class _$MapView$OnDidFinishRenderingMapListener
    with $MapView$OnDidFinishRenderingMapListener {
  _$MapView$OnDidFinishRenderingMapListener({
    required void Function(bool z) onDidFinishRenderingMap,
    this.onDidFinishRenderingMap$async = false,
  }) : _onDidFinishRenderingMap = onDidFinishRenderingMap;

  final void Function(bool z) _onDidFinishRenderingMap;
  final bool onDidFinishRenderingMap$async;

  void onDidFinishRenderingMap(bool z) {
    return _onDidFinishRenderingMap(z);
  }
}

final class $MapView$OnDidFinishRenderingMapListener$NullableType
    extends jni$_.JObjType<MapView$OnDidFinishRenderingMapListener?> {
  @jni$_.internal
  const $MapView$OnDidFinishRenderingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFinishRenderingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFinishRenderingMapListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnDidFinishRenderingMapListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFinishRenderingMapListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnDidFinishRenderingMapListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidFinishRenderingMapListener$NullableType) &&
        other is $MapView$OnDidFinishRenderingMapListener$NullableType;
  }
}

final class $MapView$OnDidFinishRenderingMapListener$Type
    extends jni$_.JObjType<MapView$OnDidFinishRenderingMapListener> {
  @jni$_.internal
  const $MapView$OnDidFinishRenderingMapListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnDidFinishRenderingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnDidFinishRenderingMapListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnDidFinishRenderingMapListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnDidFinishRenderingMapListener?> get nullableType =>
      const $MapView$OnDidFinishRenderingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnDidFinishRenderingMapListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnDidFinishRenderingMapListener$Type) &&
        other is $MapView$OnDidFinishRenderingMapListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnGlyphsErrorListener`
class MapView$OnGlyphsErrorListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnGlyphsErrorListener> $type;

  @jni$_.internal
  MapView$OnGlyphsErrorListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnGlyphsErrorListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnGlyphsErrorListener$NullableType();
  static const type = $MapView$OnGlyphsErrorListener$Type();
  static final _id_onGlyphsError = _class.instanceMethodId(
    r'onGlyphsError',
    r'([Ljava/lang/String;II)V',
  );

  static final _onGlyphsError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `public abstract void onGlyphsError(java.lang.String[] strings, int i, int i1)`
  void onGlyphsError(
    jni$_.JArray<jni$_.JString?> strings,
    int i,
    int i1,
  ) {
    final _$strings = strings.reference;
    _onGlyphsError(reference.pointer, _id_onGlyphsError as jni$_.JMethodIDPtr,
            _$strings.pointer, i, i1)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnGlyphsErrorListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onGlyphsError([Ljava/lang/String;II)V') {
        _$impls[$p]!.onGlyphsError(
          $a![0]!.as(
              const jni$_.JArrayType<jni$_.JString?>(
                  jni$_.JStringNullableType()),
              releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnGlyphsErrorListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnGlyphsErrorListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onGlyphsError$async) r'onGlyphsError([Ljava/lang/String;II)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnGlyphsErrorListener.implement(
    $MapView$OnGlyphsErrorListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnGlyphsErrorListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnGlyphsErrorListener {
  factory $MapView$OnGlyphsErrorListener({
    required void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
        onGlyphsError,
    bool onGlyphsError$async,
  }) = _$MapView$OnGlyphsErrorListener;

  void onGlyphsError(jni$_.JArray<jni$_.JString?> strings, int i, int i1);
  bool get onGlyphsError$async => false;
}

final class _$MapView$OnGlyphsErrorListener
    with $MapView$OnGlyphsErrorListener {
  _$MapView$OnGlyphsErrorListener({
    required void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
        onGlyphsError,
    this.onGlyphsError$async = false,
  }) : _onGlyphsError = onGlyphsError;

  final void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
      _onGlyphsError;
  final bool onGlyphsError$async;

  void onGlyphsError(jni$_.JArray<jni$_.JString?> strings, int i, int i1) {
    return _onGlyphsError(strings, i, i1);
  }
}

final class $MapView$OnGlyphsErrorListener$NullableType
    extends jni$_.JObjType<MapView$OnGlyphsErrorListener?> {
  @jni$_.internal
  const $MapView$OnGlyphsErrorListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnGlyphsErrorListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnGlyphsErrorListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnGlyphsErrorListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnGlyphsErrorListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnGlyphsErrorListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnGlyphsErrorListener$NullableType) &&
        other is $MapView$OnGlyphsErrorListener$NullableType;
  }
}

final class $MapView$OnGlyphsErrorListener$Type
    extends jni$_.JObjType<MapView$OnGlyphsErrorListener> {
  @jni$_.internal
  const $MapView$OnGlyphsErrorListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnGlyphsErrorListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnGlyphsErrorListener fromReference(jni$_.JReference reference) =>
      MapView$OnGlyphsErrorListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnGlyphsErrorListener?> get nullableType =>
      const $MapView$OnGlyphsErrorListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnGlyphsErrorListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnGlyphsErrorListener$Type) &&
        other is $MapView$OnGlyphsErrorListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnGlyphsLoadedListener`
class MapView$OnGlyphsLoadedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnGlyphsLoadedListener> $type;

  @jni$_.internal
  MapView$OnGlyphsLoadedListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnGlyphsLoadedListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnGlyphsLoadedListener$NullableType();
  static const type = $MapView$OnGlyphsLoadedListener$Type();
  static final _id_onGlyphsLoaded = _class.instanceMethodId(
    r'onGlyphsLoaded',
    r'([Ljava/lang/String;II)V',
  );

  static final _onGlyphsLoaded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `public abstract void onGlyphsLoaded(java.lang.String[] strings, int i, int i1)`
  void onGlyphsLoaded(
    jni$_.JArray<jni$_.JString?> strings,
    int i,
    int i1,
  ) {
    final _$strings = strings.reference;
    _onGlyphsLoaded(reference.pointer, _id_onGlyphsLoaded as jni$_.JMethodIDPtr,
            _$strings.pointer, i, i1)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnGlyphsLoadedListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onGlyphsLoaded([Ljava/lang/String;II)V') {
        _$impls[$p]!.onGlyphsLoaded(
          $a![0]!.as(
              const jni$_.JArrayType<jni$_.JString?>(
                  jni$_.JStringNullableType()),
              releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnGlyphsLoadedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnGlyphsLoadedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onGlyphsLoaded$async)
          r'onGlyphsLoaded([Ljava/lang/String;II)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnGlyphsLoadedListener.implement(
    $MapView$OnGlyphsLoadedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnGlyphsLoadedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnGlyphsLoadedListener {
  factory $MapView$OnGlyphsLoadedListener({
    required void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
        onGlyphsLoaded,
    bool onGlyphsLoaded$async,
  }) = _$MapView$OnGlyphsLoadedListener;

  void onGlyphsLoaded(jni$_.JArray<jni$_.JString?> strings, int i, int i1);
  bool get onGlyphsLoaded$async => false;
}

final class _$MapView$OnGlyphsLoadedListener
    with $MapView$OnGlyphsLoadedListener {
  _$MapView$OnGlyphsLoadedListener({
    required void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
        onGlyphsLoaded,
    this.onGlyphsLoaded$async = false,
  }) : _onGlyphsLoaded = onGlyphsLoaded;

  final void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
      _onGlyphsLoaded;
  final bool onGlyphsLoaded$async;

  void onGlyphsLoaded(jni$_.JArray<jni$_.JString?> strings, int i, int i1) {
    return _onGlyphsLoaded(strings, i, i1);
  }
}

final class $MapView$OnGlyphsLoadedListener$NullableType
    extends jni$_.JObjType<MapView$OnGlyphsLoadedListener?> {
  @jni$_.internal
  const $MapView$OnGlyphsLoadedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnGlyphsLoadedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnGlyphsLoadedListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnGlyphsLoadedListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnGlyphsLoadedListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnGlyphsLoadedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnGlyphsLoadedListener$NullableType) &&
        other is $MapView$OnGlyphsLoadedListener$NullableType;
  }
}

final class $MapView$OnGlyphsLoadedListener$Type
    extends jni$_.JObjType<MapView$OnGlyphsLoadedListener> {
  @jni$_.internal
  const $MapView$OnGlyphsLoadedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnGlyphsLoadedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnGlyphsLoadedListener fromReference(jni$_.JReference reference) =>
      MapView$OnGlyphsLoadedListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnGlyphsLoadedListener?> get nullableType =>
      const $MapView$OnGlyphsLoadedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnGlyphsLoadedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnGlyphsLoadedListener$Type) &&
        other is $MapView$OnGlyphsLoadedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnGlyphsRequestedListener`
class MapView$OnGlyphsRequestedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnGlyphsRequestedListener> $type;

  @jni$_.internal
  MapView$OnGlyphsRequestedListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnGlyphsRequestedListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnGlyphsRequestedListener$NullableType();
  static const type = $MapView$OnGlyphsRequestedListener$Type();
  static final _id_onGlyphsRequested = _class.instanceMethodId(
    r'onGlyphsRequested',
    r'([Ljava/lang/String;II)V',
  );

  static final _onGlyphsRequested = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `public abstract void onGlyphsRequested(java.lang.String[] strings, int i, int i1)`
  void onGlyphsRequested(
    jni$_.JArray<jni$_.JString?> strings,
    int i,
    int i1,
  ) {
    final _$strings = strings.reference;
    _onGlyphsRequested(
            reference.pointer,
            _id_onGlyphsRequested as jni$_.JMethodIDPtr,
            _$strings.pointer,
            i,
            i1)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnGlyphsRequestedListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onGlyphsRequested([Ljava/lang/String;II)V') {
        _$impls[$p]!.onGlyphsRequested(
          $a![0]!.as(
              const jni$_.JArrayType<jni$_.JString?>(
                  jni$_.JStringNullableType()),
              releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnGlyphsRequestedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnGlyphsRequestedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onGlyphsRequested$async)
          r'onGlyphsRequested([Ljava/lang/String;II)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnGlyphsRequestedListener.implement(
    $MapView$OnGlyphsRequestedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnGlyphsRequestedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnGlyphsRequestedListener {
  factory $MapView$OnGlyphsRequestedListener({
    required void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
        onGlyphsRequested,
    bool onGlyphsRequested$async,
  }) = _$MapView$OnGlyphsRequestedListener;

  void onGlyphsRequested(jni$_.JArray<jni$_.JString?> strings, int i, int i1);
  bool get onGlyphsRequested$async => false;
}

final class _$MapView$OnGlyphsRequestedListener
    with $MapView$OnGlyphsRequestedListener {
  _$MapView$OnGlyphsRequestedListener({
    required void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
        onGlyphsRequested,
    this.onGlyphsRequested$async = false,
  }) : _onGlyphsRequested = onGlyphsRequested;

  final void Function(jni$_.JArray<jni$_.JString?> strings, int i, int i1)
      _onGlyphsRequested;
  final bool onGlyphsRequested$async;

  void onGlyphsRequested(jni$_.JArray<jni$_.JString?> strings, int i, int i1) {
    return _onGlyphsRequested(strings, i, i1);
  }
}

final class $MapView$OnGlyphsRequestedListener$NullableType
    extends jni$_.JObjType<MapView$OnGlyphsRequestedListener?> {
  @jni$_.internal
  const $MapView$OnGlyphsRequestedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnGlyphsRequestedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnGlyphsRequestedListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnGlyphsRequestedListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnGlyphsRequestedListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnGlyphsRequestedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnGlyphsRequestedListener$NullableType) &&
        other is $MapView$OnGlyphsRequestedListener$NullableType;
  }
}

final class $MapView$OnGlyphsRequestedListener$Type
    extends jni$_.JObjType<MapView$OnGlyphsRequestedListener> {
  @jni$_.internal
  const $MapView$OnGlyphsRequestedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnGlyphsRequestedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnGlyphsRequestedListener fromReference(jni$_.JReference reference) =>
      MapView$OnGlyphsRequestedListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnGlyphsRequestedListener?> get nullableType =>
      const $MapView$OnGlyphsRequestedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnGlyphsRequestedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnGlyphsRequestedListener$Type) &&
        other is $MapView$OnGlyphsRequestedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnPostCompileShaderListener`
class MapView$OnPostCompileShaderListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnPostCompileShaderListener> $type;

  @jni$_.internal
  MapView$OnPostCompileShaderListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnPostCompileShaderListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnPostCompileShaderListener$NullableType();
  static const type = $MapView$OnPostCompileShaderListener$Type();
  static final _id_onPostCompileShader = _class.instanceMethodId(
    r'onPostCompileShader',
    r'(IILjava/lang/String;)V',
  );

  static final _onPostCompileShader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onPostCompileShader(int i, int i1, java.lang.String string)`
  void onPostCompileShader(
    int i,
    int i1,
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onPostCompileShader(
            reference.pointer,
            _id_onPostCompileShader as jni$_.JMethodIDPtr,
            i,
            i1,
            _$string.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnPostCompileShaderListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onPostCompileShader(IILjava/lang/String;)V') {
        _$impls[$p]!.onPostCompileShader(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnPostCompileShaderListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnPostCompileShaderListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onPostCompileShader$async)
          r'onPostCompileShader(IILjava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnPostCompileShaderListener.implement(
    $MapView$OnPostCompileShaderListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnPostCompileShaderListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnPostCompileShaderListener {
  factory $MapView$OnPostCompileShaderListener({
    required void Function(int i, int i1, jni$_.JString? string)
        onPostCompileShader,
    bool onPostCompileShader$async,
  }) = _$MapView$OnPostCompileShaderListener;

  void onPostCompileShader(int i, int i1, jni$_.JString? string);
  bool get onPostCompileShader$async => false;
}

final class _$MapView$OnPostCompileShaderListener
    with $MapView$OnPostCompileShaderListener {
  _$MapView$OnPostCompileShaderListener({
    required void Function(int i, int i1, jni$_.JString? string)
        onPostCompileShader,
    this.onPostCompileShader$async = false,
  }) : _onPostCompileShader = onPostCompileShader;

  final void Function(int i, int i1, jni$_.JString? string)
      _onPostCompileShader;
  final bool onPostCompileShader$async;

  void onPostCompileShader(int i, int i1, jni$_.JString? string) {
    return _onPostCompileShader(i, i1, string);
  }
}

final class $MapView$OnPostCompileShaderListener$NullableType
    extends jni$_.JObjType<MapView$OnPostCompileShaderListener?> {
  @jni$_.internal
  const $MapView$OnPostCompileShaderListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnPostCompileShaderListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnPostCompileShaderListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnPostCompileShaderListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnPostCompileShaderListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnPostCompileShaderListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnPostCompileShaderListener$NullableType) &&
        other is $MapView$OnPostCompileShaderListener$NullableType;
  }
}

final class $MapView$OnPostCompileShaderListener$Type
    extends jni$_.JObjType<MapView$OnPostCompileShaderListener> {
  @jni$_.internal
  const $MapView$OnPostCompileShaderListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnPostCompileShaderListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnPostCompileShaderListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnPostCompileShaderListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnPostCompileShaderListener?> get nullableType =>
      const $MapView$OnPostCompileShaderListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnPostCompileShaderListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnPostCompileShaderListener$Type) &&
        other is $MapView$OnPostCompileShaderListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnPreCompileShaderListener`
class MapView$OnPreCompileShaderListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnPreCompileShaderListener> $type;

  @jni$_.internal
  MapView$OnPreCompileShaderListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnPreCompileShaderListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnPreCompileShaderListener$NullableType();
  static const type = $MapView$OnPreCompileShaderListener$Type();
  static final _id_onPreCompileShader = _class.instanceMethodId(
    r'onPreCompileShader',
    r'(IILjava/lang/String;)V',
  );

  static final _onPreCompileShader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onPreCompileShader(int i, int i1, java.lang.String string)`
  void onPreCompileShader(
    int i,
    int i1,
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onPreCompileShader(
            reference.pointer,
            _id_onPreCompileShader as jni$_.JMethodIDPtr,
            i,
            i1,
            _$string.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnPreCompileShaderListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onPreCompileShader(IILjava/lang/String;)V') {
        _$impls[$p]!.onPreCompileShader(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnPreCompileShaderListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnPreCompileShaderListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onPreCompileShader$async)
          r'onPreCompileShader(IILjava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnPreCompileShaderListener.implement(
    $MapView$OnPreCompileShaderListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnPreCompileShaderListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnPreCompileShaderListener {
  factory $MapView$OnPreCompileShaderListener({
    required void Function(int i, int i1, jni$_.JString? string)
        onPreCompileShader,
    bool onPreCompileShader$async,
  }) = _$MapView$OnPreCompileShaderListener;

  void onPreCompileShader(int i, int i1, jni$_.JString? string);
  bool get onPreCompileShader$async => false;
}

final class _$MapView$OnPreCompileShaderListener
    with $MapView$OnPreCompileShaderListener {
  _$MapView$OnPreCompileShaderListener({
    required void Function(int i, int i1, jni$_.JString? string)
        onPreCompileShader,
    this.onPreCompileShader$async = false,
  }) : _onPreCompileShader = onPreCompileShader;

  final void Function(int i, int i1, jni$_.JString? string) _onPreCompileShader;
  final bool onPreCompileShader$async;

  void onPreCompileShader(int i, int i1, jni$_.JString? string) {
    return _onPreCompileShader(i, i1, string);
  }
}

final class $MapView$OnPreCompileShaderListener$NullableType
    extends jni$_.JObjType<MapView$OnPreCompileShaderListener?> {
  @jni$_.internal
  const $MapView$OnPreCompileShaderListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnPreCompileShaderListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnPreCompileShaderListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnPreCompileShaderListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnPreCompileShaderListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnPreCompileShaderListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnPreCompileShaderListener$NullableType) &&
        other is $MapView$OnPreCompileShaderListener$NullableType;
  }
}

final class $MapView$OnPreCompileShaderListener$Type
    extends jni$_.JObjType<MapView$OnPreCompileShaderListener> {
  @jni$_.internal
  const $MapView$OnPreCompileShaderListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnPreCompileShaderListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnPreCompileShaderListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnPreCompileShaderListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnPreCompileShaderListener?> get nullableType =>
      const $MapView$OnPreCompileShaderListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnPreCompileShaderListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnPreCompileShaderListener$Type) &&
        other is $MapView$OnPreCompileShaderListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnShaderCompileFailedListener`
class MapView$OnShaderCompileFailedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnShaderCompileFailedListener> $type;

  @jni$_.internal
  MapView$OnShaderCompileFailedListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnShaderCompileFailedListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnShaderCompileFailedListener$NullableType();
  static const type = $MapView$OnShaderCompileFailedListener$Type();
  static final _id_onShaderCompileFailed = _class.instanceMethodId(
    r'onShaderCompileFailed',
    r'(IILjava/lang/String;)V',
  );

  static final _onShaderCompileFailed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onShaderCompileFailed(int i, int i1, java.lang.String string)`
  void onShaderCompileFailed(
    int i,
    int i1,
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onShaderCompileFailed(
            reference.pointer,
            _id_onShaderCompileFailed as jni$_.JMethodIDPtr,
            i,
            i1,
            _$string.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnShaderCompileFailedListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onShaderCompileFailed(IILjava/lang/String;)V') {
        _$impls[$p]!.onShaderCompileFailed(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnShaderCompileFailedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnShaderCompileFailedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onShaderCompileFailed$async)
          r'onShaderCompileFailed(IILjava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnShaderCompileFailedListener.implement(
    $MapView$OnShaderCompileFailedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnShaderCompileFailedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnShaderCompileFailedListener {
  factory $MapView$OnShaderCompileFailedListener({
    required void Function(int i, int i1, jni$_.JString? string)
        onShaderCompileFailed,
    bool onShaderCompileFailed$async,
  }) = _$MapView$OnShaderCompileFailedListener;

  void onShaderCompileFailed(int i, int i1, jni$_.JString? string);
  bool get onShaderCompileFailed$async => false;
}

final class _$MapView$OnShaderCompileFailedListener
    with $MapView$OnShaderCompileFailedListener {
  _$MapView$OnShaderCompileFailedListener({
    required void Function(int i, int i1, jni$_.JString? string)
        onShaderCompileFailed,
    this.onShaderCompileFailed$async = false,
  }) : _onShaderCompileFailed = onShaderCompileFailed;

  final void Function(int i, int i1, jni$_.JString? string)
      _onShaderCompileFailed;
  final bool onShaderCompileFailed$async;

  void onShaderCompileFailed(int i, int i1, jni$_.JString? string) {
    return _onShaderCompileFailed(i, i1, string);
  }
}

final class $MapView$OnShaderCompileFailedListener$NullableType
    extends jni$_.JObjType<MapView$OnShaderCompileFailedListener?> {
  @jni$_.internal
  const $MapView$OnShaderCompileFailedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnShaderCompileFailedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnShaderCompileFailedListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnShaderCompileFailedListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnShaderCompileFailedListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnShaderCompileFailedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnShaderCompileFailedListener$NullableType) &&
        other is $MapView$OnShaderCompileFailedListener$NullableType;
  }
}

final class $MapView$OnShaderCompileFailedListener$Type
    extends jni$_.JObjType<MapView$OnShaderCompileFailedListener> {
  @jni$_.internal
  const $MapView$OnShaderCompileFailedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnShaderCompileFailedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnShaderCompileFailedListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnShaderCompileFailedListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnShaderCompileFailedListener?> get nullableType =>
      const $MapView$OnShaderCompileFailedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnShaderCompileFailedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnShaderCompileFailedListener$Type) &&
        other is $MapView$OnShaderCompileFailedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnSourceChangedListener`
class MapView$OnSourceChangedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnSourceChangedListener> $type;

  @jni$_.internal
  MapView$OnSourceChangedListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnSourceChangedListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnSourceChangedListener$NullableType();
  static const type = $MapView$OnSourceChangedListener$Type();
  static final _id_onSourceChangedListener = _class.instanceMethodId(
    r'onSourceChangedListener',
    r'(Ljava/lang/String;)V',
  );

  static final _onSourceChangedListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onSourceChangedListener(java.lang.String string)`
  void onSourceChangedListener(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onSourceChangedListener(reference.pointer,
            _id_onSourceChangedListener as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnSourceChangedListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSourceChangedListener(Ljava/lang/String;)V') {
        _$impls[$p]!.onSourceChangedListener(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnSourceChangedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnSourceChangedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onSourceChangedListener$async)
          r'onSourceChangedListener(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnSourceChangedListener.implement(
    $MapView$OnSourceChangedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnSourceChangedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnSourceChangedListener {
  factory $MapView$OnSourceChangedListener({
    required void Function(jni$_.JString? string) onSourceChangedListener,
    bool onSourceChangedListener$async,
  }) = _$MapView$OnSourceChangedListener;

  void onSourceChangedListener(jni$_.JString? string);
  bool get onSourceChangedListener$async => false;
}

final class _$MapView$OnSourceChangedListener
    with $MapView$OnSourceChangedListener {
  _$MapView$OnSourceChangedListener({
    required void Function(jni$_.JString? string) onSourceChangedListener,
    this.onSourceChangedListener$async = false,
  }) : _onSourceChangedListener = onSourceChangedListener;

  final void Function(jni$_.JString? string) _onSourceChangedListener;
  final bool onSourceChangedListener$async;

  void onSourceChangedListener(jni$_.JString? string) {
    return _onSourceChangedListener(string);
  }
}

final class $MapView$OnSourceChangedListener$NullableType
    extends jni$_.JObjType<MapView$OnSourceChangedListener?> {
  @jni$_.internal
  const $MapView$OnSourceChangedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnSourceChangedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnSourceChangedListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnSourceChangedListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnSourceChangedListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnSourceChangedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnSourceChangedListener$NullableType) &&
        other is $MapView$OnSourceChangedListener$NullableType;
  }
}

final class $MapView$OnSourceChangedListener$Type
    extends jni$_.JObjType<MapView$OnSourceChangedListener> {
  @jni$_.internal
  const $MapView$OnSourceChangedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnSourceChangedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnSourceChangedListener fromReference(jni$_.JReference reference) =>
      MapView$OnSourceChangedListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnSourceChangedListener?> get nullableType =>
      const $MapView$OnSourceChangedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnSourceChangedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnSourceChangedListener$Type) &&
        other is $MapView$OnSourceChangedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnSpriteErrorListener`
class MapView$OnSpriteErrorListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnSpriteErrorListener> $type;

  @jni$_.internal
  MapView$OnSpriteErrorListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnSpriteErrorListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnSpriteErrorListener$NullableType();
  static const type = $MapView$OnSpriteErrorListener$Type();
  static final _id_onSpriteError = _class.instanceMethodId(
    r'onSpriteError',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _onSpriteError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onSpriteError(java.lang.String string, java.lang.String string1)`
  void onSpriteError(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _onSpriteError(reference.pointer, _id_onSpriteError as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnSpriteErrorListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSpriteError(Ljava/lang/String;Ljava/lang/String;)V') {
        _$impls[$p]!.onSpriteError(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnSpriteErrorListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnSpriteErrorListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onSpriteError$async)
          r'onSpriteError(Ljava/lang/String;Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnSpriteErrorListener.implement(
    $MapView$OnSpriteErrorListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnSpriteErrorListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnSpriteErrorListener {
  factory $MapView$OnSpriteErrorListener({
    required void Function(jni$_.JString string, jni$_.JString string1)
        onSpriteError,
    bool onSpriteError$async,
  }) = _$MapView$OnSpriteErrorListener;

  void onSpriteError(jni$_.JString string, jni$_.JString string1);
  bool get onSpriteError$async => false;
}

final class _$MapView$OnSpriteErrorListener
    with $MapView$OnSpriteErrorListener {
  _$MapView$OnSpriteErrorListener({
    required void Function(jni$_.JString string, jni$_.JString string1)
        onSpriteError,
    this.onSpriteError$async = false,
  }) : _onSpriteError = onSpriteError;

  final void Function(jni$_.JString string, jni$_.JString string1)
      _onSpriteError;
  final bool onSpriteError$async;

  void onSpriteError(jni$_.JString string, jni$_.JString string1) {
    return _onSpriteError(string, string1);
  }
}

final class $MapView$OnSpriteErrorListener$NullableType
    extends jni$_.JObjType<MapView$OnSpriteErrorListener?> {
  @jni$_.internal
  const $MapView$OnSpriteErrorListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnSpriteErrorListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnSpriteErrorListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnSpriteErrorListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnSpriteErrorListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnSpriteErrorListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnSpriteErrorListener$NullableType) &&
        other is $MapView$OnSpriteErrorListener$NullableType;
  }
}

final class $MapView$OnSpriteErrorListener$Type
    extends jni$_.JObjType<MapView$OnSpriteErrorListener> {
  @jni$_.internal
  const $MapView$OnSpriteErrorListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnSpriteErrorListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnSpriteErrorListener fromReference(jni$_.JReference reference) =>
      MapView$OnSpriteErrorListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnSpriteErrorListener?> get nullableType =>
      const $MapView$OnSpriteErrorListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnSpriteErrorListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnSpriteErrorListener$Type) &&
        other is $MapView$OnSpriteErrorListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnSpriteLoadedListener`
class MapView$OnSpriteLoadedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnSpriteLoadedListener> $type;

  @jni$_.internal
  MapView$OnSpriteLoadedListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnSpriteLoadedListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnSpriteLoadedListener$NullableType();
  static const type = $MapView$OnSpriteLoadedListener$Type();
  static final _id_onSpriteLoaded = _class.instanceMethodId(
    r'onSpriteLoaded',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _onSpriteLoaded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onSpriteLoaded(java.lang.String string, java.lang.String string1)`
  void onSpriteLoaded(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _onSpriteLoaded(reference.pointer, _id_onSpriteLoaded as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnSpriteLoadedListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSpriteLoaded(Ljava/lang/String;Ljava/lang/String;)V') {
        _$impls[$p]!.onSpriteLoaded(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnSpriteLoadedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnSpriteLoadedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onSpriteLoaded$async)
          r'onSpriteLoaded(Ljava/lang/String;Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnSpriteLoadedListener.implement(
    $MapView$OnSpriteLoadedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnSpriteLoadedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnSpriteLoadedListener {
  factory $MapView$OnSpriteLoadedListener({
    required void Function(jni$_.JString string, jni$_.JString string1)
        onSpriteLoaded,
    bool onSpriteLoaded$async,
  }) = _$MapView$OnSpriteLoadedListener;

  void onSpriteLoaded(jni$_.JString string, jni$_.JString string1);
  bool get onSpriteLoaded$async => false;
}

final class _$MapView$OnSpriteLoadedListener
    with $MapView$OnSpriteLoadedListener {
  _$MapView$OnSpriteLoadedListener({
    required void Function(jni$_.JString string, jni$_.JString string1)
        onSpriteLoaded,
    this.onSpriteLoaded$async = false,
  }) : _onSpriteLoaded = onSpriteLoaded;

  final void Function(jni$_.JString string, jni$_.JString string1)
      _onSpriteLoaded;
  final bool onSpriteLoaded$async;

  void onSpriteLoaded(jni$_.JString string, jni$_.JString string1) {
    return _onSpriteLoaded(string, string1);
  }
}

final class $MapView$OnSpriteLoadedListener$NullableType
    extends jni$_.JObjType<MapView$OnSpriteLoadedListener?> {
  @jni$_.internal
  const $MapView$OnSpriteLoadedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnSpriteLoadedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnSpriteLoadedListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnSpriteLoadedListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnSpriteLoadedListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnSpriteLoadedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnSpriteLoadedListener$NullableType) &&
        other is $MapView$OnSpriteLoadedListener$NullableType;
  }
}

final class $MapView$OnSpriteLoadedListener$Type
    extends jni$_.JObjType<MapView$OnSpriteLoadedListener> {
  @jni$_.internal
  const $MapView$OnSpriteLoadedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnSpriteLoadedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnSpriteLoadedListener fromReference(jni$_.JReference reference) =>
      MapView$OnSpriteLoadedListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnSpriteLoadedListener?> get nullableType =>
      const $MapView$OnSpriteLoadedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnSpriteLoadedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnSpriteLoadedListener$Type) &&
        other is $MapView$OnSpriteLoadedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnSpriteRequestedListener`
class MapView$OnSpriteRequestedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnSpriteRequestedListener> $type;

  @jni$_.internal
  MapView$OnSpriteRequestedListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnSpriteRequestedListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnSpriteRequestedListener$NullableType();
  static const type = $MapView$OnSpriteRequestedListener$Type();
  static final _id_onSpriteRequested = _class.instanceMethodId(
    r'onSpriteRequested',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _onSpriteRequested = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onSpriteRequested(java.lang.String string, java.lang.String string1)`
  void onSpriteRequested(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _onSpriteRequested(
            reference.pointer,
            _id_onSpriteRequested as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnSpriteRequestedListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSpriteRequested(Ljava/lang/String;Ljava/lang/String;)V') {
        _$impls[$p]!.onSpriteRequested(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnSpriteRequestedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnSpriteRequestedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onSpriteRequested$async)
          r'onSpriteRequested(Ljava/lang/String;Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnSpriteRequestedListener.implement(
    $MapView$OnSpriteRequestedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnSpriteRequestedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnSpriteRequestedListener {
  factory $MapView$OnSpriteRequestedListener({
    required void Function(jni$_.JString string, jni$_.JString string1)
        onSpriteRequested,
    bool onSpriteRequested$async,
  }) = _$MapView$OnSpriteRequestedListener;

  void onSpriteRequested(jni$_.JString string, jni$_.JString string1);
  bool get onSpriteRequested$async => false;
}

final class _$MapView$OnSpriteRequestedListener
    with $MapView$OnSpriteRequestedListener {
  _$MapView$OnSpriteRequestedListener({
    required void Function(jni$_.JString string, jni$_.JString string1)
        onSpriteRequested,
    this.onSpriteRequested$async = false,
  }) : _onSpriteRequested = onSpriteRequested;

  final void Function(jni$_.JString string, jni$_.JString string1)
      _onSpriteRequested;
  final bool onSpriteRequested$async;

  void onSpriteRequested(jni$_.JString string, jni$_.JString string1) {
    return _onSpriteRequested(string, string1);
  }
}

final class $MapView$OnSpriteRequestedListener$NullableType
    extends jni$_.JObjType<MapView$OnSpriteRequestedListener?> {
  @jni$_.internal
  const $MapView$OnSpriteRequestedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnSpriteRequestedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnSpriteRequestedListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnSpriteRequestedListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnSpriteRequestedListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnSpriteRequestedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnSpriteRequestedListener$NullableType) &&
        other is $MapView$OnSpriteRequestedListener$NullableType;
  }
}

final class $MapView$OnSpriteRequestedListener$Type
    extends jni$_.JObjType<MapView$OnSpriteRequestedListener> {
  @jni$_.internal
  const $MapView$OnSpriteRequestedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnSpriteRequestedListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnSpriteRequestedListener fromReference(jni$_.JReference reference) =>
      MapView$OnSpriteRequestedListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnSpriteRequestedListener?> get nullableType =>
      const $MapView$OnSpriteRequestedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnSpriteRequestedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnSpriteRequestedListener$Type) &&
        other is $MapView$OnSpriteRequestedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnStyleImageMissingListener`
class MapView$OnStyleImageMissingListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnStyleImageMissingListener> $type;

  @jni$_.internal
  MapView$OnStyleImageMissingListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnStyleImageMissingListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnStyleImageMissingListener$NullableType();
  static const type = $MapView$OnStyleImageMissingListener$Type();
  static final _id_onStyleImageMissing = _class.instanceMethodId(
    r'onStyleImageMissing',
    r'(Ljava/lang/String;)V',
  );

  static final _onStyleImageMissing = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onStyleImageMissing(java.lang.String string)`
  void onStyleImageMissing(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _onStyleImageMissing(reference.pointer,
            _id_onStyleImageMissing as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnStyleImageMissingListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onStyleImageMissing(Ljava/lang/String;)V') {
        _$impls[$p]!.onStyleImageMissing(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnStyleImageMissingListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnStyleImageMissingListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onStyleImageMissing$async)
          r'onStyleImageMissing(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnStyleImageMissingListener.implement(
    $MapView$OnStyleImageMissingListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnStyleImageMissingListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnStyleImageMissingListener {
  factory $MapView$OnStyleImageMissingListener({
    required void Function(jni$_.JString string) onStyleImageMissing,
    bool onStyleImageMissing$async,
  }) = _$MapView$OnStyleImageMissingListener;

  void onStyleImageMissing(jni$_.JString string);
  bool get onStyleImageMissing$async => false;
}

final class _$MapView$OnStyleImageMissingListener
    with $MapView$OnStyleImageMissingListener {
  _$MapView$OnStyleImageMissingListener({
    required void Function(jni$_.JString string) onStyleImageMissing,
    this.onStyleImageMissing$async = false,
  }) : _onStyleImageMissing = onStyleImageMissing;

  final void Function(jni$_.JString string) _onStyleImageMissing;
  final bool onStyleImageMissing$async;

  void onStyleImageMissing(jni$_.JString string) {
    return _onStyleImageMissing(string);
  }
}

final class $MapView$OnStyleImageMissingListener$NullableType
    extends jni$_.JObjType<MapView$OnStyleImageMissingListener?> {
  @jni$_.internal
  const $MapView$OnStyleImageMissingListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnStyleImageMissingListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnStyleImageMissingListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnStyleImageMissingListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnStyleImageMissingListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnStyleImageMissingListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnStyleImageMissingListener$NullableType) &&
        other is $MapView$OnStyleImageMissingListener$NullableType;
  }
}

final class $MapView$OnStyleImageMissingListener$Type
    extends jni$_.JObjType<MapView$OnStyleImageMissingListener> {
  @jni$_.internal
  const $MapView$OnStyleImageMissingListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnStyleImageMissingListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnStyleImageMissingListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnStyleImageMissingListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnStyleImageMissingListener?> get nullableType =>
      const $MapView$OnStyleImageMissingListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnStyleImageMissingListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnStyleImageMissingListener$Type) &&
        other is $MapView$OnStyleImageMissingListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnTileActionListener`
class MapView$OnTileActionListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnTileActionListener> $type;

  @jni$_.internal
  MapView$OnTileActionListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnTileActionListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$OnTileActionListener$NullableType();
  static const type = $MapView$OnTileActionListener$Type();
  static final _id_onTileAction = _class.instanceMethodId(
    r'onTileAction',
    r'(Lorg/maplibre/android/tile/TileOperation;IIIIILjava/lang/String;)V',
  );

  static final _onTileAction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onTileAction(org.maplibre.android.tile.TileOperation tileOperation, int i, int i1, int i2, int i3, int i4, java.lang.String string)`
  void onTileAction(
    jni$_.JObject? tileOperation,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    jni$_.JString? string,
  ) {
    final _$tileOperation = tileOperation?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onTileAction(reference.pointer, _id_onTileAction as jni$_.JMethodIDPtr,
            _$tileOperation.pointer, i, i1, i2, i3, i4, _$string.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnTileActionListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onTileAction(Lorg/maplibre/android/tile/TileOperation;IIIIILjava/lang/String;)V') {
        _$impls[$p]!.onTileAction(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![3]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![4]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![5]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![6]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnTileActionListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnTileActionListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onTileAction$async)
          r'onTileAction(Lorg/maplibre/android/tile/TileOperation;IIIIILjava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnTileActionListener.implement(
    $MapView$OnTileActionListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnTileActionListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnTileActionListener {
  factory $MapView$OnTileActionListener({
    required void Function(jni$_.JObject? tileOperation, int i, int i1, int i2,
            int i3, int i4, jni$_.JString? string)
        onTileAction,
    bool onTileAction$async,
  }) = _$MapView$OnTileActionListener;

  void onTileAction(jni$_.JObject? tileOperation, int i, int i1, int i2, int i3,
      int i4, jni$_.JString? string);
  bool get onTileAction$async => false;
}

final class _$MapView$OnTileActionListener with $MapView$OnTileActionListener {
  _$MapView$OnTileActionListener({
    required void Function(jni$_.JObject? tileOperation, int i, int i1, int i2,
            int i3, int i4, jni$_.JString? string)
        onTileAction,
    this.onTileAction$async = false,
  }) : _onTileAction = onTileAction;

  final void Function(jni$_.JObject? tileOperation, int i, int i1, int i2,
      int i3, int i4, jni$_.JString? string) _onTileAction;
  final bool onTileAction$async;

  void onTileAction(jni$_.JObject? tileOperation, int i, int i1, int i2, int i3,
      int i4, jni$_.JString? string) {
    return _onTileAction(tileOperation, i, i1, i2, i3, i4, string);
  }
}

final class $MapView$OnTileActionListener$NullableType
    extends jni$_.JObjType<MapView$OnTileActionListener?> {
  @jni$_.internal
  const $MapView$OnTileActionListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnTileActionListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnTileActionListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnTileActionListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnTileActionListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnTileActionListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnTileActionListener$NullableType) &&
        other is $MapView$OnTileActionListener$NullableType;
  }
}

final class $MapView$OnTileActionListener$Type
    extends jni$_.JObjType<MapView$OnTileActionListener> {
  @jni$_.internal
  const $MapView$OnTileActionListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnTileActionListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnTileActionListener fromReference(jni$_.JReference reference) =>
      MapView$OnTileActionListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnTileActionListener?> get nullableType =>
      const $MapView$OnTileActionListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnTileActionListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnTileActionListener$Type) &&
        other is $MapView$OnTileActionListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnWillStartLoadingMapListener`
class MapView$OnWillStartLoadingMapListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnWillStartLoadingMapListener> $type;

  @jni$_.internal
  MapView$OnWillStartLoadingMapListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnWillStartLoadingMapListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnWillStartLoadingMapListener$NullableType();
  static const type = $MapView$OnWillStartLoadingMapListener$Type();
  static final _id_onWillStartLoadingMap = _class.instanceMethodId(
    r'onWillStartLoadingMap',
    r'()V',
  );

  static final _onWillStartLoadingMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onWillStartLoadingMap()`
  void onWillStartLoadingMap() {
    _onWillStartLoadingMap(
            reference.pointer, _id_onWillStartLoadingMap as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnWillStartLoadingMapListener> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onWillStartLoadingMap()V') {
        _$impls[$p]!.onWillStartLoadingMap();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnWillStartLoadingMapListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnWillStartLoadingMapListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onWillStartLoadingMap$async) r'onWillStartLoadingMap()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnWillStartLoadingMapListener.implement(
    $MapView$OnWillStartLoadingMapListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnWillStartLoadingMapListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnWillStartLoadingMapListener {
  factory $MapView$OnWillStartLoadingMapListener({
    required void Function() onWillStartLoadingMap,
    bool onWillStartLoadingMap$async,
  }) = _$MapView$OnWillStartLoadingMapListener;

  void onWillStartLoadingMap();
  bool get onWillStartLoadingMap$async => false;
}

final class _$MapView$OnWillStartLoadingMapListener
    with $MapView$OnWillStartLoadingMapListener {
  _$MapView$OnWillStartLoadingMapListener({
    required void Function() onWillStartLoadingMap,
    this.onWillStartLoadingMap$async = false,
  }) : _onWillStartLoadingMap = onWillStartLoadingMap;

  final void Function() _onWillStartLoadingMap;
  final bool onWillStartLoadingMap$async;

  void onWillStartLoadingMap() {
    return _onWillStartLoadingMap();
  }
}

final class $MapView$OnWillStartLoadingMapListener$NullableType
    extends jni$_.JObjType<MapView$OnWillStartLoadingMapListener?> {
  @jni$_.internal
  const $MapView$OnWillStartLoadingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnWillStartLoadingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnWillStartLoadingMapListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnWillStartLoadingMapListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnWillStartLoadingMapListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnWillStartLoadingMapListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnWillStartLoadingMapListener$NullableType) &&
        other is $MapView$OnWillStartLoadingMapListener$NullableType;
  }
}

final class $MapView$OnWillStartLoadingMapListener$Type
    extends jni$_.JObjType<MapView$OnWillStartLoadingMapListener> {
  @jni$_.internal
  const $MapView$OnWillStartLoadingMapListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnWillStartLoadingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnWillStartLoadingMapListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnWillStartLoadingMapListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnWillStartLoadingMapListener?> get nullableType =>
      const $MapView$OnWillStartLoadingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnWillStartLoadingMapListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$OnWillStartLoadingMapListener$Type) &&
        other is $MapView$OnWillStartLoadingMapListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnWillStartRenderingFrameListener`
class MapView$OnWillStartRenderingFrameListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnWillStartRenderingFrameListener> $type;

  @jni$_.internal
  MapView$OnWillStartRenderingFrameListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnWillStartRenderingFrameListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnWillStartRenderingFrameListener$NullableType();
  static const type = $MapView$OnWillStartRenderingFrameListener$Type();
  static final _id_onWillStartRenderingFrame = _class.instanceMethodId(
    r'onWillStartRenderingFrame',
    r'()V',
  );

  static final _onWillStartRenderingFrame = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onWillStartRenderingFrame()`
  void onWillStartRenderingFrame() {
    _onWillStartRenderingFrame(reference.pointer,
            _id_onWillStartRenderingFrame as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnWillStartRenderingFrameListener>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onWillStartRenderingFrame()V') {
        _$impls[$p]!.onWillStartRenderingFrame();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnWillStartRenderingFrameListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnWillStartRenderingFrameListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onWillStartRenderingFrame$async)
          r'onWillStartRenderingFrame()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnWillStartRenderingFrameListener.implement(
    $MapView$OnWillStartRenderingFrameListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnWillStartRenderingFrameListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnWillStartRenderingFrameListener {
  factory $MapView$OnWillStartRenderingFrameListener({
    required void Function() onWillStartRenderingFrame,
    bool onWillStartRenderingFrame$async,
  }) = _$MapView$OnWillStartRenderingFrameListener;

  void onWillStartRenderingFrame();
  bool get onWillStartRenderingFrame$async => false;
}

final class _$MapView$OnWillStartRenderingFrameListener
    with $MapView$OnWillStartRenderingFrameListener {
  _$MapView$OnWillStartRenderingFrameListener({
    required void Function() onWillStartRenderingFrame,
    this.onWillStartRenderingFrame$async = false,
  }) : _onWillStartRenderingFrame = onWillStartRenderingFrame;

  final void Function() _onWillStartRenderingFrame;
  final bool onWillStartRenderingFrame$async;

  void onWillStartRenderingFrame() {
    return _onWillStartRenderingFrame();
  }
}

final class $MapView$OnWillStartRenderingFrameListener$NullableType
    extends jni$_.JObjType<MapView$OnWillStartRenderingFrameListener?> {
  @jni$_.internal
  const $MapView$OnWillStartRenderingFrameListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnWillStartRenderingFrameListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnWillStartRenderingFrameListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnWillStartRenderingFrameListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnWillStartRenderingFrameListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnWillStartRenderingFrameListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnWillStartRenderingFrameListener$NullableType) &&
        other is $MapView$OnWillStartRenderingFrameListener$NullableType;
  }
}

final class $MapView$OnWillStartRenderingFrameListener$Type
    extends jni$_.JObjType<MapView$OnWillStartRenderingFrameListener> {
  @jni$_.internal
  const $MapView$OnWillStartRenderingFrameListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnWillStartRenderingFrameListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnWillStartRenderingFrameListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnWillStartRenderingFrameListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnWillStartRenderingFrameListener?> get nullableType =>
      const $MapView$OnWillStartRenderingFrameListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnWillStartRenderingFrameListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnWillStartRenderingFrameListener$Type) &&
        other is $MapView$OnWillStartRenderingFrameListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView$OnWillStartRenderingMapListener`
class MapView$OnWillStartRenderingMapListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView$OnWillStartRenderingMapListener> $type;

  @jni$_.internal
  MapView$OnWillStartRenderingMapListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/maplibre/android/maps/MapView$OnWillStartRenderingMapListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $MapView$OnWillStartRenderingMapListener$NullableType();
  static const type = $MapView$OnWillStartRenderingMapListener$Type();
  static final _id_onWillStartRenderingMap = _class.instanceMethodId(
    r'onWillStartRenderingMap',
    r'()V',
  );

  static final _onWillStartRenderingMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onWillStartRenderingMap()`
  void onWillStartRenderingMap() {
    _onWillStartRenderingMap(reference.pointer,
            _id_onWillStartRenderingMap as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MapView$OnWillStartRenderingMapListener>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onWillStartRenderingMap()V') {
        _$impls[$p]!.onWillStartRenderingMap();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MapView$OnWillStartRenderingMapListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapView$OnWillStartRenderingMapListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onWillStartRenderingMap$async) r'onWillStartRenderingMap()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapView$OnWillStartRenderingMapListener.implement(
    $MapView$OnWillStartRenderingMapListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MapView$OnWillStartRenderingMapListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapView$OnWillStartRenderingMapListener {
  factory $MapView$OnWillStartRenderingMapListener({
    required void Function() onWillStartRenderingMap,
    bool onWillStartRenderingMap$async,
  }) = _$MapView$OnWillStartRenderingMapListener;

  void onWillStartRenderingMap();
  bool get onWillStartRenderingMap$async => false;
}

final class _$MapView$OnWillStartRenderingMapListener
    with $MapView$OnWillStartRenderingMapListener {
  _$MapView$OnWillStartRenderingMapListener({
    required void Function() onWillStartRenderingMap,
    this.onWillStartRenderingMap$async = false,
  }) : _onWillStartRenderingMap = onWillStartRenderingMap;

  final void Function() _onWillStartRenderingMap;
  final bool onWillStartRenderingMap$async;

  void onWillStartRenderingMap() {
    return _onWillStartRenderingMap();
  }
}

final class $MapView$OnWillStartRenderingMapListener$NullableType
    extends jni$_.JObjType<MapView$OnWillStartRenderingMapListener?> {
  @jni$_.internal
  const $MapView$OnWillStartRenderingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnWillStartRenderingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnWillStartRenderingMapListener? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MapView$OnWillStartRenderingMapListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnWillStartRenderingMapListener?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($MapView$OnWillStartRenderingMapListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnWillStartRenderingMapListener$NullableType) &&
        other is $MapView$OnWillStartRenderingMapListener$NullableType;
  }
}

final class $MapView$OnWillStartRenderingMapListener$Type
    extends jni$_.JObjType<MapView$OnWillStartRenderingMapListener> {
  @jni$_.internal
  const $MapView$OnWillStartRenderingMapListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapView$OnWillStartRenderingMapListener;';

  @jni$_.internal
  @core$_.override
  MapView$OnWillStartRenderingMapListener fromReference(
          jni$_.JReference reference) =>
      MapView$OnWillStartRenderingMapListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView$OnWillStartRenderingMapListener?> get nullableType =>
      const $MapView$OnWillStartRenderingMapListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$OnWillStartRenderingMapListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapView$OnWillStartRenderingMapListener$Type) &&
        other is $MapView$OnWillStartRenderingMapListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapView`
class MapView extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MapView> $type;

  @jni$_.internal
  MapView.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/maplibre/android/maps/MapView');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MapView$NullableType();
  static const type = $MapView$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroid/content/Context;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MapView(
    jni$_.JObject context,
  ) {
    final _$context = context.reference;
    return MapView.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$context.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/content/Context;Landroid/util/AttributeSet;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, android.util.AttributeSet attributeSet)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MapView.new$1(
    jni$_.JObject context,
    jni$_.JObject? attributeSet,
  ) {
    final _$context = context.reference;
    final _$attributeSet = attributeSet?.reference ?? jni$_.jNullReference;
    return MapView.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$attributeSet.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Landroid/content/Context;Landroid/util/AttributeSet;I)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MapView.new$2(
    jni$_.JObject context,
    jni$_.JObject? attributeSet,
    int i,
  ) {
    final _$context = context.reference;
    final _$attributeSet = attributeSet?.reference ?? jni$_.jNullReference;
    return MapView.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$attributeSet.pointer,
            i)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Landroid/content/Context;Lorg/maplibre/android/maps/MapLibreMapOptions;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, org.maplibre.android.maps.MapLibreMapOptions mapLibreMapOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MapView.new$3(
    jni$_.JObject context,
    maplibremapoptions$_.MapLibreMapOptions? mapLibreMapOptions,
  ) {
    final _$context = context.reference;
    final _$mapLibreMapOptions =
        mapLibreMapOptions?.reference ?? jni$_.jNullReference;
    return MapView.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$mapLibreMapOptions.pointer)
        .reference);
  }

  static final _id_onCreate = _class.instanceMethodId(
    r'onCreate',
    r'(Landroid/os/Bundle;)V',
  );

  static final _onCreate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onCreate(android.os.Bundle bundle)`
  void onCreate(
    jni$_.JObject? bundle,
  ) {
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _onCreate(reference.pointer, _id_onCreate as jni$_.JMethodIDPtr,
            _$bundle.pointer)
        .check();
  }

  static final _id_onSaveInstanceState = _class.instanceMethodId(
    r'onSaveInstanceState',
    r'(Landroid/os/Bundle;)V',
  );

  static final _onSaveInstanceState = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onSaveInstanceState(android.os.Bundle bundle)`
  void onSaveInstanceState(
    jni$_.JObject bundle,
  ) {
    final _$bundle = bundle.reference;
    _onSaveInstanceState(reference.pointer,
            _id_onSaveInstanceState as jni$_.JMethodIDPtr, _$bundle.pointer)
        .check();
  }

  static final _id_onStart = _class.instanceMethodId(
    r'onStart',
    r'()V',
  );

  static final _onStart = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onStart()`
  void onStart() {
    _onStart(reference.pointer, _id_onStart as jni$_.JMethodIDPtr).check();
  }

  static final _id_onResume = _class.instanceMethodId(
    r'onResume',
    r'()V',
  );

  static final _onResume = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onResume()`
  void onResume() {
    _onResume(reference.pointer, _id_onResume as jni$_.JMethodIDPtr).check();
  }

  static final _id_onPause = _class.instanceMethodId(
    r'onPause',
    r'()V',
  );

  static final _onPause = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onPause()`
  void onPause() {
    _onPause(reference.pointer, _id_onPause as jni$_.JMethodIDPtr).check();
  }

  static final _id_onStop = _class.instanceMethodId(
    r'onStop',
    r'()V',
  );

  static final _onStop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onStop()`
  void onStop() {
    _onStop(reference.pointer, _id_onStop as jni$_.JMethodIDPtr).check();
  }

  static final _id_onDestroy = _class.instanceMethodId(
    r'onDestroy',
    r'()V',
  );

  static final _onDestroy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onDestroy()`
  void onDestroy() {
    _onDestroy(reference.pointer, _id_onDestroy as jni$_.JMethodIDPtr).check();
  }

  static final _id_queueEvent = _class.instanceMethodId(
    r'queueEvent',
    r'(Ljava/lang/Runnable;)V',
  );

  static final _queueEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void queueEvent(java.lang.Runnable runnable)`
  void queueEvent(
    jni$_.JObject runnable,
  ) {
    final _$runnable = runnable.reference;
    _queueEvent(reference.pointer, _id_queueEvent as jni$_.JMethodIDPtr,
            _$runnable.pointer)
        .check();
  }

  static final _id_setMaximumFps = _class.instanceMethodId(
    r'setMaximumFps',
    r'(I)V',
  );

  static final _setMaximumFps = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaximumFps(int i)`
  void setMaximumFps(
    int i,
  ) {
    _setMaximumFps(
            reference.pointer, _id_setMaximumFps as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setRenderingRefreshMode = _class.instanceMethodId(
    r'setRenderingRefreshMode',
    r'(Lorg/maplibre/android/maps/renderer/MapRenderer$RenderingRefreshMode;)V',
  );

  static final _setRenderingRefreshMode = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRenderingRefreshMode(org.maplibre.android.maps.renderer.MapRenderer$RenderingRefreshMode renderingRefreshMode)`
  void setRenderingRefreshMode(
    maprenderer$_.MapRenderer$RenderingRefreshMode? renderingRefreshMode,
  ) {
    final _$renderingRefreshMode =
        renderingRefreshMode?.reference ?? jni$_.jNullReference;
    _setRenderingRefreshMode(
            reference.pointer,
            _id_setRenderingRefreshMode as jni$_.JMethodIDPtr,
            _$renderingRefreshMode.pointer)
        .check();
  }

  static final _id_getRenderingRefreshMode = _class.instanceMethodId(
    r'getRenderingRefreshMode',
    r'()Lorg/maplibre/android/maps/renderer/MapRenderer$RenderingRefreshMode;',
  );

  static final _getRenderingRefreshMode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.renderer.MapRenderer$RenderingRefreshMode getRenderingRefreshMode()`
  /// The returned object must be released after use, by calling the [release] method.
  maprenderer$_.MapRenderer$RenderingRefreshMode? getRenderingRefreshMode() {
    return _getRenderingRefreshMode(reference.pointer,
            _id_getRenderingRefreshMode as jni$_.JMethodIDPtr)
        .object<maprenderer$_.MapRenderer$RenderingRefreshMode?>(
            const maprenderer$_
                .$MapRenderer$RenderingRefreshMode$NullableType());
  }

  static final _id_isDestroyed = _class.instanceMethodId(
    r'isDestroyed',
    r'()Z',
  );

  static final _isDestroyed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isDestroyed()`
  bool isDestroyed() {
    return _isDestroyed(
            reference.pointer, _id_isDestroyed as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getRenderView = _class.instanceMethodId(
    r'getRenderView',
    r'()Landroid/view/View;',
  );

  static final _getRenderView = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.view.View getRenderView()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getRenderView() {
    return _getRenderView(
            reference.pointer, _id_getRenderView as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r'onTouchEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _onTouchEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean onTouchEvent(android.view.MotionEvent motionEvent)`
  bool onTouchEvent(
    jni$_.JObject? motionEvent,
  ) {
    final _$motionEvent = motionEvent?.reference ?? jni$_.jNullReference;
    return _onTouchEvent(reference.pointer,
            _id_onTouchEvent as jni$_.JMethodIDPtr, _$motionEvent.pointer)
        .boolean;
  }

  static final _id_onKeyDown = _class.instanceMethodId(
    r'onKeyDown',
    r'(ILandroid/view/KeyEvent;)Z',
  );

  static final _onKeyDown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean onKeyDown(int i, android.view.KeyEvent keyEvent)`
  bool onKeyDown(
    int i,
    jni$_.JObject keyEvent,
  ) {
    final _$keyEvent = keyEvent.reference;
    return _onKeyDown(reference.pointer, _id_onKeyDown as jni$_.JMethodIDPtr, i,
            _$keyEvent.pointer)
        .boolean;
  }

  static final _id_onKeyLongPress = _class.instanceMethodId(
    r'onKeyLongPress',
    r'(ILandroid/view/KeyEvent;)Z',
  );

  static final _onKeyLongPress = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean onKeyLongPress(int i, android.view.KeyEvent keyEvent)`
  bool onKeyLongPress(
    int i,
    jni$_.JObject? keyEvent,
  ) {
    final _$keyEvent = keyEvent?.reference ?? jni$_.jNullReference;
    return _onKeyLongPress(reference.pointer,
            _id_onKeyLongPress as jni$_.JMethodIDPtr, i, _$keyEvent.pointer)
        .boolean;
  }

  static final _id_onKeyUp = _class.instanceMethodId(
    r'onKeyUp',
    r'(ILandroid/view/KeyEvent;)Z',
  );

  static final _onKeyUp = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean onKeyUp(int i, android.view.KeyEvent keyEvent)`
  bool onKeyUp(
    int i,
    jni$_.JObject keyEvent,
  ) {
    final _$keyEvent = keyEvent.reference;
    return _onKeyUp(reference.pointer, _id_onKeyUp as jni$_.JMethodIDPtr, i,
            _$keyEvent.pointer)
        .boolean;
  }

  static final _id_onTrackballEvent = _class.instanceMethodId(
    r'onTrackballEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _onTrackballEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean onTrackballEvent(android.view.MotionEvent motionEvent)`
  bool onTrackballEvent(
    jni$_.JObject motionEvent,
  ) {
    final _$motionEvent = motionEvent.reference;
    return _onTrackballEvent(reference.pointer,
            _id_onTrackballEvent as jni$_.JMethodIDPtr, _$motionEvent.pointer)
        .boolean;
  }

  static final _id_onGenericMotionEvent = _class.instanceMethodId(
    r'onGenericMotionEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _onGenericMotionEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean onGenericMotionEvent(android.view.MotionEvent motionEvent)`
  bool onGenericMotionEvent(
    jni$_.JObject motionEvent,
  ) {
    final _$motionEvent = motionEvent.reference;
    return _onGenericMotionEvent(
            reference.pointer,
            _id_onGenericMotionEvent as jni$_.JMethodIDPtr,
            _$motionEvent.pointer)
        .boolean;
  }

  static final _id_onLowMemory = _class.instanceMethodId(
    r'onLowMemory',
    r'()V',
  );

  static final _onLowMemory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onLowMemory()`
  void onLowMemory() {
    _onLowMemory(reference.pointer, _id_onLowMemory as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getPixelRatio = _class.instanceMethodId(
    r'getPixelRatio',
    r'()F',
  );

  static final _getPixelRatio = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public float getPixelRatio()`
  double getPixelRatio() {
    return _getPixelRatio(
            reference.pointer, _id_getPixelRatio as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_getViewContent = _class.instanceMethodId(
    r'getViewContent',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _getViewContent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap getViewContent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getViewContent() {
    return _getViewContent(
            reference.pointer, _id_getViewContent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_addOnCameraWillChangeListener = _class.instanceMethodId(
    r'addOnCameraWillChangeListener',
    r'(Lorg/maplibre/android/maps/MapView$OnCameraWillChangeListener;)V',
  );

  static final _addOnCameraWillChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnCameraWillChangeListener(org.maplibre.android.maps.MapView$OnCameraWillChangeListener onCameraWillChangeListener)`
  void addOnCameraWillChangeListener(
    MapView$OnCameraWillChangeListener onCameraWillChangeListener,
  ) {
    final _$onCameraWillChangeListener = onCameraWillChangeListener.reference;
    _addOnCameraWillChangeListener(
            reference.pointer,
            _id_addOnCameraWillChangeListener as jni$_.JMethodIDPtr,
            _$onCameraWillChangeListener.pointer)
        .check();
  }

  static final _id_removeOnCameraWillChangeListener = _class.instanceMethodId(
    r'removeOnCameraWillChangeListener',
    r'(Lorg/maplibre/android/maps/MapView$OnCameraWillChangeListener;)V',
  );

  static final _removeOnCameraWillChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnCameraWillChangeListener(org.maplibre.android.maps.MapView$OnCameraWillChangeListener onCameraWillChangeListener)`
  void removeOnCameraWillChangeListener(
    MapView$OnCameraWillChangeListener onCameraWillChangeListener,
  ) {
    final _$onCameraWillChangeListener = onCameraWillChangeListener.reference;
    _removeOnCameraWillChangeListener(
            reference.pointer,
            _id_removeOnCameraWillChangeListener as jni$_.JMethodIDPtr,
            _$onCameraWillChangeListener.pointer)
        .check();
  }

  static final _id_addOnCameraIsChangingListener = _class.instanceMethodId(
    r'addOnCameraIsChangingListener',
    r'(Lorg/maplibre/android/maps/MapView$OnCameraIsChangingListener;)V',
  );

  static final _addOnCameraIsChangingListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnCameraIsChangingListener(org.maplibre.android.maps.MapView$OnCameraIsChangingListener onCameraIsChangingListener)`
  void addOnCameraIsChangingListener(
    MapView$OnCameraIsChangingListener onCameraIsChangingListener,
  ) {
    final _$onCameraIsChangingListener = onCameraIsChangingListener.reference;
    _addOnCameraIsChangingListener(
            reference.pointer,
            _id_addOnCameraIsChangingListener as jni$_.JMethodIDPtr,
            _$onCameraIsChangingListener.pointer)
        .check();
  }

  static final _id_removeOnCameraIsChangingListener = _class.instanceMethodId(
    r'removeOnCameraIsChangingListener',
    r'(Lorg/maplibre/android/maps/MapView$OnCameraIsChangingListener;)V',
  );

  static final _removeOnCameraIsChangingListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnCameraIsChangingListener(org.maplibre.android.maps.MapView$OnCameraIsChangingListener onCameraIsChangingListener)`
  void removeOnCameraIsChangingListener(
    MapView$OnCameraIsChangingListener onCameraIsChangingListener,
  ) {
    final _$onCameraIsChangingListener = onCameraIsChangingListener.reference;
    _removeOnCameraIsChangingListener(
            reference.pointer,
            _id_removeOnCameraIsChangingListener as jni$_.JMethodIDPtr,
            _$onCameraIsChangingListener.pointer)
        .check();
  }

  static final _id_addOnCameraDidChangeListener = _class.instanceMethodId(
    r'addOnCameraDidChangeListener',
    r'(Lorg/maplibre/android/maps/MapView$OnCameraDidChangeListener;)V',
  );

  static final _addOnCameraDidChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnCameraDidChangeListener(org.maplibre.android.maps.MapView$OnCameraDidChangeListener onCameraDidChangeListener)`
  void addOnCameraDidChangeListener(
    MapView$OnCameraDidChangeListener onCameraDidChangeListener,
  ) {
    final _$onCameraDidChangeListener = onCameraDidChangeListener.reference;
    _addOnCameraDidChangeListener(
            reference.pointer,
            _id_addOnCameraDidChangeListener as jni$_.JMethodIDPtr,
            _$onCameraDidChangeListener.pointer)
        .check();
  }

  static final _id_removeOnCameraDidChangeListener = _class.instanceMethodId(
    r'removeOnCameraDidChangeListener',
    r'(Lorg/maplibre/android/maps/MapView$OnCameraDidChangeListener;)V',
  );

  static final _removeOnCameraDidChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnCameraDidChangeListener(org.maplibre.android.maps.MapView$OnCameraDidChangeListener onCameraDidChangeListener)`
  void removeOnCameraDidChangeListener(
    MapView$OnCameraDidChangeListener onCameraDidChangeListener,
  ) {
    final _$onCameraDidChangeListener = onCameraDidChangeListener.reference;
    _removeOnCameraDidChangeListener(
            reference.pointer,
            _id_removeOnCameraDidChangeListener as jni$_.JMethodIDPtr,
            _$onCameraDidChangeListener.pointer)
        .check();
  }

  static final _id_addOnWillStartLoadingMapListener = _class.instanceMethodId(
    r'addOnWillStartLoadingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnWillStartLoadingMapListener;)V',
  );

  static final _addOnWillStartLoadingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnWillStartLoadingMapListener(org.maplibre.android.maps.MapView$OnWillStartLoadingMapListener onWillStartLoadingMapListener)`
  void addOnWillStartLoadingMapListener(
    MapView$OnWillStartLoadingMapListener onWillStartLoadingMapListener,
  ) {
    final _$onWillStartLoadingMapListener =
        onWillStartLoadingMapListener.reference;
    _addOnWillStartLoadingMapListener(
            reference.pointer,
            _id_addOnWillStartLoadingMapListener as jni$_.JMethodIDPtr,
            _$onWillStartLoadingMapListener.pointer)
        .check();
  }

  static final _id_removeOnWillStartLoadingMapListener =
      _class.instanceMethodId(
    r'removeOnWillStartLoadingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnWillStartLoadingMapListener;)V',
  );

  static final _removeOnWillStartLoadingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnWillStartLoadingMapListener(org.maplibre.android.maps.MapView$OnWillStartLoadingMapListener onWillStartLoadingMapListener)`
  void removeOnWillStartLoadingMapListener(
    MapView$OnWillStartLoadingMapListener onWillStartLoadingMapListener,
  ) {
    final _$onWillStartLoadingMapListener =
        onWillStartLoadingMapListener.reference;
    _removeOnWillStartLoadingMapListener(
            reference.pointer,
            _id_removeOnWillStartLoadingMapListener as jni$_.JMethodIDPtr,
            _$onWillStartLoadingMapListener.pointer)
        .check();
  }

  static final _id_addOnDidFinishLoadingMapListener = _class.instanceMethodId(
    r'addOnDidFinishLoadingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFinishLoadingMapListener;)V',
  );

  static final _addOnDidFinishLoadingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnDidFinishLoadingMapListener(org.maplibre.android.maps.MapView$OnDidFinishLoadingMapListener onDidFinishLoadingMapListener)`
  void addOnDidFinishLoadingMapListener(
    MapView$OnDidFinishLoadingMapListener onDidFinishLoadingMapListener,
  ) {
    final _$onDidFinishLoadingMapListener =
        onDidFinishLoadingMapListener.reference;
    _addOnDidFinishLoadingMapListener(
            reference.pointer,
            _id_addOnDidFinishLoadingMapListener as jni$_.JMethodIDPtr,
            _$onDidFinishLoadingMapListener.pointer)
        .check();
  }

  static final _id_removeOnDidFinishLoadingMapListener =
      _class.instanceMethodId(
    r'removeOnDidFinishLoadingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFinishLoadingMapListener;)V',
  );

  static final _removeOnDidFinishLoadingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnDidFinishLoadingMapListener(org.maplibre.android.maps.MapView$OnDidFinishLoadingMapListener onDidFinishLoadingMapListener)`
  void removeOnDidFinishLoadingMapListener(
    MapView$OnDidFinishLoadingMapListener onDidFinishLoadingMapListener,
  ) {
    final _$onDidFinishLoadingMapListener =
        onDidFinishLoadingMapListener.reference;
    _removeOnDidFinishLoadingMapListener(
            reference.pointer,
            _id_removeOnDidFinishLoadingMapListener as jni$_.JMethodIDPtr,
            _$onDidFinishLoadingMapListener.pointer)
        .check();
  }

  static final _id_addOnDidFailLoadingMapListener = _class.instanceMethodId(
    r'addOnDidFailLoadingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFailLoadingMapListener;)V',
  );

  static final _addOnDidFailLoadingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnDidFailLoadingMapListener(org.maplibre.android.maps.MapView$OnDidFailLoadingMapListener onDidFailLoadingMapListener)`
  void addOnDidFailLoadingMapListener(
    MapView$OnDidFailLoadingMapListener onDidFailLoadingMapListener,
  ) {
    final _$onDidFailLoadingMapListener = onDidFailLoadingMapListener.reference;
    _addOnDidFailLoadingMapListener(
            reference.pointer,
            _id_addOnDidFailLoadingMapListener as jni$_.JMethodIDPtr,
            _$onDidFailLoadingMapListener.pointer)
        .check();
  }

  static final _id_removeOnDidFailLoadingMapListener = _class.instanceMethodId(
    r'removeOnDidFailLoadingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFailLoadingMapListener;)V',
  );

  static final _removeOnDidFailLoadingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnDidFailLoadingMapListener(org.maplibre.android.maps.MapView$OnDidFailLoadingMapListener onDidFailLoadingMapListener)`
  void removeOnDidFailLoadingMapListener(
    MapView$OnDidFailLoadingMapListener onDidFailLoadingMapListener,
  ) {
    final _$onDidFailLoadingMapListener = onDidFailLoadingMapListener.reference;
    _removeOnDidFailLoadingMapListener(
            reference.pointer,
            _id_removeOnDidFailLoadingMapListener as jni$_.JMethodIDPtr,
            _$onDidFailLoadingMapListener.pointer)
        .check();
  }

  static final _id_addOnWillStartRenderingFrameListener =
      _class.instanceMethodId(
    r'addOnWillStartRenderingFrameListener',
    r'(Lorg/maplibre/android/maps/MapView$OnWillStartRenderingFrameListener;)V',
  );

  static final _addOnWillStartRenderingFrameListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnWillStartRenderingFrameListener(org.maplibre.android.maps.MapView$OnWillStartRenderingFrameListener onWillStartRenderingFrameListener)`
  void addOnWillStartRenderingFrameListener(
    MapView$OnWillStartRenderingFrameListener onWillStartRenderingFrameListener,
  ) {
    final _$onWillStartRenderingFrameListener =
        onWillStartRenderingFrameListener.reference;
    _addOnWillStartRenderingFrameListener(
            reference.pointer,
            _id_addOnWillStartRenderingFrameListener as jni$_.JMethodIDPtr,
            _$onWillStartRenderingFrameListener.pointer)
        .check();
  }

  static final _id_removeOnWillStartRenderingFrameListener =
      _class.instanceMethodId(
    r'removeOnWillStartRenderingFrameListener',
    r'(Lorg/maplibre/android/maps/MapView$OnWillStartRenderingFrameListener;)V',
  );

  static final _removeOnWillStartRenderingFrameListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnWillStartRenderingFrameListener(org.maplibre.android.maps.MapView$OnWillStartRenderingFrameListener onWillStartRenderingFrameListener)`
  void removeOnWillStartRenderingFrameListener(
    MapView$OnWillStartRenderingFrameListener onWillStartRenderingFrameListener,
  ) {
    final _$onWillStartRenderingFrameListener =
        onWillStartRenderingFrameListener.reference;
    _removeOnWillStartRenderingFrameListener(
            reference.pointer,
            _id_removeOnWillStartRenderingFrameListener as jni$_.JMethodIDPtr,
            _$onWillStartRenderingFrameListener.pointer)
        .check();
  }

  static final _id_addOnDidFinishRenderingFrameListener =
      _class.instanceMethodId(
    r'addOnDidFinishRenderingFrameListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFinishRenderingFrameListener;)V',
  );

  static final _addOnDidFinishRenderingFrameListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnDidFinishRenderingFrameListener(org.maplibre.android.maps.MapView$OnDidFinishRenderingFrameListener onDidFinishRenderingFrameListener)`
  void addOnDidFinishRenderingFrameListener(
    MapView$OnDidFinishRenderingFrameListener onDidFinishRenderingFrameListener,
  ) {
    final _$onDidFinishRenderingFrameListener =
        onDidFinishRenderingFrameListener.reference;
    _addOnDidFinishRenderingFrameListener(
            reference.pointer,
            _id_addOnDidFinishRenderingFrameListener as jni$_.JMethodIDPtr,
            _$onDidFinishRenderingFrameListener.pointer)
        .check();
  }

  static final _id_removeOnDidFinishRenderingFrameListener =
      _class.instanceMethodId(
    r'removeOnDidFinishRenderingFrameListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFinishRenderingFrameListener;)V',
  );

  static final _removeOnDidFinishRenderingFrameListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnDidFinishRenderingFrameListener(org.maplibre.android.maps.MapView$OnDidFinishRenderingFrameListener onDidFinishRenderingFrameListener)`
  void removeOnDidFinishRenderingFrameListener(
    MapView$OnDidFinishRenderingFrameListener onDidFinishRenderingFrameListener,
  ) {
    final _$onDidFinishRenderingFrameListener =
        onDidFinishRenderingFrameListener.reference;
    _removeOnDidFinishRenderingFrameListener(
            reference.pointer,
            _id_removeOnDidFinishRenderingFrameListener as jni$_.JMethodIDPtr,
            _$onDidFinishRenderingFrameListener.pointer)
        .check();
  }

  static final _id_addOnWillStartRenderingMapListener = _class.instanceMethodId(
    r'addOnWillStartRenderingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnWillStartRenderingMapListener;)V',
  );

  static final _addOnWillStartRenderingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnWillStartRenderingMapListener(org.maplibre.android.maps.MapView$OnWillStartRenderingMapListener onWillStartRenderingMapListener)`
  void addOnWillStartRenderingMapListener(
    MapView$OnWillStartRenderingMapListener onWillStartRenderingMapListener,
  ) {
    final _$onWillStartRenderingMapListener =
        onWillStartRenderingMapListener.reference;
    _addOnWillStartRenderingMapListener(
            reference.pointer,
            _id_addOnWillStartRenderingMapListener as jni$_.JMethodIDPtr,
            _$onWillStartRenderingMapListener.pointer)
        .check();
  }

  static final _id_removeOnWillStartRenderingMapListener =
      _class.instanceMethodId(
    r'removeOnWillStartRenderingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnWillStartRenderingMapListener;)V',
  );

  static final _removeOnWillStartRenderingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnWillStartRenderingMapListener(org.maplibre.android.maps.MapView$OnWillStartRenderingMapListener onWillStartRenderingMapListener)`
  void removeOnWillStartRenderingMapListener(
    MapView$OnWillStartRenderingMapListener onWillStartRenderingMapListener,
  ) {
    final _$onWillStartRenderingMapListener =
        onWillStartRenderingMapListener.reference;
    _removeOnWillStartRenderingMapListener(
            reference.pointer,
            _id_removeOnWillStartRenderingMapListener as jni$_.JMethodIDPtr,
            _$onWillStartRenderingMapListener.pointer)
        .check();
  }

  static final _id_addOnDidFinishRenderingMapListener = _class.instanceMethodId(
    r'addOnDidFinishRenderingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFinishRenderingMapListener;)V',
  );

  static final _addOnDidFinishRenderingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnDidFinishRenderingMapListener(org.maplibre.android.maps.MapView$OnDidFinishRenderingMapListener onDidFinishRenderingMapListener)`
  void addOnDidFinishRenderingMapListener(
    MapView$OnDidFinishRenderingMapListener onDidFinishRenderingMapListener,
  ) {
    final _$onDidFinishRenderingMapListener =
        onDidFinishRenderingMapListener.reference;
    _addOnDidFinishRenderingMapListener(
            reference.pointer,
            _id_addOnDidFinishRenderingMapListener as jni$_.JMethodIDPtr,
            _$onDidFinishRenderingMapListener.pointer)
        .check();
  }

  static final _id_removeOnDidFinishRenderingMapListener =
      _class.instanceMethodId(
    r'removeOnDidFinishRenderingMapListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFinishRenderingMapListener;)V',
  );

  static final _removeOnDidFinishRenderingMapListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnDidFinishRenderingMapListener(org.maplibre.android.maps.MapView$OnDidFinishRenderingMapListener onDidFinishRenderingMapListener)`
  void removeOnDidFinishRenderingMapListener(
    MapView$OnDidFinishRenderingMapListener? onDidFinishRenderingMapListener,
  ) {
    final _$onDidFinishRenderingMapListener =
        onDidFinishRenderingMapListener?.reference ?? jni$_.jNullReference;
    _removeOnDidFinishRenderingMapListener(
            reference.pointer,
            _id_removeOnDidFinishRenderingMapListener as jni$_.JMethodIDPtr,
            _$onDidFinishRenderingMapListener.pointer)
        .check();
  }

  static final _id_addOnDidBecomeIdleListener = _class.instanceMethodId(
    r'addOnDidBecomeIdleListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidBecomeIdleListener;)V',
  );

  static final _addOnDidBecomeIdleListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnDidBecomeIdleListener(org.maplibre.android.maps.MapView$OnDidBecomeIdleListener onDidBecomeIdleListener)`
  void addOnDidBecomeIdleListener(
    MapView$OnDidBecomeIdleListener onDidBecomeIdleListener,
  ) {
    final _$onDidBecomeIdleListener = onDidBecomeIdleListener.reference;
    _addOnDidBecomeIdleListener(
            reference.pointer,
            _id_addOnDidBecomeIdleListener as jni$_.JMethodIDPtr,
            _$onDidBecomeIdleListener.pointer)
        .check();
  }

  static final _id_removeOnDidBecomeIdleListener = _class.instanceMethodId(
    r'removeOnDidBecomeIdleListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidBecomeIdleListener;)V',
  );

  static final _removeOnDidBecomeIdleListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnDidBecomeIdleListener(org.maplibre.android.maps.MapView$OnDidBecomeIdleListener onDidBecomeIdleListener)`
  void removeOnDidBecomeIdleListener(
    MapView$OnDidBecomeIdleListener onDidBecomeIdleListener,
  ) {
    final _$onDidBecomeIdleListener = onDidBecomeIdleListener.reference;
    _removeOnDidBecomeIdleListener(
            reference.pointer,
            _id_removeOnDidBecomeIdleListener as jni$_.JMethodIDPtr,
            _$onDidBecomeIdleListener.pointer)
        .check();
  }

  static final _id_addOnDidFinishLoadingStyleListener = _class.instanceMethodId(
    r'addOnDidFinishLoadingStyleListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFinishLoadingStyleListener;)V',
  );

  static final _addOnDidFinishLoadingStyleListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnDidFinishLoadingStyleListener(org.maplibre.android.maps.MapView$OnDidFinishLoadingStyleListener onDidFinishLoadingStyleListener)`
  void addOnDidFinishLoadingStyleListener(
    MapView$OnDidFinishLoadingStyleListener onDidFinishLoadingStyleListener,
  ) {
    final _$onDidFinishLoadingStyleListener =
        onDidFinishLoadingStyleListener.reference;
    _addOnDidFinishLoadingStyleListener(
            reference.pointer,
            _id_addOnDidFinishLoadingStyleListener as jni$_.JMethodIDPtr,
            _$onDidFinishLoadingStyleListener.pointer)
        .check();
  }

  static final _id_removeOnDidFinishLoadingStyleListener =
      _class.instanceMethodId(
    r'removeOnDidFinishLoadingStyleListener',
    r'(Lorg/maplibre/android/maps/MapView$OnDidFinishLoadingStyleListener;)V',
  );

  static final _removeOnDidFinishLoadingStyleListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnDidFinishLoadingStyleListener(org.maplibre.android.maps.MapView$OnDidFinishLoadingStyleListener onDidFinishLoadingStyleListener)`
  void removeOnDidFinishLoadingStyleListener(
    MapView$OnDidFinishLoadingStyleListener onDidFinishLoadingStyleListener,
  ) {
    final _$onDidFinishLoadingStyleListener =
        onDidFinishLoadingStyleListener.reference;
    _removeOnDidFinishLoadingStyleListener(
            reference.pointer,
            _id_removeOnDidFinishLoadingStyleListener as jni$_.JMethodIDPtr,
            _$onDidFinishLoadingStyleListener.pointer)
        .check();
  }

  static final _id_addOnSourceChangedListener = _class.instanceMethodId(
    r'addOnSourceChangedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnSourceChangedListener;)V',
  );

  static final _addOnSourceChangedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnSourceChangedListener(org.maplibre.android.maps.MapView$OnSourceChangedListener onSourceChangedListener)`
  void addOnSourceChangedListener(
    MapView$OnSourceChangedListener onSourceChangedListener,
  ) {
    final _$onSourceChangedListener = onSourceChangedListener.reference;
    _addOnSourceChangedListener(
            reference.pointer,
            _id_addOnSourceChangedListener as jni$_.JMethodIDPtr,
            _$onSourceChangedListener.pointer)
        .check();
  }

  static final _id_removeOnSourceChangedListener = _class.instanceMethodId(
    r'removeOnSourceChangedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnSourceChangedListener;)V',
  );

  static final _removeOnSourceChangedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnSourceChangedListener(org.maplibre.android.maps.MapView$OnSourceChangedListener onSourceChangedListener)`
  void removeOnSourceChangedListener(
    MapView$OnSourceChangedListener onSourceChangedListener,
  ) {
    final _$onSourceChangedListener = onSourceChangedListener.reference;
    _removeOnSourceChangedListener(
            reference.pointer,
            _id_removeOnSourceChangedListener as jni$_.JMethodIDPtr,
            _$onSourceChangedListener.pointer)
        .check();
  }

  static final _id_addOnStyleImageMissingListener = _class.instanceMethodId(
    r'addOnStyleImageMissingListener',
    r'(Lorg/maplibre/android/maps/MapView$OnStyleImageMissingListener;)V',
  );

  static final _addOnStyleImageMissingListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnStyleImageMissingListener(org.maplibre.android.maps.MapView$OnStyleImageMissingListener onStyleImageMissingListener)`
  void addOnStyleImageMissingListener(
    MapView$OnStyleImageMissingListener onStyleImageMissingListener,
  ) {
    final _$onStyleImageMissingListener = onStyleImageMissingListener.reference;
    _addOnStyleImageMissingListener(
            reference.pointer,
            _id_addOnStyleImageMissingListener as jni$_.JMethodIDPtr,
            _$onStyleImageMissingListener.pointer)
        .check();
  }

  static final _id_removeOnStyleImageMissingListener = _class.instanceMethodId(
    r'removeOnStyleImageMissingListener',
    r'(Lorg/maplibre/android/maps/MapView$OnStyleImageMissingListener;)V',
  );

  static final _removeOnStyleImageMissingListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnStyleImageMissingListener(org.maplibre.android.maps.MapView$OnStyleImageMissingListener onStyleImageMissingListener)`
  void removeOnStyleImageMissingListener(
    MapView$OnStyleImageMissingListener onStyleImageMissingListener,
  ) {
    final _$onStyleImageMissingListener = onStyleImageMissingListener.reference;
    _removeOnStyleImageMissingListener(
            reference.pointer,
            _id_removeOnStyleImageMissingListener as jni$_.JMethodIDPtr,
            _$onStyleImageMissingListener.pointer)
        .check();
  }

  static final _id_addOnCanRemoveUnusedStyleImageListener =
      _class.instanceMethodId(
    r'addOnCanRemoveUnusedStyleImageListener',
    r'(Lorg/maplibre/android/maps/MapView$OnCanRemoveUnusedStyleImageListener;)V',
  );

  static final _addOnCanRemoveUnusedStyleImageListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnCanRemoveUnusedStyleImageListener(org.maplibre.android.maps.MapView$OnCanRemoveUnusedStyleImageListener onCanRemoveUnusedStyleImageListener)`
  void addOnCanRemoveUnusedStyleImageListener(
    MapView$OnCanRemoveUnusedStyleImageListener
        onCanRemoveUnusedStyleImageListener,
  ) {
    final _$onCanRemoveUnusedStyleImageListener =
        onCanRemoveUnusedStyleImageListener.reference;
    _addOnCanRemoveUnusedStyleImageListener(
            reference.pointer,
            _id_addOnCanRemoveUnusedStyleImageListener as jni$_.JMethodIDPtr,
            _$onCanRemoveUnusedStyleImageListener.pointer)
        .check();
  }

  static final _id_removeOnCanRemoveUnusedStyleImageListener =
      _class.instanceMethodId(
    r'removeOnCanRemoveUnusedStyleImageListener',
    r'(Lorg/maplibre/android/maps/MapView$OnCanRemoveUnusedStyleImageListener;)V',
  );

  static final _removeOnCanRemoveUnusedStyleImageListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnCanRemoveUnusedStyleImageListener(org.maplibre.android.maps.MapView$OnCanRemoveUnusedStyleImageListener onCanRemoveUnusedStyleImageListener)`
  void removeOnCanRemoveUnusedStyleImageListener(
    MapView$OnCanRemoveUnusedStyleImageListener
        onCanRemoveUnusedStyleImageListener,
  ) {
    final _$onCanRemoveUnusedStyleImageListener =
        onCanRemoveUnusedStyleImageListener.reference;
    _removeOnCanRemoveUnusedStyleImageListener(
            reference.pointer,
            _id_removeOnCanRemoveUnusedStyleImageListener as jni$_.JMethodIDPtr,
            _$onCanRemoveUnusedStyleImageListener.pointer)
        .check();
  }

  static final _id_addOnPreCompileShaderListener = _class.instanceMethodId(
    r'addOnPreCompileShaderListener',
    r'(Lorg/maplibre/android/maps/MapView$OnPreCompileShaderListener;)V',
  );

  static final _addOnPreCompileShaderListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnPreCompileShaderListener(org.maplibre.android.maps.MapView$OnPreCompileShaderListener onPreCompileShaderListener)`
  void addOnPreCompileShaderListener(
    MapView$OnPreCompileShaderListener? onPreCompileShaderListener,
  ) {
    final _$onPreCompileShaderListener =
        onPreCompileShaderListener?.reference ?? jni$_.jNullReference;
    _addOnPreCompileShaderListener(
            reference.pointer,
            _id_addOnPreCompileShaderListener as jni$_.JMethodIDPtr,
            _$onPreCompileShaderListener.pointer)
        .check();
  }

  static final _id_removeOnPreCompileShaderListener = _class.instanceMethodId(
    r'removeOnPreCompileShaderListener',
    r'(Lorg/maplibre/android/maps/MapView$OnPreCompileShaderListener;)V',
  );

  static final _removeOnPreCompileShaderListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnPreCompileShaderListener(org.maplibre.android.maps.MapView$OnPreCompileShaderListener onPreCompileShaderListener)`
  void removeOnPreCompileShaderListener(
    MapView$OnPreCompileShaderListener? onPreCompileShaderListener,
  ) {
    final _$onPreCompileShaderListener =
        onPreCompileShaderListener?.reference ?? jni$_.jNullReference;
    _removeOnPreCompileShaderListener(
            reference.pointer,
            _id_removeOnPreCompileShaderListener as jni$_.JMethodIDPtr,
            _$onPreCompileShaderListener.pointer)
        .check();
  }

  static final _id_addOnPostCompileShaderListener = _class.instanceMethodId(
    r'addOnPostCompileShaderListener',
    r'(Lorg/maplibre/android/maps/MapView$OnPostCompileShaderListener;)V',
  );

  static final _addOnPostCompileShaderListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnPostCompileShaderListener(org.maplibre.android.maps.MapView$OnPostCompileShaderListener onPostCompileShaderListener)`
  void addOnPostCompileShaderListener(
    MapView$OnPostCompileShaderListener? onPostCompileShaderListener,
  ) {
    final _$onPostCompileShaderListener =
        onPostCompileShaderListener?.reference ?? jni$_.jNullReference;
    _addOnPostCompileShaderListener(
            reference.pointer,
            _id_addOnPostCompileShaderListener as jni$_.JMethodIDPtr,
            _$onPostCompileShaderListener.pointer)
        .check();
  }

  static final _id_removeOnPostCompileShaderListener = _class.instanceMethodId(
    r'removeOnPostCompileShaderListener',
    r'(Lorg/maplibre/android/maps/MapView$OnPostCompileShaderListener;)V',
  );

  static final _removeOnPostCompileShaderListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnPostCompileShaderListener(org.maplibre.android.maps.MapView$OnPostCompileShaderListener onPostCompileShaderListener)`
  void removeOnPostCompileShaderListener(
    MapView$OnPostCompileShaderListener? onPostCompileShaderListener,
  ) {
    final _$onPostCompileShaderListener =
        onPostCompileShaderListener?.reference ?? jni$_.jNullReference;
    _removeOnPostCompileShaderListener(
            reference.pointer,
            _id_removeOnPostCompileShaderListener as jni$_.JMethodIDPtr,
            _$onPostCompileShaderListener.pointer)
        .check();
  }

  static final _id_addOnShaderCompileFailedListener = _class.instanceMethodId(
    r'addOnShaderCompileFailedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnShaderCompileFailedListener;)V',
  );

  static final _addOnShaderCompileFailedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnShaderCompileFailedListener(org.maplibre.android.maps.MapView$OnShaderCompileFailedListener onShaderCompileFailedListener)`
  void addOnShaderCompileFailedListener(
    MapView$OnShaderCompileFailedListener? onShaderCompileFailedListener,
  ) {
    final _$onShaderCompileFailedListener =
        onShaderCompileFailedListener?.reference ?? jni$_.jNullReference;
    _addOnShaderCompileFailedListener(
            reference.pointer,
            _id_addOnShaderCompileFailedListener as jni$_.JMethodIDPtr,
            _$onShaderCompileFailedListener.pointer)
        .check();
  }

  static final _id_removeOnShaderCompileFailedListener =
      _class.instanceMethodId(
    r'removeOnShaderCompileFailedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnShaderCompileFailedListener;)V',
  );

  static final _removeOnShaderCompileFailedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnShaderCompileFailedListener(org.maplibre.android.maps.MapView$OnShaderCompileFailedListener onShaderCompileFailedListener)`
  void removeOnShaderCompileFailedListener(
    MapView$OnShaderCompileFailedListener? onShaderCompileFailedListener,
  ) {
    final _$onShaderCompileFailedListener =
        onShaderCompileFailedListener?.reference ?? jni$_.jNullReference;
    _removeOnShaderCompileFailedListener(
            reference.pointer,
            _id_removeOnShaderCompileFailedListener as jni$_.JMethodIDPtr,
            _$onShaderCompileFailedListener.pointer)
        .check();
  }

  static final _id_addOnGlyphsLoadedListener = _class.instanceMethodId(
    r'addOnGlyphsLoadedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnGlyphsLoadedListener;)V',
  );

  static final _addOnGlyphsLoadedListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnGlyphsLoadedListener(org.maplibre.android.maps.MapView$OnGlyphsLoadedListener onGlyphsLoadedListener)`
  void addOnGlyphsLoadedListener(
    MapView$OnGlyphsLoadedListener? onGlyphsLoadedListener,
  ) {
    final _$onGlyphsLoadedListener =
        onGlyphsLoadedListener?.reference ?? jni$_.jNullReference;
    _addOnGlyphsLoadedListener(
            reference.pointer,
            _id_addOnGlyphsLoadedListener as jni$_.JMethodIDPtr,
            _$onGlyphsLoadedListener.pointer)
        .check();
  }

  static final _id_removeOnGlyphsLoadedListener = _class.instanceMethodId(
    r'removeOnGlyphsLoadedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnGlyphsLoadedListener;)V',
  );

  static final _removeOnGlyphsLoadedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnGlyphsLoadedListener(org.maplibre.android.maps.MapView$OnGlyphsLoadedListener onGlyphsLoadedListener)`
  void removeOnGlyphsLoadedListener(
    MapView$OnGlyphsLoadedListener? onGlyphsLoadedListener,
  ) {
    final _$onGlyphsLoadedListener =
        onGlyphsLoadedListener?.reference ?? jni$_.jNullReference;
    _removeOnGlyphsLoadedListener(
            reference.pointer,
            _id_removeOnGlyphsLoadedListener as jni$_.JMethodIDPtr,
            _$onGlyphsLoadedListener.pointer)
        .check();
  }

  static final _id_addOnGlyphsErrorListener = _class.instanceMethodId(
    r'addOnGlyphsErrorListener',
    r'(Lorg/maplibre/android/maps/MapView$OnGlyphsErrorListener;)V',
  );

  static final _addOnGlyphsErrorListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnGlyphsErrorListener(org.maplibre.android.maps.MapView$OnGlyphsErrorListener onGlyphsErrorListener)`
  void addOnGlyphsErrorListener(
    MapView$OnGlyphsErrorListener? onGlyphsErrorListener,
  ) {
    final _$onGlyphsErrorListener =
        onGlyphsErrorListener?.reference ?? jni$_.jNullReference;
    _addOnGlyphsErrorListener(
            reference.pointer,
            _id_addOnGlyphsErrorListener as jni$_.JMethodIDPtr,
            _$onGlyphsErrorListener.pointer)
        .check();
  }

  static final _id_removeOnGlyphsErrorListener = _class.instanceMethodId(
    r'removeOnGlyphsErrorListener',
    r'(Lorg/maplibre/android/maps/MapView$OnGlyphsErrorListener;)V',
  );

  static final _removeOnGlyphsErrorListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnGlyphsErrorListener(org.maplibre.android.maps.MapView$OnGlyphsErrorListener onGlyphsErrorListener)`
  void removeOnGlyphsErrorListener(
    MapView$OnGlyphsErrorListener? onGlyphsErrorListener,
  ) {
    final _$onGlyphsErrorListener =
        onGlyphsErrorListener?.reference ?? jni$_.jNullReference;
    _removeOnGlyphsErrorListener(
            reference.pointer,
            _id_removeOnGlyphsErrorListener as jni$_.JMethodIDPtr,
            _$onGlyphsErrorListener.pointer)
        .check();
  }

  static final _id_addOnGlyphsRequestedListener = _class.instanceMethodId(
    r'addOnGlyphsRequestedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnGlyphsRequestedListener;)V',
  );

  static final _addOnGlyphsRequestedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnGlyphsRequestedListener(org.maplibre.android.maps.MapView$OnGlyphsRequestedListener onGlyphsRequestedListener)`
  void addOnGlyphsRequestedListener(
    MapView$OnGlyphsRequestedListener? onGlyphsRequestedListener,
  ) {
    final _$onGlyphsRequestedListener =
        onGlyphsRequestedListener?.reference ?? jni$_.jNullReference;
    _addOnGlyphsRequestedListener(
            reference.pointer,
            _id_addOnGlyphsRequestedListener as jni$_.JMethodIDPtr,
            _$onGlyphsRequestedListener.pointer)
        .check();
  }

  static final _id_removeOnGlyphsRequestedListener = _class.instanceMethodId(
    r'removeOnGlyphsRequestedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnGlyphsRequestedListener;)V',
  );

  static final _removeOnGlyphsRequestedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnGlyphsRequestedListener(org.maplibre.android.maps.MapView$OnGlyphsRequestedListener onGlyphsRequestedListener)`
  void removeOnGlyphsRequestedListener(
    MapView$OnGlyphsRequestedListener? onGlyphsRequestedListener,
  ) {
    final _$onGlyphsRequestedListener =
        onGlyphsRequestedListener?.reference ?? jni$_.jNullReference;
    _removeOnGlyphsRequestedListener(
            reference.pointer,
            _id_removeOnGlyphsRequestedListener as jni$_.JMethodIDPtr,
            _$onGlyphsRequestedListener.pointer)
        .check();
  }

  static final _id_addOnTileActionListener = _class.instanceMethodId(
    r'addOnTileActionListener',
    r'(Lorg/maplibre/android/maps/MapView$OnTileActionListener;)V',
  );

  static final _addOnTileActionListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnTileActionListener(org.maplibre.android.maps.MapView$OnTileActionListener onTileActionListener)`
  void addOnTileActionListener(
    MapView$OnTileActionListener? onTileActionListener,
  ) {
    final _$onTileActionListener =
        onTileActionListener?.reference ?? jni$_.jNullReference;
    _addOnTileActionListener(
            reference.pointer,
            _id_addOnTileActionListener as jni$_.JMethodIDPtr,
            _$onTileActionListener.pointer)
        .check();
  }

  static final _id_removeOnTileActionListener = _class.instanceMethodId(
    r'removeOnTileActionListener',
    r'(Lorg/maplibre/android/maps/MapView$OnTileActionListener;)V',
  );

  static final _removeOnTileActionListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnTileActionListener(org.maplibre.android.maps.MapView$OnTileActionListener onTileActionListener)`
  void removeOnTileActionListener(
    MapView$OnTileActionListener? onTileActionListener,
  ) {
    final _$onTileActionListener =
        onTileActionListener?.reference ?? jni$_.jNullReference;
    _removeOnTileActionListener(
            reference.pointer,
            _id_removeOnTileActionListener as jni$_.JMethodIDPtr,
            _$onTileActionListener.pointer)
        .check();
  }

  static final _id_addOnSpriteLoadedListener = _class.instanceMethodId(
    r'addOnSpriteLoadedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnSpriteLoadedListener;)V',
  );

  static final _addOnSpriteLoadedListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnSpriteLoadedListener(org.maplibre.android.maps.MapView$OnSpriteLoadedListener onSpriteLoadedListener)`
  void addOnSpriteLoadedListener(
    MapView$OnSpriteLoadedListener? onSpriteLoadedListener,
  ) {
    final _$onSpriteLoadedListener =
        onSpriteLoadedListener?.reference ?? jni$_.jNullReference;
    _addOnSpriteLoadedListener(
            reference.pointer,
            _id_addOnSpriteLoadedListener as jni$_.JMethodIDPtr,
            _$onSpriteLoadedListener.pointer)
        .check();
  }

  static final _id_removeOnSpriteLoadedListener = _class.instanceMethodId(
    r'removeOnSpriteLoadedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnSpriteLoadedListener;)V',
  );

  static final _removeOnSpriteLoadedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnSpriteLoadedListener(org.maplibre.android.maps.MapView$OnSpriteLoadedListener onSpriteLoadedListener)`
  void removeOnSpriteLoadedListener(
    MapView$OnSpriteLoadedListener? onSpriteLoadedListener,
  ) {
    final _$onSpriteLoadedListener =
        onSpriteLoadedListener?.reference ?? jni$_.jNullReference;
    _removeOnSpriteLoadedListener(
            reference.pointer,
            _id_removeOnSpriteLoadedListener as jni$_.JMethodIDPtr,
            _$onSpriteLoadedListener.pointer)
        .check();
  }

  static final _id_addOnSpriteErrorListener = _class.instanceMethodId(
    r'addOnSpriteErrorListener',
    r'(Lorg/maplibre/android/maps/MapView$OnSpriteErrorListener;)V',
  );

  static final _addOnSpriteErrorListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnSpriteErrorListener(org.maplibre.android.maps.MapView$OnSpriteErrorListener onSpriteErrorListener)`
  void addOnSpriteErrorListener(
    MapView$OnSpriteErrorListener? onSpriteErrorListener,
  ) {
    final _$onSpriteErrorListener =
        onSpriteErrorListener?.reference ?? jni$_.jNullReference;
    _addOnSpriteErrorListener(
            reference.pointer,
            _id_addOnSpriteErrorListener as jni$_.JMethodIDPtr,
            _$onSpriteErrorListener.pointer)
        .check();
  }

  static final _id_removeOnSpriteErrorListener = _class.instanceMethodId(
    r'removeOnSpriteErrorListener',
    r'(Lorg/maplibre/android/maps/MapView$OnSpriteErrorListener;)V',
  );

  static final _removeOnSpriteErrorListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnSpriteErrorListener(org.maplibre.android.maps.MapView$OnSpriteErrorListener onSpriteErrorListener)`
  void removeOnSpriteErrorListener(
    MapView$OnSpriteErrorListener? onSpriteErrorListener,
  ) {
    final _$onSpriteErrorListener =
        onSpriteErrorListener?.reference ?? jni$_.jNullReference;
    _removeOnSpriteErrorListener(
            reference.pointer,
            _id_removeOnSpriteErrorListener as jni$_.JMethodIDPtr,
            _$onSpriteErrorListener.pointer)
        .check();
  }

  static final _id_addOnSpriteRequestedListener = _class.instanceMethodId(
    r'addOnSpriteRequestedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnSpriteRequestedListener;)V',
  );

  static final _addOnSpriteRequestedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOnSpriteRequestedListener(org.maplibre.android.maps.MapView$OnSpriteRequestedListener onSpriteRequestedListener)`
  void addOnSpriteRequestedListener(
    MapView$OnSpriteRequestedListener? onSpriteRequestedListener,
  ) {
    final _$onSpriteRequestedListener =
        onSpriteRequestedListener?.reference ?? jni$_.jNullReference;
    _addOnSpriteRequestedListener(
            reference.pointer,
            _id_addOnSpriteRequestedListener as jni$_.JMethodIDPtr,
            _$onSpriteRequestedListener.pointer)
        .check();
  }

  static final _id_removeOnSpriteRequestedListener = _class.instanceMethodId(
    r'removeOnSpriteRequestedListener',
    r'(Lorg/maplibre/android/maps/MapView$OnSpriteRequestedListener;)V',
  );

  static final _removeOnSpriteRequestedListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeOnSpriteRequestedListener(org.maplibre.android.maps.MapView$OnSpriteRequestedListener onSpriteRequestedListener)`
  void removeOnSpriteRequestedListener(
    MapView$OnSpriteRequestedListener? onSpriteRequestedListener,
  ) {
    final _$onSpriteRequestedListener =
        onSpriteRequestedListener?.reference ?? jni$_.jNullReference;
    _removeOnSpriteRequestedListener(
            reference.pointer,
            _id_removeOnSpriteRequestedListener as jni$_.JMethodIDPtr,
            _$onSpriteRequestedListener.pointer)
        .check();
  }

  static final _id_getMapAsync = _class.instanceMethodId(
    r'getMapAsync',
    r'(Lorg/maplibre/android/maps/OnMapReadyCallback;)V',
  );

  static final _getMapAsync = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void getMapAsync(org.maplibre.android.maps.OnMapReadyCallback onMapReadyCallback)`
  void getMapAsync(
    onmapreadycallback$_.OnMapReadyCallback onMapReadyCallback,
  ) {
    final _$onMapReadyCallback = onMapReadyCallback.reference;
    _getMapAsync(reference.pointer, _id_getMapAsync as jni$_.JMethodIDPtr,
            _$onMapReadyCallback.pointer)
        .check();
  }

  static final _id_setMapStrictModeEnabled = _class.staticMethodId(
    r'setMapStrictModeEnabled',
    r'(Z)V',
  );

  static final _setMapStrictModeEnabled = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public void setMapStrictModeEnabled(boolean z)`
  static void setMapStrictModeEnabled(
    bool z,
  ) {
    _setMapStrictModeEnabled(_class.reference.pointer,
            _id_setMapStrictModeEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }
}

final class $MapView$NullableType extends jni$_.JObjType<MapView?> {
  @jni$_.internal
  const $MapView$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/MapView;';

  @jni$_.internal
  @core$_.override
  MapView? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : MapView.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$NullableType) &&
        other is $MapView$NullableType;
  }
}

final class $MapView$Type extends jni$_.JObjType<MapView> {
  @jni$_.internal
  const $MapView$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/maps/MapView;';

  @jni$_.internal
  @core$_.override
  MapView fromReference(jni$_.JReference reference) => MapView.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MapView?> get nullableType => const $MapView$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MapView$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapView$Type) && other is $MapView$Type;
  }
}
