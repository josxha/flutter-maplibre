// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: type=lint

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'OfflineRegionDefinition.dart' as offlineregiondefinition$_;

import 'OfflineRegionError.dart' as offlineregionerror$_;

import 'OfflineRegionStatus.dart' as offlineregionstatus$_;

/// from: `org.maplibre.android.offline.OfflineRegion$Companion`
class OfflineRegion$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OfflineRegion$Companion> $type;

  @jni$_.internal
  OfflineRegion$Companion.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/offline/OfflineRegion$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OfflineRegion$Companion$NullableType();
  static const type = $OfflineRegion$Companion$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OfflineRegion$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return OfflineRegion$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $OfflineRegion$Companion$NullableType
    extends jni$_.JObjType<OfflineRegion$Companion?> {
  @jni$_.internal
  const $OfflineRegion$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$Companion;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : OfflineRegion$Companion.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OfflineRegion$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion$Companion$NullableType) &&
        other is $OfflineRegion$Companion$NullableType;
  }
}

final class $OfflineRegion$Companion$Type
    extends jni$_.JObjType<OfflineRegion$Companion> {
  @jni$_.internal
  const $OfflineRegion$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$Companion;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$Companion fromReference(jni$_.JReference reference) =>
      OfflineRegion$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$Companion?> get nullableType =>
      const $OfflineRegion$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OfflineRegion$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion$Companion$Type) &&
        other is $OfflineRegion$Companion$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$DownloadState`
class OfflineRegion$DownloadState extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OfflineRegion$DownloadState> $type;

  @jni$_.internal
  OfflineRegion$DownloadState.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/offline/OfflineRegion$DownloadState',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OfflineRegion$DownloadState$NullableType();
  static const type = $OfflineRegion$DownloadState$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OfflineRegion$DownloadState> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OfflineRegion$DownloadState $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$DownloadState',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion$DownloadState.implement(
    $OfflineRegion$DownloadState $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion$DownloadState.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OfflineRegion$DownloadState {
  factory $OfflineRegion$DownloadState() = _$OfflineRegion$DownloadState;
}

final class _$OfflineRegion$DownloadState with $OfflineRegion$DownloadState {
  _$OfflineRegion$DownloadState();
}

final class $OfflineRegion$DownloadState$NullableType
    extends jni$_.JObjType<OfflineRegion$DownloadState?> {
  @jni$_.internal
  const $OfflineRegion$DownloadState$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$DownloadState;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$DownloadState? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : OfflineRegion$DownloadState.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$DownloadState?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OfflineRegion$DownloadState$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion$DownloadState$NullableType) &&
        other is $OfflineRegion$DownloadState$NullableType;
  }
}

final class $OfflineRegion$DownloadState$Type
    extends jni$_.JObjType<OfflineRegion$DownloadState> {
  @jni$_.internal
  const $OfflineRegion$DownloadState$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$DownloadState;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$DownloadState fromReference(jni$_.JReference reference) =>
      OfflineRegion$DownloadState.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$DownloadState?> get nullableType =>
      const $OfflineRegion$DownloadState$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OfflineRegion$DownloadState$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion$DownloadState$Type) &&
        other is $OfflineRegion$DownloadState$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback`
class OfflineRegion$OfflineRegionDeleteCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OfflineRegion$OfflineRegionDeleteCallback> $type;

  @jni$_.internal
  OfflineRegion$OfflineRegionDeleteCallback.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $OfflineRegion$OfflineRegionDeleteCallback$NullableType();
  static const type = $OfflineRegion$OfflineRegionDeleteCallback$Type();
  static final _id_onDelete = _class.instanceMethodId(
    r'onDelete',
    r'()V',
  );

  static final _onDelete =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onDelete()`
  void onDelete() {
    _onDelete(reference.pointer, _id_onDelete as jni$_.JMethodIDPtr).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _onError(
      reference.pointer,
      _id_onError as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OfflineRegion$OfflineRegionDeleteCallback>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDelete()V') {
        _$impls[$p]!.onDelete();
        return jni$_.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OfflineRegion$OfflineRegionDeleteCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onDelete$async) r'onDelete()V',
        if ($impl.onError$async) r'onError(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion$OfflineRegionDeleteCallback.implement(
    $OfflineRegion$OfflineRegionDeleteCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion$OfflineRegionDeleteCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OfflineRegion$OfflineRegionDeleteCallback {
  factory $OfflineRegion$OfflineRegionDeleteCallback({
    required void Function() onDelete,
    bool onDelete$async,
    required void Function(jni$_.JString string) onError,
    bool onError$async,
  }) = _$OfflineRegion$OfflineRegionDeleteCallback;

  void onDelete();
  bool get onDelete$async => false;
  void onError(jni$_.JString string);
  bool get onError$async => false;
}

final class _$OfflineRegion$OfflineRegionDeleteCallback
    with $OfflineRegion$OfflineRegionDeleteCallback {
  _$OfflineRegion$OfflineRegionDeleteCallback({
    required void Function() onDelete,
    this.onDelete$async = false,
    required void Function(jni$_.JString string) onError,
    this.onError$async = false,
  }) : _onDelete = onDelete,
       _onError = onError;

  final void Function() _onDelete;
  final bool onDelete$async;
  final void Function(jni$_.JString string) _onError;
  final bool onError$async;

  void onDelete() {
    return _onDelete();
  }

  void onError(jni$_.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion$OfflineRegionDeleteCallback$NullableType
    extends jni$_.JObjType<OfflineRegion$OfflineRegionDeleteCallback?> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionDeleteCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionDeleteCallback? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : OfflineRegion$OfflineRegionDeleteCallback.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionDeleteCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionDeleteCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionDeleteCallback$NullableType) &&
        other is $OfflineRegion$OfflineRegionDeleteCallback$NullableType;
  }
}

final class $OfflineRegion$OfflineRegionDeleteCallback$Type
    extends jni$_.JObjType<OfflineRegion$OfflineRegionDeleteCallback> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionDeleteCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionDeleteCallback fromReference(
    jni$_.JReference reference,
  ) => OfflineRegion$OfflineRegionDeleteCallback.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionDeleteCallback?> get nullableType =>
      const $OfflineRegion$OfflineRegionDeleteCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionDeleteCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionDeleteCallback$Type) &&
        other is $OfflineRegion$OfflineRegionDeleteCallback$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback`
class OfflineRegion$OfflineRegionInvalidateCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OfflineRegion$OfflineRegionInvalidateCallback> $type;

  @jni$_.internal
  OfflineRegion$OfflineRegionInvalidateCallback.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $OfflineRegion$OfflineRegionInvalidateCallback$NullableType();
  static const type = $OfflineRegion$OfflineRegionInvalidateCallback$Type();
  static final _id_onInvalidate = _class.instanceMethodId(
    r'onInvalidate',
    r'()V',
  );

  static final _onInvalidate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void onInvalidate()`
  void onInvalidate() {
    _onInvalidate(
      reference.pointer,
      _id_onInvalidate as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _onError(
      reference.pointer,
      _id_onError as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OfflineRegion$OfflineRegionInvalidateCallback>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onInvalidate()V') {
        _$impls[$p]!.onInvalidate();
        return jni$_.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OfflineRegion$OfflineRegionInvalidateCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onInvalidate$async) r'onInvalidate()V',
        if ($impl.onError$async) r'onError(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion$OfflineRegionInvalidateCallback.implement(
    $OfflineRegion$OfflineRegionInvalidateCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion$OfflineRegionInvalidateCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OfflineRegion$OfflineRegionInvalidateCallback {
  factory $OfflineRegion$OfflineRegionInvalidateCallback({
    required void Function() onInvalidate,
    bool onInvalidate$async,
    required void Function(jni$_.JString string) onError,
    bool onError$async,
  }) = _$OfflineRegion$OfflineRegionInvalidateCallback;

  void onInvalidate();
  bool get onInvalidate$async => false;
  void onError(jni$_.JString string);
  bool get onError$async => false;
}

final class _$OfflineRegion$OfflineRegionInvalidateCallback
    with $OfflineRegion$OfflineRegionInvalidateCallback {
  _$OfflineRegion$OfflineRegionInvalidateCallback({
    required void Function() onInvalidate,
    this.onInvalidate$async = false,
    required void Function(jni$_.JString string) onError,
    this.onError$async = false,
  }) : _onInvalidate = onInvalidate,
       _onError = onError;

  final void Function() _onInvalidate;
  final bool onInvalidate$async;
  final void Function(jni$_.JString string) _onError;
  final bool onError$async;

  void onInvalidate() {
    return _onInvalidate();
  }

  void onError(jni$_.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion$OfflineRegionInvalidateCallback$NullableType
    extends jni$_.JObjType<OfflineRegion$OfflineRegionInvalidateCallback?> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionInvalidateCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionInvalidateCallback? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : OfflineRegion$OfflineRegionInvalidateCallback.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionInvalidateCallback?>
  get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionInvalidateCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionInvalidateCallback$NullableType) &&
        other is $OfflineRegion$OfflineRegionInvalidateCallback$NullableType;
  }
}

final class $OfflineRegion$OfflineRegionInvalidateCallback$Type
    extends jni$_.JObjType<OfflineRegion$OfflineRegionInvalidateCallback> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionInvalidateCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionInvalidateCallback fromReference(
    jni$_.JReference reference,
  ) => OfflineRegion$OfflineRegionInvalidateCallback.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionInvalidateCallback?>
  get nullableType =>
      const $OfflineRegion$OfflineRegionInvalidateCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionInvalidateCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionInvalidateCallback$Type) &&
        other is $OfflineRegion$OfflineRegionInvalidateCallback$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver`
class OfflineRegion$OfflineRegionObserver extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OfflineRegion$OfflineRegionObserver> $type;

  @jni$_.internal
  OfflineRegion$OfflineRegionObserver.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/offline/OfflineRegion$OfflineRegionObserver',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $OfflineRegion$OfflineRegionObserver$NullableType();
  static const type = $OfflineRegion$OfflineRegionObserver$Type();
  static final _id_onStatusChanged = _class.instanceMethodId(
    r'onStatusChanged',
    r'(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
  );

  static final _onStatusChanged =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onStatusChanged(org.maplibre.android.offline.OfflineRegionStatus offlineRegionStatus)`
  void onStatusChanged(
    offlineregionstatus$_.OfflineRegionStatus offlineRegionStatus,
  ) {
    final _$offlineRegionStatus = offlineRegionStatus.reference;
    _onStatusChanged(
      reference.pointer,
      _id_onStatusChanged as jni$_.JMethodIDPtr,
      _$offlineRegionStatus.pointer,
    ).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Lorg/maplibre/android/offline/OfflineRegionError;)V',
  );

  static final _onError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onError(org.maplibre.android.offline.OfflineRegionError offlineRegionError)`
  void onError(
    offlineregionerror$_.OfflineRegionError offlineRegionError,
  ) {
    final _$offlineRegionError = offlineRegionError.reference;
    _onError(
      reference.pointer,
      _id_onError as jni$_.JMethodIDPtr,
      _$offlineRegionError.pointer,
    ).check();
  }

  static final _id_mapboxTileCountLimitExceeded = _class.instanceMethodId(
    r'mapboxTileCountLimitExceeded',
    r'(J)V',
  );

  static final _mapboxTileCountLimitExceeded =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void mapboxTileCountLimitExceeded(long j)`
  void mapboxTileCountLimitExceeded(
    int j,
  ) {
    _mapboxTileCountLimitExceeded(
      reference.pointer,
      _id_mapboxTileCountLimitExceeded as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OfflineRegion$OfflineRegionObserver> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onStatusChanged(Lorg/maplibre/android/offline/OfflineRegionStatus;)V') {
        _$impls[$p]!.onStatusChanged(
          $a![0]!.as(
            const offlineregionstatus$_.$OfflineRegionStatus$Type(),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onError(Lorg/maplibre/android/offline/OfflineRegionError;)V') {
        _$impls[$p]!.onError(
          $a![0]!.as(
            const offlineregionerror$_.$OfflineRegionError$Type(),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
      if ($d == r'mapboxTileCountLimitExceeded(J)V') {
        _$impls[$p]!.mapboxTileCountLimitExceeded(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OfflineRegion$OfflineRegionObserver $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver',
      $p,
      _$invokePointer,
      [
        if ($impl.onStatusChanged$async)
          r'onStatusChanged(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
        if ($impl.onError$async)
          r'onError(Lorg/maplibre/android/offline/OfflineRegionError;)V',
        if ($impl.mapboxTileCountLimitExceeded$async)
          r'mapboxTileCountLimitExceeded(J)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion$OfflineRegionObserver.implement(
    $OfflineRegion$OfflineRegionObserver $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion$OfflineRegionObserver.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OfflineRegion$OfflineRegionObserver {
  factory $OfflineRegion$OfflineRegionObserver({
    required void Function(
      offlineregionstatus$_.OfflineRegionStatus offlineRegionStatus,
    )
    onStatusChanged,
    bool onStatusChanged$async,
    required void Function(
      offlineregionerror$_.OfflineRegionError offlineRegionError,
    )
    onError,
    bool onError$async,
    required void Function(int j) mapboxTileCountLimitExceeded,
    bool mapboxTileCountLimitExceeded$async,
  }) = _$OfflineRegion$OfflineRegionObserver;

  void onStatusChanged(
    offlineregionstatus$_.OfflineRegionStatus offlineRegionStatus,
  );
  bool get onStatusChanged$async => false;
  void onError(offlineregionerror$_.OfflineRegionError offlineRegionError);
  bool get onError$async => false;
  void mapboxTileCountLimitExceeded(int j);
  bool get mapboxTileCountLimitExceeded$async => false;
}

final class _$OfflineRegion$OfflineRegionObserver
    with $OfflineRegion$OfflineRegionObserver {
  _$OfflineRegion$OfflineRegionObserver({
    required void Function(
      offlineregionstatus$_.OfflineRegionStatus offlineRegionStatus,
    )
    onStatusChanged,
    this.onStatusChanged$async = false,
    required void Function(
      offlineregionerror$_.OfflineRegionError offlineRegionError,
    )
    onError,
    this.onError$async = false,
    required void Function(int j) mapboxTileCountLimitExceeded,
    this.mapboxTileCountLimitExceeded$async = false,
  }) : _onStatusChanged = onStatusChanged,
       _onError = onError,
       _mapboxTileCountLimitExceeded = mapboxTileCountLimitExceeded;

  final void Function(
    offlineregionstatus$_.OfflineRegionStatus offlineRegionStatus,
  )
  _onStatusChanged;
  final bool onStatusChanged$async;
  final void Function(
    offlineregionerror$_.OfflineRegionError offlineRegionError,
  )
  _onError;
  final bool onError$async;
  final void Function(int j) _mapboxTileCountLimitExceeded;
  final bool mapboxTileCountLimitExceeded$async;

  void onStatusChanged(
    offlineregionstatus$_.OfflineRegionStatus offlineRegionStatus,
  ) {
    return _onStatusChanged(offlineRegionStatus);
  }

  void onError(offlineregionerror$_.OfflineRegionError offlineRegionError) {
    return _onError(offlineRegionError);
  }

  void mapboxTileCountLimitExceeded(int j) {
    return _mapboxTileCountLimitExceeded(j);
  }
}

final class $OfflineRegion$OfflineRegionObserver$NullableType
    extends jni$_.JObjType<OfflineRegion$OfflineRegionObserver?> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionObserver$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionObserver? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : OfflineRegion$OfflineRegionObserver.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionObserver?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionObserver$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionObserver$NullableType) &&
        other is $OfflineRegion$OfflineRegionObserver$NullableType;
  }
}

final class $OfflineRegion$OfflineRegionObserver$Type
    extends jni$_.JObjType<OfflineRegion$OfflineRegionObserver> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionObserver$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionObserver fromReference(
    jni$_.JReference reference,
  ) => OfflineRegion$OfflineRegionObserver.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionObserver?> get nullableType =>
      const $OfflineRegion$OfflineRegionObserver$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OfflineRegion$OfflineRegionObserver$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion$OfflineRegionObserver$Type) &&
        other is $OfflineRegion$OfflineRegionObserver$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback`
class OfflineRegion$OfflineRegionStatusCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OfflineRegion$OfflineRegionStatusCallback> $type;

  @jni$_.internal
  OfflineRegion$OfflineRegionStatusCallback.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $OfflineRegion$OfflineRegionStatusCallback$NullableType();
  static const type = $OfflineRegion$OfflineRegionStatusCallback$Type();
  static final _id_onStatus = _class.instanceMethodId(
    r'onStatus',
    r'(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
  );

  static final _onStatus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onStatus(org.maplibre.android.offline.OfflineRegionStatus offlineRegionStatus)`
  void onStatus(
    offlineregionstatus$_.OfflineRegionStatus? offlineRegionStatus,
  ) {
    final _$offlineRegionStatus =
        offlineRegionStatus?.reference ?? jni$_.jNullReference;
    _onStatus(
      reference.pointer,
      _id_onStatus as jni$_.JMethodIDPtr,
      _$offlineRegionStatus.pointer,
    ).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onError(
      reference.pointer,
      _id_onError as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OfflineRegion$OfflineRegionStatusCallback>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onStatus(Lorg/maplibre/android/offline/OfflineRegionStatus;)V') {
        _$impls[$p]!.onStatus(
          $a![0]?.as(
            const offlineregionstatus$_.$OfflineRegionStatus$Type(),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OfflineRegion$OfflineRegionStatusCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onStatus$async)
          r'onStatus(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
        if ($impl.onError$async) r'onError(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion$OfflineRegionStatusCallback.implement(
    $OfflineRegion$OfflineRegionStatusCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion$OfflineRegionStatusCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OfflineRegion$OfflineRegionStatusCallback {
  factory $OfflineRegion$OfflineRegionStatusCallback({
    required void Function(
      offlineregionstatus$_.OfflineRegionStatus? offlineRegionStatus,
    )
    onStatus,
    bool onStatus$async,
    required void Function(jni$_.JString? string) onError,
    bool onError$async,
  }) = _$OfflineRegion$OfflineRegionStatusCallback;

  void onStatus(offlineregionstatus$_.OfflineRegionStatus? offlineRegionStatus);
  bool get onStatus$async => false;
  void onError(jni$_.JString? string);
  bool get onError$async => false;
}

final class _$OfflineRegion$OfflineRegionStatusCallback
    with $OfflineRegion$OfflineRegionStatusCallback {
  _$OfflineRegion$OfflineRegionStatusCallback({
    required void Function(
      offlineregionstatus$_.OfflineRegionStatus? offlineRegionStatus,
    )
    onStatus,
    this.onStatus$async = false,
    required void Function(jni$_.JString? string) onError,
    this.onError$async = false,
  }) : _onStatus = onStatus,
       _onError = onError;

  final void Function(
    offlineregionstatus$_.OfflineRegionStatus? offlineRegionStatus,
  )
  _onStatus;
  final bool onStatus$async;
  final void Function(jni$_.JString? string) _onError;
  final bool onError$async;

  void onStatus(
    offlineregionstatus$_.OfflineRegionStatus? offlineRegionStatus,
  ) {
    return _onStatus(offlineRegionStatus);
  }

  void onError(jni$_.JString? string) {
    return _onError(string);
  }
}

final class $OfflineRegion$OfflineRegionStatusCallback$NullableType
    extends jni$_.JObjType<OfflineRegion$OfflineRegionStatusCallback?> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionStatusCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionStatusCallback? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : OfflineRegion$OfflineRegionStatusCallback.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionStatusCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionStatusCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionStatusCallback$NullableType) &&
        other is $OfflineRegion$OfflineRegionStatusCallback$NullableType;
  }
}

final class $OfflineRegion$OfflineRegionStatusCallback$Type
    extends jni$_.JObjType<OfflineRegion$OfflineRegionStatusCallback> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionStatusCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionStatusCallback fromReference(
    jni$_.JReference reference,
  ) => OfflineRegion$OfflineRegionStatusCallback.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionStatusCallback?> get nullableType =>
      const $OfflineRegion$OfflineRegionStatusCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionStatusCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionStatusCallback$Type) &&
        other is $OfflineRegion$OfflineRegionStatusCallback$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback`
class OfflineRegion$OfflineRegionUpdateMetadataCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OfflineRegion$OfflineRegionUpdateMetadataCallback> $type;

  @jni$_.internal
  OfflineRegion$OfflineRegionUpdateMetadataCallback.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $OfflineRegion$OfflineRegionUpdateMetadataCallback$NullableType();
  static const type = $OfflineRegion$OfflineRegionUpdateMetadataCallback$Type();
  static final _id_onUpdate = _class.instanceMethodId(
    r'onUpdate',
    r'([B)V',
  );

  static final _onUpdate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onUpdate(byte[] bs)`
  void onUpdate(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    _onUpdate(
      reference.pointer,
      _id_onUpdate as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _onError(
      reference.pointer,
      _id_onError as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<
    int,
    $OfflineRegion$OfflineRegionUpdateMetadataCallback
  >
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onUpdate([B)V') {
        _$impls[$p]!.onUpdate(
          $a![0]!.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OfflineRegion$OfflineRegionUpdateMetadataCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onUpdate$async) r'onUpdate([B)V',
        if ($impl.onError$async) r'onError(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion$OfflineRegionUpdateMetadataCallback.implement(
    $OfflineRegion$OfflineRegionUpdateMetadataCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion$OfflineRegionUpdateMetadataCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OfflineRegion$OfflineRegionUpdateMetadataCallback {
  factory $OfflineRegion$OfflineRegionUpdateMetadataCallback({
    required void Function(jni$_.JByteArray bs) onUpdate,
    bool onUpdate$async,
    required void Function(jni$_.JString string) onError,
    bool onError$async,
  }) = _$OfflineRegion$OfflineRegionUpdateMetadataCallback;

  void onUpdate(jni$_.JByteArray bs);
  bool get onUpdate$async => false;
  void onError(jni$_.JString string);
  bool get onError$async => false;
}

final class _$OfflineRegion$OfflineRegionUpdateMetadataCallback
    with $OfflineRegion$OfflineRegionUpdateMetadataCallback {
  _$OfflineRegion$OfflineRegionUpdateMetadataCallback({
    required void Function(jni$_.JByteArray bs) onUpdate,
    this.onUpdate$async = false,
    required void Function(jni$_.JString string) onError,
    this.onError$async = false,
  }) : _onUpdate = onUpdate,
       _onError = onError;

  final void Function(jni$_.JByteArray bs) _onUpdate;
  final bool onUpdate$async;
  final void Function(jni$_.JString string) _onError;
  final bool onError$async;

  void onUpdate(jni$_.JByteArray bs) {
    return _onUpdate(bs);
  }

  void onError(jni$_.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion$OfflineRegionUpdateMetadataCallback$NullableType
    extends jni$_.JObjType<OfflineRegion$OfflineRegionUpdateMetadataCallback?> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionUpdateMetadataCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionUpdateMetadataCallback? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : OfflineRegion$OfflineRegionUpdateMetadataCallback.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionUpdateMetadataCallback?>
  get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionUpdateMetadataCallback$NullableType)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionUpdateMetadataCallback$NullableType) &&
        other
            is $OfflineRegion$OfflineRegionUpdateMetadataCallback$NullableType;
  }
}

final class $OfflineRegion$OfflineRegionUpdateMetadataCallback$Type
    extends jni$_.JObjType<OfflineRegion$OfflineRegionUpdateMetadataCallback> {
  @jni$_.internal
  const $OfflineRegion$OfflineRegionUpdateMetadataCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;';

  @jni$_.internal
  @core$_.override
  OfflineRegion$OfflineRegionUpdateMetadataCallback fromReference(
    jni$_.JReference reference,
  ) => OfflineRegion$OfflineRegionUpdateMetadataCallback.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion$OfflineRegionUpdateMetadataCallback?>
  get nullableType =>
      const $OfflineRegion$OfflineRegionUpdateMetadataCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($OfflineRegion$OfflineRegionUpdateMetadataCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion$OfflineRegionUpdateMetadataCallback$Type) &&
        other is $OfflineRegion$OfflineRegionUpdateMetadataCallback$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion`
class OfflineRegion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OfflineRegion> $type;

  @jni$_.internal
  OfflineRegion.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/maplibre/android/offline/OfflineRegion',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OfflineRegion$NullableType();
  static const type = $OfflineRegion$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lorg/maplibre/android/offline/OfflineRegion$Companion;',
  );

  /// from: `static public final org.maplibre.android.offline.OfflineRegion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static OfflineRegion$Companion get Companion =>
      _id_Companion.get(_class, const $OfflineRegion$Companion$Type());

  /// from: `static public final int STATE_INACTIVE`
  static const STATE_INACTIVE = 0;

  /// from: `static public final int STATE_ACTIVE`
  static const STATE_ACTIVE = 1;
  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()J',
  );

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getId()`
  int getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr).long;
  }

  static final _id_getDefinition = _class.instanceMethodId(
    r'getDefinition',
    r'()Lorg/maplibre/android/offline/OfflineRegionDefinition;',
  );

  static final _getDefinition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final org.maplibre.android.offline.OfflineRegionDefinition getDefinition()`
  /// The returned object must be released after use, by calling the [release] method.
  offlineregiondefinition$_.OfflineRegionDefinition getDefinition() {
    return _getDefinition(
      reference.pointer,
      _id_getDefinition as jni$_.JMethodIDPtr,
    ).object<offlineregiondefinition$_.OfflineRegionDefinition>(
      const offlineregiondefinition$_.$OfflineRegionDefinition$Type(),
    );
  }

  static final _id_getMetadata = _class.instanceMethodId(
    r'getMetadata',
    r'()[B',
  );

  static final _getMetadata =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final byte[] getMetadata()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray getMetadata() {
    return _getMetadata(
      reference.pointer,
      _id_getMetadata as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_isDeliveringInactiveMessages = _class.instanceMethodId(
    r'isDeliveringInactiveMessages',
    r'()Z',
  );

  static final _isDeliveringInactiveMessages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isDeliveringInactiveMessages()`
  bool isDeliveringInactiveMessages() {
    return _isDeliveringInactiveMessages(
      reference.pointer,
      _id_isDeliveringInactiveMessages as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setDeliverInactiveMessages = _class.instanceMethodId(
    r'setDeliverInactiveMessages',
    r'(Z)V',
  );

  static final _setDeliverInactiveMessages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void setDeliverInactiveMessages(boolean z)`
  void setDeliverInactiveMessages(
    bool z,
  ) {
    _setDeliverInactiveMessages(
      reference.pointer,
      _id_setDeliverInactiveMessages as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setObserver = _class.instanceMethodId(
    r'setObserver',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;)V',
  );

  static final _setObserver =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setObserver(org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver offlineRegionObserver)`
  void setObserver(
    OfflineRegion$OfflineRegionObserver? offlineRegionObserver,
  ) {
    final _$offlineRegionObserver =
        offlineRegionObserver?.reference ?? jni$_.jNullReference;
    _setObserver(
      reference.pointer,
      _id_setObserver as jni$_.JMethodIDPtr,
      _$offlineRegionObserver.pointer,
    ).check();
  }

  static final _id_setDownloadState = _class.instanceMethodId(
    r'setDownloadState',
    r'(I)V',
  );

  static final _setDownloadState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void setDownloadState(int i)`
  void setDownloadState(
    int i,
  ) {
    _setDownloadState(
      reference.pointer,
      _id_setDownloadState as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getStatus = _class.instanceMethodId(
    r'getStatus',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;)V',
  );

  static final _getStatus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void getStatus(org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback offlineRegionStatusCallback)`
  void getStatus(
    OfflineRegion$OfflineRegionStatusCallback offlineRegionStatusCallback,
  ) {
    final _$offlineRegionStatusCallback = offlineRegionStatusCallback.reference;
    _getStatus(
      reference.pointer,
      _id_getStatus as jni$_.JMethodIDPtr,
      _$offlineRegionStatusCallback.pointer,
    ).check();
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;)V',
  );

  static final _delete =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void delete(org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback offlineRegionDeleteCallback)`
  void delete(
    OfflineRegion$OfflineRegionDeleteCallback offlineRegionDeleteCallback,
  ) {
    final _$offlineRegionDeleteCallback = offlineRegionDeleteCallback.reference;
    _delete(
      reference.pointer,
      _id_delete as jni$_.JMethodIDPtr,
      _$offlineRegionDeleteCallback.pointer,
    ).check();
  }

  static final _id_invalidate = _class.instanceMethodId(
    r'invalidate',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;)V',
  );

  static final _invalidate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void invalidate(org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback offlineRegionInvalidateCallback)`
  void invalidate(
    OfflineRegion$OfflineRegionInvalidateCallback?
    offlineRegionInvalidateCallback,
  ) {
    final _$offlineRegionInvalidateCallback =
        offlineRegionInvalidateCallback?.reference ?? jni$_.jNullReference;
    _invalidate(
      reference.pointer,
      _id_invalidate as jni$_.JMethodIDPtr,
      _$offlineRegionInvalidateCallback.pointer,
    ).check();
  }

  static final _id_updateMetadata = _class.instanceMethodId(
    r'updateMetadata',
    r'([BLorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;)V',
  );

  static final _updateMetadata =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void updateMetadata(byte[] bs, org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback offlineRegionUpdateMetadataCallback)`
  void updateMetadata(
    jni$_.JByteArray bs,
    OfflineRegion$OfflineRegionUpdateMetadataCallback
    offlineRegionUpdateMetadataCallback,
  ) {
    final _$bs = bs.reference;
    final _$offlineRegionUpdateMetadataCallback =
        offlineRegionUpdateMetadataCallback.reference;
    _updateMetadata(
      reference.pointer,
      _id_updateMetadata as jni$_.JMethodIDPtr,
      _$bs.pointer,
      _$offlineRegionUpdateMetadataCallback.pointer,
    ).check();
  }
}

final class $OfflineRegion$NullableType extends jni$_.JObjType<OfflineRegion?> {
  @jni$_.internal
  const $OfflineRegion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/offline/OfflineRegion;';

  @jni$_.internal
  @core$_.override
  OfflineRegion? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : OfflineRegion.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OfflineRegion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion$NullableType) &&
        other is $OfflineRegion$NullableType;
  }
}

final class $OfflineRegion$Type extends jni$_.JObjType<OfflineRegion> {
  @jni$_.internal
  const $OfflineRegion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/maplibre/android/offline/OfflineRegion;';

  @jni$_.internal
  @core$_.override
  OfflineRegion fromReference(jni$_.JReference reference) =>
      OfflineRegion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OfflineRegion?> get nullableType =>
      const $OfflineRegion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OfflineRegion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion$Type) &&
        other is $OfflineRegion$Type;
  }
}
