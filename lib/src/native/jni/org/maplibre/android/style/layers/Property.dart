// Autogenerated by jnigen. DO NOT EDIT!

// coverage:ignore-file
// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;

/// from: `org.maplibre.android.style.layers.Property$ANCHOR`
class Property_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_ANCHOR> $type;

  @_$jni.internal
  Property_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_ANCHOR> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_ANCHOR.implement(
    $Property_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_ANCHOR {
  factory $Property_ANCHOR() = _$Property_ANCHOR;
}

final class _$Property_ANCHOR with $Property_ANCHOR {
  _$Property_ANCHOR();
}

final class $Property_ANCHOR$Type extends _$jni.JObjType<Property_ANCHOR> {
  @_$jni.internal
  const $Property_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_ANCHOR fromReference(_$jni.JReference reference) =>
      Property_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ANCHOR$Type) &&
        other is $Property_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_PITCH_ALIGNMENT`
class Property_CIRCLE_PITCH_ALIGNMENT extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_CIRCLE_PITCH_ALIGNMENT> $type;

  @_$jni.internal
  Property_CIRCLE_PITCH_ALIGNMENT.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_PITCH_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_CIRCLE_PITCH_ALIGNMENT> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_CIRCLE_PITCH_ALIGNMENT $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$CIRCLE_PITCH_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_CIRCLE_PITCH_ALIGNMENT.implement(
    $Property_CIRCLE_PITCH_ALIGNMENT $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_CIRCLE_PITCH_ALIGNMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_CIRCLE_PITCH_ALIGNMENT {
  factory $Property_CIRCLE_PITCH_ALIGNMENT() =
      _$Property_CIRCLE_PITCH_ALIGNMENT;
}

final class _$Property_CIRCLE_PITCH_ALIGNMENT
    with $Property_CIRCLE_PITCH_ALIGNMENT {
  _$Property_CIRCLE_PITCH_ALIGNMENT();
}

final class $Property_CIRCLE_PITCH_ALIGNMENT$Type
    extends _$jni.JObjType<Property_CIRCLE_PITCH_ALIGNMENT> {
  @_$jni.internal
  const $Property_CIRCLE_PITCH_ALIGNMENT$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT;';

  @_$jni.internal
  @_$core.override
  Property_CIRCLE_PITCH_ALIGNMENT fromReference(_$jni.JReference reference) =>
      Property_CIRCLE_PITCH_ALIGNMENT.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_CIRCLE_PITCH_ALIGNMENT$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_PITCH_ALIGNMENT$Type) &&
        other is $Property_CIRCLE_PITCH_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_PITCH_SCALE`
class Property_CIRCLE_PITCH_SCALE extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_CIRCLE_PITCH_SCALE> $type;

  @_$jni.internal
  Property_CIRCLE_PITCH_SCALE.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_PITCH_SCALE$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_CIRCLE_PITCH_SCALE> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_CIRCLE_PITCH_SCALE $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$CIRCLE_PITCH_SCALE',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_CIRCLE_PITCH_SCALE.implement(
    $Property_CIRCLE_PITCH_SCALE $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_CIRCLE_PITCH_SCALE.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_CIRCLE_PITCH_SCALE {
  factory $Property_CIRCLE_PITCH_SCALE() = _$Property_CIRCLE_PITCH_SCALE;
}

final class _$Property_CIRCLE_PITCH_SCALE with $Property_CIRCLE_PITCH_SCALE {
  _$Property_CIRCLE_PITCH_SCALE();
}

final class $Property_CIRCLE_PITCH_SCALE$Type
    extends _$jni.JObjType<Property_CIRCLE_PITCH_SCALE> {
  @_$jni.internal
  const $Property_CIRCLE_PITCH_SCALE$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE;';

  @_$jni.internal
  @_$core.override
  Property_CIRCLE_PITCH_SCALE fromReference(_$jni.JReference reference) =>
      Property_CIRCLE_PITCH_SCALE.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_CIRCLE_PITCH_SCALE$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_PITCH_SCALE$Type) &&
        other is $Property_CIRCLE_PITCH_SCALE$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_TRANSLATE_ANCHOR`
class Property_CIRCLE_TRANSLATE_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_CIRCLE_TRANSLATE_ANCHOR> $type;

  @_$jni.internal
  Property_CIRCLE_TRANSLATE_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_CIRCLE_TRANSLATE_ANCHOR> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_CIRCLE_TRANSLATE_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$CIRCLE_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_CIRCLE_TRANSLATE_ANCHOR.implement(
    $Property_CIRCLE_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_CIRCLE_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_CIRCLE_TRANSLATE_ANCHOR {
  factory $Property_CIRCLE_TRANSLATE_ANCHOR() =
      _$Property_CIRCLE_TRANSLATE_ANCHOR;
}

final class _$Property_CIRCLE_TRANSLATE_ANCHOR
    with $Property_CIRCLE_TRANSLATE_ANCHOR {
  _$Property_CIRCLE_TRANSLATE_ANCHOR();
}

final class $Property_CIRCLE_TRANSLATE_ANCHOR$Type
    extends _$jni.JObjType<Property_CIRCLE_TRANSLATE_ANCHOR> {
  @_$jni.internal
  const $Property_CIRCLE_TRANSLATE_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_CIRCLE_TRANSLATE_ANCHOR fromReference(_$jni.JReference reference) =>
      Property_CIRCLE_TRANSLATE_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_CIRCLE_TRANSLATE_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_TRANSLATE_ANCHOR$Type) &&
        other is $Property_CIRCLE_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$FILL_EXTRUSION_TRANSLATE_ANCHOR`
class Property_FILL_EXTRUSION_TRANSLATE_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_FILL_EXTRUSION_TRANSLATE_ANCHOR> $type;

  @_$jni.internal
  Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$FILL_EXTRUSION_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.implement(
    $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR {
  factory $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR() =
      _$Property_FILL_EXTRUSION_TRANSLATE_ANCHOR;
}

final class _$Property_FILL_EXTRUSION_TRANSLATE_ANCHOR
    with $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR {
  _$Property_FILL_EXTRUSION_TRANSLATE_ANCHOR();
}

final class $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR$Type
    extends _$jni.JObjType<Property_FILL_EXTRUSION_TRANSLATE_ANCHOR> {
  @_$jni.internal
  const $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_FILL_EXTRUSION_TRANSLATE_ANCHOR fromReference(
          _$jni.JReference reference) =>
      Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_FILL_EXTRUSION_TRANSLATE_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property_FILL_EXTRUSION_TRANSLATE_ANCHOR$Type) &&
        other is $Property_FILL_EXTRUSION_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$FILL_TRANSLATE_ANCHOR`
class Property_FILL_TRANSLATE_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_FILL_TRANSLATE_ANCHOR> $type;

  @_$jni.internal
  Property_FILL_TRANSLATE_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_FILL_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_FILL_TRANSLATE_ANCHOR> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_FILL_TRANSLATE_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$FILL_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_FILL_TRANSLATE_ANCHOR.implement(
    $Property_FILL_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_FILL_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_FILL_TRANSLATE_ANCHOR {
  factory $Property_FILL_TRANSLATE_ANCHOR() = _$Property_FILL_TRANSLATE_ANCHOR;
}

final class _$Property_FILL_TRANSLATE_ANCHOR
    with $Property_FILL_TRANSLATE_ANCHOR {
  _$Property_FILL_TRANSLATE_ANCHOR();
}

final class $Property_FILL_TRANSLATE_ANCHOR$Type
    extends _$jni.JObjType<Property_FILL_TRANSLATE_ANCHOR> {
  @_$jni.internal
  const $Property_FILL_TRANSLATE_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_FILL_TRANSLATE_ANCHOR fromReference(_$jni.JReference reference) =>
      Property_FILL_TRANSLATE_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_FILL_TRANSLATE_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_FILL_TRANSLATE_ANCHOR$Type) &&
        other is $Property_FILL_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$HILLSHADE_ILLUMINATION_ANCHOR`
class Property_HILLSHADE_ILLUMINATION_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_HILLSHADE_ILLUMINATION_ANCHOR> $type;

  @_$jni.internal
  Property_HILLSHADE_ILLUMINATION_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_HILLSHADE_ILLUMINATION_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_HILLSHADE_ILLUMINATION_ANCHOR>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_HILLSHADE_ILLUMINATION_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$HILLSHADE_ILLUMINATION_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_HILLSHADE_ILLUMINATION_ANCHOR.implement(
    $Property_HILLSHADE_ILLUMINATION_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_HILLSHADE_ILLUMINATION_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_HILLSHADE_ILLUMINATION_ANCHOR {
  factory $Property_HILLSHADE_ILLUMINATION_ANCHOR() =
      _$Property_HILLSHADE_ILLUMINATION_ANCHOR;
}

final class _$Property_HILLSHADE_ILLUMINATION_ANCHOR
    with $Property_HILLSHADE_ILLUMINATION_ANCHOR {
  _$Property_HILLSHADE_ILLUMINATION_ANCHOR();
}

final class $Property_HILLSHADE_ILLUMINATION_ANCHOR$Type
    extends _$jni.JObjType<Property_HILLSHADE_ILLUMINATION_ANCHOR> {
  @_$jni.internal
  const $Property_HILLSHADE_ILLUMINATION_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_HILLSHADE_ILLUMINATION_ANCHOR fromReference(
          _$jni.JReference reference) =>
      Property_HILLSHADE_ILLUMINATION_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_HILLSHADE_ILLUMINATION_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property_HILLSHADE_ILLUMINATION_ANCHOR$Type) &&
        other is $Property_HILLSHADE_ILLUMINATION_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_ANCHOR`
class Property_ICON_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_ICON_ANCHOR> $type;

  @_$jni.internal
  Property_ICON_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_ICON_ANCHOR> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_ICON_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_ICON_ANCHOR.implement(
    $Property_ICON_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_ICON_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_ICON_ANCHOR {
  factory $Property_ICON_ANCHOR() = _$Property_ICON_ANCHOR;
}

final class _$Property_ICON_ANCHOR with $Property_ICON_ANCHOR {
  _$Property_ICON_ANCHOR();
}

final class $Property_ICON_ANCHOR$Type
    extends _$jni.JObjType<Property_ICON_ANCHOR> {
  @_$jni.internal
  const $Property_ICON_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_ICON_ANCHOR fromReference(_$jni.JReference reference) =>
      Property_ICON_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_ICON_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_ANCHOR$Type) &&
        other is $Property_ICON_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_PITCH_ALIGNMENT`
class Property_ICON_PITCH_ALIGNMENT extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_ICON_PITCH_ALIGNMENT> $type;

  @_$jni.internal
  Property_ICON_PITCH_ALIGNMENT.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_PITCH_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_ICON_PITCH_ALIGNMENT> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_ICON_PITCH_ALIGNMENT $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_PITCH_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_ICON_PITCH_ALIGNMENT.implement(
    $Property_ICON_PITCH_ALIGNMENT $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_ICON_PITCH_ALIGNMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_ICON_PITCH_ALIGNMENT {
  factory $Property_ICON_PITCH_ALIGNMENT() = _$Property_ICON_PITCH_ALIGNMENT;
}

final class _$Property_ICON_PITCH_ALIGNMENT
    with $Property_ICON_PITCH_ALIGNMENT {
  _$Property_ICON_PITCH_ALIGNMENT();
}

final class $Property_ICON_PITCH_ALIGNMENT$Type
    extends _$jni.JObjType<Property_ICON_PITCH_ALIGNMENT> {
  @_$jni.internal
  const $Property_ICON_PITCH_ALIGNMENT$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT;';

  @_$jni.internal
  @_$core.override
  Property_ICON_PITCH_ALIGNMENT fromReference(_$jni.JReference reference) =>
      Property_ICON_PITCH_ALIGNMENT.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_ICON_PITCH_ALIGNMENT$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_PITCH_ALIGNMENT$Type) &&
        other is $Property_ICON_PITCH_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_ROTATION_ALIGNMENT`
class Property_ICON_ROTATION_ALIGNMENT extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_ICON_ROTATION_ALIGNMENT> $type;

  @_$jni.internal
  Property_ICON_ROTATION_ALIGNMENT.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_ROTATION_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_ICON_ROTATION_ALIGNMENT> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_ICON_ROTATION_ALIGNMENT $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_ROTATION_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_ICON_ROTATION_ALIGNMENT.implement(
    $Property_ICON_ROTATION_ALIGNMENT $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_ICON_ROTATION_ALIGNMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_ICON_ROTATION_ALIGNMENT {
  factory $Property_ICON_ROTATION_ALIGNMENT() =
      _$Property_ICON_ROTATION_ALIGNMENT;
}

final class _$Property_ICON_ROTATION_ALIGNMENT
    with $Property_ICON_ROTATION_ALIGNMENT {
  _$Property_ICON_ROTATION_ALIGNMENT();
}

final class $Property_ICON_ROTATION_ALIGNMENT$Type
    extends _$jni.JObjType<Property_ICON_ROTATION_ALIGNMENT> {
  @_$jni.internal
  const $Property_ICON_ROTATION_ALIGNMENT$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT;';

  @_$jni.internal
  @_$core.override
  Property_ICON_ROTATION_ALIGNMENT fromReference(_$jni.JReference reference) =>
      Property_ICON_ROTATION_ALIGNMENT.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_ICON_ROTATION_ALIGNMENT$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_ROTATION_ALIGNMENT$Type) &&
        other is $Property_ICON_ROTATION_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_TEXT_FIT`
class Property_ICON_TEXT_FIT extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_ICON_TEXT_FIT> $type;

  @_$jni.internal
  Property_ICON_TEXT_FIT.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_TEXT_FIT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_TEXT_FIT$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_ICON_TEXT_FIT> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_ICON_TEXT_FIT $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_TEXT_FIT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_ICON_TEXT_FIT.implement(
    $Property_ICON_TEXT_FIT $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_ICON_TEXT_FIT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_ICON_TEXT_FIT {
  factory $Property_ICON_TEXT_FIT() = _$Property_ICON_TEXT_FIT;
}

final class _$Property_ICON_TEXT_FIT with $Property_ICON_TEXT_FIT {
  _$Property_ICON_TEXT_FIT();
}

final class $Property_ICON_TEXT_FIT$Type
    extends _$jni.JObjType<Property_ICON_TEXT_FIT> {
  @_$jni.internal
  const $Property_ICON_TEXT_FIT$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TEXT_FIT;';

  @_$jni.internal
  @_$core.override
  Property_ICON_TEXT_FIT fromReference(_$jni.JReference reference) =>
      Property_ICON_TEXT_FIT.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_ICON_TEXT_FIT$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_TEXT_FIT$Type) &&
        other is $Property_ICON_TEXT_FIT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_TRANSLATE_ANCHOR`
class Property_ICON_TRANSLATE_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_ICON_TRANSLATE_ANCHOR> $type;

  @_$jni.internal
  Property_ICON_TRANSLATE_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_ICON_TRANSLATE_ANCHOR> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_ICON_TRANSLATE_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$ICON_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_ICON_TRANSLATE_ANCHOR.implement(
    $Property_ICON_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_ICON_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_ICON_TRANSLATE_ANCHOR {
  factory $Property_ICON_TRANSLATE_ANCHOR() = _$Property_ICON_TRANSLATE_ANCHOR;
}

final class _$Property_ICON_TRANSLATE_ANCHOR
    with $Property_ICON_TRANSLATE_ANCHOR {
  _$Property_ICON_TRANSLATE_ANCHOR();
}

final class $Property_ICON_TRANSLATE_ANCHOR$Type
    extends _$jni.JObjType<Property_ICON_TRANSLATE_ANCHOR> {
  @_$jni.internal
  const $Property_ICON_TRANSLATE_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_ICON_TRANSLATE_ANCHOR fromReference(_$jni.JReference reference) =>
      Property_ICON_TRANSLATE_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_ICON_TRANSLATE_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_TRANSLATE_ANCHOR$Type) &&
        other is $Property_ICON_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_CAP`
class Property_LINE_CAP extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_LINE_CAP> $type;

  @_$jni.internal
  Property_LINE_CAP.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_CAP');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_CAP$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_LINE_CAP> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_LINE_CAP $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$LINE_CAP',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_LINE_CAP.implement(
    $Property_LINE_CAP $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_LINE_CAP.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_LINE_CAP {
  factory $Property_LINE_CAP() = _$Property_LINE_CAP;
}

final class _$Property_LINE_CAP with $Property_LINE_CAP {
  _$Property_LINE_CAP();
}

final class $Property_LINE_CAP$Type extends _$jni.JObjType<Property_LINE_CAP> {
  @_$jni.internal
  const $Property_LINE_CAP$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_CAP;';

  @_$jni.internal
  @_$core.override
  Property_LINE_CAP fromReference(_$jni.JReference reference) =>
      Property_LINE_CAP.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_LINE_CAP$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_CAP$Type) &&
        other is $Property_LINE_CAP$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_JOIN`
class Property_LINE_JOIN extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_LINE_JOIN> $type;

  @_$jni.internal
  Property_LINE_JOIN.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_JOIN');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_JOIN$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_LINE_JOIN> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_LINE_JOIN $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$LINE_JOIN',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_LINE_JOIN.implement(
    $Property_LINE_JOIN $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_LINE_JOIN.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_LINE_JOIN {
  factory $Property_LINE_JOIN() = _$Property_LINE_JOIN;
}

final class _$Property_LINE_JOIN with $Property_LINE_JOIN {
  _$Property_LINE_JOIN();
}

final class $Property_LINE_JOIN$Type
    extends _$jni.JObjType<Property_LINE_JOIN> {
  @_$jni.internal
  const $Property_LINE_JOIN$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_JOIN;';

  @_$jni.internal
  @_$core.override
  Property_LINE_JOIN fromReference(_$jni.JReference reference) =>
      Property_LINE_JOIN.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_LINE_JOIN$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_JOIN$Type) &&
        other is $Property_LINE_JOIN$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_TRANSLATE_ANCHOR`
class Property_LINE_TRANSLATE_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_LINE_TRANSLATE_ANCHOR> $type;

  @_$jni.internal
  Property_LINE_TRANSLATE_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_LINE_TRANSLATE_ANCHOR> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_LINE_TRANSLATE_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$LINE_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_LINE_TRANSLATE_ANCHOR.implement(
    $Property_LINE_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_LINE_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_LINE_TRANSLATE_ANCHOR {
  factory $Property_LINE_TRANSLATE_ANCHOR() = _$Property_LINE_TRANSLATE_ANCHOR;
}

final class _$Property_LINE_TRANSLATE_ANCHOR
    with $Property_LINE_TRANSLATE_ANCHOR {
  _$Property_LINE_TRANSLATE_ANCHOR();
}

final class $Property_LINE_TRANSLATE_ANCHOR$Type
    extends _$jni.JObjType<Property_LINE_TRANSLATE_ANCHOR> {
  @_$jni.internal
  const $Property_LINE_TRANSLATE_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_LINE_TRANSLATE_ANCHOR fromReference(_$jni.JReference reference) =>
      Property_LINE_TRANSLATE_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_LINE_TRANSLATE_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_TRANSLATE_ANCHOR$Type) &&
        other is $Property_LINE_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$RASTER_RESAMPLING`
class Property_RASTER_RESAMPLING extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_RASTER_RESAMPLING> $type;

  @_$jni.internal
  Property_RASTER_RESAMPLING.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$RASTER_RESAMPLING');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_RASTER_RESAMPLING$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_RASTER_RESAMPLING> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_RASTER_RESAMPLING $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$RASTER_RESAMPLING',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_RASTER_RESAMPLING.implement(
    $Property_RASTER_RESAMPLING $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_RASTER_RESAMPLING.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_RASTER_RESAMPLING {
  factory $Property_RASTER_RESAMPLING() = _$Property_RASTER_RESAMPLING;
}

final class _$Property_RASTER_RESAMPLING with $Property_RASTER_RESAMPLING {
  _$Property_RASTER_RESAMPLING();
}

final class $Property_RASTER_RESAMPLING$Type
    extends _$jni.JObjType<Property_RASTER_RESAMPLING> {
  @_$jni.internal
  const $Property_RASTER_RESAMPLING$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$RASTER_RESAMPLING;';

  @_$jni.internal
  @_$core.override
  Property_RASTER_RESAMPLING fromReference(_$jni.JReference reference) =>
      Property_RASTER_RESAMPLING.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_RASTER_RESAMPLING$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_RASTER_RESAMPLING$Type) &&
        other is $Property_RASTER_RESAMPLING$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$SYMBOL_PLACEMENT`
class Property_SYMBOL_PLACEMENT extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_SYMBOL_PLACEMENT> $type;

  @_$jni.internal
  Property_SYMBOL_PLACEMENT.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_SYMBOL_PLACEMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_SYMBOL_PLACEMENT> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_SYMBOL_PLACEMENT $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$SYMBOL_PLACEMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_SYMBOL_PLACEMENT.implement(
    $Property_SYMBOL_PLACEMENT $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_SYMBOL_PLACEMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_SYMBOL_PLACEMENT {
  factory $Property_SYMBOL_PLACEMENT() = _$Property_SYMBOL_PLACEMENT;
}

final class _$Property_SYMBOL_PLACEMENT with $Property_SYMBOL_PLACEMENT {
  _$Property_SYMBOL_PLACEMENT();
}

final class $Property_SYMBOL_PLACEMENT$Type
    extends _$jni.JObjType<Property_SYMBOL_PLACEMENT> {
  @_$jni.internal
  const $Property_SYMBOL_PLACEMENT$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT;';

  @_$jni.internal
  @_$core.override
  Property_SYMBOL_PLACEMENT fromReference(_$jni.JReference reference) =>
      Property_SYMBOL_PLACEMENT.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_SYMBOL_PLACEMENT$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_SYMBOL_PLACEMENT$Type) &&
        other is $Property_SYMBOL_PLACEMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$SYMBOL_Z_ORDER`
class Property_SYMBOL_Z_ORDER extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_SYMBOL_Z_ORDER> $type;

  @_$jni.internal
  Property_SYMBOL_Z_ORDER.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_SYMBOL_Z_ORDER$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_SYMBOL_Z_ORDER> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_SYMBOL_Z_ORDER $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$SYMBOL_Z_ORDER',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_SYMBOL_Z_ORDER.implement(
    $Property_SYMBOL_Z_ORDER $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_SYMBOL_Z_ORDER.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_SYMBOL_Z_ORDER {
  factory $Property_SYMBOL_Z_ORDER() = _$Property_SYMBOL_Z_ORDER;
}

final class _$Property_SYMBOL_Z_ORDER with $Property_SYMBOL_Z_ORDER {
  _$Property_SYMBOL_Z_ORDER();
}

final class $Property_SYMBOL_Z_ORDER$Type
    extends _$jni.JObjType<Property_SYMBOL_Z_ORDER> {
  @_$jni.internal
  const $Property_SYMBOL_Z_ORDER$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER;';

  @_$jni.internal
  @_$core.override
  Property_SYMBOL_Z_ORDER fromReference(_$jni.JReference reference) =>
      Property_SYMBOL_Z_ORDER.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_SYMBOL_Z_ORDER$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_SYMBOL_Z_ORDER$Type) &&
        other is $Property_SYMBOL_Z_ORDER$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_ANCHOR`
class Property_TEXT_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_TEXT_ANCHOR> $type;

  @_$jni.internal
  Property_TEXT_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_TEXT_ANCHOR> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_TEXT_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_TEXT_ANCHOR.implement(
    $Property_TEXT_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_TEXT_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_TEXT_ANCHOR {
  factory $Property_TEXT_ANCHOR() = _$Property_TEXT_ANCHOR;
}

final class _$Property_TEXT_ANCHOR with $Property_TEXT_ANCHOR {
  _$Property_TEXT_ANCHOR();
}

final class $Property_TEXT_ANCHOR$Type
    extends _$jni.JObjType<Property_TEXT_ANCHOR> {
  @_$jni.internal
  const $Property_TEXT_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_TEXT_ANCHOR fromReference(_$jni.JReference reference) =>
      Property_TEXT_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_TEXT_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_ANCHOR$Type) &&
        other is $Property_TEXT_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_JUSTIFY`
class Property_TEXT_JUSTIFY extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_TEXT_JUSTIFY> $type;

  @_$jni.internal
  Property_TEXT_JUSTIFY.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_JUSTIFY');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_JUSTIFY$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_TEXT_JUSTIFY> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_TEXT_JUSTIFY $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_JUSTIFY',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_TEXT_JUSTIFY.implement(
    $Property_TEXT_JUSTIFY $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_TEXT_JUSTIFY.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_TEXT_JUSTIFY {
  factory $Property_TEXT_JUSTIFY() = _$Property_TEXT_JUSTIFY;
}

final class _$Property_TEXT_JUSTIFY with $Property_TEXT_JUSTIFY {
  _$Property_TEXT_JUSTIFY();
}

final class $Property_TEXT_JUSTIFY$Type
    extends _$jni.JObjType<Property_TEXT_JUSTIFY> {
  @_$jni.internal
  const $Property_TEXT_JUSTIFY$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_JUSTIFY;';

  @_$jni.internal
  @_$core.override
  Property_TEXT_JUSTIFY fromReference(_$jni.JReference reference) =>
      Property_TEXT_JUSTIFY.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_TEXT_JUSTIFY$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_JUSTIFY$Type) &&
        other is $Property_TEXT_JUSTIFY$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_PITCH_ALIGNMENT`
class Property_TEXT_PITCH_ALIGNMENT extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_TEXT_PITCH_ALIGNMENT> $type;

  @_$jni.internal
  Property_TEXT_PITCH_ALIGNMENT.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_PITCH_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_TEXT_PITCH_ALIGNMENT> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_TEXT_PITCH_ALIGNMENT $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_PITCH_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_TEXT_PITCH_ALIGNMENT.implement(
    $Property_TEXT_PITCH_ALIGNMENT $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_TEXT_PITCH_ALIGNMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_TEXT_PITCH_ALIGNMENT {
  factory $Property_TEXT_PITCH_ALIGNMENT() = _$Property_TEXT_PITCH_ALIGNMENT;
}

final class _$Property_TEXT_PITCH_ALIGNMENT
    with $Property_TEXT_PITCH_ALIGNMENT {
  _$Property_TEXT_PITCH_ALIGNMENT();
}

final class $Property_TEXT_PITCH_ALIGNMENT$Type
    extends _$jni.JObjType<Property_TEXT_PITCH_ALIGNMENT> {
  @_$jni.internal
  const $Property_TEXT_PITCH_ALIGNMENT$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT;';

  @_$jni.internal
  @_$core.override
  Property_TEXT_PITCH_ALIGNMENT fromReference(_$jni.JReference reference) =>
      Property_TEXT_PITCH_ALIGNMENT.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_TEXT_PITCH_ALIGNMENT$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_PITCH_ALIGNMENT$Type) &&
        other is $Property_TEXT_PITCH_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_ROTATION_ALIGNMENT`
class Property_TEXT_ROTATION_ALIGNMENT extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_TEXT_ROTATION_ALIGNMENT> $type;

  @_$jni.internal
  Property_TEXT_ROTATION_ALIGNMENT.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_ROTATION_ALIGNMENT$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_TEXT_ROTATION_ALIGNMENT> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_TEXT_ROTATION_ALIGNMENT $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_ROTATION_ALIGNMENT',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_TEXT_ROTATION_ALIGNMENT.implement(
    $Property_TEXT_ROTATION_ALIGNMENT $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_TEXT_ROTATION_ALIGNMENT.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_TEXT_ROTATION_ALIGNMENT {
  factory $Property_TEXT_ROTATION_ALIGNMENT() =
      _$Property_TEXT_ROTATION_ALIGNMENT;
}

final class _$Property_TEXT_ROTATION_ALIGNMENT
    with $Property_TEXT_ROTATION_ALIGNMENT {
  _$Property_TEXT_ROTATION_ALIGNMENT();
}

final class $Property_TEXT_ROTATION_ALIGNMENT$Type
    extends _$jni.JObjType<Property_TEXT_ROTATION_ALIGNMENT> {
  @_$jni.internal
  const $Property_TEXT_ROTATION_ALIGNMENT$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT;';

  @_$jni.internal
  @_$core.override
  Property_TEXT_ROTATION_ALIGNMENT fromReference(_$jni.JReference reference) =>
      Property_TEXT_ROTATION_ALIGNMENT.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_TEXT_ROTATION_ALIGNMENT$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_ROTATION_ALIGNMENT$Type) &&
        other is $Property_TEXT_ROTATION_ALIGNMENT$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_TRANSFORM`
class Property_TEXT_TRANSFORM extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_TEXT_TRANSFORM> $type;

  @_$jni.internal
  Property_TEXT_TRANSFORM.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_TRANSFORM');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_TRANSFORM$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_TEXT_TRANSFORM> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_TEXT_TRANSFORM $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_TRANSFORM',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_TEXT_TRANSFORM.implement(
    $Property_TEXT_TRANSFORM $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_TEXT_TRANSFORM.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_TEXT_TRANSFORM {
  factory $Property_TEXT_TRANSFORM() = _$Property_TEXT_TRANSFORM;
}

final class _$Property_TEXT_TRANSFORM with $Property_TEXT_TRANSFORM {
  _$Property_TEXT_TRANSFORM();
}

final class $Property_TEXT_TRANSFORM$Type
    extends _$jni.JObjType<Property_TEXT_TRANSFORM> {
  @_$jni.internal
  const $Property_TEXT_TRANSFORM$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSFORM;';

  @_$jni.internal
  @_$core.override
  Property_TEXT_TRANSFORM fromReference(_$jni.JReference reference) =>
      Property_TEXT_TRANSFORM.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_TEXT_TRANSFORM$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_TRANSFORM$Type) &&
        other is $Property_TEXT_TRANSFORM$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_TRANSLATE_ANCHOR`
class Property_TEXT_TRANSLATE_ANCHOR extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_TEXT_TRANSLATE_ANCHOR> $type;

  @_$jni.internal
  Property_TEXT_TRANSLATE_ANCHOR.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_TRANSLATE_ANCHOR$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_TEXT_TRANSLATE_ANCHOR> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_TEXT_TRANSLATE_ANCHOR $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_TRANSLATE_ANCHOR',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_TEXT_TRANSLATE_ANCHOR.implement(
    $Property_TEXT_TRANSLATE_ANCHOR $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_TEXT_TRANSLATE_ANCHOR.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_TEXT_TRANSLATE_ANCHOR {
  factory $Property_TEXT_TRANSLATE_ANCHOR() = _$Property_TEXT_TRANSLATE_ANCHOR;
}

final class _$Property_TEXT_TRANSLATE_ANCHOR
    with $Property_TEXT_TRANSLATE_ANCHOR {
  _$Property_TEXT_TRANSLATE_ANCHOR();
}

final class $Property_TEXT_TRANSLATE_ANCHOR$Type
    extends _$jni.JObjType<Property_TEXT_TRANSLATE_ANCHOR> {
  @_$jni.internal
  const $Property_TEXT_TRANSLATE_ANCHOR$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR;';

  @_$jni.internal
  @_$core.override
  Property_TEXT_TRANSLATE_ANCHOR fromReference(_$jni.JReference reference) =>
      Property_TEXT_TRANSLATE_ANCHOR.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_TEXT_TRANSLATE_ANCHOR$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_TRANSLATE_ANCHOR$Type) &&
        other is $Property_TEXT_TRANSLATE_ANCHOR$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_WRITING_MODE`
class Property_TEXT_WRITING_MODE extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_TEXT_WRITING_MODE> $type;

  @_$jni.internal
  Property_TEXT_WRITING_MODE.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_WRITING_MODE');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_WRITING_MODE$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_TEXT_WRITING_MODE> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_TEXT_WRITING_MODE $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$TEXT_WRITING_MODE',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_TEXT_WRITING_MODE.implement(
    $Property_TEXT_WRITING_MODE $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_TEXT_WRITING_MODE.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_TEXT_WRITING_MODE {
  factory $Property_TEXT_WRITING_MODE() = _$Property_TEXT_WRITING_MODE;
}

final class _$Property_TEXT_WRITING_MODE with $Property_TEXT_WRITING_MODE {
  _$Property_TEXT_WRITING_MODE();
}

final class $Property_TEXT_WRITING_MODE$Type
    extends _$jni.JObjType<Property_TEXT_WRITING_MODE> {
  @_$jni.internal
  const $Property_TEXT_WRITING_MODE$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_WRITING_MODE;';

  @_$jni.internal
  @_$core.override
  Property_TEXT_WRITING_MODE fromReference(_$jni.JReference reference) =>
      Property_TEXT_WRITING_MODE.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_TEXT_WRITING_MODE$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_WRITING_MODE$Type) &&
        other is $Property_TEXT_WRITING_MODE$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property$VISIBILITY`
class Property_VISIBILITY extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property_VISIBILITY> $type;

  @_$jni.internal
  Property_VISIBILITY.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$VISIBILITY');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_VISIBILITY$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Property_VISIBILITY> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Property_VISIBILITY $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.style.layers.Property$VISIBILITY',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Property_VISIBILITY.implement(
    $Property_VISIBILITY $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Property_VISIBILITY.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Property_VISIBILITY {
  factory $Property_VISIBILITY() = _$Property_VISIBILITY;
}

final class _$Property_VISIBILITY with $Property_VISIBILITY {
  _$Property_VISIBILITY();
}

final class $Property_VISIBILITY$Type
    extends _$jni.JObjType<Property_VISIBILITY> {
  @_$jni.internal
  const $Property_VISIBILITY$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$VISIBILITY;';

  @_$jni.internal
  @_$core.override
  Property_VISIBILITY fromReference(_$jni.JReference reference) =>
      Property_VISIBILITY.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property_VISIBILITY$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_VISIBILITY$Type) &&
        other is $Property_VISIBILITY$Type;
  }
}

/// from: `org.maplibre.android.style.layers.Property`
class Property extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Property> $type;

  @_$jni.internal
  Property.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'org/maplibre/android/style/layers/Property');

  /// The type which includes information such as the signature of this class.
  static const type = $Property$Type();
  static final _id_VISIBLE = _class.staticFieldId(
    r'VISIBLE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VISIBLE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get VISIBLE =>
      _id_VISIBLE.get(_class, const _$jni.JStringType());

  static final _id_NONE = _class.staticFieldId(
    r'NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get NONE =>
      _id_NONE.get(_class, const _$jni.JStringType());

  static final _id_LINE_CAP_BUTT = _class.staticFieldId(
    r'LINE_CAP_BUTT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_BUTT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get LINE_CAP_BUTT =>
      _id_LINE_CAP_BUTT.get(_class, const _$jni.JStringType());

  static final _id_LINE_CAP_ROUND = _class.staticFieldId(
    r'LINE_CAP_ROUND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get LINE_CAP_ROUND =>
      _id_LINE_CAP_ROUND.get(_class, const _$jni.JStringType());

  static final _id_LINE_CAP_SQUARE = _class.staticFieldId(
    r'LINE_CAP_SQUARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_SQUARE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get LINE_CAP_SQUARE =>
      _id_LINE_CAP_SQUARE.get(_class, const _$jni.JStringType());

  static final _id_LINE_JOIN_BEVEL = _class.staticFieldId(
    r'LINE_JOIN_BEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_BEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get LINE_JOIN_BEVEL =>
      _id_LINE_JOIN_BEVEL.get(_class, const _$jni.JStringType());

  static final _id_LINE_JOIN_ROUND = _class.staticFieldId(
    r'LINE_JOIN_ROUND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get LINE_JOIN_ROUND =>
      _id_LINE_JOIN_ROUND.get(_class, const _$jni.JStringType());

  static final _id_LINE_JOIN_MITER = _class.staticFieldId(
    r'LINE_JOIN_MITER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_MITER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get LINE_JOIN_MITER =>
      _id_LINE_JOIN_MITER.get(_class, const _$jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_POINT = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_POINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_POINT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SYMBOL_PLACEMENT_POINT =>
      _id_SYMBOL_PLACEMENT_POINT.get(_class, const _$jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_LINE = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_LINE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_LINE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SYMBOL_PLACEMENT_LINE =>
      _id_SYMBOL_PLACEMENT_LINE.get(_class, const _$jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_LINE_CENTER = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_LINE_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_LINE_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SYMBOL_PLACEMENT_LINE_CENTER =>
      _id_SYMBOL_PLACEMENT_LINE_CENTER.get(_class, const _$jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_AUTO = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SYMBOL_Z_ORDER_AUTO =>
      _id_SYMBOL_Z_ORDER_AUTO.get(_class, const _$jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_VIEWPORT_Y = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_VIEWPORT_Y',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_VIEWPORT_Y`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SYMBOL_Z_ORDER_VIEWPORT_Y =>
      _id_SYMBOL_Z_ORDER_VIEWPORT_Y.get(_class, const _$jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_SOURCE = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_SOURCE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_SOURCE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SYMBOL_Z_ORDER_SOURCE =>
      _id_SYMBOL_Z_ORDER_SOURCE.get(_class, const _$jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_MAP = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ROTATION_ALIGNMENT_MAP =>
      _id_ICON_ROTATION_ALIGNMENT_MAP.get(_class, const _$jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ROTATION_ALIGNMENT_VIEWPORT =>
      _id_ICON_ROTATION_ALIGNMENT_VIEWPORT.get(
          _class, const _$jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_AUTO = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ROTATION_ALIGNMENT_AUTO =>
      _id_ICON_ROTATION_ALIGNMENT_AUTO.get(_class, const _$jni.JStringType());

  static final _id_ICON_TEXT_FIT_NONE = _class.staticFieldId(
    r'ICON_TEXT_FIT_NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_TEXT_FIT_NONE =>
      _id_ICON_TEXT_FIT_NONE.get(_class, const _$jni.JStringType());

  static final _id_ICON_TEXT_FIT_WIDTH = _class.staticFieldId(
    r'ICON_TEXT_FIT_WIDTH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_WIDTH`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_TEXT_FIT_WIDTH =>
      _id_ICON_TEXT_FIT_WIDTH.get(_class, const _$jni.JStringType());

  static final _id_ICON_TEXT_FIT_HEIGHT = _class.staticFieldId(
    r'ICON_TEXT_FIT_HEIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_HEIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_TEXT_FIT_HEIGHT =>
      _id_ICON_TEXT_FIT_HEIGHT.get(_class, const _$jni.JStringType());

  static final _id_ICON_TEXT_FIT_BOTH = _class.staticFieldId(
    r'ICON_TEXT_FIT_BOTH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_BOTH`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_TEXT_FIT_BOTH =>
      _id_ICON_TEXT_FIT_BOTH.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_CENTER = _class.staticFieldId(
    r'ICON_ANCHOR_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_CENTER =>
      _id_ICON_ANCHOR_CENTER.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_LEFT =>
      _id_ICON_ANCHOR_LEFT.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_RIGHT =>
      _id_ICON_ANCHOR_RIGHT.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_TOP = _class.staticFieldId(
    r'ICON_ANCHOR_TOP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_TOP =>
      _id_ICON_ANCHOR_TOP.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_BOTTOM =>
      _id_ICON_ANCHOR_BOTTOM.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_TOP_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_TOP_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_TOP_LEFT =>
      _id_ICON_ANCHOR_TOP_LEFT.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_TOP_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_TOP_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_TOP_RIGHT =>
      _id_ICON_ANCHOR_TOP_RIGHT.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_BOTTOM_LEFT =>
      _id_ICON_ANCHOR_BOTTOM_LEFT.get(_class, const _$jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_ANCHOR_BOTTOM_RIGHT =>
      _id_ICON_ANCHOR_BOTTOM_RIGHT.get(_class, const _$jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_PITCH_ALIGNMENT_MAP =>
      _id_ICON_PITCH_ALIGNMENT_MAP.get(_class, const _$jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_PITCH_ALIGNMENT_VIEWPORT =>
      _id_ICON_PITCH_ALIGNMENT_VIEWPORT.get(_class, const _$jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_AUTO = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_PITCH_ALIGNMENT_AUTO =>
      _id_ICON_PITCH_ALIGNMENT_AUTO.get(_class, const _$jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_PITCH_ALIGNMENT_MAP =>
      _id_TEXT_PITCH_ALIGNMENT_MAP.get(_class, const _$jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_PITCH_ALIGNMENT_VIEWPORT =>
      _id_TEXT_PITCH_ALIGNMENT_VIEWPORT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_AUTO = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_PITCH_ALIGNMENT_AUTO =>
      _id_TEXT_PITCH_ALIGNMENT_AUTO.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_MAP = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ROTATION_ALIGNMENT_MAP =>
      _id_TEXT_ROTATION_ALIGNMENT_MAP.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ROTATION_ALIGNMENT_VIEWPORT =>
      _id_TEXT_ROTATION_ALIGNMENT_VIEWPORT.get(
          _class, const _$jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_AUTO = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ROTATION_ALIGNMENT_AUTO =>
      _id_TEXT_ROTATION_ALIGNMENT_AUTO.get(_class, const _$jni.JStringType());

  static final _id_TEXT_JUSTIFY_AUTO = _class.staticFieldId(
    r'TEXT_JUSTIFY_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_JUSTIFY_AUTO =>
      _id_TEXT_JUSTIFY_AUTO.get(_class, const _$jni.JStringType());

  static final _id_TEXT_JUSTIFY_LEFT = _class.staticFieldId(
    r'TEXT_JUSTIFY_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_JUSTIFY_LEFT =>
      _id_TEXT_JUSTIFY_LEFT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_JUSTIFY_CENTER = _class.staticFieldId(
    r'TEXT_JUSTIFY_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_JUSTIFY_CENTER =>
      _id_TEXT_JUSTIFY_CENTER.get(_class, const _$jni.JStringType());

  static final _id_TEXT_JUSTIFY_RIGHT = _class.staticFieldId(
    r'TEXT_JUSTIFY_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_JUSTIFY_RIGHT =>
      _id_TEXT_JUSTIFY_RIGHT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_CENTER = _class.staticFieldId(
    r'TEXT_ANCHOR_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_CENTER =>
      _id_TEXT_ANCHOR_CENTER.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_LEFT =>
      _id_TEXT_ANCHOR_LEFT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_RIGHT =>
      _id_TEXT_ANCHOR_RIGHT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_TOP =>
      _id_TEXT_ANCHOR_TOP.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_BOTTOM =>
      _id_TEXT_ANCHOR_BOTTOM.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_TOP_LEFT =>
      _id_TEXT_ANCHOR_TOP_LEFT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_TOP_RIGHT =>
      _id_TEXT_ANCHOR_TOP_RIGHT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_BOTTOM_LEFT =>
      _id_TEXT_ANCHOR_BOTTOM_LEFT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_ANCHOR_BOTTOM_RIGHT =>
      _id_TEXT_ANCHOR_BOTTOM_RIGHT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_TRANSFORM_NONE = _class.staticFieldId(
    r'TEXT_TRANSFORM_NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_TRANSFORM_NONE =>
      _id_TEXT_TRANSFORM_NONE.get(_class, const _$jni.JStringType());

  static final _id_TEXT_TRANSFORM_UPPERCASE = _class.staticFieldId(
    r'TEXT_TRANSFORM_UPPERCASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_UPPERCASE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_TRANSFORM_UPPERCASE =>
      _id_TEXT_TRANSFORM_UPPERCASE.get(_class, const _$jni.JStringType());

  static final _id_TEXT_TRANSFORM_LOWERCASE = _class.staticFieldId(
    r'TEXT_TRANSFORM_LOWERCASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_LOWERCASE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_TRANSFORM_LOWERCASE =>
      _id_TEXT_TRANSFORM_LOWERCASE.get(_class, const _$jni.JStringType());

  static final _id_FILL_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'FILL_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get FILL_TRANSLATE_ANCHOR_MAP =>
      _id_FILL_TRANSLATE_ANCHOR_MAP.get(_class, const _$jni.JStringType());

  static final _id_FILL_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'FILL_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get FILL_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_FILL_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const _$jni.JStringType());

  static final _id_LINE_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'LINE_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get LINE_TRANSLATE_ANCHOR_MAP =>
      _id_LINE_TRANSLATE_ANCHOR_MAP.get(_class, const _$jni.JStringType());

  static final _id_LINE_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'LINE_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get LINE_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_LINE_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const _$jni.JStringType());

  static final _id_ICON_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'ICON_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_TRANSLATE_ANCHOR_MAP =>
      _id_ICON_TRANSLATE_ANCHOR_MAP.get(_class, const _$jni.JStringType());

  static final _id_ICON_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'ICON_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ICON_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_ICON_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'TEXT_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_TRANSLATE_ANCHOR_MAP =>
      _id_TEXT_TRANSLATE_ANCHOR_MAP.get(_class, const _$jni.JStringType());

  static final _id_TEXT_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'TEXT_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_TEXT_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const _$jni.JStringType());

  static final _id_CIRCLE_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'CIRCLE_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CIRCLE_TRANSLATE_ANCHOR_MAP =>
      _id_CIRCLE_TRANSLATE_ANCHOR_MAP.get(_class, const _$jni.JStringType());

  static final _id_CIRCLE_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CIRCLE_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_CIRCLE_TRANSLATE_ANCHOR_VIEWPORT.get(
          _class, const _$jni.JStringType());

  static final _id_CIRCLE_PITCH_SCALE_MAP = _class.staticFieldId(
    r'CIRCLE_PITCH_SCALE_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_SCALE_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CIRCLE_PITCH_SCALE_MAP =>
      _id_CIRCLE_PITCH_SCALE_MAP.get(_class, const _$jni.JStringType());

  static final _id_CIRCLE_PITCH_SCALE_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_PITCH_SCALE_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_SCALE_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CIRCLE_PITCH_SCALE_VIEWPORT =>
      _id_CIRCLE_PITCH_SCALE_VIEWPORT.get(_class, const _$jni.JStringType());

  static final _id_CIRCLE_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'CIRCLE_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CIRCLE_PITCH_ALIGNMENT_MAP =>
      _id_CIRCLE_PITCH_ALIGNMENT_MAP.get(_class, const _$jni.JStringType());

  static final _id_CIRCLE_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CIRCLE_PITCH_ALIGNMENT_VIEWPORT =>
      _id_CIRCLE_PITCH_ALIGNMENT_VIEWPORT.get(
          _class, const _$jni.JStringType());

  static final _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP =>
      _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP.get(
          _class, const _$jni.JStringType());

  static final _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT =
      _class.staticFieldId(
    r'FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT.get(
          _class, const _$jni.JStringType());

  static final _id_RASTER_RESAMPLING_LINEAR = _class.staticFieldId(
    r'RASTER_RESAMPLING_LINEAR',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RASTER_RESAMPLING_LINEAR`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get RASTER_RESAMPLING_LINEAR =>
      _id_RASTER_RESAMPLING_LINEAR.get(_class, const _$jni.JStringType());

  static final _id_RASTER_RESAMPLING_NEAREST = _class.staticFieldId(
    r'RASTER_RESAMPLING_NEAREST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RASTER_RESAMPLING_NEAREST`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get RASTER_RESAMPLING_NEAREST =>
      _id_RASTER_RESAMPLING_NEAREST.get(_class, const _$jni.JStringType());

  static final _id_HILLSHADE_ILLUMINATION_ANCHOR_MAP = _class.staticFieldId(
    r'HILLSHADE_ILLUMINATION_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HILLSHADE_ILLUMINATION_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get HILLSHADE_ILLUMINATION_ANCHOR_MAP =>
      _id_HILLSHADE_ILLUMINATION_ANCHOR_MAP.get(
          _class, const _$jni.JStringType());

  static final _id_HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT =
      _class.staticFieldId(
    r'HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT =>
      _id_HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT.get(
          _class, const _$jni.JStringType());

  static final _id_ANCHOR_MAP = _class.staticFieldId(
    r'ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ANCHOR_MAP =>
      _id_ANCHOR_MAP.get(_class, const _$jni.JStringType());

  static final _id_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ANCHOR_VIEWPORT =>
      _id_ANCHOR_VIEWPORT.get(_class, const _$jni.JStringType());

  static final _id_TEXT_WRITING_MODE_HORIZONTAL = _class.staticFieldId(
    r'TEXT_WRITING_MODE_HORIZONTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_WRITING_MODE_HORIZONTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_WRITING_MODE_HORIZONTAL =>
      _id_TEXT_WRITING_MODE_HORIZONTAL.get(_class, const _$jni.JStringType());

  static final _id_TEXT_WRITING_MODE_VERTICAL = _class.staticFieldId(
    r'TEXT_WRITING_MODE_VERTICAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_WRITING_MODE_VERTICAL`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TEXT_WRITING_MODE_VERTICAL =>
      _id_TEXT_WRITING_MODE_VERTICAL.get(_class, const _$jni.JStringType());
}

final class $Property$Type extends _$jni.JObjType<Property> {
  @_$jni.internal
  const $Property$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lorg/maplibre/android/style/layers/Property;';

  @_$jni.internal
  @_$core.override
  Property fromReference(_$jni.JReference reference) =>
      Property.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Property$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property$Type) && other is $Property$Type;
  }
}
