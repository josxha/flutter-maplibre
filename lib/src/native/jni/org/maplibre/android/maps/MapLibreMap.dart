// Autogenerated by jnigen. DO NOT EDIT!

// coverage:ignore-file
// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;

import '../../../../android/graphics/PointF.dart' as pointf_;

import '../../geojson/Feature.dart' as feature_;

import '../camera/CameraPosition.dart' as cameraposition_;

import '../camera/CameraUpdate.dart' as cameraupdate_;

import '../geometry/LatLng.dart' as latlng_;

import '../geometry/LatLngBounds.dart' as latlngbounds_;

import '../location/LocationComponent.dart' as locationcomponent_;

import '../offline/OfflineRegionDefinition.dart' as offlineregiondefinition_;

import 'Projection.dart' as projection_;

import 'Style.dart' as style_;

import 'UiSettings.dart' as uisettings_;

/// from: `org.maplibre.android.maps.MapLibreMap$CancelableCallback`
class MapLibreMap_CancelableCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_CancelableCallback> $type;

  @_$jni.internal
  MapLibreMap_CancelableCallback.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$CancelableCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_CancelableCallback$Type();
  static final _id_onCancel = _class.instanceMethodId(
    r'onCancel',
    r'()V',
  );

  static final _onCancel = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCancel()`
  void onCancel() {
    _onCancel(reference.pointer, _id_onCancel as _$jni.JMethodIDPtr).check();
  }

  static final _id_onFinish = _class.instanceMethodId(
    r'onFinish',
    r'()V',
  );

  static final _onFinish = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onFinish()`
  void onFinish() {
    _onFinish(reference.pointer, _id_onFinish as _$jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_CancelableCallback> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCancel()V') {
        _$impls[$p]!.onCancel();
        return _$jni.nullptr;
      }
      if ($d == r'onFinish()V') {
        _$impls[$p]!.onFinish();
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_CancelableCallback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$CancelableCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onCancel$async) r'onCancel()V',
        if ($impl.onFinish$async) r'onFinish()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_CancelableCallback.implement(
    $MapLibreMap_CancelableCallback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_CancelableCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_CancelableCallback {
  factory $MapLibreMap_CancelableCallback({
    required void Function() onCancel,
    bool onCancel$async,
    required void Function() onFinish,
    bool onFinish$async,
  }) = _$MapLibreMap_CancelableCallback;

  void onCancel();
  bool get onCancel$async => false;
  void onFinish();
  bool get onFinish$async => false;
}

final class _$MapLibreMap_CancelableCallback
    with $MapLibreMap_CancelableCallback {
  _$MapLibreMap_CancelableCallback({
    required void Function() onCancel,
    this.onCancel$async = false,
    required void Function() onFinish,
    this.onFinish$async = false,
  })  : _onCancel = onCancel,
        _onFinish = onFinish;

  final void Function() _onCancel;
  final bool onCancel$async;
  final void Function() _onFinish;
  final bool onFinish$async;

  void onCancel() {
    return _onCancel();
  }

  void onFinish() {
    return _onFinish();
  }
}

final class $MapLibreMap_CancelableCallback$Type
    extends _$jni.JObjType<MapLibreMap_CancelableCallback> {
  @_$jni.internal
  const $MapLibreMap_CancelableCallback$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_CancelableCallback fromReference(_$jni.JReference reference) =>
      MapLibreMap_CancelableCallback.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_CancelableCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_CancelableCallback$Type) &&
        other is $MapLibreMap_CancelableCallback$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter`
class MapLibreMap_InfoWindowAdapter extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_InfoWindowAdapter> $type;

  @_$jni.internal
  MapLibreMap_InfoWindowAdapter.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$InfoWindowAdapter');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_InfoWindowAdapter$Type();
  static final _id_getInfoWindow = _class.instanceMethodId(
    r'getInfoWindow',
    r'(Lorg/maplibre/android/annotations/Marker;)Landroid/view/View;',
  );

  static final _getInfoWindow = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract android.view.View getInfoWindow(org.maplibre.android.annotations.Marker marker)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject getInfoWindow(
    _$jni.JObject marker,
  ) {
    return _getInfoWindow(reference.pointer,
            _id_getInfoWindow as _$jni.JMethodIDPtr, marker.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_InfoWindowAdapter> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'getInfoWindow(Lorg/maplibre/android/annotations/Marker;)Landroid/view/View;') {
        final $r = _$impls[$p]!.getInfoWindow(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as _$jni.JObject)
            .as(const _$jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_InfoWindowAdapter $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_InfoWindowAdapter.implement(
    $MapLibreMap_InfoWindowAdapter $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_InfoWindowAdapter.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_InfoWindowAdapter {
  factory $MapLibreMap_InfoWindowAdapter({
    required _$jni.JObject Function(_$jni.JObject marker) getInfoWindow,
  }) = _$MapLibreMap_InfoWindowAdapter;

  _$jni.JObject getInfoWindow(_$jni.JObject marker);
}

final class _$MapLibreMap_InfoWindowAdapter
    with $MapLibreMap_InfoWindowAdapter {
  _$MapLibreMap_InfoWindowAdapter({
    required _$jni.JObject Function(_$jni.JObject marker) getInfoWindow,
  }) : _getInfoWindow = getInfoWindow;

  final _$jni.JObject Function(_$jni.JObject marker) _getInfoWindow;

  _$jni.JObject getInfoWindow(_$jni.JObject marker) {
    return _getInfoWindow(marker);
  }
}

final class $MapLibreMap_InfoWindowAdapter$Type
    extends _$jni.JObjType<MapLibreMap_InfoWindowAdapter> {
  @_$jni.internal
  const $MapLibreMap_InfoWindowAdapter$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_InfoWindowAdapter fromReference(_$jni.JReference reference) =>
      MapLibreMap_InfoWindowAdapter.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_InfoWindowAdapter$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_InfoWindowAdapter$Type) &&
        other is $MapLibreMap_InfoWindowAdapter$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener`
class MapLibreMap_OnCameraIdleListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnCameraIdleListener> $type;

  @_$jni.internal
  MapLibreMap_OnCameraIdleListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCameraIdleListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCameraIdleListener$Type();
  static final _id_onCameraIdle = _class.instanceMethodId(
    r'onCameraIdle',
    r'()V',
  );

  static final _onCameraIdle = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCameraIdle()`
  void onCameraIdle() {
    _onCameraIdle(reference.pointer, _id_onCameraIdle as _$jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnCameraIdleListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraIdle()V') {
        _$impls[$p]!.onCameraIdle();
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnCameraIdleListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCameraIdle$async) r'onCameraIdle()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnCameraIdleListener.implement(
    $MapLibreMap_OnCameraIdleListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnCameraIdleListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnCameraIdleListener {
  factory $MapLibreMap_OnCameraIdleListener({
    required void Function() onCameraIdle,
    bool onCameraIdle$async,
  }) = _$MapLibreMap_OnCameraIdleListener;

  void onCameraIdle();
  bool get onCameraIdle$async => false;
}

final class _$MapLibreMap_OnCameraIdleListener
    with $MapLibreMap_OnCameraIdleListener {
  _$MapLibreMap_OnCameraIdleListener({
    required void Function() onCameraIdle,
    this.onCameraIdle$async = false,
  }) : _onCameraIdle = onCameraIdle;

  final void Function() _onCameraIdle;
  final bool onCameraIdle$async;

  void onCameraIdle() {
    return _onCameraIdle();
  }
}

final class $MapLibreMap_OnCameraIdleListener$Type
    extends _$jni.JObjType<MapLibreMap_OnCameraIdleListener> {
  @_$jni.internal
  const $MapLibreMap_OnCameraIdleListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnCameraIdleListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnCameraIdleListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnCameraIdleListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnCameraIdleListener$Type) &&
        other is $MapLibreMap_OnCameraIdleListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener`
class MapLibreMap_OnCameraMoveCanceledListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnCameraMoveCanceledListener> $type;

  @_$jni.internal
  MapLibreMap_OnCameraMoveCanceledListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCameraMoveCanceledListener$Type();
  static final _id_onCameraMoveCanceled = _class.instanceMethodId(
    r'onCameraMoveCanceled',
    r'()V',
  );

  static final _onCameraMoveCanceled = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCameraMoveCanceled()`
  void onCameraMoveCanceled() {
    _onCameraMoveCanceled(
            reference.pointer, _id_onCameraMoveCanceled as _$jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnCameraMoveCanceledListener>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMoveCanceled()V') {
        _$impls[$p]!.onCameraMoveCanceled();
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnCameraMoveCanceledListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCameraMoveCanceled$async) r'onCameraMoveCanceled()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnCameraMoveCanceledListener.implement(
    $MapLibreMap_OnCameraMoveCanceledListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnCameraMoveCanceledListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnCameraMoveCanceledListener {
  factory $MapLibreMap_OnCameraMoveCanceledListener({
    required void Function() onCameraMoveCanceled,
    bool onCameraMoveCanceled$async,
  }) = _$MapLibreMap_OnCameraMoveCanceledListener;

  void onCameraMoveCanceled();
  bool get onCameraMoveCanceled$async => false;
}

final class _$MapLibreMap_OnCameraMoveCanceledListener
    with $MapLibreMap_OnCameraMoveCanceledListener {
  _$MapLibreMap_OnCameraMoveCanceledListener({
    required void Function() onCameraMoveCanceled,
    this.onCameraMoveCanceled$async = false,
  }) : _onCameraMoveCanceled = onCameraMoveCanceled;

  final void Function() _onCameraMoveCanceled;
  final bool onCameraMoveCanceled$async;

  void onCameraMoveCanceled() {
    return _onCameraMoveCanceled();
  }
}

final class $MapLibreMap_OnCameraMoveCanceledListener$Type
    extends _$jni.JObjType<MapLibreMap_OnCameraMoveCanceledListener> {
  @_$jni.internal
  const $MapLibreMap_OnCameraMoveCanceledListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnCameraMoveCanceledListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnCameraMoveCanceledListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnCameraMoveCanceledListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnCameraMoveCanceledListener$Type) &&
        other is $MapLibreMap_OnCameraMoveCanceledListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener`
class MapLibreMap_OnCameraMoveListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnCameraMoveListener> $type;

  @_$jni.internal
  MapLibreMap_OnCameraMoveListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCameraMoveListener$Type();
  static final _id_onCameraMove = _class.instanceMethodId(
    r'onCameraMove',
    r'()V',
  );

  static final _onCameraMove = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCameraMove()`
  void onCameraMove() {
    _onCameraMove(reference.pointer, _id_onCameraMove as _$jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnCameraMoveListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMove()V') {
        _$impls[$p]!.onCameraMove();
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnCameraMoveListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCameraMove$async) r'onCameraMove()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnCameraMoveListener.implement(
    $MapLibreMap_OnCameraMoveListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnCameraMoveListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnCameraMoveListener {
  factory $MapLibreMap_OnCameraMoveListener({
    required void Function() onCameraMove,
    bool onCameraMove$async,
  }) = _$MapLibreMap_OnCameraMoveListener;

  void onCameraMove();
  bool get onCameraMove$async => false;
}

final class _$MapLibreMap_OnCameraMoveListener
    with $MapLibreMap_OnCameraMoveListener {
  _$MapLibreMap_OnCameraMoveListener({
    required void Function() onCameraMove,
    this.onCameraMove$async = false,
  }) : _onCameraMove = onCameraMove;

  final void Function() _onCameraMove;
  final bool onCameraMove$async;

  void onCameraMove() {
    return _onCameraMove();
  }
}

final class $MapLibreMap_OnCameraMoveListener$Type
    extends _$jni.JObjType<MapLibreMap_OnCameraMoveListener> {
  @_$jni.internal
  const $MapLibreMap_OnCameraMoveListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnCameraMoveListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnCameraMoveListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnCameraMoveListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnCameraMoveListener$Type) &&
        other is $MapLibreMap_OnCameraMoveListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener`
class MapLibreMap_OnCameraMoveStartedListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnCameraMoveStartedListener> $type;

  @_$jni.internal
  MapLibreMap_OnCameraMoveStartedListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCameraMoveStartedListener$Type();

  /// from: `static public final int REASON_API_GESTURE`
  static const REASON_API_GESTURE = 1;

  /// from: `static public final int REASON_DEVELOPER_ANIMATION`
  static const REASON_DEVELOPER_ANIMATION = 2;

  /// from: `static public final int REASON_API_ANIMATION`
  static const REASON_API_ANIMATION = 3;
  static final _id_onCameraMoveStarted = _class.instanceMethodId(
    r'onCameraMoveStarted',
    r'(I)V',
  );

  static final _onCameraMoveStarted = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public abstract void onCameraMoveStarted(int i)`
  void onCameraMoveStarted(
    int i,
  ) {
    _onCameraMoveStarted(
            reference.pointer, _id_onCameraMoveStarted as _$jni.JMethodIDPtr, i)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnCameraMoveStartedListener>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMoveStarted(I)V') {
        _$impls[$p]!.onCameraMoveStarted(
          $a[0]
              .as(const _$jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnCameraMoveStartedListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCameraMoveStarted$async) r'onCameraMoveStarted(I)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnCameraMoveStartedListener.implement(
    $MapLibreMap_OnCameraMoveStartedListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnCameraMoveStartedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnCameraMoveStartedListener {
  factory $MapLibreMap_OnCameraMoveStartedListener({
    required void Function(int i) onCameraMoveStarted,
    bool onCameraMoveStarted$async,
  }) = _$MapLibreMap_OnCameraMoveStartedListener;

  void onCameraMoveStarted(int i);
  bool get onCameraMoveStarted$async => false;
}

final class _$MapLibreMap_OnCameraMoveStartedListener
    with $MapLibreMap_OnCameraMoveStartedListener {
  _$MapLibreMap_OnCameraMoveStartedListener({
    required void Function(int i) onCameraMoveStarted,
    this.onCameraMoveStarted$async = false,
  }) : _onCameraMoveStarted = onCameraMoveStarted;

  final void Function(int i) _onCameraMoveStarted;
  final bool onCameraMoveStarted$async;

  void onCameraMoveStarted(int i) {
    return _onCameraMoveStarted(i);
  }
}

final class $MapLibreMap_OnCameraMoveStartedListener$Type
    extends _$jni.JObjType<MapLibreMap_OnCameraMoveStartedListener> {
  @_$jni.internal
  const $MapLibreMap_OnCameraMoveStartedListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnCameraMoveStartedListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnCameraMoveStartedListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnCameraMoveStartedListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnCameraMoveStartedListener$Type) &&
        other is $MapLibreMap_OnCameraMoveStartedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCompassAnimationListener`
class MapLibreMap_OnCompassAnimationListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnCompassAnimationListener> $type;

  @_$jni.internal
  MapLibreMap_OnCompassAnimationListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCompassAnimationListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCompassAnimationListener$Type();
  static final _id_onCompassAnimation = _class.instanceMethodId(
    r'onCompassAnimation',
    r'()V',
  );

  static final _onCompassAnimation = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCompassAnimation()`
  void onCompassAnimation() {
    _onCompassAnimation(
            reference.pointer, _id_onCompassAnimation as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCompassAnimationFinished = _class.instanceMethodId(
    r'onCompassAnimationFinished',
    r'()V',
  );

  static final _onCompassAnimationFinished =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public abstract void onCompassAnimationFinished()`
  void onCompassAnimationFinished() {
    _onCompassAnimationFinished(reference.pointer,
            _id_onCompassAnimationFinished as _$jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnCompassAnimationListener>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCompassAnimation()V') {
        _$impls[$p]!.onCompassAnimation();
        return _$jni.nullptr;
      }
      if ($d == r'onCompassAnimationFinished()V') {
        _$impls[$p]!.onCompassAnimationFinished();
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnCompassAnimationListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnCompassAnimationListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCompassAnimation$async) r'onCompassAnimation()V',
        if ($impl.onCompassAnimationFinished$async)
          r'onCompassAnimationFinished()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnCompassAnimationListener.implement(
    $MapLibreMap_OnCompassAnimationListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnCompassAnimationListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnCompassAnimationListener {
  factory $MapLibreMap_OnCompassAnimationListener({
    required void Function() onCompassAnimation,
    bool onCompassAnimation$async,
    required void Function() onCompassAnimationFinished,
    bool onCompassAnimationFinished$async,
  }) = _$MapLibreMap_OnCompassAnimationListener;

  void onCompassAnimation();
  bool get onCompassAnimation$async => false;
  void onCompassAnimationFinished();
  bool get onCompassAnimationFinished$async => false;
}

final class _$MapLibreMap_OnCompassAnimationListener
    with $MapLibreMap_OnCompassAnimationListener {
  _$MapLibreMap_OnCompassAnimationListener({
    required void Function() onCompassAnimation,
    this.onCompassAnimation$async = false,
    required void Function() onCompassAnimationFinished,
    this.onCompassAnimationFinished$async = false,
  })  : _onCompassAnimation = onCompassAnimation,
        _onCompassAnimationFinished = onCompassAnimationFinished;

  final void Function() _onCompassAnimation;
  final bool onCompassAnimation$async;
  final void Function() _onCompassAnimationFinished;
  final bool onCompassAnimationFinished$async;

  void onCompassAnimation() {
    return _onCompassAnimation();
  }

  void onCompassAnimationFinished() {
    return _onCompassAnimationFinished();
  }
}

final class $MapLibreMap_OnCompassAnimationListener$Type
    extends _$jni.JObjType<MapLibreMap_OnCompassAnimationListener> {
  @_$jni.internal
  const $MapLibreMap_OnCompassAnimationListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCompassAnimationListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnCompassAnimationListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnCompassAnimationListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnCompassAnimationListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnCompassAnimationListener$Type) &&
        other is $MapLibreMap_OnCompassAnimationListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnDeveloperAnimationListener`
class MapLibreMap_OnDeveloperAnimationListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnDeveloperAnimationListener> $type;

  @_$jni.internal
  MapLibreMap_OnDeveloperAnimationListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnDeveloperAnimationListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnDeveloperAnimationListener$Type();
  static final _id_onDeveloperAnimationStarted = _class.instanceMethodId(
    r'onDeveloperAnimationStarted',
    r'()V',
  );

  static final _onDeveloperAnimationStarted =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public abstract void onDeveloperAnimationStarted()`
  void onDeveloperAnimationStarted() {
    _onDeveloperAnimationStarted(reference.pointer,
            _id_onDeveloperAnimationStarted as _$jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnDeveloperAnimationListener>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDeveloperAnimationStarted()V') {
        _$impls[$p]!.onDeveloperAnimationStarted();
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnDeveloperAnimationListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnDeveloperAnimationListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onDeveloperAnimationStarted$async)
          r'onDeveloperAnimationStarted()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnDeveloperAnimationListener.implement(
    $MapLibreMap_OnDeveloperAnimationListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnDeveloperAnimationListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnDeveloperAnimationListener {
  factory $MapLibreMap_OnDeveloperAnimationListener({
    required void Function() onDeveloperAnimationStarted,
    bool onDeveloperAnimationStarted$async,
  }) = _$MapLibreMap_OnDeveloperAnimationListener;

  void onDeveloperAnimationStarted();
  bool get onDeveloperAnimationStarted$async => false;
}

final class _$MapLibreMap_OnDeveloperAnimationListener
    with $MapLibreMap_OnDeveloperAnimationListener {
  _$MapLibreMap_OnDeveloperAnimationListener({
    required void Function() onDeveloperAnimationStarted,
    this.onDeveloperAnimationStarted$async = false,
  }) : _onDeveloperAnimationStarted = onDeveloperAnimationStarted;

  final void Function() _onDeveloperAnimationStarted;
  final bool onDeveloperAnimationStarted$async;

  void onDeveloperAnimationStarted() {
    return _onDeveloperAnimationStarted();
  }
}

final class $MapLibreMap_OnDeveloperAnimationListener$Type
    extends _$jni.JObjType<MapLibreMap_OnDeveloperAnimationListener> {
  @_$jni.internal
  const $MapLibreMap_OnDeveloperAnimationListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnDeveloperAnimationListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnDeveloperAnimationListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnDeveloperAnimationListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnDeveloperAnimationListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnDeveloperAnimationListener$Type) &&
        other is $MapLibreMap_OnDeveloperAnimationListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnFlingListener`
class MapLibreMap_OnFlingListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnFlingListener> $type;

  @_$jni.internal
  MapLibreMap_OnFlingListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnFlingListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnFlingListener$Type();
  static final _id_onFling = _class.instanceMethodId(
    r'onFling',
    r'()V',
  );

  static final _onFling = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onFling()`
  void onFling() {
    _onFling(reference.pointer, _id_onFling as _$jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnFlingListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFling()V') {
        _$impls[$p]!.onFling();
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnFlingListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnFlingListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onFling$async) r'onFling()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnFlingListener.implement(
    $MapLibreMap_OnFlingListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnFlingListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnFlingListener {
  factory $MapLibreMap_OnFlingListener({
    required void Function() onFling,
    bool onFling$async,
  }) = _$MapLibreMap_OnFlingListener;

  void onFling();
  bool get onFling$async => false;
}

final class _$MapLibreMap_OnFlingListener with $MapLibreMap_OnFlingListener {
  _$MapLibreMap_OnFlingListener({
    required void Function() onFling,
    this.onFling$async = false,
  }) : _onFling = onFling;

  final void Function() _onFling;
  final bool onFling$async;

  void onFling() {
    return _onFling();
  }
}

final class $MapLibreMap_OnFlingListener$Type
    extends _$jni.JObjType<MapLibreMap_OnFlingListener> {
  @_$jni.internal
  const $MapLibreMap_OnFlingListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnFlingListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnFlingListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnFlingListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnFlingListener$Type) &&
        other is $MapLibreMap_OnFlingListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener`
class MapLibreMap_OnFpsChangedListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnFpsChangedListener> $type;

  @_$jni.internal
  MapLibreMap_OnFpsChangedListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnFpsChangedListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnFpsChangedListener$Type();
  static final _id_onFpsChanged = _class.instanceMethodId(
    r'onFpsChanged',
    r'(D)V',
  );

  static final _onFpsChanged = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, double)>();

  /// from: `public abstract void onFpsChanged(double d)`
  void onFpsChanged(
    double d,
  ) {
    _onFpsChanged(reference.pointer, _id_onFpsChanged as _$jni.JMethodIDPtr, d)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnFpsChangedListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFpsChanged(D)V') {
        _$impls[$p]!.onFpsChanged(
          $a[0]
              .as(const _$jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnFpsChangedListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onFpsChanged$async) r'onFpsChanged(D)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnFpsChangedListener.implement(
    $MapLibreMap_OnFpsChangedListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnFpsChangedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnFpsChangedListener {
  factory $MapLibreMap_OnFpsChangedListener({
    required void Function(double d) onFpsChanged,
    bool onFpsChanged$async,
  }) = _$MapLibreMap_OnFpsChangedListener;

  void onFpsChanged(double d);
  bool get onFpsChanged$async => false;
}

final class _$MapLibreMap_OnFpsChangedListener
    with $MapLibreMap_OnFpsChangedListener {
  _$MapLibreMap_OnFpsChangedListener({
    required void Function(double d) onFpsChanged,
    this.onFpsChanged$async = false,
  }) : _onFpsChanged = onFpsChanged;

  final void Function(double d) _onFpsChanged;
  final bool onFpsChanged$async;

  void onFpsChanged(double d) {
    return _onFpsChanged(d);
  }
}

final class $MapLibreMap_OnFpsChangedListener$Type
    extends _$jni.JObjType<MapLibreMap_OnFpsChangedListener> {
  @_$jni.internal
  const $MapLibreMap_OnFpsChangedListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnFpsChangedListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnFpsChangedListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnFpsChangedListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnFpsChangedListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnFpsChangedListener$Type) &&
        other is $MapLibreMap_OnFpsChangedListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener`
class MapLibreMap_OnInfoWindowClickListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnInfoWindowClickListener> $type;

  @_$jni.internal
  MapLibreMap_OnInfoWindowClickListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnInfoWindowClickListener$Type();
  static final _id_onInfoWindowClick = _class.instanceMethodId(
    r'onInfoWindowClick',
    r'(Lorg/maplibre/android/annotations/Marker;)Z',
  );

  static final _onInfoWindowClick = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract boolean onInfoWindowClick(org.maplibre.android.annotations.Marker marker)`
  bool onInfoWindowClick(
    _$jni.JObject marker,
  ) {
    return _onInfoWindowClick(
            reference.pointer,
            _id_onInfoWindowClick as _$jni.JMethodIDPtr,
            marker.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnInfoWindowClickListener> _$impls =
      {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowClick(Lorg/maplibre/android/annotations/Marker;)Z') {
        final $r = _$impls[$p]!.onInfoWindowClick(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnInfoWindowClickListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnInfoWindowClickListener.implement(
    $MapLibreMap_OnInfoWindowClickListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnInfoWindowClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnInfoWindowClickListener {
  factory $MapLibreMap_OnInfoWindowClickListener({
    required bool Function(_$jni.JObject marker) onInfoWindowClick,
  }) = _$MapLibreMap_OnInfoWindowClickListener;

  bool onInfoWindowClick(_$jni.JObject marker);
}

final class _$MapLibreMap_OnInfoWindowClickListener
    with $MapLibreMap_OnInfoWindowClickListener {
  _$MapLibreMap_OnInfoWindowClickListener({
    required bool Function(_$jni.JObject marker) onInfoWindowClick,
  }) : _onInfoWindowClick = onInfoWindowClick;

  final bool Function(_$jni.JObject marker) _onInfoWindowClick;

  bool onInfoWindowClick(_$jni.JObject marker) {
    return _onInfoWindowClick(marker);
  }
}

final class $MapLibreMap_OnInfoWindowClickListener$Type
    extends _$jni.JObjType<MapLibreMap_OnInfoWindowClickListener> {
  @_$jni.internal
  const $MapLibreMap_OnInfoWindowClickListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnInfoWindowClickListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnInfoWindowClickListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnInfoWindowClickListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnInfoWindowClickListener$Type) &&
        other is $MapLibreMap_OnInfoWindowClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener`
class MapLibreMap_OnInfoWindowCloseListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnInfoWindowCloseListener> $type;

  @_$jni.internal
  MapLibreMap_OnInfoWindowCloseListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnInfoWindowCloseListener$Type();
  static final _id_onInfoWindowClose = _class.instanceMethodId(
    r'onInfoWindowClose',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _onInfoWindowClose = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onInfoWindowClose(org.maplibre.android.annotations.Marker marker)`
  void onInfoWindowClose(
    _$jni.JObject marker,
  ) {
    _onInfoWindowClose(
            reference.pointer,
            _id_onInfoWindowClose as _$jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnInfoWindowCloseListener> _$impls =
      {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowClose(Lorg/maplibre/android/annotations/Marker;)V') {
        _$impls[$p]!.onInfoWindowClose(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnInfoWindowCloseListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onInfoWindowClose$async)
          r'onInfoWindowClose(Lorg/maplibre/android/annotations/Marker;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnInfoWindowCloseListener.implement(
    $MapLibreMap_OnInfoWindowCloseListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnInfoWindowCloseListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnInfoWindowCloseListener {
  factory $MapLibreMap_OnInfoWindowCloseListener({
    required void Function(_$jni.JObject marker) onInfoWindowClose,
    bool onInfoWindowClose$async,
  }) = _$MapLibreMap_OnInfoWindowCloseListener;

  void onInfoWindowClose(_$jni.JObject marker);
  bool get onInfoWindowClose$async => false;
}

final class _$MapLibreMap_OnInfoWindowCloseListener
    with $MapLibreMap_OnInfoWindowCloseListener {
  _$MapLibreMap_OnInfoWindowCloseListener({
    required void Function(_$jni.JObject marker) onInfoWindowClose,
    this.onInfoWindowClose$async = false,
  }) : _onInfoWindowClose = onInfoWindowClose;

  final void Function(_$jni.JObject marker) _onInfoWindowClose;
  final bool onInfoWindowClose$async;

  void onInfoWindowClose(_$jni.JObject marker) {
    return _onInfoWindowClose(marker);
  }
}

final class $MapLibreMap_OnInfoWindowCloseListener$Type
    extends _$jni.JObjType<MapLibreMap_OnInfoWindowCloseListener> {
  @_$jni.internal
  const $MapLibreMap_OnInfoWindowCloseListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnInfoWindowCloseListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnInfoWindowCloseListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnInfoWindowCloseListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnInfoWindowCloseListener$Type) &&
        other is $MapLibreMap_OnInfoWindowCloseListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener`
class MapLibreMap_OnInfoWindowLongClickListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnInfoWindowLongClickListener> $type;

  @_$jni.internal
  MapLibreMap_OnInfoWindowLongClickListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnInfoWindowLongClickListener$Type();
  static final _id_onInfoWindowLongClick = _class.instanceMethodId(
    r'onInfoWindowLongClick',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _onInfoWindowLongClick = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onInfoWindowLongClick(org.maplibre.android.annotations.Marker marker)`
  void onInfoWindowLongClick(
    _$jni.JObject marker,
  ) {
    _onInfoWindowLongClick(
            reference.pointer,
            _id_onInfoWindowLongClick as _$jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnInfoWindowLongClickListener>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowLongClick(Lorg/maplibre/android/annotations/Marker;)V') {
        _$impls[$p]!.onInfoWindowLongClick(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnInfoWindowLongClickListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onInfoWindowLongClick$async)
          r'onInfoWindowLongClick(Lorg/maplibre/android/annotations/Marker;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnInfoWindowLongClickListener.implement(
    $MapLibreMap_OnInfoWindowLongClickListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnInfoWindowLongClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnInfoWindowLongClickListener {
  factory $MapLibreMap_OnInfoWindowLongClickListener({
    required void Function(_$jni.JObject marker) onInfoWindowLongClick,
    bool onInfoWindowLongClick$async,
  }) = _$MapLibreMap_OnInfoWindowLongClickListener;

  void onInfoWindowLongClick(_$jni.JObject marker);
  bool get onInfoWindowLongClick$async => false;
}

final class _$MapLibreMap_OnInfoWindowLongClickListener
    with $MapLibreMap_OnInfoWindowLongClickListener {
  _$MapLibreMap_OnInfoWindowLongClickListener({
    required void Function(_$jni.JObject marker) onInfoWindowLongClick,
    this.onInfoWindowLongClick$async = false,
  }) : _onInfoWindowLongClick = onInfoWindowLongClick;

  final void Function(_$jni.JObject marker) _onInfoWindowLongClick;
  final bool onInfoWindowLongClick$async;

  void onInfoWindowLongClick(_$jni.JObject marker) {
    return _onInfoWindowLongClick(marker);
  }
}

final class $MapLibreMap_OnInfoWindowLongClickListener$Type
    extends _$jni.JObjType<MapLibreMap_OnInfoWindowLongClickListener> {
  @_$jni.internal
  const $MapLibreMap_OnInfoWindowLongClickListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnInfoWindowLongClickListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnInfoWindowLongClickListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode =>
      ($MapLibreMap_OnInfoWindowLongClickListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnInfoWindowLongClickListener$Type) &&
        other is $MapLibreMap_OnInfoWindowLongClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMapClickListener`
class MapLibreMap_OnMapClickListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnMapClickListener> $type;

  @_$jni.internal
  MapLibreMap_OnMapClickListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnMapClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnMapClickListener$Type();
  static final _id_onMapClick = _class.instanceMethodId(
    r'onMapClick',
    r'(Lorg/maplibre/android/geometry/LatLng;)Z',
  );

  static final _onMapClick = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract boolean onMapClick(org.maplibre.android.geometry.LatLng latLng)`
  bool onMapClick(
    latlng_.LatLng latLng,
  ) {
    return _onMapClick(reference.pointer, _id_onMapClick as _$jni.JMethodIDPtr,
            latLng.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnMapClickListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMapClick(Lorg/maplibre/android/geometry/LatLng;)Z') {
        final $r = _$impls[$p]!.onMapClick(
          $a[0].as(const latlng_.$LatLng$Type(), releaseOriginal: true),
        );
        return _$jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnMapClickListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnMapClickListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnMapClickListener.implement(
    $MapLibreMap_OnMapClickListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnMapClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnMapClickListener {
  factory $MapLibreMap_OnMapClickListener({
    required bool Function(latlng_.LatLng latLng) onMapClick,
  }) = _$MapLibreMap_OnMapClickListener;

  bool onMapClick(latlng_.LatLng latLng);
}

final class _$MapLibreMap_OnMapClickListener
    with $MapLibreMap_OnMapClickListener {
  _$MapLibreMap_OnMapClickListener({
    required bool Function(latlng_.LatLng latLng) onMapClick,
  }) : _onMapClick = onMapClick;

  final bool Function(latlng_.LatLng latLng) _onMapClick;

  bool onMapClick(latlng_.LatLng latLng) {
    return _onMapClick(latLng);
  }
}

final class $MapLibreMap_OnMapClickListener$Type
    extends _$jni.JObjType<MapLibreMap_OnMapClickListener> {
  @_$jni.internal
  const $MapLibreMap_OnMapClickListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnMapClickListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnMapClickListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnMapClickListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnMapClickListener$Type) &&
        other is $MapLibreMap_OnMapClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener`
class MapLibreMap_OnMapLongClickListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnMapLongClickListener> $type;

  @_$jni.internal
  MapLibreMap_OnMapLongClickListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnMapLongClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnMapLongClickListener$Type();
  static final _id_onMapLongClick = _class.instanceMethodId(
    r'onMapLongClick',
    r'(Lorg/maplibre/android/geometry/LatLng;)Z',
  );

  static final _onMapLongClick = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract boolean onMapLongClick(org.maplibre.android.geometry.LatLng latLng)`
  bool onMapLongClick(
    latlng_.LatLng latLng,
  ) {
    return _onMapLongClick(reference.pointer,
            _id_onMapLongClick as _$jni.JMethodIDPtr, latLng.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnMapLongClickListener> _$impls =
      {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMapLongClick(Lorg/maplibre/android/geometry/LatLng;)Z') {
        final $r = _$impls[$p]!.onMapLongClick(
          $a[0].as(const latlng_.$LatLng$Type(), releaseOriginal: true),
        );
        return _$jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnMapLongClickListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnMapLongClickListener.implement(
    $MapLibreMap_OnMapLongClickListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnMapLongClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnMapLongClickListener {
  factory $MapLibreMap_OnMapLongClickListener({
    required bool Function(latlng_.LatLng latLng) onMapLongClick,
  }) = _$MapLibreMap_OnMapLongClickListener;

  bool onMapLongClick(latlng_.LatLng latLng);
}

final class _$MapLibreMap_OnMapLongClickListener
    with $MapLibreMap_OnMapLongClickListener {
  _$MapLibreMap_OnMapLongClickListener({
    required bool Function(latlng_.LatLng latLng) onMapLongClick,
  }) : _onMapLongClick = onMapLongClick;

  final bool Function(latlng_.LatLng latLng) _onMapLongClick;

  bool onMapLongClick(latlng_.LatLng latLng) {
    return _onMapLongClick(latLng);
  }
}

final class $MapLibreMap_OnMapLongClickListener$Type
    extends _$jni.JObjType<MapLibreMap_OnMapLongClickListener> {
  @_$jni.internal
  const $MapLibreMap_OnMapLongClickListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnMapLongClickListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnMapLongClickListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnMapLongClickListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnMapLongClickListener$Type) &&
        other is $MapLibreMap_OnMapLongClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener`
class MapLibreMap_OnMarkerClickListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnMarkerClickListener> $type;

  @_$jni.internal
  MapLibreMap_OnMarkerClickListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnMarkerClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnMarkerClickListener$Type();
  static final _id_onMarkerClick = _class.instanceMethodId(
    r'onMarkerClick',
    r'(Lorg/maplibre/android/annotations/Marker;)Z',
  );

  static final _onMarkerClick = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract boolean onMarkerClick(org.maplibre.android.annotations.Marker marker)`
  bool onMarkerClick(
    _$jni.JObject marker,
  ) {
    return _onMarkerClick(reference.pointer,
            _id_onMarkerClick as _$jni.JMethodIDPtr, marker.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnMarkerClickListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMarkerClick(Lorg/maplibre/android/annotations/Marker;)Z') {
        final $r = _$impls[$p]!.onMarkerClick(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnMarkerClickListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnMarkerClickListener.implement(
    $MapLibreMap_OnMarkerClickListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnMarkerClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnMarkerClickListener {
  factory $MapLibreMap_OnMarkerClickListener({
    required bool Function(_$jni.JObject marker) onMarkerClick,
  }) = _$MapLibreMap_OnMarkerClickListener;

  bool onMarkerClick(_$jni.JObject marker);
}

final class _$MapLibreMap_OnMarkerClickListener
    with $MapLibreMap_OnMarkerClickListener {
  _$MapLibreMap_OnMarkerClickListener({
    required bool Function(_$jni.JObject marker) onMarkerClick,
  }) : _onMarkerClick = onMarkerClick;

  final bool Function(_$jni.JObject marker) _onMarkerClick;

  bool onMarkerClick(_$jni.JObject marker) {
    return _onMarkerClick(marker);
  }
}

final class $MapLibreMap_OnMarkerClickListener$Type
    extends _$jni.JObjType<MapLibreMap_OnMarkerClickListener> {
  @_$jni.internal
  const $MapLibreMap_OnMarkerClickListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMarkerClickListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnMarkerClickListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnMarkerClickListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnMarkerClickListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnMarkerClickListener$Type) &&
        other is $MapLibreMap_OnMarkerClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMoveListener`
class MapLibreMap_OnMoveListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnMoveListener> $type;

  @_$jni.internal
  MapLibreMap_OnMoveListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnMoveListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnMoveListener$Type();
  static final _id_onMoveBegin = _class.instanceMethodId(
    r'onMoveBegin',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMoveBegin = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onMoveBegin(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMoveBegin(
    _$jni.JObject moveGestureDetector,
  ) {
    _onMoveBegin(reference.pointer, _id_onMoveBegin as _$jni.JMethodIDPtr,
            moveGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onMove = _class.instanceMethodId(
    r'onMove',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMove = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onMove(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMove(
    _$jni.JObject moveGestureDetector,
  ) {
    _onMove(reference.pointer, _id_onMove as _$jni.JMethodIDPtr,
            moveGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onMoveEnd = _class.instanceMethodId(
    r'onMoveEnd',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMoveEnd = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onMoveEnd(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMoveEnd(
    _$jni.JObject moveGestureDetector,
  ) {
    _onMoveEnd(reference.pointer, _id_onMoveEnd as _$jni.JMethodIDPtr,
            moveGestureDetector.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnMoveListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onMoveBegin(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMoveBegin(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onMove(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMove(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onMoveEnd(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMoveEnd(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnMoveListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnMoveListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onMoveBegin$async)
          r'onMoveBegin(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
        if ($impl.onMove$async)
          r'onMove(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
        if ($impl.onMoveEnd$async)
          r'onMoveEnd(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnMoveListener.implement(
    $MapLibreMap_OnMoveListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnMoveListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnMoveListener {
  factory $MapLibreMap_OnMoveListener({
    required void Function(_$jni.JObject moveGestureDetector) onMoveBegin,
    bool onMoveBegin$async,
    required void Function(_$jni.JObject moveGestureDetector) onMove,
    bool onMove$async,
    required void Function(_$jni.JObject moveGestureDetector) onMoveEnd,
    bool onMoveEnd$async,
  }) = _$MapLibreMap_OnMoveListener;

  void onMoveBegin(_$jni.JObject moveGestureDetector);
  bool get onMoveBegin$async => false;
  void onMove(_$jni.JObject moveGestureDetector);
  bool get onMove$async => false;
  void onMoveEnd(_$jni.JObject moveGestureDetector);
  bool get onMoveEnd$async => false;
}

final class _$MapLibreMap_OnMoveListener with $MapLibreMap_OnMoveListener {
  _$MapLibreMap_OnMoveListener({
    required void Function(_$jni.JObject moveGestureDetector) onMoveBegin,
    this.onMoveBegin$async = false,
    required void Function(_$jni.JObject moveGestureDetector) onMove,
    this.onMove$async = false,
    required void Function(_$jni.JObject moveGestureDetector) onMoveEnd,
    this.onMoveEnd$async = false,
  })  : _onMoveBegin = onMoveBegin,
        _onMove = onMove,
        _onMoveEnd = onMoveEnd;

  final void Function(_$jni.JObject moveGestureDetector) _onMoveBegin;
  final bool onMoveBegin$async;
  final void Function(_$jni.JObject moveGestureDetector) _onMove;
  final bool onMove$async;
  final void Function(_$jni.JObject moveGestureDetector) _onMoveEnd;
  final bool onMoveEnd$async;

  void onMoveBegin(_$jni.JObject moveGestureDetector) {
    return _onMoveBegin(moveGestureDetector);
  }

  void onMove(_$jni.JObject moveGestureDetector) {
    return _onMove(moveGestureDetector);
  }

  void onMoveEnd(_$jni.JObject moveGestureDetector) {
    return _onMoveEnd(moveGestureDetector);
  }
}

final class $MapLibreMap_OnMoveListener$Type
    extends _$jni.JObjType<MapLibreMap_OnMoveListener> {
  @_$jni.internal
  const $MapLibreMap_OnMoveListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnMoveListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnMoveListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnMoveListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnMoveListener$Type) &&
        other is $MapLibreMap_OnMoveListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener`
class MapLibreMap_OnPolygonClickListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnPolygonClickListener> $type;

  @_$jni.internal
  MapLibreMap_OnPolygonClickListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnPolygonClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnPolygonClickListener$Type();
  static final _id_onPolygonClick = _class.instanceMethodId(
    r'onPolygonClick',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _onPolygonClick = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onPolygonClick(org.maplibre.android.annotations.Polygon polygon)`
  void onPolygonClick(
    _$jni.JObject polygon,
  ) {
    _onPolygonClick(reference.pointer, _id_onPolygonClick as _$jni.JMethodIDPtr,
            polygon.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnPolygonClickListener> _$impls =
      {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onPolygonClick(Lorg/maplibre/android/annotations/Polygon;)V') {
        _$impls[$p]!.onPolygonClick(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnPolygonClickListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onPolygonClick$async)
          r'onPolygonClick(Lorg/maplibre/android/annotations/Polygon;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnPolygonClickListener.implement(
    $MapLibreMap_OnPolygonClickListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnPolygonClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnPolygonClickListener {
  factory $MapLibreMap_OnPolygonClickListener({
    required void Function(_$jni.JObject polygon) onPolygonClick,
    bool onPolygonClick$async,
  }) = _$MapLibreMap_OnPolygonClickListener;

  void onPolygonClick(_$jni.JObject polygon);
  bool get onPolygonClick$async => false;
}

final class _$MapLibreMap_OnPolygonClickListener
    with $MapLibreMap_OnPolygonClickListener {
  _$MapLibreMap_OnPolygonClickListener({
    required void Function(_$jni.JObject polygon) onPolygonClick,
    this.onPolygonClick$async = false,
  }) : _onPolygonClick = onPolygonClick;

  final void Function(_$jni.JObject polygon) _onPolygonClick;
  final bool onPolygonClick$async;

  void onPolygonClick(_$jni.JObject polygon) {
    return _onPolygonClick(polygon);
  }
}

final class $MapLibreMap_OnPolygonClickListener$Type
    extends _$jni.JObjType<MapLibreMap_OnPolygonClickListener> {
  @_$jni.internal
  const $MapLibreMap_OnPolygonClickListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnPolygonClickListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnPolygonClickListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnPolygonClickListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnPolygonClickListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnPolygonClickListener$Type) &&
        other is $MapLibreMap_OnPolygonClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener`
class MapLibreMap_OnPolylineClickListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnPolylineClickListener> $type;

  @_$jni.internal
  MapLibreMap_OnPolylineClickListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnPolylineClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnPolylineClickListener$Type();
  static final _id_onPolylineClick = _class.instanceMethodId(
    r'onPolylineClick',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _onPolylineClick = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onPolylineClick(org.maplibre.android.annotations.Polyline polyline)`
  void onPolylineClick(
    _$jni.JObject polyline,
  ) {
    _onPolylineClick(
            reference.pointer,
            _id_onPolylineClick as _$jni.JMethodIDPtr,
            polyline.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnPolylineClickListener> _$impls =
      {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onPolylineClick(Lorg/maplibre/android/annotations/Polyline;)V') {
        _$impls[$p]!.onPolylineClick(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnPolylineClickListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onPolylineClick$async)
          r'onPolylineClick(Lorg/maplibre/android/annotations/Polyline;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnPolylineClickListener.implement(
    $MapLibreMap_OnPolylineClickListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnPolylineClickListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnPolylineClickListener {
  factory $MapLibreMap_OnPolylineClickListener({
    required void Function(_$jni.JObject polyline) onPolylineClick,
    bool onPolylineClick$async,
  }) = _$MapLibreMap_OnPolylineClickListener;

  void onPolylineClick(_$jni.JObject polyline);
  bool get onPolylineClick$async => false;
}

final class _$MapLibreMap_OnPolylineClickListener
    with $MapLibreMap_OnPolylineClickListener {
  _$MapLibreMap_OnPolylineClickListener({
    required void Function(_$jni.JObject polyline) onPolylineClick,
    this.onPolylineClick$async = false,
  }) : _onPolylineClick = onPolylineClick;

  final void Function(_$jni.JObject polyline) _onPolylineClick;
  final bool onPolylineClick$async;

  void onPolylineClick(_$jni.JObject polyline) {
    return _onPolylineClick(polyline);
  }
}

final class $MapLibreMap_OnPolylineClickListener$Type
    extends _$jni.JObjType<MapLibreMap_OnPolylineClickListener> {
  @_$jni.internal
  const $MapLibreMap_OnPolylineClickListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnPolylineClickListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnPolylineClickListener fromReference(
          _$jni.JReference reference) =>
      MapLibreMap_OnPolylineClickListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnPolylineClickListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnPolylineClickListener$Type) &&
        other is $MapLibreMap_OnPolylineClickListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnRotateListener`
class MapLibreMap_OnRotateListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnRotateListener> $type;

  @_$jni.internal
  MapLibreMap_OnRotateListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnRotateListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnRotateListener$Type();
  static final _id_onRotateBegin = _class.instanceMethodId(
    r'onRotateBegin',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotateBegin = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onRotateBegin(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotateBegin(
    _$jni.JObject rotateGestureDetector,
  ) {
    _onRotateBegin(reference.pointer, _id_onRotateBegin as _$jni.JMethodIDPtr,
            rotateGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onRotate = _class.instanceMethodId(
    r'onRotate',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotate = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onRotate(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotate(
    _$jni.JObject rotateGestureDetector,
  ) {
    _onRotate(reference.pointer, _id_onRotate as _$jni.JMethodIDPtr,
            rotateGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onRotateEnd = _class.instanceMethodId(
    r'onRotateEnd',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotateEnd = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onRotateEnd(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotateEnd(
    _$jni.JObject rotateGestureDetector,
  ) {
    _onRotateEnd(reference.pointer, _id_onRotateEnd as _$jni.JMethodIDPtr,
            rotateGestureDetector.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnRotateListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onRotateBegin(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotateBegin(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onRotate(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotate(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onRotateEnd(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotateEnd(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnRotateListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnRotateListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onRotateBegin$async)
          r'onRotateBegin(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
        if ($impl.onRotate$async)
          r'onRotate(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
        if ($impl.onRotateEnd$async)
          r'onRotateEnd(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnRotateListener.implement(
    $MapLibreMap_OnRotateListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnRotateListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnRotateListener {
  factory $MapLibreMap_OnRotateListener({
    required void Function(_$jni.JObject rotateGestureDetector) onRotateBegin,
    bool onRotateBegin$async,
    required void Function(_$jni.JObject rotateGestureDetector) onRotate,
    bool onRotate$async,
    required void Function(_$jni.JObject rotateGestureDetector) onRotateEnd,
    bool onRotateEnd$async,
  }) = _$MapLibreMap_OnRotateListener;

  void onRotateBegin(_$jni.JObject rotateGestureDetector);
  bool get onRotateBegin$async => false;
  void onRotate(_$jni.JObject rotateGestureDetector);
  bool get onRotate$async => false;
  void onRotateEnd(_$jni.JObject rotateGestureDetector);
  bool get onRotateEnd$async => false;
}

final class _$MapLibreMap_OnRotateListener with $MapLibreMap_OnRotateListener {
  _$MapLibreMap_OnRotateListener({
    required void Function(_$jni.JObject rotateGestureDetector) onRotateBegin,
    this.onRotateBegin$async = false,
    required void Function(_$jni.JObject rotateGestureDetector) onRotate,
    this.onRotate$async = false,
    required void Function(_$jni.JObject rotateGestureDetector) onRotateEnd,
    this.onRotateEnd$async = false,
  })  : _onRotateBegin = onRotateBegin,
        _onRotate = onRotate,
        _onRotateEnd = onRotateEnd;

  final void Function(_$jni.JObject rotateGestureDetector) _onRotateBegin;
  final bool onRotateBegin$async;
  final void Function(_$jni.JObject rotateGestureDetector) _onRotate;
  final bool onRotate$async;
  final void Function(_$jni.JObject rotateGestureDetector) _onRotateEnd;
  final bool onRotateEnd$async;

  void onRotateBegin(_$jni.JObject rotateGestureDetector) {
    return _onRotateBegin(rotateGestureDetector);
  }

  void onRotate(_$jni.JObject rotateGestureDetector) {
    return _onRotate(rotateGestureDetector);
  }

  void onRotateEnd(_$jni.JObject rotateGestureDetector) {
    return _onRotateEnd(rotateGestureDetector);
  }
}

final class $MapLibreMap_OnRotateListener$Type
    extends _$jni.JObjType<MapLibreMap_OnRotateListener> {
  @_$jni.internal
  const $MapLibreMap_OnRotateListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnRotateListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnRotateListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnRotateListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnRotateListener$Type) &&
        other is $MapLibreMap_OnRotateListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnScaleListener`
class MapLibreMap_OnScaleListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnScaleListener> $type;

  @_$jni.internal
  MapLibreMap_OnScaleListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnScaleListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnScaleListener$Type();
  static final _id_onScaleBegin = _class.instanceMethodId(
    r'onScaleBegin',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScaleBegin = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onScaleBegin(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScaleBegin(
    _$jni.JObject standardScaleGestureDetector,
  ) {
    _onScaleBegin(reference.pointer, _id_onScaleBegin as _$jni.JMethodIDPtr,
            standardScaleGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onScale = _class.instanceMethodId(
    r'onScale',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScale = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onScale(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScale(
    _$jni.JObject standardScaleGestureDetector,
  ) {
    _onScale(reference.pointer, _id_onScale as _$jni.JMethodIDPtr,
            standardScaleGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onScaleEnd = _class.instanceMethodId(
    r'onScaleEnd',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScaleEnd = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onScaleEnd(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScaleEnd(
    _$jni.JObject standardScaleGestureDetector,
  ) {
    _onScaleEnd(reference.pointer, _id_onScaleEnd as _$jni.JMethodIDPtr,
            standardScaleGestureDetector.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnScaleListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onScaleBegin(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScaleBegin(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onScale(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScale(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onScaleEnd(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScaleEnd(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnScaleListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnScaleListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onScaleBegin$async)
          r'onScaleBegin(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
        if ($impl.onScale$async)
          r'onScale(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
        if ($impl.onScaleEnd$async)
          r'onScaleEnd(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnScaleListener.implement(
    $MapLibreMap_OnScaleListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnScaleListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnScaleListener {
  factory $MapLibreMap_OnScaleListener({
    required void Function(_$jni.JObject standardScaleGestureDetector)
        onScaleBegin,
    bool onScaleBegin$async,
    required void Function(_$jni.JObject standardScaleGestureDetector) onScale,
    bool onScale$async,
    required void Function(_$jni.JObject standardScaleGestureDetector)
        onScaleEnd,
    bool onScaleEnd$async,
  }) = _$MapLibreMap_OnScaleListener;

  void onScaleBegin(_$jni.JObject standardScaleGestureDetector);
  bool get onScaleBegin$async => false;
  void onScale(_$jni.JObject standardScaleGestureDetector);
  bool get onScale$async => false;
  void onScaleEnd(_$jni.JObject standardScaleGestureDetector);
  bool get onScaleEnd$async => false;
}

final class _$MapLibreMap_OnScaleListener with $MapLibreMap_OnScaleListener {
  _$MapLibreMap_OnScaleListener({
    required void Function(_$jni.JObject standardScaleGestureDetector)
        onScaleBegin,
    this.onScaleBegin$async = false,
    required void Function(_$jni.JObject standardScaleGestureDetector) onScale,
    this.onScale$async = false,
    required void Function(_$jni.JObject standardScaleGestureDetector)
        onScaleEnd,
    this.onScaleEnd$async = false,
  })  : _onScaleBegin = onScaleBegin,
        _onScale = onScale,
        _onScaleEnd = onScaleEnd;

  final void Function(_$jni.JObject standardScaleGestureDetector) _onScaleBegin;
  final bool onScaleBegin$async;
  final void Function(_$jni.JObject standardScaleGestureDetector) _onScale;
  final bool onScale$async;
  final void Function(_$jni.JObject standardScaleGestureDetector) _onScaleEnd;
  final bool onScaleEnd$async;

  void onScaleBegin(_$jni.JObject standardScaleGestureDetector) {
    return _onScaleBegin(standardScaleGestureDetector);
  }

  void onScale(_$jni.JObject standardScaleGestureDetector) {
    return _onScale(standardScaleGestureDetector);
  }

  void onScaleEnd(_$jni.JObject standardScaleGestureDetector) {
    return _onScaleEnd(standardScaleGestureDetector);
  }
}

final class $MapLibreMap_OnScaleListener$Type
    extends _$jni.JObjType<MapLibreMap_OnScaleListener> {
  @_$jni.internal
  const $MapLibreMap_OnScaleListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnScaleListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnScaleListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnScaleListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnScaleListener$Type) &&
        other is $MapLibreMap_OnScaleListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnShoveListener`
class MapLibreMap_OnShoveListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_OnShoveListener> $type;

  @_$jni.internal
  MapLibreMap_OnShoveListener.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnShoveListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnShoveListener$Type();
  static final _id_onShoveBegin = _class.instanceMethodId(
    r'onShoveBegin',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShoveBegin = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onShoveBegin(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShoveBegin(
    _$jni.JObject shoveGestureDetector,
  ) {
    _onShoveBegin(reference.pointer, _id_onShoveBegin as _$jni.JMethodIDPtr,
            shoveGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onShove = _class.instanceMethodId(
    r'onShove',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShove = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onShove(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShove(
    _$jni.JObject shoveGestureDetector,
  ) {
    _onShove(reference.pointer, _id_onShove as _$jni.JMethodIDPtr,
            shoveGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onShoveEnd = _class.instanceMethodId(
    r'onShoveEnd',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShoveEnd = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onShoveEnd(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShoveEnd(
    _$jni.JObject shoveGestureDetector,
  ) {
    _onShoveEnd(reference.pointer, _id_onShoveEnd as _$jni.JMethodIDPtr,
            shoveGestureDetector.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_OnShoveListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onShoveBegin(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShoveBegin(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onShove(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShove(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onShoveEnd(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShoveEnd(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_OnShoveListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$OnShoveListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onShoveBegin$async)
          r'onShoveBegin(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
        if ($impl.onShove$async)
          r'onShove(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
        if ($impl.onShoveEnd$async)
          r'onShoveEnd(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_OnShoveListener.implement(
    $MapLibreMap_OnShoveListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_OnShoveListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_OnShoveListener {
  factory $MapLibreMap_OnShoveListener({
    required void Function(_$jni.JObject shoveGestureDetector) onShoveBegin,
    bool onShoveBegin$async,
    required void Function(_$jni.JObject shoveGestureDetector) onShove,
    bool onShove$async,
    required void Function(_$jni.JObject shoveGestureDetector) onShoveEnd,
    bool onShoveEnd$async,
  }) = _$MapLibreMap_OnShoveListener;

  void onShoveBegin(_$jni.JObject shoveGestureDetector);
  bool get onShoveBegin$async => false;
  void onShove(_$jni.JObject shoveGestureDetector);
  bool get onShove$async => false;
  void onShoveEnd(_$jni.JObject shoveGestureDetector);
  bool get onShoveEnd$async => false;
}

final class _$MapLibreMap_OnShoveListener with $MapLibreMap_OnShoveListener {
  _$MapLibreMap_OnShoveListener({
    required void Function(_$jni.JObject shoveGestureDetector) onShoveBegin,
    this.onShoveBegin$async = false,
    required void Function(_$jni.JObject shoveGestureDetector) onShove,
    this.onShove$async = false,
    required void Function(_$jni.JObject shoveGestureDetector) onShoveEnd,
    this.onShoveEnd$async = false,
  })  : _onShoveBegin = onShoveBegin,
        _onShove = onShove,
        _onShoveEnd = onShoveEnd;

  final void Function(_$jni.JObject shoveGestureDetector) _onShoveBegin;
  final bool onShoveBegin$async;
  final void Function(_$jni.JObject shoveGestureDetector) _onShove;
  final bool onShove$async;
  final void Function(_$jni.JObject shoveGestureDetector) _onShoveEnd;
  final bool onShoveEnd$async;

  void onShoveBegin(_$jni.JObject shoveGestureDetector) {
    return _onShoveBegin(shoveGestureDetector);
  }

  void onShove(_$jni.JObject shoveGestureDetector) {
    return _onShove(shoveGestureDetector);
  }

  void onShoveEnd(_$jni.JObject shoveGestureDetector) {
    return _onShoveEnd(shoveGestureDetector);
  }
}

final class $MapLibreMap_OnShoveListener$Type
    extends _$jni.JObjType<MapLibreMap_OnShoveListener> {
  @_$jni.internal
  const $MapLibreMap_OnShoveListener$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_OnShoveListener fromReference(_$jni.JReference reference) =>
      MapLibreMap_OnShoveListener.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_OnShoveListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnShoveListener$Type) &&
        other is $MapLibreMap_OnShoveListener$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback`
class MapLibreMap_SnapshotReadyCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap_SnapshotReadyCallback> $type;

  @_$jni.internal
  MapLibreMap_SnapshotReadyCallback.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_SnapshotReadyCallback$Type();
  static final _id_onSnapshotReady = _class.instanceMethodId(
    r'onSnapshotReady',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onSnapshotReady = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onSnapshotReady(android.graphics.Bitmap bitmap)`
  void onSnapshotReady(
    _$jni.JObject bitmap,
  ) {
    _onSnapshotReady(reference.pointer,
            _id_onSnapshotReady as _$jni.JMethodIDPtr, bitmap.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MapLibreMap_SnapshotReadyCallback> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSnapshotReady(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onSnapshotReady(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MapLibreMap_SnapshotReadyCallback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onSnapshotReady$async)
          r'onSnapshotReady(Landroid/graphics/Bitmap;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MapLibreMap_SnapshotReadyCallback.implement(
    $MapLibreMap_SnapshotReadyCallback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MapLibreMap_SnapshotReadyCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $MapLibreMap_SnapshotReadyCallback {
  factory $MapLibreMap_SnapshotReadyCallback({
    required void Function(_$jni.JObject bitmap) onSnapshotReady,
    bool onSnapshotReady$async,
  }) = _$MapLibreMap_SnapshotReadyCallback;

  void onSnapshotReady(_$jni.JObject bitmap);
  bool get onSnapshotReady$async => false;
}

final class _$MapLibreMap_SnapshotReadyCallback
    with $MapLibreMap_SnapshotReadyCallback {
  _$MapLibreMap_SnapshotReadyCallback({
    required void Function(_$jni.JObject bitmap) onSnapshotReady,
    this.onSnapshotReady$async = false,
  }) : _onSnapshotReady = onSnapshotReady;

  final void Function(_$jni.JObject bitmap) _onSnapshotReady;
  final bool onSnapshotReady$async;

  void onSnapshotReady(_$jni.JObject bitmap) {
    return _onSnapshotReady(bitmap);
  }
}

final class $MapLibreMap_SnapshotReadyCallback$Type
    extends _$jni.JObjType<MapLibreMap_SnapshotReadyCallback> {
  @_$jni.internal
  const $MapLibreMap_SnapshotReadyCallback$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback;';

  @_$jni.internal
  @_$core.override
  MapLibreMap_SnapshotReadyCallback fromReference(_$jni.JReference reference) =>
      MapLibreMap_SnapshotReadyCallback.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap_SnapshotReadyCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_SnapshotReadyCallback$Type) &&
        other is $MapLibreMap_SnapshotReadyCallback$Type;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap`
class MapLibreMap extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MapLibreMap> $type;

  @_$jni.internal
  MapLibreMap.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'org/maplibre/android/maps/MapLibreMap');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap$Type();
  static final _id_triggerRepaint = _class.instanceMethodId(
    r'triggerRepaint',
    r'()V',
  );

  static final _triggerRepaint = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void triggerRepaint()`
  void triggerRepaint() {
    _triggerRepaint(reference.pointer, _id_triggerRepaint as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_setSwapBehaviorFlush = _class.instanceMethodId(
    r'setSwapBehaviorFlush',
    r'(Z)V',
  );

  static final _setSwapBehaviorFlush = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setSwapBehaviorFlush(boolean z)`
  void setSwapBehaviorFlush(
    bool z,
  ) {
    _setSwapBehaviorFlush(reference.pointer,
            _id_setSwapBehaviorFlush as _$jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getStyle = _class.instanceMethodId(
    r'getStyle',
    r'(Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _getStyle = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void getStyle(org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void getStyle(
    style_.Style_OnStyleLoaded onStyleLoaded,
  ) {
    _getStyle(reference.pointer, _id_getStyle as _$jni.JMethodIDPtr,
            onStyleLoaded.reference.pointer)
        .check();
  }

  static final _id_getStyle$1 = _class.instanceMethodId(
    r'getStyle',
    r'()Lorg/maplibre/android/maps/Style;',
  );

  static final _getStyle$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.Style getStyle()`
  /// The returned object must be released after use, by calling the [release] method.
  style_.Style getStyle$1() {
    return _getStyle$1(reference.pointer, _id_getStyle$1 as _$jni.JMethodIDPtr)
        .object(const style_.$Style$Type());
  }

  static final _id_setPrefetchesTiles = _class.instanceMethodId(
    r'setPrefetchesTiles',
    r'(Z)V',
  );

  static final _setPrefetchesTiles = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setPrefetchesTiles(boolean z)`
  void setPrefetchesTiles(
    bool z,
  ) {
    _setPrefetchesTiles(reference.pointer,
            _id_setPrefetchesTiles as _$jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getPrefetchesTiles = _class.instanceMethodId(
    r'getPrefetchesTiles',
    r'()Z',
  );

  static final _getPrefetchesTiles = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getPrefetchesTiles()`
  bool getPrefetchesTiles() {
    return _getPrefetchesTiles(
            reference.pointer, _id_getPrefetchesTiles as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPrefetchZoomDelta = _class.instanceMethodId(
    r'setPrefetchZoomDelta',
    r'(I)V',
  );

  static final _setPrefetchZoomDelta = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setPrefetchZoomDelta(int i)`
  void setPrefetchZoomDelta(
    int i,
  ) {
    _setPrefetchZoomDelta(reference.pointer,
            _id_setPrefetchZoomDelta as _$jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getPrefetchZoomDelta = _class.instanceMethodId(
    r'getPrefetchZoomDelta',
    r'()I',
  );

  static final _getPrefetchZoomDelta = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int getPrefetchZoomDelta()`
  int getPrefetchZoomDelta() {
    return _getPrefetchZoomDelta(
            reference.pointer, _id_getPrefetchZoomDelta as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setTileCacheEnabled = _class.instanceMethodId(
    r'setTileCacheEnabled',
    r'(Z)V',
  );

  static final _setTileCacheEnabled = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setTileCacheEnabled(boolean z)`
  void setTileCacheEnabled(
    bool z,
  ) {
    _setTileCacheEnabled(reference.pointer,
            _id_setTileCacheEnabled as _$jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getTileCacheEnabled = _class.instanceMethodId(
    r'getTileCacheEnabled',
    r'()Z',
  );

  static final _getTileCacheEnabled = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getTileCacheEnabled()`
  bool getTileCacheEnabled() {
    return _getTileCacheEnabled(
            reference.pointer, _id_getTileCacheEnabled as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setMinZoomPreference = _class.instanceMethodId(
    r'setMinZoomPreference',
    r'(D)V',
  );

  static final _setMinZoomPreference = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, double)>();

  /// from: `public void setMinZoomPreference(double d)`
  void setMinZoomPreference(
    double d,
  ) {
    _setMinZoomPreference(reference.pointer,
            _id_setMinZoomPreference as _$jni.JMethodIDPtr, d)
        .check();
  }

  static final _id_getMinZoomLevel = _class.instanceMethodId(
    r'getMinZoomLevel',
    r'()D',
  );

  static final _getMinZoomLevel = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public double getMinZoomLevel()`
  double getMinZoomLevel() {
    return _getMinZoomLevel(
            reference.pointer, _id_getMinZoomLevel as _$jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_setMaxZoomPreference = _class.instanceMethodId(
    r'setMaxZoomPreference',
    r'(D)V',
  );

  static final _setMaxZoomPreference = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, double)>();

  /// from: `public void setMaxZoomPreference(double d)`
  void setMaxZoomPreference(
    double d,
  ) {
    _setMaxZoomPreference(reference.pointer,
            _id_setMaxZoomPreference as _$jni.JMethodIDPtr, d)
        .check();
  }

  static final _id_getMaxZoomLevel = _class.instanceMethodId(
    r'getMaxZoomLevel',
    r'()D',
  );

  static final _getMaxZoomLevel = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public double getMaxZoomLevel()`
  double getMaxZoomLevel() {
    return _getMaxZoomLevel(
            reference.pointer, _id_getMaxZoomLevel as _$jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_setMinPitchPreference = _class.instanceMethodId(
    r'setMinPitchPreference',
    r'(D)V',
  );

  static final _setMinPitchPreference = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, double)>();

  /// from: `public void setMinPitchPreference(double d)`
  void setMinPitchPreference(
    double d,
  ) {
    _setMinPitchPreference(reference.pointer,
            _id_setMinPitchPreference as _$jni.JMethodIDPtr, d)
        .check();
  }

  static final _id_getMinPitch = _class.instanceMethodId(
    r'getMinPitch',
    r'()D',
  );

  static final _getMinPitch = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public double getMinPitch()`
  double getMinPitch() {
    return _getMinPitch(
            reference.pointer, _id_getMinPitch as _$jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_setMaxPitchPreference = _class.instanceMethodId(
    r'setMaxPitchPreference',
    r'(D)V',
  );

  static final _setMaxPitchPreference = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, double)>();

  /// from: `public void setMaxPitchPreference(double d)`
  void setMaxPitchPreference(
    double d,
  ) {
    _setMaxPitchPreference(reference.pointer,
            _id_setMaxPitchPreference as _$jni.JMethodIDPtr, d)
        .check();
  }

  static final _id_getMaxPitch = _class.instanceMethodId(
    r'getMaxPitch',
    r'()D',
  );

  static final _getMaxPitch = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public double getMaxPitch()`
  double getMaxPitch() {
    return _getMaxPitch(
            reference.pointer, _id_getMaxPitch as _$jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getUiSettings = _class.instanceMethodId(
    r'getUiSettings',
    r'()Lorg/maplibre/android/maps/UiSettings;',
  );

  static final _getUiSettings = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.UiSettings getUiSettings()`
  /// The returned object must be released after use, by calling the [release] method.
  uisettings_.UiSettings getUiSettings() {
    return _getUiSettings(
            reference.pointer, _id_getUiSettings as _$jni.JMethodIDPtr)
        .object(const uisettings_.$UiSettings$Type());
  }

  static final _id_getProjection = _class.instanceMethodId(
    r'getProjection',
    r'()Lorg/maplibre/android/maps/Projection;',
  );

  static final _getProjection = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.Projection getProjection()`
  /// The returned object must be released after use, by calling the [release] method.
  projection_.Projection getProjection() {
    return _getProjection(
            reference.pointer, _id_getProjection as _$jni.JMethodIDPtr)
        .object(const projection_.$Projection$Type());
  }

  static final _id_cancelTransitions = _class.instanceMethodId(
    r'cancelTransitions',
    r'()V',
  );

  static final _cancelTransitions = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void cancelTransitions()`
  void cancelTransitions() {
    _cancelTransitions(
            reference.pointer, _id_cancelTransitions as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_getCameraPosition = _class.instanceMethodId(
    r'getCameraPosition',
    r'()Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraPosition = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public final org.maplibre.android.camera.CameraPosition getCameraPosition()`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraPosition() {
    return _getCameraPosition(
            reference.pointer, _id_getCameraPosition as _$jni.JMethodIDPtr)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_setCameraPosition = _class.instanceMethodId(
    r'setCameraPosition',
    r'(Lorg/maplibre/android/camera/CameraPosition;)V',
  );

  static final _setCameraPosition = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setCameraPosition(org.maplibre.android.camera.CameraPosition cameraPosition)`
  void setCameraPosition(
    cameraposition_.CameraPosition cameraPosition,
  ) {
    _setCameraPosition(
            reference.pointer,
            _id_setCameraPosition as _$jni.JMethodIDPtr,
            cameraPosition.reference.pointer)
        .check();
  }

  static final _id_moveCamera = _class.instanceMethodId(
    r'moveCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _moveCamera = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void moveCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void moveCamera(
    cameraupdate_.CameraUpdate cameraUpdate,
  ) {
    _moveCamera(reference.pointer, _id_moveCamera as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer)
        .check();
  }

  static final _id_moveCamera$1 = _class.instanceMethodId(
    r'moveCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _moveCamera$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void moveCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void moveCamera$1(
    cameraupdate_.CameraUpdate cameraUpdate,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _moveCamera$1(
            reference.pointer,
            _id_moveCamera$1 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_easeCamera = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _easeCamera = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void easeCamera(
    cameraupdate_.CameraUpdate cameraUpdate,
  ) {
    _easeCamera(reference.pointer, _id_easeCamera as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer)
        .check();
  }

  static final _id_easeCamera$1 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera$1(
    cameraupdate_.CameraUpdate cameraUpdate,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _easeCamera$1(
            reference.pointer,
            _id_easeCamera$1 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_easeCamera$2 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;I)V',
  );

  static final _easeCamera$2 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni
                          .VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i)`
  void easeCamera$2(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
  ) {
    _easeCamera$2(reference.pointer, _id_easeCamera$2 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer, i)
        .check();
  }

  static final _id_easeCamera$3 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;ILorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              int,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera$3(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _easeCamera$3(
            reference.pointer,
            _id_easeCamera$3 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            i,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_easeCamera$4 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;IZ)V',
  );

  static final _easeCamera$4 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int, int)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, boolean z)`
  void easeCamera$4(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
    bool z,
  ) {
    _easeCamera$4(reference.pointer, _id_easeCamera$4 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer, i, z ? 1 : 0)
        .check();
  }

  static final _id_easeCamera$5 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;IZLorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera$5 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              int,
              int,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, boolean z, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera$5(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
    bool z,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _easeCamera$5(
            reference.pointer,
            _id_easeCamera$5 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            i,
            z ? 1 : 0,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_animateCamera = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _animateCamera = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void animateCamera(
    cameraupdate_.CameraUpdate cameraUpdate,
  ) {
    _animateCamera(reference.pointer, _id_animateCamera as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer)
        .check();
  }

  static final _id_animateCamera$1 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _animateCamera$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void animateCamera$1(
    cameraupdate_.CameraUpdate cameraUpdate,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _animateCamera$1(
            reference.pointer,
            _id_animateCamera$1 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_animateCamera$2 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;I)V',
  );

  static final _animateCamera$2 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni
                          .VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i)`
  void animateCamera$2(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
  ) {
    _animateCamera$2(
            reference.pointer,
            _id_animateCamera$2 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            i)
        .check();
  }

  static final _id_animateCamera$3 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;ILorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _animateCamera$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              int,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void animateCamera$3(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _animateCamera$3(
            reference.pointer,
            _id_animateCamera$3 as _$jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            i,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_scrollBy = _class.instanceMethodId(
    r'scrollBy',
    r'(FF)V',
  );

  static final _scrollBy = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Double, _$jni.Double)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, double, double)>();

  /// from: `public void scrollBy(float f, float f1)`
  void scrollBy(
    double f,
    double f1,
  ) {
    _scrollBy(reference.pointer, _id_scrollBy as _$jni.JMethodIDPtr, f, f1)
        .check();
  }

  static final _id_scrollBy$1 = _class.instanceMethodId(
    r'scrollBy',
    r'(FFJ)V',
  );

  static final _scrollBy$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Double,
                        _$jni.Double,
                        _$jni.Int64
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, double, double, int)>();

  /// from: `public void scrollBy(float f, float f1, long j)`
  void scrollBy$1(
    double f,
    double f1,
    int j,
  ) {
    _scrollBy$1(
            reference.pointer, _id_scrollBy$1 as _$jni.JMethodIDPtr, f, f1, j)
        .check();
  }

  static final _id_resetNorth = _class.instanceMethodId(
    r'resetNorth',
    r'()V',
  );

  static final _resetNorth = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void resetNorth()`
  void resetNorth() {
    _resetNorth(reference.pointer, _id_resetNorth as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_setFocalBearing = _class.instanceMethodId(
    r'setFocalBearing',
    r'(DFFJ)V',
  );

  static final _setFocalBearing = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Double,
                        _$jni.Double,
                        _$jni.Double,
                        _$jni.Int64
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, double, double, double, int)>();

  /// from: `public void setFocalBearing(double d, float f, float f1, long j)`
  void setFocalBearing(
    double d,
    double f,
    double f1,
    int j,
  ) {
    _setFocalBearing(reference.pointer,
            _id_setFocalBearing as _$jni.JMethodIDPtr, d, f, f1, j)
        .check();
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()F',
  );

  static final _getHeight = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public float getHeight()`
  double getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as _$jni.JMethodIDPtr)
        .float;
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()F',
  );

  static final _getWidth = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public float getWidth()`
  double getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as _$jni.JMethodIDPtr)
        .float;
  }

  static final _id_setOfflineRegionDefinition = _class.instanceMethodId(
    r'setOfflineRegionDefinition',
    r'(Lorg/maplibre/android/offline/OfflineRegionDefinition;)V',
  );

  static final _setOfflineRegionDefinition =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOfflineRegionDefinition(org.maplibre.android.offline.OfflineRegionDefinition offlineRegionDefinition)`
  void setOfflineRegionDefinition(
    offlineregiondefinition_.OfflineRegionDefinition offlineRegionDefinition,
  ) {
    _setOfflineRegionDefinition(
            reference.pointer,
            _id_setOfflineRegionDefinition as _$jni.JMethodIDPtr,
            offlineRegionDefinition.reference.pointer)
        .check();
  }

  static final _id_setOfflineRegionDefinition$1 = _class.instanceMethodId(
    r'setOfflineRegionDefinition',
    r'(Lorg/maplibre/android/offline/OfflineRegionDefinition;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setOfflineRegionDefinition$1 =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Pointer<_$jni.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOfflineRegionDefinition(org.maplibre.android.offline.OfflineRegionDefinition offlineRegionDefinition, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setOfflineRegionDefinition$1(
    offlineregiondefinition_.OfflineRegionDefinition offlineRegionDefinition,
    style_.Style_OnStyleLoaded onStyleLoaded,
  ) {
    _setOfflineRegionDefinition$1(
            reference.pointer,
            _id_setOfflineRegionDefinition$1 as _$jni.JMethodIDPtr,
            offlineRegionDefinition.reference.pointer,
            onStyleLoaded.reference.pointer)
        .check();
  }

  static final _id_isDebugActive = _class.instanceMethodId(
    r'isDebugActive',
    r'()Z',
  );

  static final _isDebugActive = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isDebugActive()`
  bool isDebugActive() {
    return _isDebugActive(
            reference.pointer, _id_isDebugActive as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setDebugActive = _class.instanceMethodId(
    r'setDebugActive',
    r'(Z)V',
  );

  static final _setDebugActive = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setDebugActive(boolean z)`
  void setDebugActive(
    bool z,
  ) {
    _setDebugActive(reference.pointer, _id_setDebugActive as _$jni.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_cycleDebugOptions = _class.instanceMethodId(
    r'cycleDebugOptions',
    r'()V',
  );

  static final _cycleDebugOptions = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void cycleDebugOptions()`
  void cycleDebugOptions() {
    _cycleDebugOptions(
            reference.pointer, _id_cycleDebugOptions as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_setStyle = _class.instanceMethodId(
    r'setStyle',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyle = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setStyle(java.lang.String string)`
  void setStyle(
    _$jni.JString string,
  ) {
    _setStyle(reference.pointer, _id_setStyle as _$jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_setStyle$1 = _class.instanceMethodId(
    r'setStyle',
    r'(Ljava/lang/String;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setStyle$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setStyle(java.lang.String string, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setStyle$1(
    _$jni.JString string,
    style_.Style_OnStyleLoaded onStyleLoaded,
  ) {
    _setStyle$1(reference.pointer, _id_setStyle$1 as _$jni.JMethodIDPtr,
            string.reference.pointer, onStyleLoaded.reference.pointer)
        .check();
  }

  static final _id_setStyle$2 = _class.instanceMethodId(
    r'setStyle',
    r'(Lorg/maplibre/android/maps/Style$Builder;)V',
  );

  static final _setStyle$2 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setStyle(org.maplibre.android.maps.Style$Builder builder)`
  void setStyle$2(
    style_.Style_Builder builder,
  ) {
    _setStyle$2(reference.pointer, _id_setStyle$2 as _$jni.JMethodIDPtr,
            builder.reference.pointer)
        .check();
  }

  static final _id_setStyle$3 = _class.instanceMethodId(
    r'setStyle',
    r'(Lorg/maplibre/android/maps/Style$Builder;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setStyle$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setStyle(org.maplibre.android.maps.Style$Builder builder, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setStyle$3(
    style_.Style_Builder builder,
    style_.Style_OnStyleLoaded onStyleLoaded,
  ) {
    _setStyle$3(reference.pointer, _id_setStyle$3 as _$jni.JMethodIDPtr,
            builder.reference.pointer, onStyleLoaded.reference.pointer)
        .check();
  }

  static final _id_addMarker = _class.instanceMethodId(
    r'addMarker',
    r'(Lorg/maplibre/android/annotations/MarkerOptions;)Lorg/maplibre/android/annotations/Marker;',
  );

  static final _addMarker = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.maplibre.android.annotations.Marker addMarker(org.maplibre.android.annotations.MarkerOptions markerOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject addMarker(
    _$jni.JObject markerOptions,
  ) {
    return _addMarker(reference.pointer, _id_addMarker as _$jni.JMethodIDPtr,
            markerOptions.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  static final _id_addMarker$1 = _class.instanceMethodId(
    r'addMarker',
    r'(Lorg/maplibre/android/annotations/BaseMarkerOptions;)Lorg/maplibre/android/annotations/Marker;',
  );

  static final _addMarker$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.maplibre.android.annotations.Marker addMarker(org.maplibre.android.annotations.BaseMarkerOptions baseMarkerOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject addMarker$1(
    _$jni.JObject baseMarkerOptions,
  ) {
    return _addMarker$1(
            reference.pointer,
            _id_addMarker$1 as _$jni.JMethodIDPtr,
            baseMarkerOptions.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  static final _id_addMarkers = _class.instanceMethodId(
    r'addMarkers',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addMarkers = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.List addMarkers(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> addMarkers(
    _$jni.JList<_$jni.JObject> list,
  ) {
    return _addMarkers(reference.pointer, _id_addMarkers as _$jni.JMethodIDPtr,
            list.reference.pointer)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_updateMarker = _class.instanceMethodId(
    r'updateMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _updateMarker = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void updateMarker(org.maplibre.android.annotations.Marker marker)`
  void updateMarker(
    _$jni.JObject marker,
  ) {
    _updateMarker(reference.pointer, _id_updateMarker as _$jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  static final _id_addPolyline = _class.instanceMethodId(
    r'addPolyline',
    r'(Lorg/maplibre/android/annotations/PolylineOptions;)Lorg/maplibre/android/annotations/Polyline;',
  );

  static final _addPolyline = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.maplibre.android.annotations.Polyline addPolyline(org.maplibre.android.annotations.PolylineOptions polylineOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject addPolyline(
    _$jni.JObject polylineOptions,
  ) {
    return _addPolyline(
            reference.pointer,
            _id_addPolyline as _$jni.JMethodIDPtr,
            polylineOptions.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  static final _id_addPolylines = _class.instanceMethodId(
    r'addPolylines',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addPolylines = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.List addPolylines(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> addPolylines(
    _$jni.JList<_$jni.JObject> list,
  ) {
    return _addPolylines(reference.pointer,
            _id_addPolylines as _$jni.JMethodIDPtr, list.reference.pointer)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_updatePolyline = _class.instanceMethodId(
    r'updatePolyline',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _updatePolyline = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void updatePolyline(org.maplibre.android.annotations.Polyline polyline)`
  void updatePolyline(
    _$jni.JObject polyline,
  ) {
    _updatePolyline(reference.pointer, _id_updatePolyline as _$jni.JMethodIDPtr,
            polyline.reference.pointer)
        .check();
  }

  static final _id_addPolygon = _class.instanceMethodId(
    r'addPolygon',
    r'(Lorg/maplibre/android/annotations/PolygonOptions;)Lorg/maplibre/android/annotations/Polygon;',
  );

  static final _addPolygon = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.maplibre.android.annotations.Polygon addPolygon(org.maplibre.android.annotations.PolygonOptions polygonOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject addPolygon(
    _$jni.JObject polygonOptions,
  ) {
    return _addPolygon(reference.pointer, _id_addPolygon as _$jni.JMethodIDPtr,
            polygonOptions.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  static final _id_addPolygons = _class.instanceMethodId(
    r'addPolygons',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addPolygons = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.List addPolygons(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> addPolygons(
    _$jni.JList<_$jni.JObject> list,
  ) {
    return _addPolygons(reference.pointer,
            _id_addPolygons as _$jni.JMethodIDPtr, list.reference.pointer)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_updatePolygon = _class.instanceMethodId(
    r'updatePolygon',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _updatePolygon = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void updatePolygon(org.maplibre.android.annotations.Polygon polygon)`
  void updatePolygon(
    _$jni.JObject polygon,
  ) {
    _updatePolygon(reference.pointer, _id_updatePolygon as _$jni.JMethodIDPtr,
            polygon.reference.pointer)
        .check();
  }

  static final _id_removeMarker = _class.instanceMethodId(
    r'removeMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _removeMarker = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeMarker(org.maplibre.android.annotations.Marker marker)`
  void removeMarker(
    _$jni.JObject marker,
  ) {
    _removeMarker(reference.pointer, _id_removeMarker as _$jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  static final _id_removePolyline = _class.instanceMethodId(
    r'removePolyline',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _removePolyline = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removePolyline(org.maplibre.android.annotations.Polyline polyline)`
  void removePolyline(
    _$jni.JObject polyline,
  ) {
    _removePolyline(reference.pointer, _id_removePolyline as _$jni.JMethodIDPtr,
            polyline.reference.pointer)
        .check();
  }

  static final _id_removePolygon = _class.instanceMethodId(
    r'removePolygon',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _removePolygon = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removePolygon(org.maplibre.android.annotations.Polygon polygon)`
  void removePolygon(
    _$jni.JObject polygon,
  ) {
    _removePolygon(reference.pointer, _id_removePolygon as _$jni.JMethodIDPtr,
            polygon.reference.pointer)
        .check();
  }

  static final _id_removeAnnotation = _class.instanceMethodId(
    r'removeAnnotation',
    r'(Lorg/maplibre/android/annotations/Annotation;)V',
  );

  static final _removeAnnotation = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeAnnotation(org.maplibre.android.annotations.Annotation annotation)`
  void removeAnnotation(
    _$jni.JObject annotation,
  ) {
    _removeAnnotation(
            reference.pointer,
            _id_removeAnnotation as _$jni.JMethodIDPtr,
            annotation.reference.pointer)
        .check();
  }

  static final _id_removeAnnotation$1 = _class.instanceMethodId(
    r'removeAnnotation',
    r'(J)V',
  );

  static final _removeAnnotation$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void removeAnnotation(long j)`
  void removeAnnotation$1(
    int j,
  ) {
    _removeAnnotation$1(
            reference.pointer, _id_removeAnnotation$1 as _$jni.JMethodIDPtr, j)
        .check();
  }

  static final _id_removeAnnotations = _class.instanceMethodId(
    r'removeAnnotations',
    r'(Ljava/util/List;)V',
  );

  static final _removeAnnotations = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeAnnotations(java.util.List list)`
  void removeAnnotations(
    _$jni.JList<_$jni.JObject> list,
  ) {
    _removeAnnotations(reference.pointer,
            _id_removeAnnotations as _$jni.JMethodIDPtr, list.reference.pointer)
        .check();
  }

  static final _id_removeAnnotations$1 = _class.instanceMethodId(
    r'removeAnnotations',
    r'()V',
  );

  static final _removeAnnotations$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void removeAnnotations()`
  void removeAnnotations$1() {
    _removeAnnotations$1(
            reference.pointer, _id_removeAnnotations$1 as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as _$jni.JMethodIDPtr).check();
  }

  static final _id_getAnnotation = _class.instanceMethodId(
    r'getAnnotation',
    r'(J)Lorg/maplibre/android/annotations/Annotation;',
  );

  static final _getAnnotation = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.annotations.Annotation getAnnotation(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject getAnnotation(
    int j,
  ) {
    return _getAnnotation(
            reference.pointer, _id_getAnnotation as _$jni.JMethodIDPtr, j)
        .object(const _$jni.JObjectType());
  }

  static final _id_getAnnotations = _class.instanceMethodId(
    r'getAnnotations',
    r'()Ljava/util/List;',
  );

  static final _getAnnotations = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getAnnotations()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> getAnnotations() {
    return _getAnnotations(
            reference.pointer, _id_getAnnotations as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_getMarkers = _class.instanceMethodId(
    r'getMarkers',
    r'()Ljava/util/List;',
  );

  static final _getMarkers = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getMarkers()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> getMarkers() {
    return _getMarkers(reference.pointer, _id_getMarkers as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_getPolygons = _class.instanceMethodId(
    r'getPolygons',
    r'()Ljava/util/List;',
  );

  static final _getPolygons = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getPolygons()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> getPolygons() {
    return _getPolygons(
            reference.pointer, _id_getPolygons as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_getPolylines = _class.instanceMethodId(
    r'getPolylines',
    r'()Ljava/util/List;',
  );

  static final _getPolylines = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getPolylines()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> getPolylines() {
    return _getPolylines(
            reference.pointer, _id_getPolylines as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_setOnMarkerClickListener = _class.instanceMethodId(
    r'setOnMarkerClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMarkerClickListener;)V',
  );

  static final _setOnMarkerClickListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOnMarkerClickListener(org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener onMarkerClickListener)`
  void setOnMarkerClickListener(
    MapLibreMap_OnMarkerClickListener onMarkerClickListener,
  ) {
    _setOnMarkerClickListener(
            reference.pointer,
            _id_setOnMarkerClickListener as _$jni.JMethodIDPtr,
            onMarkerClickListener.reference.pointer)
        .check();
  }

  static final _id_setOnPolygonClickListener = _class.instanceMethodId(
    r'setOnPolygonClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnPolygonClickListener;)V',
  );

  static final _setOnPolygonClickListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOnPolygonClickListener(org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener onPolygonClickListener)`
  void setOnPolygonClickListener(
    MapLibreMap_OnPolygonClickListener onPolygonClickListener,
  ) {
    _setOnPolygonClickListener(
            reference.pointer,
            _id_setOnPolygonClickListener as _$jni.JMethodIDPtr,
            onPolygonClickListener.reference.pointer)
        .check();
  }

  static final _id_setOnPolylineClickListener = _class.instanceMethodId(
    r'setOnPolylineClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnPolylineClickListener;)V',
  );

  static final _setOnPolylineClickListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOnPolylineClickListener(org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener onPolylineClickListener)`
  void setOnPolylineClickListener(
    MapLibreMap_OnPolylineClickListener onPolylineClickListener,
  ) {
    _setOnPolylineClickListener(
            reference.pointer,
            _id_setOnPolylineClickListener as _$jni.JMethodIDPtr,
            onPolylineClickListener.reference.pointer)
        .check();
  }

  static final _id_selectMarker = _class.instanceMethodId(
    r'selectMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _selectMarker = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void selectMarker(org.maplibre.android.annotations.Marker marker)`
  void selectMarker(
    _$jni.JObject marker,
  ) {
    _selectMarker(reference.pointer, _id_selectMarker as _$jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  static final _id_deselectMarkers = _class.instanceMethodId(
    r'deselectMarkers',
    r'()V',
  );

  static final _deselectMarkers = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void deselectMarkers()`
  void deselectMarkers() {
    _deselectMarkers(
            reference.pointer, _id_deselectMarkers as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_deselectMarker = _class.instanceMethodId(
    r'deselectMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _deselectMarker = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void deselectMarker(org.maplibre.android.annotations.Marker marker)`
  void deselectMarker(
    _$jni.JObject marker,
  ) {
    _deselectMarker(reference.pointer, _id_deselectMarker as _$jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  static final _id_getSelectedMarkers = _class.instanceMethodId(
    r'getSelectedMarkers',
    r'()Ljava/util/List;',
  );

  static final _getSelectedMarkers = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getSelectedMarkers()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> getSelectedMarkers() {
    return _getSelectedMarkers(
            reference.pointer, _id_getSelectedMarkers as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_setInfoWindowAdapter = _class.instanceMethodId(
    r'setInfoWindowAdapter',
    r'(Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;)V',
  );

  static final _setInfoWindowAdapter = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setInfoWindowAdapter(org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter infoWindowAdapter)`
  void setInfoWindowAdapter(
    MapLibreMap_InfoWindowAdapter infoWindowAdapter,
  ) {
    _setInfoWindowAdapter(
            reference.pointer,
            _id_setInfoWindowAdapter as _$jni.JMethodIDPtr,
            infoWindowAdapter.reference.pointer)
        .check();
  }

  static final _id_getInfoWindowAdapter = _class.instanceMethodId(
    r'getInfoWindowAdapter',
    r'()Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;',
  );

  static final _getInfoWindowAdapter = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter getInfoWindowAdapter()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap_InfoWindowAdapter getInfoWindowAdapter() {
    return _getInfoWindowAdapter(
            reference.pointer, _id_getInfoWindowAdapter as _$jni.JMethodIDPtr)
        .object(const $MapLibreMap_InfoWindowAdapter$Type());
  }

  static final _id_setAllowConcurrentMultipleOpenInfoWindows =
      _class.instanceMethodId(
    r'setAllowConcurrentMultipleOpenInfoWindows',
    r'(Z)V',
  );

  static final _setAllowConcurrentMultipleOpenInfoWindows =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setAllowConcurrentMultipleOpenInfoWindows(boolean z)`
  void setAllowConcurrentMultipleOpenInfoWindows(
    bool z,
  ) {
    _setAllowConcurrentMultipleOpenInfoWindows(
            reference.pointer,
            _id_setAllowConcurrentMultipleOpenInfoWindows as _$jni.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isAllowConcurrentMultipleOpenInfoWindows =
      _class.instanceMethodId(
    r'isAllowConcurrentMultipleOpenInfoWindows',
    r'()Z',
  );

  static final _isAllowConcurrentMultipleOpenInfoWindows =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public boolean isAllowConcurrentMultipleOpenInfoWindows()`
  bool isAllowConcurrentMultipleOpenInfoWindows() {
    return _isAllowConcurrentMultipleOpenInfoWindows(reference.pointer,
            _id_isAllowConcurrentMultipleOpenInfoWindows as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setLatLngBoundsForCameraTarget = _class.instanceMethodId(
    r'setLatLngBoundsForCameraTarget',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;)V',
  );

  static final _setLatLngBoundsForCameraTarget =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setLatLngBoundsForCameraTarget(org.maplibre.android.geometry.LatLngBounds latLngBounds)`
  void setLatLngBoundsForCameraTarget(
    latlngbounds_.LatLngBounds latLngBounds,
  ) {
    _setLatLngBoundsForCameraTarget(
            reference.pointer,
            _id_setLatLngBoundsForCameraTarget as _$jni.JMethodIDPtr,
            latLngBounds.reference.pointer)
        .check();
  }

  static final _id_getCameraForLatLngBounds = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForLatLngBounds(
    latlngbounds_.LatLngBounds latLngBounds,
  ) {
    return _getCameraForLatLngBounds(
            reference.pointer,
            _id_getCameraForLatLngBounds as _$jni.JMethodIDPtr,
            latLngBounds.reference.pointer)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_getCameraForLatLngBounds$1 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;[I)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds$1 =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Pointer<_$jni.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForLatLngBounds$1(
    latlngbounds_.LatLngBounds latLngBounds,
    _$jni.JArray<_$jni.jint> is$,
  ) {
    return _getCameraForLatLngBounds$1(
            reference.pointer,
            _id_getCameraForLatLngBounds$1 as _$jni.JMethodIDPtr,
            latLngBounds.reference.pointer,
            is$.reference.pointer)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_getCameraForLatLngBounds$2 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;DD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds$2 =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Double,
                            _$jni.Double
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.Pointer<_$jni.Void>,
                  double,
                  double)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForLatLngBounds$2(
    latlngbounds_.LatLngBounds latLngBounds,
    double d,
    double d1,
  ) {
    return _getCameraForLatLngBounds$2(
            reference.pointer,
            _id_getCameraForLatLngBounds$2 as _$jni.JMethodIDPtr,
            latLngBounds.reference.pointer,
            d,
            d1)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_getCameraForLatLngBounds$3 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;[IDD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds$3 =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Double,
                            _$jni.Double
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.Pointer<_$jni.Void>,
                  double,
                  double)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, int[] is, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForLatLngBounds$3(
    latlngbounds_.LatLngBounds latLngBounds,
    _$jni.JArray<_$jni.jint> is$,
    double d,
    double d1,
  ) {
    return _getCameraForLatLngBounds$3(
            reference.pointer,
            _id_getCameraForLatLngBounds$3 as _$jni.JMethodIDPtr,
            latLngBounds.reference.pointer,
            is$.reference.pointer,
            d,
            d1)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_getCameraForGeometry = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForGeometry(
    _$jni.JObject geometry,
  ) {
    return _getCameraForGeometry(
            reference.pointer,
            _id_getCameraForGeometry as _$jni.JMethodIDPtr,
            geometry.reference.pointer)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_getCameraForGeometry$1 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;[I)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForGeometry$1(
    _$jni.JObject geometry,
    _$jni.JArray<_$jni.jint> is$,
  ) {
    return _getCameraForGeometry$1(
            reference.pointer,
            _id_getCameraForGeometry$1 as _$jni.JMethodIDPtr,
            geometry.reference.pointer,
            is$.reference.pointer)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_getCameraForGeometry$2 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;DD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Double,
                        _$jni.Double
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, double, double)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForGeometry$2(
    _$jni.JObject geometry,
    double d,
    double d1,
  ) {
    return _getCameraForGeometry$2(
            reference.pointer,
            _id_getCameraForGeometry$2 as _$jni.JMethodIDPtr,
            geometry.reference.pointer,
            d,
            d1)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_getCameraForGeometry$3 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;[IDD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Double,
                        _$jni.Double
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              double,
              double)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, int[] is, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForGeometry$3(
    _$jni.JObject geometry,
    _$jni.JArray<_$jni.jint> is$,
    double d,
    double d1,
  ) {
    return _getCameraForGeometry$3(
            reference.pointer,
            _id_getCameraForGeometry$3 as _$jni.JMethodIDPtr,
            geometry.reference.pointer,
            is$.reference.pointer,
            d,
            d1)
        .object(const cameraposition_.$CameraPosition$Type());
  }

  static final _id_setPadding = _class.instanceMethodId(
    r'setPadding',
    r'(IIII)V',
  );

  static final _setPadding = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, int, int)>();

  /// from: `public void setPadding(int i, int i1, int i2, int i3)`
  void setPadding(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _setPadding(reference.pointer, _id_setPadding as _$jni.JMethodIDPtr, i, i1,
            i2, i3)
        .check();
  }

  static final _id_getPadding = _class.instanceMethodId(
    r'getPadding',
    r'()[I',
  );

  static final _getPadding = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int[] getPadding()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.jint> getPadding() {
    return _getPadding(reference.pointer, _id_getPadding as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.jintType()));
  }

  static final _id_addOnCameraIdleListener = _class.instanceMethodId(
    r'addOnCameraIdleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;)V',
  );

  static final _addOnCameraIdleListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnCameraIdleListener(org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener onCameraIdleListener)`
  void addOnCameraIdleListener(
    MapLibreMap_OnCameraIdleListener onCameraIdleListener,
  ) {
    _addOnCameraIdleListener(
            reference.pointer,
            _id_addOnCameraIdleListener as _$jni.JMethodIDPtr,
            onCameraIdleListener.reference.pointer)
        .check();
  }

  static final _id_removeOnCameraIdleListener = _class.instanceMethodId(
    r'removeOnCameraIdleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;)V',
  );

  static final _removeOnCameraIdleListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnCameraIdleListener(org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener onCameraIdleListener)`
  void removeOnCameraIdleListener(
    MapLibreMap_OnCameraIdleListener onCameraIdleListener,
  ) {
    _removeOnCameraIdleListener(
            reference.pointer,
            _id_removeOnCameraIdleListener as _$jni.JMethodIDPtr,
            onCameraIdleListener.reference.pointer)
        .check();
  }

  static final _id_addOnCameraMoveCancelListener = _class.instanceMethodId(
    r'addOnCameraMoveCancelListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;)V',
  );

  static final _addOnCameraMoveCancelListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnCameraMoveCancelListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener onCameraMoveCanceledListener)`
  void addOnCameraMoveCancelListener(
    MapLibreMap_OnCameraMoveCanceledListener onCameraMoveCanceledListener,
  ) {
    _addOnCameraMoveCancelListener(
            reference.pointer,
            _id_addOnCameraMoveCancelListener as _$jni.JMethodIDPtr,
            onCameraMoveCanceledListener.reference.pointer)
        .check();
  }

  static final _id_removeOnCameraMoveCancelListener = _class.instanceMethodId(
    r'removeOnCameraMoveCancelListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;)V',
  );

  static final _removeOnCameraMoveCancelListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnCameraMoveCancelListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener onCameraMoveCanceledListener)`
  void removeOnCameraMoveCancelListener(
    MapLibreMap_OnCameraMoveCanceledListener onCameraMoveCanceledListener,
  ) {
    _removeOnCameraMoveCancelListener(
            reference.pointer,
            _id_removeOnCameraMoveCancelListener as _$jni.JMethodIDPtr,
            onCameraMoveCanceledListener.reference.pointer)
        .check();
  }

  static final _id_addOnCameraMoveStartedListener = _class.instanceMethodId(
    r'addOnCameraMoveStartedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;)V',
  );

  static final _addOnCameraMoveStartedListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnCameraMoveStartedListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener onCameraMoveStartedListener)`
  void addOnCameraMoveStartedListener(
    MapLibreMap_OnCameraMoveStartedListener onCameraMoveStartedListener,
  ) {
    _addOnCameraMoveStartedListener(
            reference.pointer,
            _id_addOnCameraMoveStartedListener as _$jni.JMethodIDPtr,
            onCameraMoveStartedListener.reference.pointer)
        .check();
  }

  static final _id_removeOnCameraMoveStartedListener = _class.instanceMethodId(
    r'removeOnCameraMoveStartedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;)V',
  );

  static final _removeOnCameraMoveStartedListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnCameraMoveStartedListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener onCameraMoveStartedListener)`
  void removeOnCameraMoveStartedListener(
    MapLibreMap_OnCameraMoveStartedListener onCameraMoveStartedListener,
  ) {
    _removeOnCameraMoveStartedListener(
            reference.pointer,
            _id_removeOnCameraMoveStartedListener as _$jni.JMethodIDPtr,
            onCameraMoveStartedListener.reference.pointer)
        .check();
  }

  static final _id_addOnCameraMoveListener = _class.instanceMethodId(
    r'addOnCameraMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;)V',
  );

  static final _addOnCameraMoveListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnCameraMoveListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener onCameraMoveListener)`
  void addOnCameraMoveListener(
    MapLibreMap_OnCameraMoveListener onCameraMoveListener,
  ) {
    _addOnCameraMoveListener(
            reference.pointer,
            _id_addOnCameraMoveListener as _$jni.JMethodIDPtr,
            onCameraMoveListener.reference.pointer)
        .check();
  }

  static final _id_removeOnCameraMoveListener = _class.instanceMethodId(
    r'removeOnCameraMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;)V',
  );

  static final _removeOnCameraMoveListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnCameraMoveListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener onCameraMoveListener)`
  void removeOnCameraMoveListener(
    MapLibreMap_OnCameraMoveListener onCameraMoveListener,
  ) {
    _removeOnCameraMoveListener(
            reference.pointer,
            _id_removeOnCameraMoveListener as _$jni.JMethodIDPtr,
            onCameraMoveListener.reference.pointer)
        .check();
  }

  static final _id_setOnFpsChangedListener = _class.instanceMethodId(
    r'setOnFpsChangedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFpsChangedListener;)V',
  );

  static final _setOnFpsChangedListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOnFpsChangedListener(org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener onFpsChangedListener)`
  void setOnFpsChangedListener(
    MapLibreMap_OnFpsChangedListener onFpsChangedListener,
  ) {
    _setOnFpsChangedListener(
            reference.pointer,
            _id_setOnFpsChangedListener as _$jni.JMethodIDPtr,
            onFpsChangedListener.reference.pointer)
        .check();
  }

  static final _id_addOnFlingListener = _class.instanceMethodId(
    r'addOnFlingListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;)V',
  );

  static final _addOnFlingListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnFlingListener(org.maplibre.android.maps.MapLibreMap$OnFlingListener onFlingListener)`
  void addOnFlingListener(
    MapLibreMap_OnFlingListener onFlingListener,
  ) {
    _addOnFlingListener(
            reference.pointer,
            _id_addOnFlingListener as _$jni.JMethodIDPtr,
            onFlingListener.reference.pointer)
        .check();
  }

  static final _id_removeOnFlingListener = _class.instanceMethodId(
    r'removeOnFlingListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;)V',
  );

  static final _removeOnFlingListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnFlingListener(org.maplibre.android.maps.MapLibreMap$OnFlingListener onFlingListener)`
  void removeOnFlingListener(
    MapLibreMap_OnFlingListener onFlingListener,
  ) {
    _removeOnFlingListener(
            reference.pointer,
            _id_removeOnFlingListener as _$jni.JMethodIDPtr,
            onFlingListener.reference.pointer)
        .check();
  }

  static final _id_addOnMoveListener = _class.instanceMethodId(
    r'addOnMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;)V',
  );

  static final _addOnMoveListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnMoveListener(org.maplibre.android.maps.MapLibreMap$OnMoveListener onMoveListener)`
  void addOnMoveListener(
    MapLibreMap_OnMoveListener onMoveListener,
  ) {
    _addOnMoveListener(
            reference.pointer,
            _id_addOnMoveListener as _$jni.JMethodIDPtr,
            onMoveListener.reference.pointer)
        .check();
  }

  static final _id_removeOnMoveListener = _class.instanceMethodId(
    r'removeOnMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;)V',
  );

  static final _removeOnMoveListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnMoveListener(org.maplibre.android.maps.MapLibreMap$OnMoveListener onMoveListener)`
  void removeOnMoveListener(
    MapLibreMap_OnMoveListener onMoveListener,
  ) {
    _removeOnMoveListener(
            reference.pointer,
            _id_removeOnMoveListener as _$jni.JMethodIDPtr,
            onMoveListener.reference.pointer)
        .check();
  }

  static final _id_addOnRotateListener = _class.instanceMethodId(
    r'addOnRotateListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;)V',
  );

  static final _addOnRotateListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnRotateListener(org.maplibre.android.maps.MapLibreMap$OnRotateListener onRotateListener)`
  void addOnRotateListener(
    MapLibreMap_OnRotateListener onRotateListener,
  ) {
    _addOnRotateListener(
            reference.pointer,
            _id_addOnRotateListener as _$jni.JMethodIDPtr,
            onRotateListener.reference.pointer)
        .check();
  }

  static final _id_removeOnRotateListener = _class.instanceMethodId(
    r'removeOnRotateListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;)V',
  );

  static final _removeOnRotateListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnRotateListener(org.maplibre.android.maps.MapLibreMap$OnRotateListener onRotateListener)`
  void removeOnRotateListener(
    MapLibreMap_OnRotateListener onRotateListener,
  ) {
    _removeOnRotateListener(
            reference.pointer,
            _id_removeOnRotateListener as _$jni.JMethodIDPtr,
            onRotateListener.reference.pointer)
        .check();
  }

  static final _id_addOnScaleListener = _class.instanceMethodId(
    r'addOnScaleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;)V',
  );

  static final _addOnScaleListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnScaleListener(org.maplibre.android.maps.MapLibreMap$OnScaleListener onScaleListener)`
  void addOnScaleListener(
    MapLibreMap_OnScaleListener onScaleListener,
  ) {
    _addOnScaleListener(
            reference.pointer,
            _id_addOnScaleListener as _$jni.JMethodIDPtr,
            onScaleListener.reference.pointer)
        .check();
  }

  static final _id_removeOnScaleListener = _class.instanceMethodId(
    r'removeOnScaleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;)V',
  );

  static final _removeOnScaleListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnScaleListener(org.maplibre.android.maps.MapLibreMap$OnScaleListener onScaleListener)`
  void removeOnScaleListener(
    MapLibreMap_OnScaleListener onScaleListener,
  ) {
    _removeOnScaleListener(
            reference.pointer,
            _id_removeOnScaleListener as _$jni.JMethodIDPtr,
            onScaleListener.reference.pointer)
        .check();
  }

  static final _id_addOnShoveListener = _class.instanceMethodId(
    r'addOnShoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;)V',
  );

  static final _addOnShoveListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnShoveListener(org.maplibre.android.maps.MapLibreMap$OnShoveListener onShoveListener)`
  void addOnShoveListener(
    MapLibreMap_OnShoveListener onShoveListener,
  ) {
    _addOnShoveListener(
            reference.pointer,
            _id_addOnShoveListener as _$jni.JMethodIDPtr,
            onShoveListener.reference.pointer)
        .check();
  }

  static final _id_removeOnShoveListener = _class.instanceMethodId(
    r'removeOnShoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;)V',
  );

  static final _removeOnShoveListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnShoveListener(org.maplibre.android.maps.MapLibreMap$OnShoveListener onShoveListener)`
  void removeOnShoveListener(
    MapLibreMap_OnShoveListener onShoveListener,
  ) {
    _removeOnShoveListener(
            reference.pointer,
            _id_removeOnShoveListener as _$jni.JMethodIDPtr,
            onShoveListener.reference.pointer)
        .check();
  }

  static final _id_setGesturesManager = _class.instanceMethodId(
    r'setGesturesManager',
    r'(Lorg/maplibre/android/gestures/AndroidGesturesManager;ZZ)V',
  );

  static final _setGesturesManager = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int, int)>();

  /// from: `public void setGesturesManager(org.maplibre.android.gestures.AndroidGesturesManager androidGesturesManager, boolean z, boolean z1)`
  void setGesturesManager(
    _$jni.JObject androidGesturesManager,
    bool z,
    bool z1,
  ) {
    _setGesturesManager(
            reference.pointer,
            _id_setGesturesManager as _$jni.JMethodIDPtr,
            androidGesturesManager.reference.pointer,
            z ? 1 : 0,
            z1 ? 1 : 0)
        .check();
  }

  static final _id_getGesturesManager = _class.instanceMethodId(
    r'getGesturesManager',
    r'()Lorg/maplibre/android/gestures/AndroidGesturesManager;',
  );

  static final _getGesturesManager = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.gestures.AndroidGesturesManager getGesturesManager()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject getGesturesManager() {
    return _getGesturesManager(
            reference.pointer, _id_getGesturesManager as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_cancelAllVelocityAnimations = _class.instanceMethodId(
    r'cancelAllVelocityAnimations',
    r'()V',
  );

  static final _cancelAllVelocityAnimations =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public void cancelAllVelocityAnimations()`
  void cancelAllVelocityAnimations() {
    _cancelAllVelocityAnimations(reference.pointer,
            _id_cancelAllVelocityAnimations as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_addOnMapClickListener = _class.instanceMethodId(
    r'addOnMapClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;)V',
  );

  static final _addOnMapClickListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnMapClickListener(org.maplibre.android.maps.MapLibreMap$OnMapClickListener onMapClickListener)`
  void addOnMapClickListener(
    MapLibreMap_OnMapClickListener onMapClickListener,
  ) {
    _addOnMapClickListener(
            reference.pointer,
            _id_addOnMapClickListener as _$jni.JMethodIDPtr,
            onMapClickListener.reference.pointer)
        .check();
  }

  static final _id_removeOnMapClickListener = _class.instanceMethodId(
    r'removeOnMapClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;)V',
  );

  static final _removeOnMapClickListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnMapClickListener(org.maplibre.android.maps.MapLibreMap$OnMapClickListener onMapClickListener)`
  void removeOnMapClickListener(
    MapLibreMap_OnMapClickListener onMapClickListener,
  ) {
    _removeOnMapClickListener(
            reference.pointer,
            _id_removeOnMapClickListener as _$jni.JMethodIDPtr,
            onMapClickListener.reference.pointer)
        .check();
  }

  static final _id_addOnMapLongClickListener = _class.instanceMethodId(
    r'addOnMapLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;)V',
  );

  static final _addOnMapLongClickListener = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addOnMapLongClickListener(org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener onMapLongClickListener)`
  void addOnMapLongClickListener(
    MapLibreMap_OnMapLongClickListener onMapLongClickListener,
  ) {
    _addOnMapLongClickListener(
            reference.pointer,
            _id_addOnMapLongClickListener as _$jni.JMethodIDPtr,
            onMapLongClickListener.reference.pointer)
        .check();
  }

  static final _id_removeOnMapLongClickListener = _class.instanceMethodId(
    r'removeOnMapLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;)V',
  );

  static final _removeOnMapLongClickListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removeOnMapLongClickListener(org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener onMapLongClickListener)`
  void removeOnMapLongClickListener(
    MapLibreMap_OnMapLongClickListener onMapLongClickListener,
  ) {
    _removeOnMapLongClickListener(
            reference.pointer,
            _id_removeOnMapLongClickListener as _$jni.JMethodIDPtr,
            onMapLongClickListener.reference.pointer)
        .check();
  }

  static final _id_setOnInfoWindowClickListener = _class.instanceMethodId(
    r'setOnInfoWindowClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;)V',
  );

  static final _setOnInfoWindowClickListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOnInfoWindowClickListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener onInfoWindowClickListener)`
  void setOnInfoWindowClickListener(
    MapLibreMap_OnInfoWindowClickListener onInfoWindowClickListener,
  ) {
    _setOnInfoWindowClickListener(
            reference.pointer,
            _id_setOnInfoWindowClickListener as _$jni.JMethodIDPtr,
            onInfoWindowClickListener.reference.pointer)
        .check();
  }

  static final _id_getOnInfoWindowClickListener = _class.instanceMethodId(
    r'getOnInfoWindowClickListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;',
  );

  static final _getOnInfoWindowClickListener =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener getOnInfoWindowClickListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap_OnInfoWindowClickListener getOnInfoWindowClickListener() {
    return _getOnInfoWindowClickListener(reference.pointer,
            _id_getOnInfoWindowClickListener as _$jni.JMethodIDPtr)
        .object(const $MapLibreMap_OnInfoWindowClickListener$Type());
  }

  static final _id_setOnInfoWindowLongClickListener = _class.instanceMethodId(
    r'setOnInfoWindowLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;)V',
  );

  static final _setOnInfoWindowLongClickListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOnInfoWindowLongClickListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener onInfoWindowLongClickListener)`
  void setOnInfoWindowLongClickListener(
    MapLibreMap_OnInfoWindowLongClickListener onInfoWindowLongClickListener,
  ) {
    _setOnInfoWindowLongClickListener(
            reference.pointer,
            _id_setOnInfoWindowLongClickListener as _$jni.JMethodIDPtr,
            onInfoWindowLongClickListener.reference.pointer)
        .check();
  }

  static final _id_getOnInfoWindowLongClickListener = _class.instanceMethodId(
    r'getOnInfoWindowLongClickListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;',
  );

  static final _getOnInfoWindowLongClickListener =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener getOnInfoWindowLongClickListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap_OnInfoWindowLongClickListener getOnInfoWindowLongClickListener() {
    return _getOnInfoWindowLongClickListener(reference.pointer,
            _id_getOnInfoWindowLongClickListener as _$jni.JMethodIDPtr)
        .object(const $MapLibreMap_OnInfoWindowLongClickListener$Type());
  }

  static final _id_setOnInfoWindowCloseListener = _class.instanceMethodId(
    r'setOnInfoWindowCloseListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;)V',
  );

  static final _setOnInfoWindowCloseListener =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setOnInfoWindowCloseListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener onInfoWindowCloseListener)`
  void setOnInfoWindowCloseListener(
    MapLibreMap_OnInfoWindowCloseListener onInfoWindowCloseListener,
  ) {
    _setOnInfoWindowCloseListener(
            reference.pointer,
            _id_setOnInfoWindowCloseListener as _$jni.JMethodIDPtr,
            onInfoWindowCloseListener.reference.pointer)
        .check();
  }

  static final _id_getOnInfoWindowCloseListener = _class.instanceMethodId(
    r'getOnInfoWindowCloseListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;',
  );

  static final _getOnInfoWindowCloseListener =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener getOnInfoWindowCloseListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap_OnInfoWindowCloseListener getOnInfoWindowCloseListener() {
    return _getOnInfoWindowCloseListener(reference.pointer,
            _id_getOnInfoWindowCloseListener as _$jni.JMethodIDPtr)
        .object(const $MapLibreMap_OnInfoWindowCloseListener$Type());
  }

  static final _id_snapshot = _class.instanceMethodId(
    r'snapshot',
    r'(Lorg/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback;)V',
  );

  static final _snapshot = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void snapshot(org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback snapshotReadyCallback)`
  void snapshot(
    MapLibreMap_SnapshotReadyCallback snapshotReadyCallback,
  ) {
    _snapshot(reference.pointer, _id_snapshot as _$jni.JMethodIDPtr,
            snapshotReadyCallback.reference.pointer)
        .check();
  }

  static final _id_queryRenderedFeatures = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/PointF;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.PointF pointF, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<feature_.Feature> queryRenderedFeatures(
    pointf_.PointF pointF,
    _$jni.JArray<_$jni.JString> strings,
  ) {
    return _queryRenderedFeatures(
            reference.pointer,
            _id_queryRenderedFeatures as _$jni.JMethodIDPtr,
            pointF.reference.pointer,
            strings.reference.pointer)
        .object(const _$jni.JListType(feature_.$Feature$Type()));
  }

  static final _id_queryRenderedFeatures$1 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/PointF;Lorg/maplibre/android/style/expressions/Expression;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.PointF pointF, org.maplibre.android.style.expressions.Expression expression, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<feature_.Feature> queryRenderedFeatures$1(
    pointf_.PointF pointF,
    _$jni.JObject expression,
    _$jni.JArray<_$jni.JString> strings,
  ) {
    return _queryRenderedFeatures$1(
            reference.pointer,
            _id_queryRenderedFeatures$1 as _$jni.JMethodIDPtr,
            pointF.reference.pointer,
            expression.reference.pointer,
            strings.reference.pointer)
        .object(const _$jni.JListType(feature_.$Feature$Type()));
  }

  static final _id_queryRenderedFeatures$2 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/RectF;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.RectF rectF, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<feature_.Feature> queryRenderedFeatures$2(
    _$jni.JObject rectF,
    _$jni.JArray<_$jni.JString> strings,
  ) {
    return _queryRenderedFeatures$2(
            reference.pointer,
            _id_queryRenderedFeatures$2 as _$jni.JMethodIDPtr,
            rectF.reference.pointer,
            strings.reference.pointer)
        .object(const _$jni.JListType(feature_.$Feature$Type()));
  }

  static final _id_queryRenderedFeatures$3 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/RectF;Lorg/maplibre/android/style/expressions/Expression;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.RectF rectF, org.maplibre.android.style.expressions.Expression expression, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<feature_.Feature> queryRenderedFeatures$3(
    _$jni.JObject rectF,
    _$jni.JObject expression,
    _$jni.JArray<_$jni.JString> strings,
  ) {
    return _queryRenderedFeatures$3(
            reference.pointer,
            _id_queryRenderedFeatures$3 as _$jni.JMethodIDPtr,
            rectF.reference.pointer,
            expression.reference.pointer,
            strings.reference.pointer)
        .object(const _$jni.JListType(feature_.$Feature$Type()));
  }

  static final _id_getLocationComponent = _class.instanceMethodId(
    r'getLocationComponent',
    r'()Lorg/maplibre/android/location/LocationComponent;',
  );

  static final _getLocationComponent = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.location.LocationComponent getLocationComponent()`
  /// The returned object must be released after use, by calling the [release] method.
  locationcomponent_.LocationComponent getLocationComponent() {
    return _getLocationComponent(
            reference.pointer, _id_getLocationComponent as _$jni.JMethodIDPtr)
        .object(const locationcomponent_.$LocationComponent$Type());
  }
}

final class $MapLibreMap$Type extends _$jni.JObjType<MapLibreMap> {
  @_$jni.internal
  const $MapLibreMap$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lorg/maplibre/android/maps/MapLibreMap;';

  @_$jni.internal
  @_$core.override
  MapLibreMap fromReference(_$jni.JReference reference) =>
      MapLibreMap.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MapLibreMap$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap$Type) &&
        other is $MapLibreMap$Type;
  }
}
