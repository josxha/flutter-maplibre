// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: `org.maplibre.android.style.layers.Property$ANCHOR`
class Property_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_ANCHOR> $type = type;

  Property_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/style/layers/Property$ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ANCHORType();
}

final class $Property_ANCHORType extends jni.JObjType<Property_ANCHOR> {
  const $Property_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ANCHOR;';

  @override
  Property_ANCHOR fromReference(jni.JReference reference) =>
      Property_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ANCHORType) &&
        other is $Property_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_PITCH_ALIGNMENT`
class Property_CIRCLE_PITCH_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_CIRCLE_PITCH_ALIGNMENT> $type = type;

  Property_CIRCLE_PITCH_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_PITCH_ALIGNMENTType();
}

final class $Property_CIRCLE_PITCH_ALIGNMENTType
    extends jni.JObjType<Property_CIRCLE_PITCH_ALIGNMENT> {
  const $Property_CIRCLE_PITCH_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT;';

  @override
  Property_CIRCLE_PITCH_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_CIRCLE_PITCH_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_CIRCLE_PITCH_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_PITCH_ALIGNMENTType) &&
        other is $Property_CIRCLE_PITCH_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_PITCH_SCALE`
class Property_CIRCLE_PITCH_SCALE extends jni.JObject {
  @override
  late final jni.JObjType<Property_CIRCLE_PITCH_SCALE> $type = type;

  Property_CIRCLE_PITCH_SCALE.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_PITCH_SCALEType();
}

final class $Property_CIRCLE_PITCH_SCALEType
    extends jni.JObjType<Property_CIRCLE_PITCH_SCALE> {
  const $Property_CIRCLE_PITCH_SCALEType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE;';

  @override
  Property_CIRCLE_PITCH_SCALE fromReference(jni.JReference reference) =>
      Property_CIRCLE_PITCH_SCALE.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_CIRCLE_PITCH_SCALEType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_PITCH_SCALEType) &&
        other is $Property_CIRCLE_PITCH_SCALEType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_TRANSLATE_ANCHOR`
class Property_CIRCLE_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_CIRCLE_TRANSLATE_ANCHOR> $type = type;

  Property_CIRCLE_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_TRANSLATE_ANCHORType();
}

final class $Property_CIRCLE_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_CIRCLE_TRANSLATE_ANCHOR> {
  const $Property_CIRCLE_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR;';

  @override
  Property_CIRCLE_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_CIRCLE_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_CIRCLE_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_TRANSLATE_ANCHORType) &&
        other is $Property_CIRCLE_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$FILL_EXTRUSION_TRANSLATE_ANCHOR`
class Property_FILL_EXTRUSION_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_FILL_EXTRUSION_TRANSLATE_ANCHOR> $type =
      type;

  Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_FILL_EXTRUSION_TRANSLATE_ANCHORType();
}

final class $Property_FILL_EXTRUSION_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_FILL_EXTRUSION_TRANSLATE_ANCHOR> {
  const $Property_FILL_EXTRUSION_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR;';

  @override
  Property_FILL_EXTRUSION_TRANSLATE_ANCHOR fromReference(
          jni.JReference reference) =>
      Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_FILL_EXTRUSION_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property_FILL_EXTRUSION_TRANSLATE_ANCHORType) &&
        other is $Property_FILL_EXTRUSION_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$FILL_TRANSLATE_ANCHOR`
class Property_FILL_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_FILL_TRANSLATE_ANCHOR> $type = type;

  Property_FILL_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_FILL_TRANSLATE_ANCHORType();
}

final class $Property_FILL_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_FILL_TRANSLATE_ANCHOR> {
  const $Property_FILL_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR;';

  @override
  Property_FILL_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_FILL_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_FILL_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_FILL_TRANSLATE_ANCHORType) &&
        other is $Property_FILL_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$HILLSHADE_ILLUMINATION_ANCHOR`
class Property_HILLSHADE_ILLUMINATION_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_HILLSHADE_ILLUMINATION_ANCHOR> $type = type;

  Property_HILLSHADE_ILLUMINATION_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_HILLSHADE_ILLUMINATION_ANCHORType();
}

final class $Property_HILLSHADE_ILLUMINATION_ANCHORType
    extends jni.JObjType<Property_HILLSHADE_ILLUMINATION_ANCHOR> {
  const $Property_HILLSHADE_ILLUMINATION_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR;';

  @override
  Property_HILLSHADE_ILLUMINATION_ANCHOR fromReference(
          jni.JReference reference) =>
      Property_HILLSHADE_ILLUMINATION_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_HILLSHADE_ILLUMINATION_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_HILLSHADE_ILLUMINATION_ANCHORType) &&
        other is $Property_HILLSHADE_ILLUMINATION_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_ANCHOR`
class Property_ICON_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_ANCHOR> $type = type;

  Property_ICON_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_ANCHORType();
}

final class $Property_ICON_ANCHORType
    extends jni.JObjType<Property_ICON_ANCHOR> {
  const $Property_ICON_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ANCHOR;';

  @override
  Property_ICON_ANCHOR fromReference(jni.JReference reference) =>
      Property_ICON_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_ANCHORType) &&
        other is $Property_ICON_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_PITCH_ALIGNMENT`
class Property_ICON_PITCH_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_PITCH_ALIGNMENT> $type = type;

  Property_ICON_PITCH_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_PITCH_ALIGNMENTType();
}

final class $Property_ICON_PITCH_ALIGNMENTType
    extends jni.JObjType<Property_ICON_PITCH_ALIGNMENT> {
  const $Property_ICON_PITCH_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT;';

  @override
  Property_ICON_PITCH_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_ICON_PITCH_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_PITCH_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_PITCH_ALIGNMENTType) &&
        other is $Property_ICON_PITCH_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_ROTATION_ALIGNMENT`
class Property_ICON_ROTATION_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_ROTATION_ALIGNMENT> $type = type;

  Property_ICON_ROTATION_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_ROTATION_ALIGNMENTType();
}

final class $Property_ICON_ROTATION_ALIGNMENTType
    extends jni.JObjType<Property_ICON_ROTATION_ALIGNMENT> {
  const $Property_ICON_ROTATION_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT;';

  @override
  Property_ICON_ROTATION_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_ICON_ROTATION_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_ROTATION_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_ROTATION_ALIGNMENTType) &&
        other is $Property_ICON_ROTATION_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_TEXT_FIT`
class Property_ICON_TEXT_FIT extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_TEXT_FIT> $type = type;

  Property_ICON_TEXT_FIT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_TEXT_FIT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_TEXT_FITType();
}

final class $Property_ICON_TEXT_FITType
    extends jni.JObjType<Property_ICON_TEXT_FIT> {
  const $Property_ICON_TEXT_FITType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TEXT_FIT;';

  @override
  Property_ICON_TEXT_FIT fromReference(jni.JReference reference) =>
      Property_ICON_TEXT_FIT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_TEXT_FITType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_TEXT_FITType) &&
        other is $Property_ICON_TEXT_FITType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_TRANSLATE_ANCHOR`
class Property_ICON_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_TRANSLATE_ANCHOR> $type = type;

  Property_ICON_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_TRANSLATE_ANCHORType();
}

final class $Property_ICON_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_ICON_TRANSLATE_ANCHOR> {
  const $Property_ICON_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR;';

  @override
  Property_ICON_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_ICON_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_TRANSLATE_ANCHORType) &&
        other is $Property_ICON_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_CAP`
class Property_LINE_CAP extends jni.JObject {
  @override
  late final jni.JObjType<Property_LINE_CAP> $type = type;

  Property_LINE_CAP.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_CAP');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_CAPType();
}

final class $Property_LINE_CAPType extends jni.JObjType<Property_LINE_CAP> {
  const $Property_LINE_CAPType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_CAP;';

  @override
  Property_LINE_CAP fromReference(jni.JReference reference) =>
      Property_LINE_CAP.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_LINE_CAPType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_CAPType) &&
        other is $Property_LINE_CAPType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_JOIN`
class Property_LINE_JOIN extends jni.JObject {
  @override
  late final jni.JObjType<Property_LINE_JOIN> $type = type;

  Property_LINE_JOIN.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_JOIN');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_JOINType();
}

final class $Property_LINE_JOINType extends jni.JObjType<Property_LINE_JOIN> {
  const $Property_LINE_JOINType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_JOIN;';

  @override
  Property_LINE_JOIN fromReference(jni.JReference reference) =>
      Property_LINE_JOIN.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_LINE_JOINType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_JOINType) &&
        other is $Property_LINE_JOINType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_TRANSLATE_ANCHOR`
class Property_LINE_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_LINE_TRANSLATE_ANCHOR> $type = type;

  Property_LINE_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_TRANSLATE_ANCHORType();
}

final class $Property_LINE_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_LINE_TRANSLATE_ANCHOR> {
  const $Property_LINE_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR;';

  @override
  Property_LINE_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_LINE_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_LINE_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_TRANSLATE_ANCHORType) &&
        other is $Property_LINE_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$RASTER_RESAMPLING`
class Property_RASTER_RESAMPLING extends jni.JObject {
  @override
  late final jni.JObjType<Property_RASTER_RESAMPLING> $type = type;

  Property_RASTER_RESAMPLING.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$RASTER_RESAMPLING');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_RASTER_RESAMPLINGType();
}

final class $Property_RASTER_RESAMPLINGType
    extends jni.JObjType<Property_RASTER_RESAMPLING> {
  const $Property_RASTER_RESAMPLINGType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$RASTER_RESAMPLING;';

  @override
  Property_RASTER_RESAMPLING fromReference(jni.JReference reference) =>
      Property_RASTER_RESAMPLING.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_RASTER_RESAMPLINGType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_RASTER_RESAMPLINGType) &&
        other is $Property_RASTER_RESAMPLINGType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$SYMBOL_PLACEMENT`
class Property_SYMBOL_PLACEMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_SYMBOL_PLACEMENT> $type = type;

  Property_SYMBOL_PLACEMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_SYMBOL_PLACEMENTType();
}

final class $Property_SYMBOL_PLACEMENTType
    extends jni.JObjType<Property_SYMBOL_PLACEMENT> {
  const $Property_SYMBOL_PLACEMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT;';

  @override
  Property_SYMBOL_PLACEMENT fromReference(jni.JReference reference) =>
      Property_SYMBOL_PLACEMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_SYMBOL_PLACEMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_SYMBOL_PLACEMENTType) &&
        other is $Property_SYMBOL_PLACEMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$SYMBOL_Z_ORDER`
class Property_SYMBOL_Z_ORDER extends jni.JObject {
  @override
  late final jni.JObjType<Property_SYMBOL_Z_ORDER> $type = type;

  Property_SYMBOL_Z_ORDER.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_SYMBOL_Z_ORDERType();
}

final class $Property_SYMBOL_Z_ORDERType
    extends jni.JObjType<Property_SYMBOL_Z_ORDER> {
  const $Property_SYMBOL_Z_ORDERType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER;';

  @override
  Property_SYMBOL_Z_ORDER fromReference(jni.JReference reference) =>
      Property_SYMBOL_Z_ORDER.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_SYMBOL_Z_ORDERType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_SYMBOL_Z_ORDERType) &&
        other is $Property_SYMBOL_Z_ORDERType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_ANCHOR`
class Property_TEXT_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_ANCHOR> $type = type;

  Property_TEXT_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_ANCHORType();
}

final class $Property_TEXT_ANCHORType
    extends jni.JObjType<Property_TEXT_ANCHOR> {
  const $Property_TEXT_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ANCHOR;';

  @override
  Property_TEXT_ANCHOR fromReference(jni.JReference reference) =>
      Property_TEXT_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_ANCHORType) &&
        other is $Property_TEXT_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_JUSTIFY`
class Property_TEXT_JUSTIFY extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_JUSTIFY> $type = type;

  Property_TEXT_JUSTIFY.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_JUSTIFY');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_JUSTIFYType();
}

final class $Property_TEXT_JUSTIFYType
    extends jni.JObjType<Property_TEXT_JUSTIFY> {
  const $Property_TEXT_JUSTIFYType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_JUSTIFY;';

  @override
  Property_TEXT_JUSTIFY fromReference(jni.JReference reference) =>
      Property_TEXT_JUSTIFY.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_JUSTIFYType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_JUSTIFYType) &&
        other is $Property_TEXT_JUSTIFYType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_PITCH_ALIGNMENT`
class Property_TEXT_PITCH_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_PITCH_ALIGNMENT> $type = type;

  Property_TEXT_PITCH_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_PITCH_ALIGNMENTType();
}

final class $Property_TEXT_PITCH_ALIGNMENTType
    extends jni.JObjType<Property_TEXT_PITCH_ALIGNMENT> {
  const $Property_TEXT_PITCH_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT;';

  @override
  Property_TEXT_PITCH_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_TEXT_PITCH_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_PITCH_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_PITCH_ALIGNMENTType) &&
        other is $Property_TEXT_PITCH_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_ROTATION_ALIGNMENT`
class Property_TEXT_ROTATION_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_ROTATION_ALIGNMENT> $type = type;

  Property_TEXT_ROTATION_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_ROTATION_ALIGNMENTType();
}

final class $Property_TEXT_ROTATION_ALIGNMENTType
    extends jni.JObjType<Property_TEXT_ROTATION_ALIGNMENT> {
  const $Property_TEXT_ROTATION_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT;';

  @override
  Property_TEXT_ROTATION_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_TEXT_ROTATION_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_ROTATION_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_ROTATION_ALIGNMENTType) &&
        other is $Property_TEXT_ROTATION_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_TRANSFORM`
class Property_TEXT_TRANSFORM extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_TRANSFORM> $type = type;

  Property_TEXT_TRANSFORM.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_TRANSFORM');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_TRANSFORMType();
}

final class $Property_TEXT_TRANSFORMType
    extends jni.JObjType<Property_TEXT_TRANSFORM> {
  const $Property_TEXT_TRANSFORMType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSFORM;';

  @override
  Property_TEXT_TRANSFORM fromReference(jni.JReference reference) =>
      Property_TEXT_TRANSFORM.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_TRANSFORMType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_TRANSFORMType) &&
        other is $Property_TEXT_TRANSFORMType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_TRANSLATE_ANCHOR`
class Property_TEXT_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_TRANSLATE_ANCHOR> $type = type;

  Property_TEXT_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_TRANSLATE_ANCHORType();
}

final class $Property_TEXT_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_TEXT_TRANSLATE_ANCHOR> {
  const $Property_TEXT_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR;';

  @override
  Property_TEXT_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_TEXT_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_TRANSLATE_ANCHORType) &&
        other is $Property_TEXT_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_WRITING_MODE`
class Property_TEXT_WRITING_MODE extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_WRITING_MODE> $type = type;

  Property_TEXT_WRITING_MODE.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_WRITING_MODE');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_WRITING_MODEType();
}

final class $Property_TEXT_WRITING_MODEType
    extends jni.JObjType<Property_TEXT_WRITING_MODE> {
  const $Property_TEXT_WRITING_MODEType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_WRITING_MODE;';

  @override
  Property_TEXT_WRITING_MODE fromReference(jni.JReference reference) =>
      Property_TEXT_WRITING_MODE.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_WRITING_MODEType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_WRITING_MODEType) &&
        other is $Property_TEXT_WRITING_MODEType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$VISIBILITY`
class Property_VISIBILITY extends jni.JObject {
  @override
  late final jni.JObjType<Property_VISIBILITY> $type = type;

  Property_VISIBILITY.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$VISIBILITY');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_VISIBILITYType();
}

final class $Property_VISIBILITYType extends jni.JObjType<Property_VISIBILITY> {
  const $Property_VISIBILITYType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$VISIBILITY;';

  @override
  Property_VISIBILITY fromReference(jni.JReference reference) =>
      Property_VISIBILITY.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_VISIBILITYType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_VISIBILITYType) &&
        other is $Property_VISIBILITYType;
  }
}

/// from: `org.maplibre.android.style.layers.Property`
class Property extends jni.JObject {
  @override
  late final jni.JObjType<Property> $type = type;

  Property.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/style/layers/Property');

  /// The type which includes information such as the signature of this class.
  static const type = $PropertyType();
  static final _id_VISIBLE = _class.staticFieldId(
    r'VISIBLE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VISIBLE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VISIBLE =>
      _id_VISIBLE.get(_class, const jni.JStringType());

  static final _id_NONE = _class.staticFieldId(
    r'NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NONE => _id_NONE.get(_class, const jni.JStringType());

  static final _id_LINE_CAP_BUTT = _class.staticFieldId(
    r'LINE_CAP_BUTT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_BUTT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_CAP_BUTT =>
      _id_LINE_CAP_BUTT.get(_class, const jni.JStringType());

  static final _id_LINE_CAP_ROUND = _class.staticFieldId(
    r'LINE_CAP_ROUND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_CAP_ROUND =>
      _id_LINE_CAP_ROUND.get(_class, const jni.JStringType());

  static final _id_LINE_CAP_SQUARE = _class.staticFieldId(
    r'LINE_CAP_SQUARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_SQUARE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_CAP_SQUARE =>
      _id_LINE_CAP_SQUARE.get(_class, const jni.JStringType());

  static final _id_LINE_JOIN_BEVEL = _class.staticFieldId(
    r'LINE_JOIN_BEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_BEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_JOIN_BEVEL =>
      _id_LINE_JOIN_BEVEL.get(_class, const jni.JStringType());

  static final _id_LINE_JOIN_ROUND = _class.staticFieldId(
    r'LINE_JOIN_ROUND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_JOIN_ROUND =>
      _id_LINE_JOIN_ROUND.get(_class, const jni.JStringType());

  static final _id_LINE_JOIN_MITER = _class.staticFieldId(
    r'LINE_JOIN_MITER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_MITER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_JOIN_MITER =>
      _id_LINE_JOIN_MITER.get(_class, const jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_POINT = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_POINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_POINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_PLACEMENT_POINT =>
      _id_SYMBOL_PLACEMENT_POINT.get(_class, const jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_LINE = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_LINE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_LINE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_PLACEMENT_LINE =>
      _id_SYMBOL_PLACEMENT_LINE.get(_class, const jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_LINE_CENTER = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_LINE_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_LINE_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_PLACEMENT_LINE_CENTER =>
      _id_SYMBOL_PLACEMENT_LINE_CENTER.get(_class, const jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_AUTO = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_Z_ORDER_AUTO =>
      _id_SYMBOL_Z_ORDER_AUTO.get(_class, const jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_VIEWPORT_Y = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_VIEWPORT_Y',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_VIEWPORT_Y`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_Z_ORDER_VIEWPORT_Y =>
      _id_SYMBOL_Z_ORDER_VIEWPORT_Y.get(_class, const jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_SOURCE = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_SOURCE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_SOURCE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_Z_ORDER_SOURCE =>
      _id_SYMBOL_Z_ORDER_SOURCE.get(_class, const jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_MAP = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ROTATION_ALIGNMENT_MAP =>
      _id_ICON_ROTATION_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ROTATION_ALIGNMENT_VIEWPORT =>
      _id_ICON_ROTATION_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_AUTO = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ROTATION_ALIGNMENT_AUTO =>
      _id_ICON_ROTATION_ALIGNMENT_AUTO.get(_class, const jni.JStringType());

  static final _id_ICON_TEXT_FIT_NONE = _class.staticFieldId(
    r'ICON_TEXT_FIT_NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TEXT_FIT_NONE =>
      _id_ICON_TEXT_FIT_NONE.get(_class, const jni.JStringType());

  static final _id_ICON_TEXT_FIT_WIDTH = _class.staticFieldId(
    r'ICON_TEXT_FIT_WIDTH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_WIDTH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TEXT_FIT_WIDTH =>
      _id_ICON_TEXT_FIT_WIDTH.get(_class, const jni.JStringType());

  static final _id_ICON_TEXT_FIT_HEIGHT = _class.staticFieldId(
    r'ICON_TEXT_FIT_HEIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_HEIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TEXT_FIT_HEIGHT =>
      _id_ICON_TEXT_FIT_HEIGHT.get(_class, const jni.JStringType());

  static final _id_ICON_TEXT_FIT_BOTH = _class.staticFieldId(
    r'ICON_TEXT_FIT_BOTH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_BOTH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TEXT_FIT_BOTH =>
      _id_ICON_TEXT_FIT_BOTH.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_CENTER = _class.staticFieldId(
    r'ICON_ANCHOR_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_CENTER =>
      _id_ICON_ANCHOR_CENTER.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_LEFT =>
      _id_ICON_ANCHOR_LEFT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_RIGHT =>
      _id_ICON_ANCHOR_RIGHT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_TOP = _class.staticFieldId(
    r'ICON_ANCHOR_TOP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_TOP =>
      _id_ICON_ANCHOR_TOP.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_BOTTOM =>
      _id_ICON_ANCHOR_BOTTOM.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_TOP_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_TOP_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_TOP_LEFT =>
      _id_ICON_ANCHOR_TOP_LEFT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_TOP_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_TOP_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_TOP_RIGHT =>
      _id_ICON_ANCHOR_TOP_RIGHT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_BOTTOM_LEFT =>
      _id_ICON_ANCHOR_BOTTOM_LEFT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_BOTTOM_RIGHT =>
      _id_ICON_ANCHOR_BOTTOM_RIGHT.get(_class, const jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_PITCH_ALIGNMENT_MAP =>
      _id_ICON_PITCH_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_PITCH_ALIGNMENT_VIEWPORT =>
      _id_ICON_PITCH_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_AUTO = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_PITCH_ALIGNMENT_AUTO =>
      _id_ICON_PITCH_ALIGNMENT_AUTO.get(_class, const jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_PITCH_ALIGNMENT_MAP =>
      _id_TEXT_PITCH_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_PITCH_ALIGNMENT_VIEWPORT =>
      _id_TEXT_PITCH_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_AUTO = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_PITCH_ALIGNMENT_AUTO =>
      _id_TEXT_PITCH_ALIGNMENT_AUTO.get(_class, const jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_MAP = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ROTATION_ALIGNMENT_MAP =>
      _id_TEXT_ROTATION_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ROTATION_ALIGNMENT_VIEWPORT =>
      _id_TEXT_ROTATION_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_AUTO = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ROTATION_ALIGNMENT_AUTO =>
      _id_TEXT_ROTATION_ALIGNMENT_AUTO.get(_class, const jni.JStringType());

  static final _id_TEXT_JUSTIFY_AUTO = _class.staticFieldId(
    r'TEXT_JUSTIFY_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_JUSTIFY_AUTO =>
      _id_TEXT_JUSTIFY_AUTO.get(_class, const jni.JStringType());

  static final _id_TEXT_JUSTIFY_LEFT = _class.staticFieldId(
    r'TEXT_JUSTIFY_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_JUSTIFY_LEFT =>
      _id_TEXT_JUSTIFY_LEFT.get(_class, const jni.JStringType());

  static final _id_TEXT_JUSTIFY_CENTER = _class.staticFieldId(
    r'TEXT_JUSTIFY_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_JUSTIFY_CENTER =>
      _id_TEXT_JUSTIFY_CENTER.get(_class, const jni.JStringType());

  static final _id_TEXT_JUSTIFY_RIGHT = _class.staticFieldId(
    r'TEXT_JUSTIFY_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_JUSTIFY_RIGHT =>
      _id_TEXT_JUSTIFY_RIGHT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_CENTER = _class.staticFieldId(
    r'TEXT_ANCHOR_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_CENTER =>
      _id_TEXT_ANCHOR_CENTER.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_LEFT =>
      _id_TEXT_ANCHOR_LEFT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_RIGHT =>
      _id_TEXT_ANCHOR_RIGHT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_TOP =>
      _id_TEXT_ANCHOR_TOP.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_BOTTOM =>
      _id_TEXT_ANCHOR_BOTTOM.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_TOP_LEFT =>
      _id_TEXT_ANCHOR_TOP_LEFT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_TOP_RIGHT =>
      _id_TEXT_ANCHOR_TOP_RIGHT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_BOTTOM_LEFT =>
      _id_TEXT_ANCHOR_BOTTOM_LEFT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_BOTTOM_RIGHT =>
      _id_TEXT_ANCHOR_BOTTOM_RIGHT.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSFORM_NONE = _class.staticFieldId(
    r'TEXT_TRANSFORM_NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSFORM_NONE =>
      _id_TEXT_TRANSFORM_NONE.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSFORM_UPPERCASE = _class.staticFieldId(
    r'TEXT_TRANSFORM_UPPERCASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_UPPERCASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSFORM_UPPERCASE =>
      _id_TEXT_TRANSFORM_UPPERCASE.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSFORM_LOWERCASE = _class.staticFieldId(
    r'TEXT_TRANSFORM_LOWERCASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_LOWERCASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSFORM_LOWERCASE =>
      _id_TEXT_TRANSFORM_LOWERCASE.get(_class, const jni.JStringType());

  static final _id_FILL_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'FILL_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILL_TRANSLATE_ANCHOR_MAP =>
      _id_FILL_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_FILL_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'FILL_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILL_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_FILL_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_LINE_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'LINE_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_TRANSLATE_ANCHOR_MAP =>
      _id_LINE_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_LINE_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'LINE_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_LINE_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_ICON_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'ICON_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TRANSLATE_ANCHOR_MAP =>
      _id_ICON_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_ICON_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'ICON_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_ICON_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'TEXT_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSLATE_ANCHOR_MAP =>
      _id_TEXT_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'TEXT_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_TEXT_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_CIRCLE_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'CIRCLE_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_TRANSLATE_ANCHOR_MAP =>
      _id_CIRCLE_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_CIRCLE_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_CIRCLE_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_CIRCLE_PITCH_SCALE_MAP = _class.staticFieldId(
    r'CIRCLE_PITCH_SCALE_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_SCALE_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_PITCH_SCALE_MAP =>
      _id_CIRCLE_PITCH_SCALE_MAP.get(_class, const jni.JStringType());

  static final _id_CIRCLE_PITCH_SCALE_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_PITCH_SCALE_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_SCALE_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_PITCH_SCALE_VIEWPORT =>
      _id_CIRCLE_PITCH_SCALE_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_CIRCLE_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'CIRCLE_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_PITCH_ALIGNMENT_MAP =>
      _id_CIRCLE_PITCH_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_CIRCLE_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_PITCH_ALIGNMENT_VIEWPORT =>
      _id_CIRCLE_PITCH_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP =>
      _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP.get(
          _class, const jni.JStringType());

  static final _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT =
      _class.staticFieldId(
    r'FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT.get(
          _class, const jni.JStringType());

  static final _id_RASTER_RESAMPLING_LINEAR = _class.staticFieldId(
    r'RASTER_RESAMPLING_LINEAR',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RASTER_RESAMPLING_LINEAR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RASTER_RESAMPLING_LINEAR =>
      _id_RASTER_RESAMPLING_LINEAR.get(_class, const jni.JStringType());

  static final _id_RASTER_RESAMPLING_NEAREST = _class.staticFieldId(
    r'RASTER_RESAMPLING_NEAREST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RASTER_RESAMPLING_NEAREST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RASTER_RESAMPLING_NEAREST =>
      _id_RASTER_RESAMPLING_NEAREST.get(_class, const jni.JStringType());

  static final _id_HILLSHADE_ILLUMINATION_ANCHOR_MAP = _class.staticFieldId(
    r'HILLSHADE_ILLUMINATION_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HILLSHADE_ILLUMINATION_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HILLSHADE_ILLUMINATION_ANCHOR_MAP =>
      _id_HILLSHADE_ILLUMINATION_ANCHOR_MAP.get(
          _class, const jni.JStringType());

  static final _id_HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT =
      _class.staticFieldId(
    r'HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT =>
      _id_HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT.get(
          _class, const jni.JStringType());

  static final _id_ANCHOR_MAP = _class.staticFieldId(
    r'ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ANCHOR_MAP =>
      _id_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ANCHOR_VIEWPORT =>
      _id_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_TEXT_WRITING_MODE_HORIZONTAL = _class.staticFieldId(
    r'TEXT_WRITING_MODE_HORIZONTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_WRITING_MODE_HORIZONTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_WRITING_MODE_HORIZONTAL =>
      _id_TEXT_WRITING_MODE_HORIZONTAL.get(_class, const jni.JStringType());

  static final _id_TEXT_WRITING_MODE_VERTICAL = _class.staticFieldId(
    r'TEXT_WRITING_MODE_VERTICAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_WRITING_MODE_VERTICAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_WRITING_MODE_VERTICAL =>
      _id_TEXT_WRITING_MODE_VERTICAL.get(_class, const jni.JStringType());
}

final class $PropertyType extends jni.JObjType<Property> {
  const $PropertyType();

  @override
  String get signature => r'Lorg/maplibre/android/style/layers/Property;';

  @override
  Property fromReference(jni.JReference reference) =>
      Property.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PropertyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PropertyType) && other is $PropertyType;
  }
}
