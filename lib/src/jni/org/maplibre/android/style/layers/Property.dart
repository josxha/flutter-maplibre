// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: `org.maplibre.android.style.layers.Property$ANCHOR`
class Property_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_ANCHOR> $type = type;

  Property_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/style/layers/Property$ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_ANCHORImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_ANCHOR.implement(
    $Property_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_ANCHORImpl {
  factory $Property_ANCHORImpl() = _$Property_ANCHORImpl;
}

class _$Property_ANCHORImpl implements $Property_ANCHORImpl {
  _$Property_ANCHORImpl();
}

final class $Property_ANCHORType extends jni.JObjType<Property_ANCHOR> {
  const $Property_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ANCHOR;';

  @override
  Property_ANCHOR fromReference(jni.JReference reference) =>
      Property_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ANCHORType) &&
        other is $Property_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_PITCH_ALIGNMENT`
class Property_CIRCLE_PITCH_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_CIRCLE_PITCH_ALIGNMENT> $type = type;

  Property_CIRCLE_PITCH_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_PITCH_ALIGNMENTType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_CIRCLE_PITCH_ALIGNMENTImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_CIRCLE_PITCH_ALIGNMENT.implement(
    $Property_CIRCLE_PITCH_ALIGNMENTImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_CIRCLE_PITCH_ALIGNMENT.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$CIRCLE_PITCH_ALIGNMENT',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_CIRCLE_PITCH_ALIGNMENTImpl {
  factory $Property_CIRCLE_PITCH_ALIGNMENTImpl() =
      _$Property_CIRCLE_PITCH_ALIGNMENTImpl;
}

class _$Property_CIRCLE_PITCH_ALIGNMENTImpl
    implements $Property_CIRCLE_PITCH_ALIGNMENTImpl {
  _$Property_CIRCLE_PITCH_ALIGNMENTImpl();
}

final class $Property_CIRCLE_PITCH_ALIGNMENTType
    extends jni.JObjType<Property_CIRCLE_PITCH_ALIGNMENT> {
  const $Property_CIRCLE_PITCH_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_ALIGNMENT;';

  @override
  Property_CIRCLE_PITCH_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_CIRCLE_PITCH_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_CIRCLE_PITCH_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_PITCH_ALIGNMENTType) &&
        other is $Property_CIRCLE_PITCH_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_PITCH_SCALE`
class Property_CIRCLE_PITCH_SCALE extends jni.JObject {
  @override
  late final jni.JObjType<Property_CIRCLE_PITCH_SCALE> $type = type;

  Property_CIRCLE_PITCH_SCALE.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_PITCH_SCALEType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_CIRCLE_PITCH_SCALEImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_CIRCLE_PITCH_SCALE.implement(
    $Property_CIRCLE_PITCH_SCALEImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_CIRCLE_PITCH_SCALE.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$CIRCLE_PITCH_SCALE',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_CIRCLE_PITCH_SCALEImpl {
  factory $Property_CIRCLE_PITCH_SCALEImpl() =
      _$Property_CIRCLE_PITCH_SCALEImpl;
}

class _$Property_CIRCLE_PITCH_SCALEImpl
    implements $Property_CIRCLE_PITCH_SCALEImpl {
  _$Property_CIRCLE_PITCH_SCALEImpl();
}

final class $Property_CIRCLE_PITCH_SCALEType
    extends jni.JObjType<Property_CIRCLE_PITCH_SCALE> {
  const $Property_CIRCLE_PITCH_SCALEType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_PITCH_SCALE;';

  @override
  Property_CIRCLE_PITCH_SCALE fromReference(jni.JReference reference) =>
      Property_CIRCLE_PITCH_SCALE.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_CIRCLE_PITCH_SCALEType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_PITCH_SCALEType) &&
        other is $Property_CIRCLE_PITCH_SCALEType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$CIRCLE_TRANSLATE_ANCHOR`
class Property_CIRCLE_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_CIRCLE_TRANSLATE_ANCHOR> $type = type;

  Property_CIRCLE_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_CIRCLE_TRANSLATE_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_CIRCLE_TRANSLATE_ANCHORImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_CIRCLE_TRANSLATE_ANCHOR.implement(
    $Property_CIRCLE_TRANSLATE_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_CIRCLE_TRANSLATE_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$CIRCLE_TRANSLATE_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_CIRCLE_TRANSLATE_ANCHORImpl {
  factory $Property_CIRCLE_TRANSLATE_ANCHORImpl() =
      _$Property_CIRCLE_TRANSLATE_ANCHORImpl;
}

class _$Property_CIRCLE_TRANSLATE_ANCHORImpl
    implements $Property_CIRCLE_TRANSLATE_ANCHORImpl {
  _$Property_CIRCLE_TRANSLATE_ANCHORImpl();
}

final class $Property_CIRCLE_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_CIRCLE_TRANSLATE_ANCHOR> {
  const $Property_CIRCLE_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$CIRCLE_TRANSLATE_ANCHOR;';

  @override
  Property_CIRCLE_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_CIRCLE_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_CIRCLE_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_CIRCLE_TRANSLATE_ANCHORType) &&
        other is $Property_CIRCLE_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$FILL_EXTRUSION_TRANSLATE_ANCHOR`
class Property_FILL_EXTRUSION_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_FILL_EXTRUSION_TRANSLATE_ANCHOR> $type =
      type;

  Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_FILL_EXTRUSION_TRANSLATE_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_FILL_EXTRUSION_TRANSLATE_ANCHORImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.implement(
    $Property_FILL_EXTRUSION_TRANSLATE_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$FILL_EXTRUSION_TRANSLATE_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_FILL_EXTRUSION_TRANSLATE_ANCHORImpl {
  factory $Property_FILL_EXTRUSION_TRANSLATE_ANCHORImpl() =
      _$Property_FILL_EXTRUSION_TRANSLATE_ANCHORImpl;
}

class _$Property_FILL_EXTRUSION_TRANSLATE_ANCHORImpl
    implements $Property_FILL_EXTRUSION_TRANSLATE_ANCHORImpl {
  _$Property_FILL_EXTRUSION_TRANSLATE_ANCHORImpl();
}

final class $Property_FILL_EXTRUSION_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_FILL_EXTRUSION_TRANSLATE_ANCHOR> {
  const $Property_FILL_EXTRUSION_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_EXTRUSION_TRANSLATE_ANCHOR;';

  @override
  Property_FILL_EXTRUSION_TRANSLATE_ANCHOR fromReference(
          jni.JReference reference) =>
      Property_FILL_EXTRUSION_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_FILL_EXTRUSION_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Property_FILL_EXTRUSION_TRANSLATE_ANCHORType) &&
        other is $Property_FILL_EXTRUSION_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$FILL_TRANSLATE_ANCHOR`
class Property_FILL_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_FILL_TRANSLATE_ANCHOR> $type = type;

  Property_FILL_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_FILL_TRANSLATE_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_FILL_TRANSLATE_ANCHORImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_FILL_TRANSLATE_ANCHOR.implement(
    $Property_FILL_TRANSLATE_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_FILL_TRANSLATE_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$FILL_TRANSLATE_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_FILL_TRANSLATE_ANCHORImpl {
  factory $Property_FILL_TRANSLATE_ANCHORImpl() =
      _$Property_FILL_TRANSLATE_ANCHORImpl;
}

class _$Property_FILL_TRANSLATE_ANCHORImpl
    implements $Property_FILL_TRANSLATE_ANCHORImpl {
  _$Property_FILL_TRANSLATE_ANCHORImpl();
}

final class $Property_FILL_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_FILL_TRANSLATE_ANCHOR> {
  const $Property_FILL_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$FILL_TRANSLATE_ANCHOR;';

  @override
  Property_FILL_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_FILL_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_FILL_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_FILL_TRANSLATE_ANCHORType) &&
        other is $Property_FILL_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$HILLSHADE_ILLUMINATION_ANCHOR`
class Property_HILLSHADE_ILLUMINATION_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_HILLSHADE_ILLUMINATION_ANCHOR> $type = type;

  Property_HILLSHADE_ILLUMINATION_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_HILLSHADE_ILLUMINATION_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_HILLSHADE_ILLUMINATION_ANCHORImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_HILLSHADE_ILLUMINATION_ANCHOR.implement(
    $Property_HILLSHADE_ILLUMINATION_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_HILLSHADE_ILLUMINATION_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$HILLSHADE_ILLUMINATION_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_HILLSHADE_ILLUMINATION_ANCHORImpl {
  factory $Property_HILLSHADE_ILLUMINATION_ANCHORImpl() =
      _$Property_HILLSHADE_ILLUMINATION_ANCHORImpl;
}

class _$Property_HILLSHADE_ILLUMINATION_ANCHORImpl
    implements $Property_HILLSHADE_ILLUMINATION_ANCHORImpl {
  _$Property_HILLSHADE_ILLUMINATION_ANCHORImpl();
}

final class $Property_HILLSHADE_ILLUMINATION_ANCHORType
    extends jni.JObjType<Property_HILLSHADE_ILLUMINATION_ANCHOR> {
  const $Property_HILLSHADE_ILLUMINATION_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$HILLSHADE_ILLUMINATION_ANCHOR;';

  @override
  Property_HILLSHADE_ILLUMINATION_ANCHOR fromReference(
          jni.JReference reference) =>
      Property_HILLSHADE_ILLUMINATION_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_HILLSHADE_ILLUMINATION_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_HILLSHADE_ILLUMINATION_ANCHORType) &&
        other is $Property_HILLSHADE_ILLUMINATION_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_ANCHOR`
class Property_ICON_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_ANCHOR> $type = type;

  Property_ICON_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_ICON_ANCHORImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_ICON_ANCHOR.implement(
    $Property_ICON_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_ICON_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$ICON_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_ICON_ANCHORImpl {
  factory $Property_ICON_ANCHORImpl() = _$Property_ICON_ANCHORImpl;
}

class _$Property_ICON_ANCHORImpl implements $Property_ICON_ANCHORImpl {
  _$Property_ICON_ANCHORImpl();
}

final class $Property_ICON_ANCHORType
    extends jni.JObjType<Property_ICON_ANCHOR> {
  const $Property_ICON_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ANCHOR;';

  @override
  Property_ICON_ANCHOR fromReference(jni.JReference reference) =>
      Property_ICON_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_ANCHORType) &&
        other is $Property_ICON_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_PITCH_ALIGNMENT`
class Property_ICON_PITCH_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_PITCH_ALIGNMENT> $type = type;

  Property_ICON_PITCH_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_PITCH_ALIGNMENTType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_ICON_PITCH_ALIGNMENTImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_ICON_PITCH_ALIGNMENT.implement(
    $Property_ICON_PITCH_ALIGNMENTImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_ICON_PITCH_ALIGNMENT.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$ICON_PITCH_ALIGNMENT',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_ICON_PITCH_ALIGNMENTImpl {
  factory $Property_ICON_PITCH_ALIGNMENTImpl() =
      _$Property_ICON_PITCH_ALIGNMENTImpl;
}

class _$Property_ICON_PITCH_ALIGNMENTImpl
    implements $Property_ICON_PITCH_ALIGNMENTImpl {
  _$Property_ICON_PITCH_ALIGNMENTImpl();
}

final class $Property_ICON_PITCH_ALIGNMENTType
    extends jni.JObjType<Property_ICON_PITCH_ALIGNMENT> {
  const $Property_ICON_PITCH_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_PITCH_ALIGNMENT;';

  @override
  Property_ICON_PITCH_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_ICON_PITCH_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_PITCH_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_PITCH_ALIGNMENTType) &&
        other is $Property_ICON_PITCH_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_ROTATION_ALIGNMENT`
class Property_ICON_ROTATION_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_ROTATION_ALIGNMENT> $type = type;

  Property_ICON_ROTATION_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_ROTATION_ALIGNMENTType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_ICON_ROTATION_ALIGNMENTImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_ICON_ROTATION_ALIGNMENT.implement(
    $Property_ICON_ROTATION_ALIGNMENTImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_ICON_ROTATION_ALIGNMENT.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$ICON_ROTATION_ALIGNMENT',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_ICON_ROTATION_ALIGNMENTImpl {
  factory $Property_ICON_ROTATION_ALIGNMENTImpl() =
      _$Property_ICON_ROTATION_ALIGNMENTImpl;
}

class _$Property_ICON_ROTATION_ALIGNMENTImpl
    implements $Property_ICON_ROTATION_ALIGNMENTImpl {
  _$Property_ICON_ROTATION_ALIGNMENTImpl();
}

final class $Property_ICON_ROTATION_ALIGNMENTType
    extends jni.JObjType<Property_ICON_ROTATION_ALIGNMENT> {
  const $Property_ICON_ROTATION_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_ROTATION_ALIGNMENT;';

  @override
  Property_ICON_ROTATION_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_ICON_ROTATION_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_ROTATION_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_ROTATION_ALIGNMENTType) &&
        other is $Property_ICON_ROTATION_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_TEXT_FIT`
class Property_ICON_TEXT_FIT extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_TEXT_FIT> $type = type;

  Property_ICON_TEXT_FIT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_TEXT_FIT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_TEXT_FITType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_ICON_TEXT_FITImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_ICON_TEXT_FIT.implement(
    $Property_ICON_TEXT_FITImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_ICON_TEXT_FIT.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$ICON_TEXT_FIT',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_ICON_TEXT_FITImpl {
  factory $Property_ICON_TEXT_FITImpl() = _$Property_ICON_TEXT_FITImpl;
}

class _$Property_ICON_TEXT_FITImpl implements $Property_ICON_TEXT_FITImpl {
  _$Property_ICON_TEXT_FITImpl();
}

final class $Property_ICON_TEXT_FITType
    extends jni.JObjType<Property_ICON_TEXT_FIT> {
  const $Property_ICON_TEXT_FITType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TEXT_FIT;';

  @override
  Property_ICON_TEXT_FIT fromReference(jni.JReference reference) =>
      Property_ICON_TEXT_FIT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_TEXT_FITType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_TEXT_FITType) &&
        other is $Property_ICON_TEXT_FITType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$ICON_TRANSLATE_ANCHOR`
class Property_ICON_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_ICON_TRANSLATE_ANCHOR> $type = type;

  Property_ICON_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_ICON_TRANSLATE_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_ICON_TRANSLATE_ANCHORImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_ICON_TRANSLATE_ANCHOR.implement(
    $Property_ICON_TRANSLATE_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_ICON_TRANSLATE_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$ICON_TRANSLATE_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_ICON_TRANSLATE_ANCHORImpl {
  factory $Property_ICON_TRANSLATE_ANCHORImpl() =
      _$Property_ICON_TRANSLATE_ANCHORImpl;
}

class _$Property_ICON_TRANSLATE_ANCHORImpl
    implements $Property_ICON_TRANSLATE_ANCHORImpl {
  _$Property_ICON_TRANSLATE_ANCHORImpl();
}

final class $Property_ICON_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_ICON_TRANSLATE_ANCHOR> {
  const $Property_ICON_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$ICON_TRANSLATE_ANCHOR;';

  @override
  Property_ICON_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_ICON_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_ICON_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_ICON_TRANSLATE_ANCHORType) &&
        other is $Property_ICON_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_CAP`
class Property_LINE_CAP extends jni.JObject {
  @override
  late final jni.JObjType<Property_LINE_CAP> $type = type;

  Property_LINE_CAP.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_CAP');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_CAPType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_LINE_CAPImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_LINE_CAP.implement(
    $Property_LINE_CAPImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_LINE_CAP.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$LINE_CAP',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_LINE_CAPImpl {
  factory $Property_LINE_CAPImpl() = _$Property_LINE_CAPImpl;
}

class _$Property_LINE_CAPImpl implements $Property_LINE_CAPImpl {
  _$Property_LINE_CAPImpl();
}

final class $Property_LINE_CAPType extends jni.JObjType<Property_LINE_CAP> {
  const $Property_LINE_CAPType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_CAP;';

  @override
  Property_LINE_CAP fromReference(jni.JReference reference) =>
      Property_LINE_CAP.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_LINE_CAPType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_CAPType) &&
        other is $Property_LINE_CAPType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_JOIN`
class Property_LINE_JOIN extends jni.JObject {
  @override
  late final jni.JObjType<Property_LINE_JOIN> $type = type;

  Property_LINE_JOIN.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_JOIN');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_JOINType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_LINE_JOINImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_LINE_JOIN.implement(
    $Property_LINE_JOINImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_LINE_JOIN.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$LINE_JOIN',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_LINE_JOINImpl {
  factory $Property_LINE_JOINImpl() = _$Property_LINE_JOINImpl;
}

class _$Property_LINE_JOINImpl implements $Property_LINE_JOINImpl {
  _$Property_LINE_JOINImpl();
}

final class $Property_LINE_JOINType extends jni.JObjType<Property_LINE_JOIN> {
  const $Property_LINE_JOINType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_JOIN;';

  @override
  Property_LINE_JOIN fromReference(jni.JReference reference) =>
      Property_LINE_JOIN.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_LINE_JOINType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_JOINType) &&
        other is $Property_LINE_JOINType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$LINE_TRANSLATE_ANCHOR`
class Property_LINE_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_LINE_TRANSLATE_ANCHOR> $type = type;

  Property_LINE_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_LINE_TRANSLATE_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_LINE_TRANSLATE_ANCHORImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_LINE_TRANSLATE_ANCHOR.implement(
    $Property_LINE_TRANSLATE_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_LINE_TRANSLATE_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$LINE_TRANSLATE_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_LINE_TRANSLATE_ANCHORImpl {
  factory $Property_LINE_TRANSLATE_ANCHORImpl() =
      _$Property_LINE_TRANSLATE_ANCHORImpl;
}

class _$Property_LINE_TRANSLATE_ANCHORImpl
    implements $Property_LINE_TRANSLATE_ANCHORImpl {
  _$Property_LINE_TRANSLATE_ANCHORImpl();
}

final class $Property_LINE_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_LINE_TRANSLATE_ANCHOR> {
  const $Property_LINE_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$LINE_TRANSLATE_ANCHOR;';

  @override
  Property_LINE_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_LINE_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_LINE_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_LINE_TRANSLATE_ANCHORType) &&
        other is $Property_LINE_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$RASTER_RESAMPLING`
class Property_RASTER_RESAMPLING extends jni.JObject {
  @override
  late final jni.JObjType<Property_RASTER_RESAMPLING> $type = type;

  Property_RASTER_RESAMPLING.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$RASTER_RESAMPLING');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_RASTER_RESAMPLINGType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_RASTER_RESAMPLINGImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_RASTER_RESAMPLING.implement(
    $Property_RASTER_RESAMPLINGImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_RASTER_RESAMPLING.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$RASTER_RESAMPLING',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_RASTER_RESAMPLINGImpl {
  factory $Property_RASTER_RESAMPLINGImpl() = _$Property_RASTER_RESAMPLINGImpl;
}

class _$Property_RASTER_RESAMPLINGImpl
    implements $Property_RASTER_RESAMPLINGImpl {
  _$Property_RASTER_RESAMPLINGImpl();
}

final class $Property_RASTER_RESAMPLINGType
    extends jni.JObjType<Property_RASTER_RESAMPLING> {
  const $Property_RASTER_RESAMPLINGType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$RASTER_RESAMPLING;';

  @override
  Property_RASTER_RESAMPLING fromReference(jni.JReference reference) =>
      Property_RASTER_RESAMPLING.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_RASTER_RESAMPLINGType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_RASTER_RESAMPLINGType) &&
        other is $Property_RASTER_RESAMPLINGType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$SYMBOL_PLACEMENT`
class Property_SYMBOL_PLACEMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_SYMBOL_PLACEMENT> $type = type;

  Property_SYMBOL_PLACEMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_SYMBOL_PLACEMENTType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_SYMBOL_PLACEMENTImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_SYMBOL_PLACEMENT.implement(
    $Property_SYMBOL_PLACEMENTImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_SYMBOL_PLACEMENT.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$SYMBOL_PLACEMENT',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_SYMBOL_PLACEMENTImpl {
  factory $Property_SYMBOL_PLACEMENTImpl() = _$Property_SYMBOL_PLACEMENTImpl;
}

class _$Property_SYMBOL_PLACEMENTImpl
    implements $Property_SYMBOL_PLACEMENTImpl {
  _$Property_SYMBOL_PLACEMENTImpl();
}

final class $Property_SYMBOL_PLACEMENTType
    extends jni.JObjType<Property_SYMBOL_PLACEMENT> {
  const $Property_SYMBOL_PLACEMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_PLACEMENT;';

  @override
  Property_SYMBOL_PLACEMENT fromReference(jni.JReference reference) =>
      Property_SYMBOL_PLACEMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_SYMBOL_PLACEMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_SYMBOL_PLACEMENTType) &&
        other is $Property_SYMBOL_PLACEMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$SYMBOL_Z_ORDER`
class Property_SYMBOL_Z_ORDER extends jni.JObject {
  @override
  late final jni.JObjType<Property_SYMBOL_Z_ORDER> $type = type;

  Property_SYMBOL_Z_ORDER.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_SYMBOL_Z_ORDERType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_SYMBOL_Z_ORDERImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_SYMBOL_Z_ORDER.implement(
    $Property_SYMBOL_Z_ORDERImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_SYMBOL_Z_ORDER.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$SYMBOL_Z_ORDER',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_SYMBOL_Z_ORDERImpl {
  factory $Property_SYMBOL_Z_ORDERImpl() = _$Property_SYMBOL_Z_ORDERImpl;
}

class _$Property_SYMBOL_Z_ORDERImpl implements $Property_SYMBOL_Z_ORDERImpl {
  _$Property_SYMBOL_Z_ORDERImpl();
}

final class $Property_SYMBOL_Z_ORDERType
    extends jni.JObjType<Property_SYMBOL_Z_ORDER> {
  const $Property_SYMBOL_Z_ORDERType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$SYMBOL_Z_ORDER;';

  @override
  Property_SYMBOL_Z_ORDER fromReference(jni.JReference reference) =>
      Property_SYMBOL_Z_ORDER.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_SYMBOL_Z_ORDERType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_SYMBOL_Z_ORDERType) &&
        other is $Property_SYMBOL_Z_ORDERType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_ANCHOR`
class Property_TEXT_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_ANCHOR> $type = type;

  Property_TEXT_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_TEXT_ANCHORImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_TEXT_ANCHOR.implement(
    $Property_TEXT_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_TEXT_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$TEXT_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_TEXT_ANCHORImpl {
  factory $Property_TEXT_ANCHORImpl() = _$Property_TEXT_ANCHORImpl;
}

class _$Property_TEXT_ANCHORImpl implements $Property_TEXT_ANCHORImpl {
  _$Property_TEXT_ANCHORImpl();
}

final class $Property_TEXT_ANCHORType
    extends jni.JObjType<Property_TEXT_ANCHOR> {
  const $Property_TEXT_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ANCHOR;';

  @override
  Property_TEXT_ANCHOR fromReference(jni.JReference reference) =>
      Property_TEXT_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_ANCHORType) &&
        other is $Property_TEXT_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_JUSTIFY`
class Property_TEXT_JUSTIFY extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_JUSTIFY> $type = type;

  Property_TEXT_JUSTIFY.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_JUSTIFY');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_JUSTIFYType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_TEXT_JUSTIFYImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_TEXT_JUSTIFY.implement(
    $Property_TEXT_JUSTIFYImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_TEXT_JUSTIFY.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$TEXT_JUSTIFY',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_TEXT_JUSTIFYImpl {
  factory $Property_TEXT_JUSTIFYImpl() = _$Property_TEXT_JUSTIFYImpl;
}

class _$Property_TEXT_JUSTIFYImpl implements $Property_TEXT_JUSTIFYImpl {
  _$Property_TEXT_JUSTIFYImpl();
}

final class $Property_TEXT_JUSTIFYType
    extends jni.JObjType<Property_TEXT_JUSTIFY> {
  const $Property_TEXT_JUSTIFYType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_JUSTIFY;';

  @override
  Property_TEXT_JUSTIFY fromReference(jni.JReference reference) =>
      Property_TEXT_JUSTIFY.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_JUSTIFYType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_JUSTIFYType) &&
        other is $Property_TEXT_JUSTIFYType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_PITCH_ALIGNMENT`
class Property_TEXT_PITCH_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_PITCH_ALIGNMENT> $type = type;

  Property_TEXT_PITCH_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_PITCH_ALIGNMENTType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_TEXT_PITCH_ALIGNMENTImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_TEXT_PITCH_ALIGNMENT.implement(
    $Property_TEXT_PITCH_ALIGNMENTImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_TEXT_PITCH_ALIGNMENT.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$TEXT_PITCH_ALIGNMENT',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_TEXT_PITCH_ALIGNMENTImpl {
  factory $Property_TEXT_PITCH_ALIGNMENTImpl() =
      _$Property_TEXT_PITCH_ALIGNMENTImpl;
}

class _$Property_TEXT_PITCH_ALIGNMENTImpl
    implements $Property_TEXT_PITCH_ALIGNMENTImpl {
  _$Property_TEXT_PITCH_ALIGNMENTImpl();
}

final class $Property_TEXT_PITCH_ALIGNMENTType
    extends jni.JObjType<Property_TEXT_PITCH_ALIGNMENT> {
  const $Property_TEXT_PITCH_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_PITCH_ALIGNMENT;';

  @override
  Property_TEXT_PITCH_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_TEXT_PITCH_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_PITCH_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_PITCH_ALIGNMENTType) &&
        other is $Property_TEXT_PITCH_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_ROTATION_ALIGNMENT`
class Property_TEXT_ROTATION_ALIGNMENT extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_ROTATION_ALIGNMENT> $type = type;

  Property_TEXT_ROTATION_ALIGNMENT.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_ROTATION_ALIGNMENTType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_TEXT_ROTATION_ALIGNMENTImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_TEXT_ROTATION_ALIGNMENT.implement(
    $Property_TEXT_ROTATION_ALIGNMENTImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_TEXT_ROTATION_ALIGNMENT.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$TEXT_ROTATION_ALIGNMENT',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_TEXT_ROTATION_ALIGNMENTImpl {
  factory $Property_TEXT_ROTATION_ALIGNMENTImpl() =
      _$Property_TEXT_ROTATION_ALIGNMENTImpl;
}

class _$Property_TEXT_ROTATION_ALIGNMENTImpl
    implements $Property_TEXT_ROTATION_ALIGNMENTImpl {
  _$Property_TEXT_ROTATION_ALIGNMENTImpl();
}

final class $Property_TEXT_ROTATION_ALIGNMENTType
    extends jni.JObjType<Property_TEXT_ROTATION_ALIGNMENT> {
  const $Property_TEXT_ROTATION_ALIGNMENTType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_ROTATION_ALIGNMENT;';

  @override
  Property_TEXT_ROTATION_ALIGNMENT fromReference(jni.JReference reference) =>
      Property_TEXT_ROTATION_ALIGNMENT.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_ROTATION_ALIGNMENTType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_ROTATION_ALIGNMENTType) &&
        other is $Property_TEXT_ROTATION_ALIGNMENTType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_TRANSFORM`
class Property_TEXT_TRANSFORM extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_TRANSFORM> $type = type;

  Property_TEXT_TRANSFORM.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_TRANSFORM');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_TRANSFORMType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_TEXT_TRANSFORMImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_TEXT_TRANSFORM.implement(
    $Property_TEXT_TRANSFORMImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_TEXT_TRANSFORM.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$TEXT_TRANSFORM',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_TEXT_TRANSFORMImpl {
  factory $Property_TEXT_TRANSFORMImpl() = _$Property_TEXT_TRANSFORMImpl;
}

class _$Property_TEXT_TRANSFORMImpl implements $Property_TEXT_TRANSFORMImpl {
  _$Property_TEXT_TRANSFORMImpl();
}

final class $Property_TEXT_TRANSFORMType
    extends jni.JObjType<Property_TEXT_TRANSFORM> {
  const $Property_TEXT_TRANSFORMType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSFORM;';

  @override
  Property_TEXT_TRANSFORM fromReference(jni.JReference reference) =>
      Property_TEXT_TRANSFORM.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_TRANSFORMType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_TRANSFORMType) &&
        other is $Property_TEXT_TRANSFORMType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_TRANSLATE_ANCHOR`
class Property_TEXT_TRANSLATE_ANCHOR extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_TRANSLATE_ANCHOR> $type = type;

  Property_TEXT_TRANSLATE_ANCHOR.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_TRANSLATE_ANCHORType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_TEXT_TRANSLATE_ANCHORImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_TEXT_TRANSLATE_ANCHOR.implement(
    $Property_TEXT_TRANSLATE_ANCHORImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_TEXT_TRANSLATE_ANCHOR.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$TEXT_TRANSLATE_ANCHOR',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_TEXT_TRANSLATE_ANCHORImpl {
  factory $Property_TEXT_TRANSLATE_ANCHORImpl() =
      _$Property_TEXT_TRANSLATE_ANCHORImpl;
}

class _$Property_TEXT_TRANSLATE_ANCHORImpl
    implements $Property_TEXT_TRANSLATE_ANCHORImpl {
  _$Property_TEXT_TRANSLATE_ANCHORImpl();
}

final class $Property_TEXT_TRANSLATE_ANCHORType
    extends jni.JObjType<Property_TEXT_TRANSLATE_ANCHOR> {
  const $Property_TEXT_TRANSLATE_ANCHORType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_TRANSLATE_ANCHOR;';

  @override
  Property_TEXT_TRANSLATE_ANCHOR fromReference(jni.JReference reference) =>
      Property_TEXT_TRANSLATE_ANCHOR.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_TRANSLATE_ANCHORType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_TRANSLATE_ANCHORType) &&
        other is $Property_TEXT_TRANSLATE_ANCHORType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$TEXT_WRITING_MODE`
class Property_TEXT_WRITING_MODE extends jni.JObject {
  @override
  late final jni.JObjType<Property_TEXT_WRITING_MODE> $type = type;

  Property_TEXT_WRITING_MODE.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$TEXT_WRITING_MODE');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_TEXT_WRITING_MODEType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_TEXT_WRITING_MODEImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_TEXT_WRITING_MODE.implement(
    $Property_TEXT_WRITING_MODEImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_TEXT_WRITING_MODE.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$TEXT_WRITING_MODE',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_TEXT_WRITING_MODEImpl {
  factory $Property_TEXT_WRITING_MODEImpl() = _$Property_TEXT_WRITING_MODEImpl;
}

class _$Property_TEXT_WRITING_MODEImpl
    implements $Property_TEXT_WRITING_MODEImpl {
  _$Property_TEXT_WRITING_MODEImpl();
}

final class $Property_TEXT_WRITING_MODEType
    extends jni.JObjType<Property_TEXT_WRITING_MODE> {
  const $Property_TEXT_WRITING_MODEType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$TEXT_WRITING_MODE;';

  @override
  Property_TEXT_WRITING_MODE fromReference(jni.JReference reference) =>
      Property_TEXT_WRITING_MODE.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_TEXT_WRITING_MODEType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_TEXT_WRITING_MODEType) &&
        other is $Property_TEXT_WRITING_MODEType;
  }
}

/// from: `org.maplibre.android.style.layers.Property$VISIBILITY`
class Property_VISIBILITY extends jni.JObject {
  @override
  late final jni.JObjType<Property_VISIBILITY> $type = type;

  Property_VISIBILITY.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/style/layers/Property$VISIBILITY');

  /// The type which includes information such as the signature of this class.
  static const type = $Property_VISIBILITYType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Property_VISIBILITYImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Property_VISIBILITY.implement(
    $Property_VISIBILITYImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Property_VISIBILITY.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.style.layers.Property$VISIBILITY',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Property_VISIBILITYImpl {
  factory $Property_VISIBILITYImpl() = _$Property_VISIBILITYImpl;
}

class _$Property_VISIBILITYImpl implements $Property_VISIBILITYImpl {
  _$Property_VISIBILITYImpl();
}

final class $Property_VISIBILITYType extends jni.JObjType<Property_VISIBILITY> {
  const $Property_VISIBILITYType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/style/layers/Property$VISIBILITY;';

  @override
  Property_VISIBILITY fromReference(jni.JReference reference) =>
      Property_VISIBILITY.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Property_VISIBILITYType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Property_VISIBILITYType) &&
        other is $Property_VISIBILITYType;
  }
}

/// from: `org.maplibre.android.style.layers.Property`
class Property extends jni.JObject {
  @override
  late final jni.JObjType<Property> $type = type;

  Property.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/style/layers/Property');

  /// The type which includes information such as the signature of this class.
  static const type = $PropertyType();
  static final _id_VISIBLE = _class.staticFieldId(
    r'VISIBLE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VISIBLE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VISIBLE =>
      _id_VISIBLE.get(_class, const jni.JStringType());

  static final _id_NONE = _class.staticFieldId(
    r'NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NONE => _id_NONE.get(_class, const jni.JStringType());

  static final _id_LINE_CAP_BUTT = _class.staticFieldId(
    r'LINE_CAP_BUTT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_BUTT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_CAP_BUTT =>
      _id_LINE_CAP_BUTT.get(_class, const jni.JStringType());

  static final _id_LINE_CAP_ROUND = _class.staticFieldId(
    r'LINE_CAP_ROUND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_CAP_ROUND =>
      _id_LINE_CAP_ROUND.get(_class, const jni.JStringType());

  static final _id_LINE_CAP_SQUARE = _class.staticFieldId(
    r'LINE_CAP_SQUARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_CAP_SQUARE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_CAP_SQUARE =>
      _id_LINE_CAP_SQUARE.get(_class, const jni.JStringType());

  static final _id_LINE_JOIN_BEVEL = _class.staticFieldId(
    r'LINE_JOIN_BEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_BEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_JOIN_BEVEL =>
      _id_LINE_JOIN_BEVEL.get(_class, const jni.JStringType());

  static final _id_LINE_JOIN_ROUND = _class.staticFieldId(
    r'LINE_JOIN_ROUND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_JOIN_ROUND =>
      _id_LINE_JOIN_ROUND.get(_class, const jni.JStringType());

  static final _id_LINE_JOIN_MITER = _class.staticFieldId(
    r'LINE_JOIN_MITER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_JOIN_MITER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_JOIN_MITER =>
      _id_LINE_JOIN_MITER.get(_class, const jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_POINT = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_POINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_POINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_PLACEMENT_POINT =>
      _id_SYMBOL_PLACEMENT_POINT.get(_class, const jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_LINE = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_LINE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_LINE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_PLACEMENT_LINE =>
      _id_SYMBOL_PLACEMENT_LINE.get(_class, const jni.JStringType());

  static final _id_SYMBOL_PLACEMENT_LINE_CENTER = _class.staticFieldId(
    r'SYMBOL_PLACEMENT_LINE_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_PLACEMENT_LINE_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_PLACEMENT_LINE_CENTER =>
      _id_SYMBOL_PLACEMENT_LINE_CENTER.get(_class, const jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_AUTO = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_Z_ORDER_AUTO =>
      _id_SYMBOL_Z_ORDER_AUTO.get(_class, const jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_VIEWPORT_Y = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_VIEWPORT_Y',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_VIEWPORT_Y`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_Z_ORDER_VIEWPORT_Y =>
      _id_SYMBOL_Z_ORDER_VIEWPORT_Y.get(_class, const jni.JStringType());

  static final _id_SYMBOL_Z_ORDER_SOURCE = _class.staticFieldId(
    r'SYMBOL_Z_ORDER_SOURCE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYMBOL_Z_ORDER_SOURCE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYMBOL_Z_ORDER_SOURCE =>
      _id_SYMBOL_Z_ORDER_SOURCE.get(_class, const jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_MAP = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ROTATION_ALIGNMENT_MAP =>
      _id_ICON_ROTATION_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ROTATION_ALIGNMENT_VIEWPORT =>
      _id_ICON_ROTATION_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_ICON_ROTATION_ALIGNMENT_AUTO = _class.staticFieldId(
    r'ICON_ROTATION_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ROTATION_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ROTATION_ALIGNMENT_AUTO =>
      _id_ICON_ROTATION_ALIGNMENT_AUTO.get(_class, const jni.JStringType());

  static final _id_ICON_TEXT_FIT_NONE = _class.staticFieldId(
    r'ICON_TEXT_FIT_NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TEXT_FIT_NONE =>
      _id_ICON_TEXT_FIT_NONE.get(_class, const jni.JStringType());

  static final _id_ICON_TEXT_FIT_WIDTH = _class.staticFieldId(
    r'ICON_TEXT_FIT_WIDTH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_WIDTH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TEXT_FIT_WIDTH =>
      _id_ICON_TEXT_FIT_WIDTH.get(_class, const jni.JStringType());

  static final _id_ICON_TEXT_FIT_HEIGHT = _class.staticFieldId(
    r'ICON_TEXT_FIT_HEIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_HEIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TEXT_FIT_HEIGHT =>
      _id_ICON_TEXT_FIT_HEIGHT.get(_class, const jni.JStringType());

  static final _id_ICON_TEXT_FIT_BOTH = _class.staticFieldId(
    r'ICON_TEXT_FIT_BOTH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TEXT_FIT_BOTH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TEXT_FIT_BOTH =>
      _id_ICON_TEXT_FIT_BOTH.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_CENTER = _class.staticFieldId(
    r'ICON_ANCHOR_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_CENTER =>
      _id_ICON_ANCHOR_CENTER.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_LEFT =>
      _id_ICON_ANCHOR_LEFT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_RIGHT =>
      _id_ICON_ANCHOR_RIGHT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_TOP = _class.staticFieldId(
    r'ICON_ANCHOR_TOP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_TOP =>
      _id_ICON_ANCHOR_TOP.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_BOTTOM =>
      _id_ICON_ANCHOR_BOTTOM.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_TOP_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_TOP_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_TOP_LEFT =>
      _id_ICON_ANCHOR_TOP_LEFT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_TOP_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_TOP_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_TOP_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_TOP_RIGHT =>
      _id_ICON_ANCHOR_TOP_RIGHT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM_LEFT = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_BOTTOM_LEFT =>
      _id_ICON_ANCHOR_BOTTOM_LEFT.get(_class, const jni.JStringType());

  static final _id_ICON_ANCHOR_BOTTOM_RIGHT = _class.staticFieldId(
    r'ICON_ANCHOR_BOTTOM_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_ANCHOR_BOTTOM_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_ANCHOR_BOTTOM_RIGHT =>
      _id_ICON_ANCHOR_BOTTOM_RIGHT.get(_class, const jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_PITCH_ALIGNMENT_MAP =>
      _id_ICON_PITCH_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_PITCH_ALIGNMENT_VIEWPORT =>
      _id_ICON_PITCH_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_ICON_PITCH_ALIGNMENT_AUTO = _class.staticFieldId(
    r'ICON_PITCH_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_PITCH_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_PITCH_ALIGNMENT_AUTO =>
      _id_ICON_PITCH_ALIGNMENT_AUTO.get(_class, const jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_PITCH_ALIGNMENT_MAP =>
      _id_TEXT_PITCH_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_PITCH_ALIGNMENT_VIEWPORT =>
      _id_TEXT_PITCH_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_TEXT_PITCH_ALIGNMENT_AUTO = _class.staticFieldId(
    r'TEXT_PITCH_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_PITCH_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_PITCH_ALIGNMENT_AUTO =>
      _id_TEXT_PITCH_ALIGNMENT_AUTO.get(_class, const jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_MAP = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ROTATION_ALIGNMENT_MAP =>
      _id_TEXT_ROTATION_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ROTATION_ALIGNMENT_VIEWPORT =>
      _id_TEXT_ROTATION_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_TEXT_ROTATION_ALIGNMENT_AUTO = _class.staticFieldId(
    r'TEXT_ROTATION_ALIGNMENT_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ROTATION_ALIGNMENT_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ROTATION_ALIGNMENT_AUTO =>
      _id_TEXT_ROTATION_ALIGNMENT_AUTO.get(_class, const jni.JStringType());

  static final _id_TEXT_JUSTIFY_AUTO = _class.staticFieldId(
    r'TEXT_JUSTIFY_AUTO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_JUSTIFY_AUTO =>
      _id_TEXT_JUSTIFY_AUTO.get(_class, const jni.JStringType());

  static final _id_TEXT_JUSTIFY_LEFT = _class.staticFieldId(
    r'TEXT_JUSTIFY_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_JUSTIFY_LEFT =>
      _id_TEXT_JUSTIFY_LEFT.get(_class, const jni.JStringType());

  static final _id_TEXT_JUSTIFY_CENTER = _class.staticFieldId(
    r'TEXT_JUSTIFY_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_JUSTIFY_CENTER =>
      _id_TEXT_JUSTIFY_CENTER.get(_class, const jni.JStringType());

  static final _id_TEXT_JUSTIFY_RIGHT = _class.staticFieldId(
    r'TEXT_JUSTIFY_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_JUSTIFY_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_JUSTIFY_RIGHT =>
      _id_TEXT_JUSTIFY_RIGHT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_CENTER = _class.staticFieldId(
    r'TEXT_ANCHOR_CENTER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_CENTER =>
      _id_TEXT_ANCHOR_CENTER.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_LEFT =>
      _id_TEXT_ANCHOR_LEFT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_RIGHT =>
      _id_TEXT_ANCHOR_RIGHT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_TOP =>
      _id_TEXT_ANCHOR_TOP.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_BOTTOM =>
      _id_TEXT_ANCHOR_BOTTOM.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_TOP_LEFT =>
      _id_TEXT_ANCHOR_TOP_LEFT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_TOP_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_TOP_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_TOP_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_TOP_RIGHT =>
      _id_TEXT_ANCHOR_TOP_RIGHT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM_LEFT = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM_LEFT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM_LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_BOTTOM_LEFT =>
      _id_TEXT_ANCHOR_BOTTOM_LEFT.get(_class, const jni.JStringType());

  static final _id_TEXT_ANCHOR_BOTTOM_RIGHT = _class.staticFieldId(
    r'TEXT_ANCHOR_BOTTOM_RIGHT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_ANCHOR_BOTTOM_RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_ANCHOR_BOTTOM_RIGHT =>
      _id_TEXT_ANCHOR_BOTTOM_RIGHT.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSFORM_NONE = _class.staticFieldId(
    r'TEXT_TRANSFORM_NONE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSFORM_NONE =>
      _id_TEXT_TRANSFORM_NONE.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSFORM_UPPERCASE = _class.staticFieldId(
    r'TEXT_TRANSFORM_UPPERCASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_UPPERCASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSFORM_UPPERCASE =>
      _id_TEXT_TRANSFORM_UPPERCASE.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSFORM_LOWERCASE = _class.staticFieldId(
    r'TEXT_TRANSFORM_LOWERCASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSFORM_LOWERCASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSFORM_LOWERCASE =>
      _id_TEXT_TRANSFORM_LOWERCASE.get(_class, const jni.JStringType());

  static final _id_FILL_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'FILL_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILL_TRANSLATE_ANCHOR_MAP =>
      _id_FILL_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_FILL_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'FILL_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILL_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_FILL_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_LINE_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'LINE_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_TRANSLATE_ANCHOR_MAP =>
      _id_LINE_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_LINE_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'LINE_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LINE_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LINE_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_LINE_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_ICON_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'ICON_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TRANSLATE_ANCHOR_MAP =>
      _id_ICON_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_ICON_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'ICON_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ICON_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ICON_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_ICON_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'TEXT_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSLATE_ANCHOR_MAP =>
      _id_TEXT_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_TEXT_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'TEXT_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_TEXT_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_CIRCLE_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'CIRCLE_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_TRANSLATE_ANCHOR_MAP =>
      _id_CIRCLE_TRANSLATE_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_CIRCLE_TRANSLATE_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_CIRCLE_TRANSLATE_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_CIRCLE_PITCH_SCALE_MAP = _class.staticFieldId(
    r'CIRCLE_PITCH_SCALE_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_SCALE_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_PITCH_SCALE_MAP =>
      _id_CIRCLE_PITCH_SCALE_MAP.get(_class, const jni.JStringType());

  static final _id_CIRCLE_PITCH_SCALE_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_PITCH_SCALE_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_SCALE_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_PITCH_SCALE_VIEWPORT =>
      _id_CIRCLE_PITCH_SCALE_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_CIRCLE_PITCH_ALIGNMENT_MAP = _class.staticFieldId(
    r'CIRCLE_PITCH_ALIGNMENT_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_ALIGNMENT_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_PITCH_ALIGNMENT_MAP =>
      _id_CIRCLE_PITCH_ALIGNMENT_MAP.get(_class, const jni.JStringType());

  static final _id_CIRCLE_PITCH_ALIGNMENT_VIEWPORT = _class.staticFieldId(
    r'CIRCLE_PITCH_ALIGNMENT_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CIRCLE_PITCH_ALIGNMENT_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CIRCLE_PITCH_ALIGNMENT_VIEWPORT =>
      _id_CIRCLE_PITCH_ALIGNMENT_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP = _class.staticFieldId(
    r'FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP =>
      _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_MAP.get(
          _class, const jni.JStringType());

  static final _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT =
      _class.staticFieldId(
    r'FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT =>
      _id_FILL_EXTRUSION_TRANSLATE_ANCHOR_VIEWPORT.get(
          _class, const jni.JStringType());

  static final _id_RASTER_RESAMPLING_LINEAR = _class.staticFieldId(
    r'RASTER_RESAMPLING_LINEAR',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RASTER_RESAMPLING_LINEAR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RASTER_RESAMPLING_LINEAR =>
      _id_RASTER_RESAMPLING_LINEAR.get(_class, const jni.JStringType());

  static final _id_RASTER_RESAMPLING_NEAREST = _class.staticFieldId(
    r'RASTER_RESAMPLING_NEAREST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RASTER_RESAMPLING_NEAREST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RASTER_RESAMPLING_NEAREST =>
      _id_RASTER_RESAMPLING_NEAREST.get(_class, const jni.JStringType());

  static final _id_HILLSHADE_ILLUMINATION_ANCHOR_MAP = _class.staticFieldId(
    r'HILLSHADE_ILLUMINATION_ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HILLSHADE_ILLUMINATION_ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HILLSHADE_ILLUMINATION_ANCHOR_MAP =>
      _id_HILLSHADE_ILLUMINATION_ANCHOR_MAP.get(
          _class, const jni.JStringType());

  static final _id_HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT =
      _class.staticFieldId(
    r'HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT =>
      _id_HILLSHADE_ILLUMINATION_ANCHOR_VIEWPORT.get(
          _class, const jni.JStringType());

  static final _id_ANCHOR_MAP = _class.staticFieldId(
    r'ANCHOR_MAP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANCHOR_MAP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ANCHOR_MAP =>
      _id_ANCHOR_MAP.get(_class, const jni.JStringType());

  static final _id_ANCHOR_VIEWPORT = _class.staticFieldId(
    r'ANCHOR_VIEWPORT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANCHOR_VIEWPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ANCHOR_VIEWPORT =>
      _id_ANCHOR_VIEWPORT.get(_class, const jni.JStringType());

  static final _id_TEXT_WRITING_MODE_HORIZONTAL = _class.staticFieldId(
    r'TEXT_WRITING_MODE_HORIZONTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_WRITING_MODE_HORIZONTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_WRITING_MODE_HORIZONTAL =>
      _id_TEXT_WRITING_MODE_HORIZONTAL.get(_class, const jni.JStringType());

  static final _id_TEXT_WRITING_MODE_VERTICAL = _class.staticFieldId(
    r'TEXT_WRITING_MODE_VERTICAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_WRITING_MODE_VERTICAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_WRITING_MODE_VERTICAL =>
      _id_TEXT_WRITING_MODE_VERTICAL.get(_class, const jni.JStringType());
}

final class $PropertyType extends jni.JObjType<Property> {
  const $PropertyType();

  @override
  String get signature => r'Lorg/maplibre/android/style/layers/Property;';

  @override
  Property fromReference(jni.JReference reference) =>
      Property.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PropertyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PropertyType) && other is $PropertyType;
  }
}
