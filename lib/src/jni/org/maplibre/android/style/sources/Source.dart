// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: `org.maplibre.android.style.sources.Source`
class Source extends jni.JObject {
  @override
  late final jni.JObjType<Source> $type = type;

  Source.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/style/sources/Source');

  /// The type which includes information such as the signature of this class.
  static const type = $SourceType();
  static final _id_detached = _class.instanceFieldId(
    r'detached',
    r'Z',
  );

  /// from: `protected boolean detached`
  bool get detached => _id_detached.get(this, const jni.jbooleanType());

  /// from: `protected boolean detached`
  set detached(bool value) =>
      _id_detached.set(this, const jni.jbooleanType(), value);

  static final _id_new0 = _class.constructorId(
    r'(J)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `protected void <init>(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Source(
    int j,
  ) {
    return Source.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr, j)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'()V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Source.new1() {
    return Source.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_checkThread = _class.instanceMethodId(
    r'checkThread',
    r'()V',
  );

  static final _checkThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `protected void checkThread()`
  void checkThread() {
    _checkThread(reference.pointer, _id_checkThread as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getId() {
    return _getId(reference.pointer, _id_getId as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAttribution = _class.instanceMethodId(
    r'getAttribution',
    r'()Ljava/lang/String;',
  );

  static final _getAttribution = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAttribution()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAttribution() {
    return _getAttribution(
            reference.pointer, _id_getAttribution as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPrefetchZoomDelta = _class.instanceMethodId(
    r'getPrefetchZoomDelta',
    r'()Ljava/lang/Integer;',
  );

  static final _getPrefetchZoomDelta = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Integer getPrefetchZoomDelta()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger getPrefetchZoomDelta() {
    return _getPrefetchZoomDelta(
            reference.pointer, _id_getPrefetchZoomDelta as jni.JMethodIDPtr)
        .object(const jni.JIntegerType());
  }

  static final _id_setPrefetchZoomDelta = _class.instanceMethodId(
    r'setPrefetchZoomDelta',
    r'(Ljava/lang/Integer;)V',
  );

  static final _setPrefetchZoomDelta = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setPrefetchZoomDelta(java.lang.Integer integer)`
  void setPrefetchZoomDelta(
    jni.JInteger integer,
  ) {
    _setPrefetchZoomDelta(
            reference.pointer,
            _id_setPrefetchZoomDelta as jni.JMethodIDPtr,
            integer.reference.pointer)
        .check();
  }

  static final _id_setMaxOverscaleFactorForParentTiles =
      _class.instanceMethodId(
    r'setMaxOverscaleFactorForParentTiles',
    r'(Ljava/lang/Integer;)V',
  );

  static final _setMaxOverscaleFactorForParentTiles =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: `public void setMaxOverscaleFactorForParentTiles(java.lang.Integer integer)`
  void setMaxOverscaleFactorForParentTiles(
    jni.JInteger integer,
  ) {
    _setMaxOverscaleFactorForParentTiles(
            reference.pointer,
            _id_setMaxOverscaleFactorForParentTiles as jni.JMethodIDPtr,
            integer.reference.pointer)
        .check();
  }

  static final _id_getMaxOverscaleFactorForParentTiles =
      _class.instanceMethodId(
    r'getMaxOverscaleFactorForParentTiles',
    r'()Ljava/lang/Integer;',
  );

  static final _getMaxOverscaleFactorForParentTiles =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `public java.lang.Integer getMaxOverscaleFactorForParentTiles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger getMaxOverscaleFactorForParentTiles() {
    return _getMaxOverscaleFactorForParentTiles(reference.pointer,
            _id_getMaxOverscaleFactorForParentTiles as jni.JMethodIDPtr)
        .object(const jni.JIntegerType());
  }

  static final _id_isVolatile = _class.instanceMethodId(
    r'isVolatile',
    r'()Ljava/lang/Boolean;',
  );

  static final _isVolatile = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Boolean isVolatile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JBoolean isVolatile() {
    return _isVolatile(reference.pointer, _id_isVolatile as jni.JMethodIDPtr)
        .object(const jni.JBooleanType());
  }

  static final _id_setVolatile = _class.instanceMethodId(
    r'setVolatile',
    r'(Ljava/lang/Boolean;)V',
  );

  static final _setVolatile = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setVolatile(java.lang.Boolean boolean)`
  void setVolatile(
    jni.JBoolean boolean,
  ) {
    _setVolatile(reference.pointer, _id_setVolatile as jni.JMethodIDPtr,
            boolean.reference.pointer)
        .check();
  }

  static final _id_setMinimumTileUpdateInterval = _class.instanceMethodId(
    r'setMinimumTileUpdateInterval',
    r'(Ljava/lang/Long;)V',
  );

  static final _setMinimumTileUpdateInterval = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setMinimumTileUpdateInterval(java.lang.Long long)`
  void setMinimumTileUpdateInterval(
    jni.JLong long,
  ) {
    _setMinimumTileUpdateInterval(
            reference.pointer,
            _id_setMinimumTileUpdateInterval as jni.JMethodIDPtr,
            long.reference.pointer)
        .check();
  }

  static final _id_getMinimumTileUpdateInterval = _class.instanceMethodId(
    r'getMinimumTileUpdateInterval',
    r'()Ljava/lang/Long;',
  );

  static final _getMinimumTileUpdateInterval = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getMinimumTileUpdateInterval()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JLong getMinimumTileUpdateInterval() {
    return _getMinimumTileUpdateInterval(reference.pointer,
            _id_getMinimumTileUpdateInterval as jni.JMethodIDPtr)
        .object(const jni.JLongType());
  }

  static final _id_getNativePtr = _class.instanceMethodId(
    r'getNativePtr',
    r'()J',
  );

  static final _getNativePtr = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public long getNativePtr()`
  int getNativePtr() {
    return _getNativePtr(
            reference.pointer, _id_getNativePtr as jni.JMethodIDPtr)
        .long;
  }

  static final _id_nativeGetId = _class.instanceMethodId(
    r'nativeGetId',
    r'()Ljava/lang/String;',
  );

  static final _nativeGetId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `protected native java.lang.String nativeGetId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString nativeGetId() {
    return _nativeGetId(reference.pointer, _id_nativeGetId as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_nativeGetAttribution = _class.instanceMethodId(
    r'nativeGetAttribution',
    r'()Ljava/lang/String;',
  );

  static final _nativeGetAttribution = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `protected native java.lang.String nativeGetAttribution()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString nativeGetAttribution() {
    return _nativeGetAttribution(
            reference.pointer, _id_nativeGetAttribution as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_nativeGetPrefetchZoomDelta = _class.instanceMethodId(
    r'nativeGetPrefetchZoomDelta',
    r'()Ljava/lang/Integer;',
  );

  static final _nativeGetPrefetchZoomDelta = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `protected native java.lang.Integer nativeGetPrefetchZoomDelta()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger nativeGetPrefetchZoomDelta() {
    return _nativeGetPrefetchZoomDelta(reference.pointer,
            _id_nativeGetPrefetchZoomDelta as jni.JMethodIDPtr)
        .object(const jni.JIntegerType());
  }

  static final _id_nativeSetPrefetchZoomDelta = _class.instanceMethodId(
    r'nativeSetPrefetchZoomDelta',
    r'(Ljava/lang/Integer;)V',
  );

  static final _nativeSetPrefetchZoomDelta = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `protected native void nativeSetPrefetchZoomDelta(java.lang.Integer integer)`
  void nativeSetPrefetchZoomDelta(
    jni.JInteger integer,
  ) {
    _nativeSetPrefetchZoomDelta(
            reference.pointer,
            _id_nativeSetPrefetchZoomDelta as jni.JMethodIDPtr,
            integer.reference.pointer)
        .check();
  }

  static final _id_nativeSetMaxOverscaleFactorForParentTiles =
      _class.instanceMethodId(
    r'nativeSetMaxOverscaleFactorForParentTiles',
    r'(Ljava/lang/Integer;)V',
  );

  static final _nativeSetMaxOverscaleFactorForParentTiles =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: `protected native void nativeSetMaxOverscaleFactorForParentTiles(java.lang.Integer integer)`
  void nativeSetMaxOverscaleFactorForParentTiles(
    jni.JInteger integer,
  ) {
    _nativeSetMaxOverscaleFactorForParentTiles(
            reference.pointer,
            _id_nativeSetMaxOverscaleFactorForParentTiles as jni.JMethodIDPtr,
            integer.reference.pointer)
        .check();
  }

  static final _id_nativeGetMaxOverscaleFactorForParentTiles =
      _class.instanceMethodId(
    r'nativeGetMaxOverscaleFactorForParentTiles',
    r'()Ljava/lang/Integer;',
  );

  static final _nativeGetMaxOverscaleFactorForParentTiles =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `protected native java.lang.Integer nativeGetMaxOverscaleFactorForParentTiles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger nativeGetMaxOverscaleFactorForParentTiles() {
    return _nativeGetMaxOverscaleFactorForParentTiles(reference.pointer,
            _id_nativeGetMaxOverscaleFactorForParentTiles as jni.JMethodIDPtr)
        .object(const jni.JIntegerType());
  }

  static final _id_nativeIsVolatile = _class.instanceMethodId(
    r'nativeIsVolatile',
    r'()Ljava/lang/Boolean;',
  );

  static final _nativeIsVolatile = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `protected native java.lang.Boolean nativeIsVolatile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JBoolean nativeIsVolatile() {
    return _nativeIsVolatile(
            reference.pointer, _id_nativeIsVolatile as jni.JMethodIDPtr)
        .object(const jni.JBooleanType());
  }

  static final _id_nativeSetVolatile = _class.instanceMethodId(
    r'nativeSetVolatile',
    r'(Ljava/lang/Boolean;)V',
  );

  static final _nativeSetVolatile = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `protected native void nativeSetVolatile(java.lang.Boolean boolean)`
  void nativeSetVolatile(
    jni.JBoolean boolean,
  ) {
    _nativeSetVolatile(
            reference.pointer,
            _id_nativeSetVolatile as jni.JMethodIDPtr,
            boolean.reference.pointer)
        .check();
  }

  static final _id_nativeSetMinimumTileUpdateInterval = _class.instanceMethodId(
    r'nativeSetMinimumTileUpdateInterval',
    r'(Ljava/lang/Long;)V',
  );

  static final _nativeSetMinimumTileUpdateInterval =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: `protected native void nativeSetMinimumTileUpdateInterval(java.lang.Long long)`
  void nativeSetMinimumTileUpdateInterval(
    jni.JLong long,
  ) {
    _nativeSetMinimumTileUpdateInterval(
            reference.pointer,
            _id_nativeSetMinimumTileUpdateInterval as jni.JMethodIDPtr,
            long.reference.pointer)
        .check();
  }

  static final _id_nativeGetMinimumTileUpdateInterval = _class.instanceMethodId(
    r'nativeGetMinimumTileUpdateInterval',
    r'()Ljava/lang/Long;',
  );

  static final _nativeGetMinimumTileUpdateInterval =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `protected native java.lang.Long nativeGetMinimumTileUpdateInterval()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JLong nativeGetMinimumTileUpdateInterval() {
    return _nativeGetMinimumTileUpdateInterval(reference.pointer,
            _id_nativeGetMinimumTileUpdateInterval as jni.JMethodIDPtr)
        .object(const jni.JLongType());
  }

  static final _id_setDetached = _class.instanceMethodId(
    r'setDetached',
    r'()V',
  );

  static final _setDetached = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void setDetached()`
  void setDetached() {
    _setDetached(reference.pointer, _id_setDetached as jni.JMethodIDPtr)
        .check();
  }
}

final class $SourceType extends jni.JObjType<Source> {
  const $SourceType();

  @override
  String get signature => r'Lorg/maplibre/android/style/sources/Source;';

  @override
  Source fromReference(jni.JReference reference) =>
      Source.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($SourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($SourceType) && other is $SourceType;
  }
}
