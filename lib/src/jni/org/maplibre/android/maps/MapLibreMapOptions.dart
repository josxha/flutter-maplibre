// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import '../camera/CameraPosition.dart' as cameraposition_;

/// from: `org.maplibre.android.maps.MapLibreMapOptions`
class MapLibreMapOptions extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMapOptions> $type = type;

  MapLibreMapOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/maps/MapLibreMapOptions');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMapOptionsType();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MapLibreMapOptions() {
    return MapLibreMapOptions.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_createFromAttributes = _class.staticMethodId(
    r'createFromAttributes',
    r'(Landroid/content/Context;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _createFromAttributes = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public org.maplibre.android.maps.MapLibreMapOptions createFromAttributes(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static MapLibreMapOptions createFromAttributes(
    jni.JObject context,
  ) {
    return _createFromAttributes(
            _class.reference.pointer,
            _id_createFromAttributes as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_createFromAttributes1 = _class.staticMethodId(
    r'createFromAttributes',
    r'(Landroid/content/Context;Landroid/util/AttributeSet;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _createFromAttributes1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `static public org.maplibre.android.maps.MapLibreMapOptions createFromAttributes(android.content.Context context, android.util.AttributeSet attributeSet)`
  /// The returned object must be released after use, by calling the [release] method.
  static MapLibreMapOptions createFromAttributes1(
    jni.JObject context,
    jni.JObject attributeSet,
  ) {
    return _createFromAttributes1(
            _class.reference.pointer,
            _id_createFromAttributes1 as jni.JMethodIDPtr,
            context.reference.pointer,
            attributeSet.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_apiBaseUrl = _class.instanceMethodId(
    r'apiBaseUrl',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _apiBaseUrl = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions apiBaseUrl(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions apiBaseUrl(
    jni.JString string,
  ) {
    return _apiBaseUrl(reference.pointer, _id_apiBaseUrl as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_apiBaseUri = _class.instanceMethodId(
    r'apiBaseUri',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _apiBaseUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions apiBaseUri(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions apiBaseUri(
    jni.JString string,
  ) {
    return _apiBaseUri(reference.pointer, _id_apiBaseUri as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_camera = _class.instanceMethodId(
    r'camera',
    r'(Lorg/maplibre/android/camera/CameraPosition;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _camera = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions camera(org.maplibre.android.camera.CameraPosition cameraPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions camera(
    cameraposition_.CameraPosition cameraPosition,
  ) {
    return _camera(reference.pointer, _id_camera as jni.JMethodIDPtr,
            cameraPosition.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_debugActive = _class.instanceMethodId(
    r'debugActive',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _debugActive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions debugActive(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions debugActive(
    bool z,
  ) {
    return _debugActive(
            reference.pointer, _id_debugActive as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_minZoomPreference = _class.instanceMethodId(
    r'minZoomPreference',
    r'(D)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _minZoomPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions minZoomPreference(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions minZoomPreference(
    double d,
  ) {
    return _minZoomPreference(
            reference.pointer, _id_minZoomPreference as jni.JMethodIDPtr, d)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_maxZoomPreference = _class.instanceMethodId(
    r'maxZoomPreference',
    r'(D)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _maxZoomPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions maxZoomPreference(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions maxZoomPreference(
    double d,
  ) {
    return _maxZoomPreference(
            reference.pointer, _id_maxZoomPreference as jni.JMethodIDPtr, d)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_minPitchPreference = _class.instanceMethodId(
    r'minPitchPreference',
    r'(D)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _minPitchPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions minPitchPreference(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions minPitchPreference(
    double d,
  ) {
    return _minPitchPreference(
            reference.pointer, _id_minPitchPreference as jni.JMethodIDPtr, d)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_maxPitchPreference = _class.instanceMethodId(
    r'maxPitchPreference',
    r'(D)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _maxPitchPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions maxPitchPreference(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions maxPitchPreference(
    double d,
  ) {
    return _maxPitchPreference(
            reference.pointer, _id_maxPitchPreference as jni.JMethodIDPtr, d)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_compassEnabled = _class.instanceMethodId(
    r'compassEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassEnabled(
    bool z,
  ) {
    return _compassEnabled(reference.pointer,
            _id_compassEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_compassGravity = _class.instanceMethodId(
    r'compassGravity',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassGravity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassGravity(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassGravity(
    int i,
  ) {
    return _compassGravity(
            reference.pointer, _id_compassGravity as jni.JMethodIDPtr, i)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_compassMargins = _class.instanceMethodId(
    r'compassMargins',
    r'([I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassMargins = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassMargins(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassMargins(
    jni.JArray<jni.jint> is0,
  ) {
    return _compassMargins(reference.pointer,
            _id_compassMargins as jni.JMethodIDPtr, is0.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_compassFadesWhenFacingNorth = _class.instanceMethodId(
    r'compassFadesWhenFacingNorth',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassFadesWhenFacingNorth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassFadesWhenFacingNorth(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassFadesWhenFacingNorth(
    bool z,
  ) {
    return _compassFadesWhenFacingNorth(reference.pointer,
            _id_compassFadesWhenFacingNorth as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_compassImage = _class.instanceMethodId(
    r'compassImage',
    r'(Landroid/graphics/drawable/Drawable;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _compassImage = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions compassImage(android.graphics.drawable.Drawable drawable)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions compassImage(
    jni.JObject drawable,
  ) {
    return _compassImage(reference.pointer,
            _id_compassImage as jni.JMethodIDPtr, drawable.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_logoEnabled = _class.instanceMethodId(
    r'logoEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _logoEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions logoEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions logoEnabled(
    bool z,
  ) {
    return _logoEnabled(
            reference.pointer, _id_logoEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_logoGravity = _class.instanceMethodId(
    r'logoGravity',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _logoGravity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions logoGravity(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions logoGravity(
    int i,
  ) {
    return _logoGravity(
            reference.pointer, _id_logoGravity as jni.JMethodIDPtr, i)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_logoMargins = _class.instanceMethodId(
    r'logoMargins',
    r'([I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _logoMargins = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions logoMargins(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions logoMargins(
    jni.JArray<jni.jint> is0,
  ) {
    return _logoMargins(reference.pointer, _id_logoMargins as jni.JMethodIDPtr,
            is0.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_attributionEnabled = _class.instanceMethodId(
    r'attributionEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _attributionEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions attributionEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions attributionEnabled(
    bool z,
  ) {
    return _attributionEnabled(reference.pointer,
            _id_attributionEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_attributionGravity = _class.instanceMethodId(
    r'attributionGravity',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _attributionGravity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions attributionGravity(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions attributionGravity(
    int i,
  ) {
    return _attributionGravity(
            reference.pointer, _id_attributionGravity as jni.JMethodIDPtr, i)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_attributionMargins = _class.instanceMethodId(
    r'attributionMargins',
    r'([I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _attributionMargins = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions attributionMargins(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions attributionMargins(
    jni.JArray<jni.jint> is0,
  ) {
    return _attributionMargins(reference.pointer,
            _id_attributionMargins as jni.JMethodIDPtr, is0.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_attributionTintColor = _class.instanceMethodId(
    r'attributionTintColor',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _attributionTintColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions attributionTintColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions attributionTintColor(
    int i,
  ) {
    return _attributionTintColor(
            reference.pointer, _id_attributionTintColor as jni.JMethodIDPtr, i)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_rotateGesturesEnabled = _class.instanceMethodId(
    r'rotateGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _rotateGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions rotateGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions rotateGesturesEnabled(
    bool z,
  ) {
    return _rotateGesturesEnabled(reference.pointer,
            _id_rotateGesturesEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_scrollGesturesEnabled = _class.instanceMethodId(
    r'scrollGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _scrollGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions scrollGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions scrollGesturesEnabled(
    bool z,
  ) {
    return _scrollGesturesEnabled(reference.pointer,
            _id_scrollGesturesEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_horizontalScrollGesturesEnabled = _class.instanceMethodId(
    r'horizontalScrollGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _horizontalScrollGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions horizontalScrollGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions horizontalScrollGesturesEnabled(
    bool z,
  ) {
    return _horizontalScrollGesturesEnabled(reference.pointer,
            _id_horizontalScrollGesturesEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_tiltGesturesEnabled = _class.instanceMethodId(
    r'tiltGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _tiltGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions tiltGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions tiltGesturesEnabled(
    bool z,
  ) {
    return _tiltGesturesEnabled(reference.pointer,
            _id_tiltGesturesEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_zoomGesturesEnabled = _class.instanceMethodId(
    r'zoomGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _zoomGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions zoomGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions zoomGesturesEnabled(
    bool z,
  ) {
    return _zoomGesturesEnabled(reference.pointer,
            _id_zoomGesturesEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_doubleTapGesturesEnabled = _class.instanceMethodId(
    r'doubleTapGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _doubleTapGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions doubleTapGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions doubleTapGesturesEnabled(
    bool z,
  ) {
    return _doubleTapGesturesEnabled(reference.pointer,
            _id_doubleTapGesturesEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_quickZoomGesturesEnabled = _class.instanceMethodId(
    r'quickZoomGesturesEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _quickZoomGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions quickZoomGesturesEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions quickZoomGesturesEnabled(
    bool z,
  ) {
    return _quickZoomGesturesEnabled(reference.pointer,
            _id_quickZoomGesturesEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_textureMode = _class.instanceMethodId(
    r'textureMode',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _textureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions textureMode(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions textureMode(
    bool z,
  ) {
    return _textureMode(
            reference.pointer, _id_textureMode as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_translucentTextureSurface = _class.instanceMethodId(
    r'translucentTextureSurface',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _translucentTextureSurface = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions translucentTextureSurface(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions translucentTextureSurface(
    bool z,
  ) {
    return _translucentTextureSurface(reference.pointer,
            _id_translucentTextureSurface as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_foregroundLoadColor = _class.instanceMethodId(
    r'foregroundLoadColor',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _foregroundLoadColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions foregroundLoadColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions foregroundLoadColor(
    int i,
  ) {
    return _foregroundLoadColor(
            reference.pointer, _id_foregroundLoadColor as jni.JMethodIDPtr, i)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_setPrefetchesTiles = _class.instanceMethodId(
    r'setPrefetchesTiles',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _setPrefetchesTiles = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions setPrefetchesTiles(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions setPrefetchesTiles(
    bool z,
  ) {
    return _setPrefetchesTiles(reference.pointer,
            _id_setPrefetchesTiles as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_setPrefetchZoomDelta = _class.instanceMethodId(
    r'setPrefetchZoomDelta',
    r'(I)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _setPrefetchZoomDelta = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions setPrefetchZoomDelta(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions setPrefetchZoomDelta(
    int i,
  ) {
    return _setPrefetchZoomDelta(
            reference.pointer, _id_setPrefetchZoomDelta as jni.JMethodIDPtr, i)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_crossSourceCollisions = _class.instanceMethodId(
    r'crossSourceCollisions',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _crossSourceCollisions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions crossSourceCollisions(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions crossSourceCollisions(
    bool z,
  ) {
    return _crossSourceCollisions(reference.pointer,
            _id_crossSourceCollisions as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_localIdeographFontFamilyEnabled = _class.instanceMethodId(
    r'localIdeographFontFamilyEnabled',
    r'(Z)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _localIdeographFontFamilyEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions localIdeographFontFamilyEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions localIdeographFontFamilyEnabled(
    bool z,
  ) {
    return _localIdeographFontFamilyEnabled(reference.pointer,
            _id_localIdeographFontFamilyEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_localIdeographFontFamily = _class.instanceMethodId(
    r'localIdeographFontFamily',
    r'(Ljava/lang/String;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _localIdeographFontFamily = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions localIdeographFontFamily(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions localIdeographFontFamily(
    jni.JString string,
  ) {
    return _localIdeographFontFamily(
            reference.pointer,
            _id_localIdeographFontFamily as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_localIdeographFontFamily1 = _class.instanceMethodId(
    r'localIdeographFontFamily',
    r'([Ljava/lang/String;)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _localIdeographFontFamily1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions localIdeographFontFamily(java.lang.String[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions localIdeographFontFamily1(
    jni.JArray<jni.JString> strings,
  ) {
    return _localIdeographFontFamily1(
            reference.pointer,
            _id_localIdeographFontFamily1 as jni.JMethodIDPtr,
            strings.reference.pointer)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_pixelRatio = _class.instanceMethodId(
    r'pixelRatio',
    r'(F)Lorg/maplibre/android/maps/MapLibreMapOptions;',
  );

  static final _pixelRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public org.maplibre.android.maps.MapLibreMapOptions pixelRatio(float f)`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMapOptions pixelRatio(
    double f,
  ) {
    return _pixelRatio(reference.pointer, _id_pixelRatio as jni.JMethodIDPtr, f)
        .object(const $MapLibreMapOptionsType());
  }

  static final _id_getPrefetchesTiles = _class.instanceMethodId(
    r'getPrefetchesTiles',
    r'()Z',
  );

  static final _getPrefetchesTiles = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getPrefetchesTiles()`
  bool getPrefetchesTiles() {
    return _getPrefetchesTiles(
            reference.pointer, _id_getPrefetchesTiles as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getPrefetchZoomDelta = _class.instanceMethodId(
    r'getPrefetchZoomDelta',
    r'()I',
  );

  static final _getPrefetchZoomDelta = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getPrefetchZoomDelta()`
  int getPrefetchZoomDelta() {
    return _getPrefetchZoomDelta(
            reference.pointer, _id_getPrefetchZoomDelta as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getCrossSourceCollisions = _class.instanceMethodId(
    r'getCrossSourceCollisions',
    r'()Z',
  );

  static final _getCrossSourceCollisions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getCrossSourceCollisions()`
  bool getCrossSourceCollisions() {
    return _getCrossSourceCollisions(
            reference.pointer, _id_getCrossSourceCollisions as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_renderSurfaceOnTop = _class.instanceMethodId(
    r'renderSurfaceOnTop',
    r'(Z)V',
  );

  static final _renderSurfaceOnTop = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void renderSurfaceOnTop(boolean z)`
  void renderSurfaceOnTop(
    bool z,
  ) {
    _renderSurfaceOnTop(reference.pointer,
            _id_renderSurfaceOnTop as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getRenderSurfaceOnTop = _class.instanceMethodId(
    r'getRenderSurfaceOnTop',
    r'()Z',
  );

  static final _getRenderSurfaceOnTop = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getRenderSurfaceOnTop()`
  bool getRenderSurfaceOnTop() {
    return _getRenderSurfaceOnTop(
            reference.pointer, _id_getRenderSurfaceOnTop as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getApiBaseUrl = _class.instanceMethodId(
    r'getApiBaseUrl',
    r'()Ljava/lang/String;',
  );

  static final _getApiBaseUrl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getApiBaseUrl()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getApiBaseUrl() {
    return _getApiBaseUrl(
            reference.pointer, _id_getApiBaseUrl as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getApiBaseUri = _class.instanceMethodId(
    r'getApiBaseUri',
    r'()Ljava/lang/String;',
  );

  static final _getApiBaseUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getApiBaseUri()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getApiBaseUri() {
    return _getApiBaseUri(
            reference.pointer, _id_getApiBaseUri as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getCamera = _class.instanceMethodId(
    r'getCamera',
    r'()Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCamera = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCamera()`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCamera() {
    return _getCamera(reference.pointer, _id_getCamera as jni.JMethodIDPtr)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_getMinZoomPreference = _class.instanceMethodId(
    r'getMinZoomPreference',
    r'()D',
  );

  static final _getMinZoomPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public double getMinZoomPreference()`
  double getMinZoomPreference() {
    return _getMinZoomPreference(
            reference.pointer, _id_getMinZoomPreference as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getMaxZoomPreference = _class.instanceMethodId(
    r'getMaxZoomPreference',
    r'()D',
  );

  static final _getMaxZoomPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public double getMaxZoomPreference()`
  double getMaxZoomPreference() {
    return _getMaxZoomPreference(
            reference.pointer, _id_getMaxZoomPreference as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getMinPitchPreference = _class.instanceMethodId(
    r'getMinPitchPreference',
    r'()D',
  );

  static final _getMinPitchPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public double getMinPitchPreference()`
  double getMinPitchPreference() {
    return _getMinPitchPreference(
            reference.pointer, _id_getMinPitchPreference as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getMaxPitchPreference = _class.instanceMethodId(
    r'getMaxPitchPreference',
    r'()D',
  );

  static final _getMaxPitchPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public double getMaxPitchPreference()`
  double getMaxPitchPreference() {
    return _getMaxPitchPreference(
            reference.pointer, _id_getMaxPitchPreference as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getCompassEnabled = _class.instanceMethodId(
    r'getCompassEnabled',
    r'()Z',
  );

  static final _getCompassEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getCompassEnabled()`
  bool getCompassEnabled() {
    return _getCompassEnabled(
            reference.pointer, _id_getCompassEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getCompassGravity = _class.instanceMethodId(
    r'getCompassGravity',
    r'()I',
  );

  static final _getCompassGravity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getCompassGravity()`
  int getCompassGravity() {
    return _getCompassGravity(
            reference.pointer, _id_getCompassGravity as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getCompassMargins = _class.instanceMethodId(
    r'getCompassMargins',
    r'()[I',
  );

  static final _getCompassMargins = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int[] getCompassMargins()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getCompassMargins() {
    return _getCompassMargins(
            reference.pointer, _id_getCompassMargins as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_getCompassFadeFacingNorth = _class.instanceMethodId(
    r'getCompassFadeFacingNorth',
    r'()Z',
  );

  static final _getCompassFadeFacingNorth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getCompassFadeFacingNorth()`
  bool getCompassFadeFacingNorth() {
    return _getCompassFadeFacingNorth(reference.pointer,
            _id_getCompassFadeFacingNorth as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getCompassImage = _class.instanceMethodId(
    r'getCompassImage',
    r'()Landroid/graphics/drawable/Drawable;',
  );

  static final _getCompassImage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.drawable.Drawable getCompassImage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCompassImage() {
    return _getCompassImage(
            reference.pointer, _id_getCompassImage as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getLogoEnabled = _class.instanceMethodId(
    r'getLogoEnabled',
    r'()Z',
  );

  static final _getLogoEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getLogoEnabled()`
  bool getLogoEnabled() {
    return _getLogoEnabled(
            reference.pointer, _id_getLogoEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getLogoGravity = _class.instanceMethodId(
    r'getLogoGravity',
    r'()I',
  );

  static final _getLogoGravity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getLogoGravity()`
  int getLogoGravity() {
    return _getLogoGravity(
            reference.pointer, _id_getLogoGravity as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getLogoMargins = _class.instanceMethodId(
    r'getLogoMargins',
    r'()[I',
  );

  static final _getLogoMargins = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int[] getLogoMargins()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getLogoMargins() {
    return _getLogoMargins(
            reference.pointer, _id_getLogoMargins as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_getRotateGesturesEnabled = _class.instanceMethodId(
    r'getRotateGesturesEnabled',
    r'()Z',
  );

  static final _getRotateGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getRotateGesturesEnabled()`
  bool getRotateGesturesEnabled() {
    return _getRotateGesturesEnabled(
            reference.pointer, _id_getRotateGesturesEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getScrollGesturesEnabled = _class.instanceMethodId(
    r'getScrollGesturesEnabled',
    r'()Z',
  );

  static final _getScrollGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getScrollGesturesEnabled()`
  bool getScrollGesturesEnabled() {
    return _getScrollGesturesEnabled(
            reference.pointer, _id_getScrollGesturesEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getHorizontalScrollGesturesEnabled = _class.instanceMethodId(
    r'getHorizontalScrollGesturesEnabled',
    r'()Z',
  );

  static final _getHorizontalScrollGesturesEnabled =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `public boolean getHorizontalScrollGesturesEnabled()`
  bool getHorizontalScrollGesturesEnabled() {
    return _getHorizontalScrollGesturesEnabled(reference.pointer,
            _id_getHorizontalScrollGesturesEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getTiltGesturesEnabled = _class.instanceMethodId(
    r'getTiltGesturesEnabled',
    r'()Z',
  );

  static final _getTiltGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getTiltGesturesEnabled()`
  bool getTiltGesturesEnabled() {
    return _getTiltGesturesEnabled(
            reference.pointer, _id_getTiltGesturesEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getZoomGesturesEnabled = _class.instanceMethodId(
    r'getZoomGesturesEnabled',
    r'()Z',
  );

  static final _getZoomGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getZoomGesturesEnabled()`
  bool getZoomGesturesEnabled() {
    return _getZoomGesturesEnabled(
            reference.pointer, _id_getZoomGesturesEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getDoubleTapGesturesEnabled = _class.instanceMethodId(
    r'getDoubleTapGesturesEnabled',
    r'()Z',
  );

  static final _getDoubleTapGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getDoubleTapGesturesEnabled()`
  bool getDoubleTapGesturesEnabled() {
    return _getDoubleTapGesturesEnabled(reference.pointer,
            _id_getDoubleTapGesturesEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getQuickZoomGesturesEnabled = _class.instanceMethodId(
    r'getQuickZoomGesturesEnabled',
    r'()Z',
  );

  static final _getQuickZoomGesturesEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getQuickZoomGesturesEnabled()`
  bool getQuickZoomGesturesEnabled() {
    return _getQuickZoomGesturesEnabled(reference.pointer,
            _id_getQuickZoomGesturesEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAttributionEnabled = _class.instanceMethodId(
    r'getAttributionEnabled',
    r'()Z',
  );

  static final _getAttributionEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getAttributionEnabled()`
  bool getAttributionEnabled() {
    return _getAttributionEnabled(
            reference.pointer, _id_getAttributionEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAttributionGravity = _class.instanceMethodId(
    r'getAttributionGravity',
    r'()I',
  );

  static final _getAttributionGravity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getAttributionGravity()`
  int getAttributionGravity() {
    return _getAttributionGravity(
            reference.pointer, _id_getAttributionGravity as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getAttributionMargins = _class.instanceMethodId(
    r'getAttributionMargins',
    r'()[I',
  );

  static final _getAttributionMargins = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int[] getAttributionMargins()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getAttributionMargins() {
    return _getAttributionMargins(
            reference.pointer, _id_getAttributionMargins as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_getAttributionTintColor = _class.instanceMethodId(
    r'getAttributionTintColor',
    r'()I',
  );

  static final _getAttributionTintColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getAttributionTintColor()`
  int getAttributionTintColor() {
    return _getAttributionTintColor(
            reference.pointer, _id_getAttributionTintColor as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getDebugActive = _class.instanceMethodId(
    r'getDebugActive',
    r'()Z',
  );

  static final _getDebugActive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getDebugActive()`
  bool getDebugActive() {
    return _getDebugActive(
            reference.pointer, _id_getDebugActive as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getTextureMode = _class.instanceMethodId(
    r'getTextureMode',
    r'()Z',
  );

  static final _getTextureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getTextureMode()`
  bool getTextureMode() {
    return _getTextureMode(
            reference.pointer, _id_getTextureMode as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getTranslucentTextureSurface = _class.instanceMethodId(
    r'getTranslucentTextureSurface',
    r'()Z',
  );

  static final _getTranslucentTextureSurface = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getTranslucentTextureSurface()`
  bool getTranslucentTextureSurface() {
    return _getTranslucentTextureSurface(reference.pointer,
            _id_getTranslucentTextureSurface as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getForegroundLoadColor = _class.instanceMethodId(
    r'getForegroundLoadColor',
    r'()I',
  );

  static final _getForegroundLoadColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getForegroundLoadColor()`
  int getForegroundLoadColor() {
    return _getForegroundLoadColor(
            reference.pointer, _id_getForegroundLoadColor as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getLocalIdeographFontFamily = _class.instanceMethodId(
    r'getLocalIdeographFontFamily',
    r'()Ljava/lang/String;',
  );

  static final _getLocalIdeographFontFamily = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getLocalIdeographFontFamily()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLocalIdeographFontFamily() {
    return _getLocalIdeographFontFamily(reference.pointer,
            _id_getLocalIdeographFontFamily as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_isLocalIdeographFontFamilyEnabled = _class.instanceMethodId(
    r'isLocalIdeographFontFamilyEnabled',
    r'()Z',
  );

  static final _isLocalIdeographFontFamilyEnabled =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `public boolean isLocalIdeographFontFamilyEnabled()`
  bool isLocalIdeographFontFamilyEnabled() {
    return _isLocalIdeographFontFamilyEnabled(reference.pointer,
            _id_isLocalIdeographFontFamilyEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getPixelRatio = _class.instanceMethodId(
    r'getPixelRatio',
    r'()F',
  );

  static final _getPixelRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getPixelRatio()`
  double getPixelRatio() {
    return _getPixelRatio(
            reference.pointer, _id_getPixelRatio as jni.JMethodIDPtr)
        .float;
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, _id_writeToParcel as jni.JMethodIDPtr,
            parcel.reference.pointer, i)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }
}

final class $MapLibreMapOptionsType extends jni.JObjType<MapLibreMapOptions> {
  const $MapLibreMapOptionsType();

  @override
  String get signature => r'Lorg/maplibre/android/maps/MapLibreMapOptions;';

  @override
  MapLibreMapOptions fromReference(jni.JReference reference) =>
      MapLibreMapOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMapOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMapOptionsType) &&
        other is $MapLibreMapOptionsType;
  }
}
