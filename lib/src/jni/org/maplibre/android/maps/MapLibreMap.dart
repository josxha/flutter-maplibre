// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import '../../../../android/graphics/PointF.dart' as pointf_;

import '../camera/CameraPosition.dart' as cameraposition_;

import '../camera/CameraUpdate.dart' as cameraupdate_;

import '../geometry/LatLng.dart' as latlng_;

import '../geometry/LatLngBounds.dart' as latlngbounds_;

import '../location/LocationComponent.dart' as locationcomponent_;

import '../offline/OfflineRegionDefinition.dart' as offlineregiondefinition_;

import 'Projection.dart' as projection_;

import 'Style.dart' as style_;

import 'UiSettings.dart' as uisettings_;

/// from: `org.maplibre.android.maps.MapLibreMap$CancelableCallback`
class MapLibreMap_CancelableCallback extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_CancelableCallback> $type = type;

  MapLibreMap_CancelableCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$CancelableCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_CancelableCallbackType();
  static final _id_onCancel = _class.instanceMethodId(
    r'onCancel',
    r'()V',
  );

  static final _onCancel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCancel()`
  void onCancel() {
    _onCancel(reference.pointer, _id_onCancel as jni.JMethodIDPtr).check();
  }

  static final _id_onFinish = _class.instanceMethodId(
    r'onFinish',
    r'()V',
  );

  static final _onFinish = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onFinish()`
  void onFinish() {
    _onFinish(reference.pointer, _id_onFinish as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_CancelableCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCancel()V') {
        _$impls[$p]!.onCancel();
        return jni.nullptr;
      }
      if ($d == r'onFinish()V') {
        _$impls[$p]!.onFinish();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_CancelableCallback.implement(
    $MapLibreMap_CancelableCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_CancelableCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$CancelableCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_CancelableCallbackImpl {
  factory $MapLibreMap_CancelableCallbackImpl({
    required void Function() onCancel,
    required void Function() onFinish,
  }) = _$MapLibreMap_CancelableCallbackImpl;

  void onCancel();
  void onFinish();
}

class _$MapLibreMap_CancelableCallbackImpl
    implements $MapLibreMap_CancelableCallbackImpl {
  _$MapLibreMap_CancelableCallbackImpl({
    required void Function() onCancel,
    required void Function() onFinish,
  })  : _onCancel = onCancel,
        _onFinish = onFinish;

  final void Function() _onCancel;
  final void Function() _onFinish;

  void onCancel() {
    return _onCancel();
  }

  void onFinish() {
    return _onFinish();
  }
}

final class $MapLibreMap_CancelableCallbackType
    extends jni.JObjType<MapLibreMap_CancelableCallback> {
  const $MapLibreMap_CancelableCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;';

  @override
  MapLibreMap_CancelableCallback fromReference(jni.JReference reference) =>
      MapLibreMap_CancelableCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_CancelableCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_CancelableCallbackType) &&
        other is $MapLibreMap_CancelableCallbackType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter`
class MapLibreMap_InfoWindowAdapter extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_InfoWindowAdapter> $type = type;

  MapLibreMap_InfoWindowAdapter.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$InfoWindowAdapter');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_InfoWindowAdapterType();
  static final _id_getInfoWindow = _class.instanceMethodId(
    r'getInfoWindow',
    r'(Lorg/maplibre/android/annotations/Marker;)Landroid/view/View;',
  );

  static final _getInfoWindow = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract android.view.View getInfoWindow(org.maplibre.android.annotations.Marker marker)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getInfoWindow(
    jni.JObject marker,
  ) {
    return _getInfoWindow(reference.pointer,
            _id_getInfoWindow as jni.JMethodIDPtr, marker.reference.pointer)
        .object(const jni.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_InfoWindowAdapterImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'getInfoWindow(Lorg/maplibre/android/annotations/Marker;)Landroid/view/View;') {
        final $r = _$impls[$p]!.getInfoWindow(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_InfoWindowAdapter.implement(
    $MapLibreMap_InfoWindowAdapterImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_InfoWindowAdapter.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_InfoWindowAdapterImpl {
  factory $MapLibreMap_InfoWindowAdapterImpl({
    required jni.JObject Function(jni.JObject marker) getInfoWindow,
  }) = _$MapLibreMap_InfoWindowAdapterImpl;

  jni.JObject getInfoWindow(jni.JObject marker);
}

class _$MapLibreMap_InfoWindowAdapterImpl
    implements $MapLibreMap_InfoWindowAdapterImpl {
  _$MapLibreMap_InfoWindowAdapterImpl({
    required jni.JObject Function(jni.JObject marker) getInfoWindow,
  }) : _getInfoWindow = getInfoWindow;

  final jni.JObject Function(jni.JObject marker) _getInfoWindow;

  jni.JObject getInfoWindow(jni.JObject marker) {
    return _getInfoWindow(marker);
  }
}

final class $MapLibreMap_InfoWindowAdapterType
    extends jni.JObjType<MapLibreMap_InfoWindowAdapter> {
  const $MapLibreMap_InfoWindowAdapterType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;';

  @override
  MapLibreMap_InfoWindowAdapter fromReference(jni.JReference reference) =>
      MapLibreMap_InfoWindowAdapter.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_InfoWindowAdapterType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_InfoWindowAdapterType) &&
        other is $MapLibreMap_InfoWindowAdapterType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener`
class MapLibreMap_OnCameraIdleListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnCameraIdleListener> $type = type;

  MapLibreMap_OnCameraIdleListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCameraIdleListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCameraIdleListenerType();
  static final _id_onCameraIdle = _class.instanceMethodId(
    r'onCameraIdle',
    r'()V',
  );

  static final _onCameraIdle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCameraIdle()`
  void onCameraIdle() {
    _onCameraIdle(reference.pointer, _id_onCameraIdle as jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnCameraIdleListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraIdle()V') {
        _$impls[$p]!.onCameraIdle();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnCameraIdleListener.implement(
    $MapLibreMap_OnCameraIdleListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnCameraIdleListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnCameraIdleListenerImpl {
  factory $MapLibreMap_OnCameraIdleListenerImpl({
    required void Function() onCameraIdle,
  }) = _$MapLibreMap_OnCameraIdleListenerImpl;

  void onCameraIdle();
}

class _$MapLibreMap_OnCameraIdleListenerImpl
    implements $MapLibreMap_OnCameraIdleListenerImpl {
  _$MapLibreMap_OnCameraIdleListenerImpl({
    required void Function() onCameraIdle,
  }) : _onCameraIdle = onCameraIdle;

  final void Function() _onCameraIdle;

  void onCameraIdle() {
    return _onCameraIdle();
  }
}

final class $MapLibreMap_OnCameraIdleListenerType
    extends jni.JObjType<MapLibreMap_OnCameraIdleListener> {
  const $MapLibreMap_OnCameraIdleListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;';

  @override
  MapLibreMap_OnCameraIdleListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnCameraIdleListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnCameraIdleListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnCameraIdleListenerType) &&
        other is $MapLibreMap_OnCameraIdleListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener`
class MapLibreMap_OnCameraMoveCanceledListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnCameraMoveCanceledListener> $type =
      type;

  MapLibreMap_OnCameraMoveCanceledListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCameraMoveCanceledListenerType();
  static final _id_onCameraMoveCanceled = _class.instanceMethodId(
    r'onCameraMoveCanceled',
    r'()V',
  );

  static final _onCameraMoveCanceled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCameraMoveCanceled()`
  void onCameraMoveCanceled() {
    _onCameraMoveCanceled(
            reference.pointer, _id_onCameraMoveCanceled as jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnCameraMoveCanceledListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMoveCanceled()V') {
        _$impls[$p]!.onCameraMoveCanceled();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnCameraMoveCanceledListener.implement(
    $MapLibreMap_OnCameraMoveCanceledListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnCameraMoveCanceledListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnCameraMoveCanceledListenerImpl {
  factory $MapLibreMap_OnCameraMoveCanceledListenerImpl({
    required void Function() onCameraMoveCanceled,
  }) = _$MapLibreMap_OnCameraMoveCanceledListenerImpl;

  void onCameraMoveCanceled();
}

class _$MapLibreMap_OnCameraMoveCanceledListenerImpl
    implements $MapLibreMap_OnCameraMoveCanceledListenerImpl {
  _$MapLibreMap_OnCameraMoveCanceledListenerImpl({
    required void Function() onCameraMoveCanceled,
  }) : _onCameraMoveCanceled = onCameraMoveCanceled;

  final void Function() _onCameraMoveCanceled;

  void onCameraMoveCanceled() {
    return _onCameraMoveCanceled();
  }
}

final class $MapLibreMap_OnCameraMoveCanceledListenerType
    extends jni.JObjType<MapLibreMap_OnCameraMoveCanceledListener> {
  const $MapLibreMap_OnCameraMoveCanceledListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;';

  @override
  MapLibreMap_OnCameraMoveCanceledListener fromReference(
          jni.JReference reference) =>
      MapLibreMap_OnCameraMoveCanceledListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnCameraMoveCanceledListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnCameraMoveCanceledListenerType) &&
        other is $MapLibreMap_OnCameraMoveCanceledListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener`
class MapLibreMap_OnCameraMoveListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnCameraMoveListener> $type = type;

  MapLibreMap_OnCameraMoveListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCameraMoveListenerType();
  static final _id_onCameraMove = _class.instanceMethodId(
    r'onCameraMove',
    r'()V',
  );

  static final _onCameraMove = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCameraMove()`
  void onCameraMove() {
    _onCameraMove(reference.pointer, _id_onCameraMove as jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnCameraMoveListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMove()V') {
        _$impls[$p]!.onCameraMove();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnCameraMoveListener.implement(
    $MapLibreMap_OnCameraMoveListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnCameraMoveListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnCameraMoveListenerImpl {
  factory $MapLibreMap_OnCameraMoveListenerImpl({
    required void Function() onCameraMove,
  }) = _$MapLibreMap_OnCameraMoveListenerImpl;

  void onCameraMove();
}

class _$MapLibreMap_OnCameraMoveListenerImpl
    implements $MapLibreMap_OnCameraMoveListenerImpl {
  _$MapLibreMap_OnCameraMoveListenerImpl({
    required void Function() onCameraMove,
  }) : _onCameraMove = onCameraMove;

  final void Function() _onCameraMove;

  void onCameraMove() {
    return _onCameraMove();
  }
}

final class $MapLibreMap_OnCameraMoveListenerType
    extends jni.JObjType<MapLibreMap_OnCameraMoveListener> {
  const $MapLibreMap_OnCameraMoveListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;';

  @override
  MapLibreMap_OnCameraMoveListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnCameraMoveListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnCameraMoveListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnCameraMoveListenerType) &&
        other is $MapLibreMap_OnCameraMoveListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener`
class MapLibreMap_OnCameraMoveStartedListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnCameraMoveStartedListener> $type = type;

  MapLibreMap_OnCameraMoveStartedListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCameraMoveStartedListenerType();

  /// from: `static public final int REASON_API_GESTURE`
  static const REASON_API_GESTURE = 1;

  /// from: `static public final int REASON_DEVELOPER_ANIMATION`
  static const REASON_DEVELOPER_ANIMATION = 2;

  /// from: `static public final int REASON_API_ANIMATION`
  static const REASON_API_ANIMATION = 3;
  static final _id_onCameraMoveStarted = _class.instanceMethodId(
    r'onCameraMoveStarted',
    r'(I)V',
  );

  static final _onCameraMoveStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public abstract void onCameraMoveStarted(int i)`
  void onCameraMoveStarted(
    int i,
  ) {
    _onCameraMoveStarted(
            reference.pointer, _id_onCameraMoveStarted as jni.JMethodIDPtr, i)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnCameraMoveStartedListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCameraMoveStarted(I)V') {
        _$impls[$p]!.onCameraMoveStarted(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnCameraMoveStartedListener.implement(
    $MapLibreMap_OnCameraMoveStartedListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnCameraMoveStartedListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnCameraMoveStartedListenerImpl {
  factory $MapLibreMap_OnCameraMoveStartedListenerImpl({
    required void Function(int i) onCameraMoveStarted,
  }) = _$MapLibreMap_OnCameraMoveStartedListenerImpl;

  void onCameraMoveStarted(int i);
}

class _$MapLibreMap_OnCameraMoveStartedListenerImpl
    implements $MapLibreMap_OnCameraMoveStartedListenerImpl {
  _$MapLibreMap_OnCameraMoveStartedListenerImpl({
    required void Function(int i) onCameraMoveStarted,
  }) : _onCameraMoveStarted = onCameraMoveStarted;

  final void Function(int i) _onCameraMoveStarted;

  void onCameraMoveStarted(int i) {
    return _onCameraMoveStarted(i);
  }
}

final class $MapLibreMap_OnCameraMoveStartedListenerType
    extends jni.JObjType<MapLibreMap_OnCameraMoveStartedListener> {
  const $MapLibreMap_OnCameraMoveStartedListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;';

  @override
  MapLibreMap_OnCameraMoveStartedListener fromReference(
          jni.JReference reference) =>
      MapLibreMap_OnCameraMoveStartedListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnCameraMoveStartedListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnCameraMoveStartedListenerType) &&
        other is $MapLibreMap_OnCameraMoveStartedListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnCompassAnimationListener`
class MapLibreMap_OnCompassAnimationListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnCompassAnimationListener> $type = type;

  MapLibreMap_OnCompassAnimationListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnCompassAnimationListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnCompassAnimationListenerType();
  static final _id_onCompassAnimation = _class.instanceMethodId(
    r'onCompassAnimation',
    r'()V',
  );

  static final _onCompassAnimation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCompassAnimation()`
  void onCompassAnimation() {
    _onCompassAnimation(
            reference.pointer, _id_onCompassAnimation as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCompassAnimationFinished = _class.instanceMethodId(
    r'onCompassAnimationFinished',
    r'()V',
  );

  static final _onCompassAnimationFinished = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCompassAnimationFinished()`
  void onCompassAnimationFinished() {
    _onCompassAnimationFinished(reference.pointer,
            _id_onCompassAnimationFinished as jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnCompassAnimationListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCompassAnimation()V') {
        _$impls[$p]!.onCompassAnimation();
        return jni.nullptr;
      }
      if ($d == r'onCompassAnimationFinished()V') {
        _$impls[$p]!.onCompassAnimationFinished();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnCompassAnimationListener.implement(
    $MapLibreMap_OnCompassAnimationListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnCompassAnimationListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnCompassAnimationListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnCompassAnimationListenerImpl {
  factory $MapLibreMap_OnCompassAnimationListenerImpl({
    required void Function() onCompassAnimation,
    required void Function() onCompassAnimationFinished,
  }) = _$MapLibreMap_OnCompassAnimationListenerImpl;

  void onCompassAnimation();
  void onCompassAnimationFinished();
}

class _$MapLibreMap_OnCompassAnimationListenerImpl
    implements $MapLibreMap_OnCompassAnimationListenerImpl {
  _$MapLibreMap_OnCompassAnimationListenerImpl({
    required void Function() onCompassAnimation,
    required void Function() onCompassAnimationFinished,
  })  : _onCompassAnimation = onCompassAnimation,
        _onCompassAnimationFinished = onCompassAnimationFinished;

  final void Function() _onCompassAnimation;
  final void Function() _onCompassAnimationFinished;

  void onCompassAnimation() {
    return _onCompassAnimation();
  }

  void onCompassAnimationFinished() {
    return _onCompassAnimationFinished();
  }
}

final class $MapLibreMap_OnCompassAnimationListenerType
    extends jni.JObjType<MapLibreMap_OnCompassAnimationListener> {
  const $MapLibreMap_OnCompassAnimationListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnCompassAnimationListener;';

  @override
  MapLibreMap_OnCompassAnimationListener fromReference(
          jni.JReference reference) =>
      MapLibreMap_OnCompassAnimationListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnCompassAnimationListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnCompassAnimationListenerType) &&
        other is $MapLibreMap_OnCompassAnimationListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnDeveloperAnimationListener`
class MapLibreMap_OnDeveloperAnimationListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnDeveloperAnimationListener> $type =
      type;

  MapLibreMap_OnDeveloperAnimationListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnDeveloperAnimationListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnDeveloperAnimationListenerType();
  static final _id_onDeveloperAnimationStarted = _class.instanceMethodId(
    r'onDeveloperAnimationStarted',
    r'()V',
  );

  static final _onDeveloperAnimationStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onDeveloperAnimationStarted()`
  void onDeveloperAnimationStarted() {
    _onDeveloperAnimationStarted(reference.pointer,
            _id_onDeveloperAnimationStarted as jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnDeveloperAnimationListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDeveloperAnimationStarted()V') {
        _$impls[$p]!.onDeveloperAnimationStarted();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnDeveloperAnimationListener.implement(
    $MapLibreMap_OnDeveloperAnimationListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnDeveloperAnimationListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnDeveloperAnimationListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnDeveloperAnimationListenerImpl {
  factory $MapLibreMap_OnDeveloperAnimationListenerImpl({
    required void Function() onDeveloperAnimationStarted,
  }) = _$MapLibreMap_OnDeveloperAnimationListenerImpl;

  void onDeveloperAnimationStarted();
}

class _$MapLibreMap_OnDeveloperAnimationListenerImpl
    implements $MapLibreMap_OnDeveloperAnimationListenerImpl {
  _$MapLibreMap_OnDeveloperAnimationListenerImpl({
    required void Function() onDeveloperAnimationStarted,
  }) : _onDeveloperAnimationStarted = onDeveloperAnimationStarted;

  final void Function() _onDeveloperAnimationStarted;

  void onDeveloperAnimationStarted() {
    return _onDeveloperAnimationStarted();
  }
}

final class $MapLibreMap_OnDeveloperAnimationListenerType
    extends jni.JObjType<MapLibreMap_OnDeveloperAnimationListener> {
  const $MapLibreMap_OnDeveloperAnimationListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnDeveloperAnimationListener;';

  @override
  MapLibreMap_OnDeveloperAnimationListener fromReference(
          jni.JReference reference) =>
      MapLibreMap_OnDeveloperAnimationListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnDeveloperAnimationListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnDeveloperAnimationListenerType) &&
        other is $MapLibreMap_OnDeveloperAnimationListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnFlingListener`
class MapLibreMap_OnFlingListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnFlingListener> $type = type;

  MapLibreMap_OnFlingListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnFlingListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnFlingListenerType();
  static final _id_onFling = _class.instanceMethodId(
    r'onFling',
    r'()V',
  );

  static final _onFling = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onFling()`
  void onFling() {
    _onFling(reference.pointer, _id_onFling as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnFlingListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFling()V') {
        _$impls[$p]!.onFling();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnFlingListener.implement(
    $MapLibreMap_OnFlingListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnFlingListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnFlingListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnFlingListenerImpl {
  factory $MapLibreMap_OnFlingListenerImpl({
    required void Function() onFling,
  }) = _$MapLibreMap_OnFlingListenerImpl;

  void onFling();
}

class _$MapLibreMap_OnFlingListenerImpl
    implements $MapLibreMap_OnFlingListenerImpl {
  _$MapLibreMap_OnFlingListenerImpl({
    required void Function() onFling,
  }) : _onFling = onFling;

  final void Function() _onFling;

  void onFling() {
    return _onFling();
  }
}

final class $MapLibreMap_OnFlingListenerType
    extends jni.JObjType<MapLibreMap_OnFlingListener> {
  const $MapLibreMap_OnFlingListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;';

  @override
  MapLibreMap_OnFlingListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnFlingListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnFlingListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnFlingListenerType) &&
        other is $MapLibreMap_OnFlingListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener`
class MapLibreMap_OnFpsChangedListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnFpsChangedListener> $type = type;

  MapLibreMap_OnFpsChangedListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnFpsChangedListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnFpsChangedListenerType();
  static final _id_onFpsChanged = _class.instanceMethodId(
    r'onFpsChanged',
    r'(D)V',
  );

  static final _onFpsChanged = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public abstract void onFpsChanged(double d)`
  void onFpsChanged(
    double d,
  ) {
    _onFpsChanged(reference.pointer, _id_onFpsChanged as jni.JMethodIDPtr, d)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnFpsChangedListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFpsChanged(D)V') {
        _$impls[$p]!.onFpsChanged(
          $a[0]
              .castTo(const jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnFpsChangedListener.implement(
    $MapLibreMap_OnFpsChangedListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnFpsChangedListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnFpsChangedListenerImpl {
  factory $MapLibreMap_OnFpsChangedListenerImpl({
    required void Function(double d) onFpsChanged,
  }) = _$MapLibreMap_OnFpsChangedListenerImpl;

  void onFpsChanged(double d);
}

class _$MapLibreMap_OnFpsChangedListenerImpl
    implements $MapLibreMap_OnFpsChangedListenerImpl {
  _$MapLibreMap_OnFpsChangedListenerImpl({
    required void Function(double d) onFpsChanged,
  }) : _onFpsChanged = onFpsChanged;

  final void Function(double d) _onFpsChanged;

  void onFpsChanged(double d) {
    return _onFpsChanged(d);
  }
}

final class $MapLibreMap_OnFpsChangedListenerType
    extends jni.JObjType<MapLibreMap_OnFpsChangedListener> {
  const $MapLibreMap_OnFpsChangedListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnFpsChangedListener;';

  @override
  MapLibreMap_OnFpsChangedListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnFpsChangedListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnFpsChangedListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnFpsChangedListenerType) &&
        other is $MapLibreMap_OnFpsChangedListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener`
class MapLibreMap_OnInfoWindowClickListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnInfoWindowClickListener> $type = type;

  MapLibreMap_OnInfoWindowClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnInfoWindowClickListenerType();
  static final _id_onInfoWindowClick = _class.instanceMethodId(
    r'onInfoWindowClick',
    r'(Lorg/maplibre/android/annotations/Marker;)Z',
  );

  static final _onInfoWindowClick = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract boolean onInfoWindowClick(org.maplibre.android.annotations.Marker marker)`
  bool onInfoWindowClick(
    jni.JObject marker,
  ) {
    return _onInfoWindowClick(reference.pointer,
            _id_onInfoWindowClick as jni.JMethodIDPtr, marker.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnInfoWindowClickListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowClick(Lorg/maplibre/android/annotations/Marker;)Z') {
        final $r = _$impls[$p]!.onInfoWindowClick(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnInfoWindowClickListener.implement(
    $MapLibreMap_OnInfoWindowClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnInfoWindowClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnInfoWindowClickListenerImpl {
  factory $MapLibreMap_OnInfoWindowClickListenerImpl({
    required bool Function(jni.JObject marker) onInfoWindowClick,
  }) = _$MapLibreMap_OnInfoWindowClickListenerImpl;

  bool onInfoWindowClick(jni.JObject marker);
}

class _$MapLibreMap_OnInfoWindowClickListenerImpl
    implements $MapLibreMap_OnInfoWindowClickListenerImpl {
  _$MapLibreMap_OnInfoWindowClickListenerImpl({
    required bool Function(jni.JObject marker) onInfoWindowClick,
  }) : _onInfoWindowClick = onInfoWindowClick;

  final bool Function(jni.JObject marker) _onInfoWindowClick;

  bool onInfoWindowClick(jni.JObject marker) {
    return _onInfoWindowClick(marker);
  }
}

final class $MapLibreMap_OnInfoWindowClickListenerType
    extends jni.JObjType<MapLibreMap_OnInfoWindowClickListener> {
  const $MapLibreMap_OnInfoWindowClickListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;';

  @override
  MapLibreMap_OnInfoWindowClickListener fromReference(
          jni.JReference reference) =>
      MapLibreMap_OnInfoWindowClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnInfoWindowClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnInfoWindowClickListenerType) &&
        other is $MapLibreMap_OnInfoWindowClickListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener`
class MapLibreMap_OnInfoWindowCloseListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnInfoWindowCloseListener> $type = type;

  MapLibreMap_OnInfoWindowCloseListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnInfoWindowCloseListenerType();
  static final _id_onInfoWindowClose = _class.instanceMethodId(
    r'onInfoWindowClose',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _onInfoWindowClose = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onInfoWindowClose(org.maplibre.android.annotations.Marker marker)`
  void onInfoWindowClose(
    jni.JObject marker,
  ) {
    _onInfoWindowClose(reference.pointer,
            _id_onInfoWindowClose as jni.JMethodIDPtr, marker.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnInfoWindowCloseListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowClose(Lorg/maplibre/android/annotations/Marker;)V') {
        _$impls[$p]!.onInfoWindowClose(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnInfoWindowCloseListener.implement(
    $MapLibreMap_OnInfoWindowCloseListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnInfoWindowCloseListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnInfoWindowCloseListenerImpl {
  factory $MapLibreMap_OnInfoWindowCloseListenerImpl({
    required void Function(jni.JObject marker) onInfoWindowClose,
  }) = _$MapLibreMap_OnInfoWindowCloseListenerImpl;

  void onInfoWindowClose(jni.JObject marker);
}

class _$MapLibreMap_OnInfoWindowCloseListenerImpl
    implements $MapLibreMap_OnInfoWindowCloseListenerImpl {
  _$MapLibreMap_OnInfoWindowCloseListenerImpl({
    required void Function(jni.JObject marker) onInfoWindowClose,
  }) : _onInfoWindowClose = onInfoWindowClose;

  final void Function(jni.JObject marker) _onInfoWindowClose;

  void onInfoWindowClose(jni.JObject marker) {
    return _onInfoWindowClose(marker);
  }
}

final class $MapLibreMap_OnInfoWindowCloseListenerType
    extends jni.JObjType<MapLibreMap_OnInfoWindowCloseListener> {
  const $MapLibreMap_OnInfoWindowCloseListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;';

  @override
  MapLibreMap_OnInfoWindowCloseListener fromReference(
          jni.JReference reference) =>
      MapLibreMap_OnInfoWindowCloseListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnInfoWindowCloseListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnInfoWindowCloseListenerType) &&
        other is $MapLibreMap_OnInfoWindowCloseListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener`
class MapLibreMap_OnInfoWindowLongClickListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnInfoWindowLongClickListener> $type =
      type;

  MapLibreMap_OnInfoWindowLongClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnInfoWindowLongClickListenerType();
  static final _id_onInfoWindowLongClick = _class.instanceMethodId(
    r'onInfoWindowLongClick',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _onInfoWindowLongClick = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onInfoWindowLongClick(org.maplibre.android.annotations.Marker marker)`
  void onInfoWindowLongClick(
    jni.JObject marker,
  ) {
    _onInfoWindowLongClick(
            reference.pointer,
            _id_onInfoWindowLongClick as jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnInfoWindowLongClickListenerImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onInfoWindowLongClick(Lorg/maplibre/android/annotations/Marker;)V') {
        _$impls[$p]!.onInfoWindowLongClick(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnInfoWindowLongClickListener.implement(
    $MapLibreMap_OnInfoWindowLongClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnInfoWindowLongClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnInfoWindowLongClickListenerImpl {
  factory $MapLibreMap_OnInfoWindowLongClickListenerImpl({
    required void Function(jni.JObject marker) onInfoWindowLongClick,
  }) = _$MapLibreMap_OnInfoWindowLongClickListenerImpl;

  void onInfoWindowLongClick(jni.JObject marker);
}

class _$MapLibreMap_OnInfoWindowLongClickListenerImpl
    implements $MapLibreMap_OnInfoWindowLongClickListenerImpl {
  _$MapLibreMap_OnInfoWindowLongClickListenerImpl({
    required void Function(jni.JObject marker) onInfoWindowLongClick,
  }) : _onInfoWindowLongClick = onInfoWindowLongClick;

  final void Function(jni.JObject marker) _onInfoWindowLongClick;

  void onInfoWindowLongClick(jni.JObject marker) {
    return _onInfoWindowLongClick(marker);
  }
}

final class $MapLibreMap_OnInfoWindowLongClickListenerType
    extends jni.JObjType<MapLibreMap_OnInfoWindowLongClickListener> {
  const $MapLibreMap_OnInfoWindowLongClickListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;';

  @override
  MapLibreMap_OnInfoWindowLongClickListener fromReference(
          jni.JReference reference) =>
      MapLibreMap_OnInfoWindowLongClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnInfoWindowLongClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MapLibreMap_OnInfoWindowLongClickListenerType) &&
        other is $MapLibreMap_OnInfoWindowLongClickListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMapClickListener`
class MapLibreMap_OnMapClickListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnMapClickListener> $type = type;

  MapLibreMap_OnMapClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnMapClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnMapClickListenerType();
  static final _id_onMapClick = _class.instanceMethodId(
    r'onMapClick',
    r'(Lorg/maplibre/android/geometry/LatLng;)Z',
  );

  static final _onMapClick = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract boolean onMapClick(org.maplibre.android.geometry.LatLng latLng)`
  bool onMapClick(
    latlng_.LatLng latLng,
  ) {
    return _onMapClick(reference.pointer, _id_onMapClick as jni.JMethodIDPtr,
            latLng.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnMapClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMapClick(Lorg/maplibre/android/geometry/LatLng;)Z') {
        final $r = _$impls[$p]!.onMapClick(
          $a[0].castTo(const latlng_.$LatLngType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnMapClickListener.implement(
    $MapLibreMap_OnMapClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnMapClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnMapClickListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnMapClickListenerImpl {
  factory $MapLibreMap_OnMapClickListenerImpl({
    required bool Function(latlng_.LatLng latLng) onMapClick,
  }) = _$MapLibreMap_OnMapClickListenerImpl;

  bool onMapClick(latlng_.LatLng latLng);
}

class _$MapLibreMap_OnMapClickListenerImpl
    implements $MapLibreMap_OnMapClickListenerImpl {
  _$MapLibreMap_OnMapClickListenerImpl({
    required bool Function(latlng_.LatLng latLng) onMapClick,
  }) : _onMapClick = onMapClick;

  final bool Function(latlng_.LatLng latLng) _onMapClick;

  bool onMapClick(latlng_.LatLng latLng) {
    return _onMapClick(latLng);
  }
}

final class $MapLibreMap_OnMapClickListenerType
    extends jni.JObjType<MapLibreMap_OnMapClickListener> {
  const $MapLibreMap_OnMapClickListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;';

  @override
  MapLibreMap_OnMapClickListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnMapClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnMapClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnMapClickListenerType) &&
        other is $MapLibreMap_OnMapClickListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener`
class MapLibreMap_OnMapLongClickListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnMapLongClickListener> $type = type;

  MapLibreMap_OnMapLongClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnMapLongClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnMapLongClickListenerType();
  static final _id_onMapLongClick = _class.instanceMethodId(
    r'onMapLongClick',
    r'(Lorg/maplibre/android/geometry/LatLng;)Z',
  );

  static final _onMapLongClick = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract boolean onMapLongClick(org.maplibre.android.geometry.LatLng latLng)`
  bool onMapLongClick(
    latlng_.LatLng latLng,
  ) {
    return _onMapLongClick(reference.pointer,
            _id_onMapLongClick as jni.JMethodIDPtr, latLng.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnMapLongClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMapLongClick(Lorg/maplibre/android/geometry/LatLng;)Z') {
        final $r = _$impls[$p]!.onMapLongClick(
          $a[0].castTo(const latlng_.$LatLngType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnMapLongClickListener.implement(
    $MapLibreMap_OnMapLongClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnMapLongClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnMapLongClickListenerImpl {
  factory $MapLibreMap_OnMapLongClickListenerImpl({
    required bool Function(latlng_.LatLng latLng) onMapLongClick,
  }) = _$MapLibreMap_OnMapLongClickListenerImpl;

  bool onMapLongClick(latlng_.LatLng latLng);
}

class _$MapLibreMap_OnMapLongClickListenerImpl
    implements $MapLibreMap_OnMapLongClickListenerImpl {
  _$MapLibreMap_OnMapLongClickListenerImpl({
    required bool Function(latlng_.LatLng latLng) onMapLongClick,
  }) : _onMapLongClick = onMapLongClick;

  final bool Function(latlng_.LatLng latLng) _onMapLongClick;

  bool onMapLongClick(latlng_.LatLng latLng) {
    return _onMapLongClick(latLng);
  }
}

final class $MapLibreMap_OnMapLongClickListenerType
    extends jni.JObjType<MapLibreMap_OnMapLongClickListener> {
  const $MapLibreMap_OnMapLongClickListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;';

  @override
  MapLibreMap_OnMapLongClickListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnMapLongClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnMapLongClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnMapLongClickListenerType) &&
        other is $MapLibreMap_OnMapLongClickListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener`
class MapLibreMap_OnMarkerClickListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnMarkerClickListener> $type = type;

  MapLibreMap_OnMarkerClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnMarkerClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnMarkerClickListenerType();
  static final _id_onMarkerClick = _class.instanceMethodId(
    r'onMarkerClick',
    r'(Lorg/maplibre/android/annotations/Marker;)Z',
  );

  static final _onMarkerClick = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract boolean onMarkerClick(org.maplibre.android.annotations.Marker marker)`
  bool onMarkerClick(
    jni.JObject marker,
  ) {
    return _onMarkerClick(reference.pointer,
            _id_onMarkerClick as jni.JMethodIDPtr, marker.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnMarkerClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMarkerClick(Lorg/maplibre/android/annotations/Marker;)Z') {
        final $r = _$impls[$p]!.onMarkerClick(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnMarkerClickListener.implement(
    $MapLibreMap_OnMarkerClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnMarkerClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnMarkerClickListenerImpl {
  factory $MapLibreMap_OnMarkerClickListenerImpl({
    required bool Function(jni.JObject marker) onMarkerClick,
  }) = _$MapLibreMap_OnMarkerClickListenerImpl;

  bool onMarkerClick(jni.JObject marker);
}

class _$MapLibreMap_OnMarkerClickListenerImpl
    implements $MapLibreMap_OnMarkerClickListenerImpl {
  _$MapLibreMap_OnMarkerClickListenerImpl({
    required bool Function(jni.JObject marker) onMarkerClick,
  }) : _onMarkerClick = onMarkerClick;

  final bool Function(jni.JObject marker) _onMarkerClick;

  bool onMarkerClick(jni.JObject marker) {
    return _onMarkerClick(marker);
  }
}

final class $MapLibreMap_OnMarkerClickListenerType
    extends jni.JObjType<MapLibreMap_OnMarkerClickListener> {
  const $MapLibreMap_OnMarkerClickListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMarkerClickListener;';

  @override
  MapLibreMap_OnMarkerClickListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnMarkerClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnMarkerClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnMarkerClickListenerType) &&
        other is $MapLibreMap_OnMarkerClickListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnMoveListener`
class MapLibreMap_OnMoveListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnMoveListener> $type = type;

  MapLibreMap_OnMoveListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnMoveListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnMoveListenerType();
  static final _id_onMoveBegin = _class.instanceMethodId(
    r'onMoveBegin',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMoveBegin = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onMoveBegin(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMoveBegin(
    jni.JObject moveGestureDetector,
  ) {
    _onMoveBegin(reference.pointer, _id_onMoveBegin as jni.JMethodIDPtr,
            moveGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onMove = _class.instanceMethodId(
    r'onMove',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMove = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onMove(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMove(
    jni.JObject moveGestureDetector,
  ) {
    _onMove(reference.pointer, _id_onMove as jni.JMethodIDPtr,
            moveGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onMoveEnd = _class.instanceMethodId(
    r'onMoveEnd',
    r'(Lorg/maplibre/android/gestures/MoveGestureDetector;)V',
  );

  static final _onMoveEnd = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onMoveEnd(org.maplibre.android.gestures.MoveGestureDetector moveGestureDetector)`
  void onMoveEnd(
    jni.JObject moveGestureDetector,
  ) {
    _onMoveEnd(reference.pointer, _id_onMoveEnd as jni.JMethodIDPtr,
            moveGestureDetector.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnMoveListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onMoveBegin(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMoveBegin(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onMove(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMove(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onMoveEnd(Lorg/maplibre/android/gestures/MoveGestureDetector;)V') {
        _$impls[$p]!.onMoveEnd(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnMoveListener.implement(
    $MapLibreMap_OnMoveListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnMoveListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnMoveListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnMoveListenerImpl {
  factory $MapLibreMap_OnMoveListenerImpl({
    required void Function(jni.JObject moveGestureDetector) onMoveBegin,
    required void Function(jni.JObject moveGestureDetector) onMove,
    required void Function(jni.JObject moveGestureDetector) onMoveEnd,
  }) = _$MapLibreMap_OnMoveListenerImpl;

  void onMoveBegin(jni.JObject moveGestureDetector);
  void onMove(jni.JObject moveGestureDetector);
  void onMoveEnd(jni.JObject moveGestureDetector);
}

class _$MapLibreMap_OnMoveListenerImpl
    implements $MapLibreMap_OnMoveListenerImpl {
  _$MapLibreMap_OnMoveListenerImpl({
    required void Function(jni.JObject moveGestureDetector) onMoveBegin,
    required void Function(jni.JObject moveGestureDetector) onMove,
    required void Function(jni.JObject moveGestureDetector) onMoveEnd,
  })  : _onMoveBegin = onMoveBegin,
        _onMove = onMove,
        _onMoveEnd = onMoveEnd;

  final void Function(jni.JObject moveGestureDetector) _onMoveBegin;
  final void Function(jni.JObject moveGestureDetector) _onMove;
  final void Function(jni.JObject moveGestureDetector) _onMoveEnd;

  void onMoveBegin(jni.JObject moveGestureDetector) {
    return _onMoveBegin(moveGestureDetector);
  }

  void onMove(jni.JObject moveGestureDetector) {
    return _onMove(moveGestureDetector);
  }

  void onMoveEnd(jni.JObject moveGestureDetector) {
    return _onMoveEnd(moveGestureDetector);
  }
}

final class $MapLibreMap_OnMoveListenerType
    extends jni.JObjType<MapLibreMap_OnMoveListener> {
  const $MapLibreMap_OnMoveListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;';

  @override
  MapLibreMap_OnMoveListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnMoveListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnMoveListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnMoveListenerType) &&
        other is $MapLibreMap_OnMoveListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener`
class MapLibreMap_OnPolygonClickListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnPolygonClickListener> $type = type;

  MapLibreMap_OnPolygonClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnPolygonClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnPolygonClickListenerType();
  static final _id_onPolygonClick = _class.instanceMethodId(
    r'onPolygonClick',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _onPolygonClick = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onPolygonClick(org.maplibre.android.annotations.Polygon polygon)`
  void onPolygonClick(
    jni.JObject polygon,
  ) {
    _onPolygonClick(reference.pointer, _id_onPolygonClick as jni.JMethodIDPtr,
            polygon.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnPolygonClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onPolygonClick(Lorg/maplibre/android/annotations/Polygon;)V') {
        _$impls[$p]!.onPolygonClick(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnPolygonClickListener.implement(
    $MapLibreMap_OnPolygonClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnPolygonClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnPolygonClickListenerImpl {
  factory $MapLibreMap_OnPolygonClickListenerImpl({
    required void Function(jni.JObject polygon) onPolygonClick,
  }) = _$MapLibreMap_OnPolygonClickListenerImpl;

  void onPolygonClick(jni.JObject polygon);
}

class _$MapLibreMap_OnPolygonClickListenerImpl
    implements $MapLibreMap_OnPolygonClickListenerImpl {
  _$MapLibreMap_OnPolygonClickListenerImpl({
    required void Function(jni.JObject polygon) onPolygonClick,
  }) : _onPolygonClick = onPolygonClick;

  final void Function(jni.JObject polygon) _onPolygonClick;

  void onPolygonClick(jni.JObject polygon) {
    return _onPolygonClick(polygon);
  }
}

final class $MapLibreMap_OnPolygonClickListenerType
    extends jni.JObjType<MapLibreMap_OnPolygonClickListener> {
  const $MapLibreMap_OnPolygonClickListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnPolygonClickListener;';

  @override
  MapLibreMap_OnPolygonClickListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnPolygonClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnPolygonClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnPolygonClickListenerType) &&
        other is $MapLibreMap_OnPolygonClickListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener`
class MapLibreMap_OnPolylineClickListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnPolylineClickListener> $type = type;

  MapLibreMap_OnPolylineClickListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnPolylineClickListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnPolylineClickListenerType();
  static final _id_onPolylineClick = _class.instanceMethodId(
    r'onPolylineClick',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _onPolylineClick = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onPolylineClick(org.maplibre.android.annotations.Polyline polyline)`
  void onPolylineClick(
    jni.JObject polyline,
  ) {
    _onPolylineClick(reference.pointer, _id_onPolylineClick as jni.JMethodIDPtr,
            polyline.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnPolylineClickListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onPolylineClick(Lorg/maplibre/android/annotations/Polyline;)V') {
        _$impls[$p]!.onPolylineClick(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnPolylineClickListener.implement(
    $MapLibreMap_OnPolylineClickListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnPolylineClickListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnPolylineClickListenerImpl {
  factory $MapLibreMap_OnPolylineClickListenerImpl({
    required void Function(jni.JObject polyline) onPolylineClick,
  }) = _$MapLibreMap_OnPolylineClickListenerImpl;

  void onPolylineClick(jni.JObject polyline);
}

class _$MapLibreMap_OnPolylineClickListenerImpl
    implements $MapLibreMap_OnPolylineClickListenerImpl {
  _$MapLibreMap_OnPolylineClickListenerImpl({
    required void Function(jni.JObject polyline) onPolylineClick,
  }) : _onPolylineClick = onPolylineClick;

  final void Function(jni.JObject polyline) _onPolylineClick;

  void onPolylineClick(jni.JObject polyline) {
    return _onPolylineClick(polyline);
  }
}

final class $MapLibreMap_OnPolylineClickListenerType
    extends jni.JObjType<MapLibreMap_OnPolylineClickListener> {
  const $MapLibreMap_OnPolylineClickListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnPolylineClickListener;';

  @override
  MapLibreMap_OnPolylineClickListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnPolylineClickListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnPolylineClickListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnPolylineClickListenerType) &&
        other is $MapLibreMap_OnPolylineClickListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnRotateListener`
class MapLibreMap_OnRotateListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnRotateListener> $type = type;

  MapLibreMap_OnRotateListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnRotateListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnRotateListenerType();
  static final _id_onRotateBegin = _class.instanceMethodId(
    r'onRotateBegin',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotateBegin = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onRotateBegin(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotateBegin(
    jni.JObject rotateGestureDetector,
  ) {
    _onRotateBegin(reference.pointer, _id_onRotateBegin as jni.JMethodIDPtr,
            rotateGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onRotate = _class.instanceMethodId(
    r'onRotate',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onRotate(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotate(
    jni.JObject rotateGestureDetector,
  ) {
    _onRotate(reference.pointer, _id_onRotate as jni.JMethodIDPtr,
            rotateGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onRotateEnd = _class.instanceMethodId(
    r'onRotateEnd',
    r'(Lorg/maplibre/android/gestures/RotateGestureDetector;)V',
  );

  static final _onRotateEnd = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onRotateEnd(org.maplibre.android.gestures.RotateGestureDetector rotateGestureDetector)`
  void onRotateEnd(
    jni.JObject rotateGestureDetector,
  ) {
    _onRotateEnd(reference.pointer, _id_onRotateEnd as jni.JMethodIDPtr,
            rotateGestureDetector.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnRotateListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onRotateBegin(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotateBegin(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onRotate(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotate(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onRotateEnd(Lorg/maplibre/android/gestures/RotateGestureDetector;)V') {
        _$impls[$p]!.onRotateEnd(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnRotateListener.implement(
    $MapLibreMap_OnRotateListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnRotateListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnRotateListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnRotateListenerImpl {
  factory $MapLibreMap_OnRotateListenerImpl({
    required void Function(jni.JObject rotateGestureDetector) onRotateBegin,
    required void Function(jni.JObject rotateGestureDetector) onRotate,
    required void Function(jni.JObject rotateGestureDetector) onRotateEnd,
  }) = _$MapLibreMap_OnRotateListenerImpl;

  void onRotateBegin(jni.JObject rotateGestureDetector);
  void onRotate(jni.JObject rotateGestureDetector);
  void onRotateEnd(jni.JObject rotateGestureDetector);
}

class _$MapLibreMap_OnRotateListenerImpl
    implements $MapLibreMap_OnRotateListenerImpl {
  _$MapLibreMap_OnRotateListenerImpl({
    required void Function(jni.JObject rotateGestureDetector) onRotateBegin,
    required void Function(jni.JObject rotateGestureDetector) onRotate,
    required void Function(jni.JObject rotateGestureDetector) onRotateEnd,
  })  : _onRotateBegin = onRotateBegin,
        _onRotate = onRotate,
        _onRotateEnd = onRotateEnd;

  final void Function(jni.JObject rotateGestureDetector) _onRotateBegin;
  final void Function(jni.JObject rotateGestureDetector) _onRotate;
  final void Function(jni.JObject rotateGestureDetector) _onRotateEnd;

  void onRotateBegin(jni.JObject rotateGestureDetector) {
    return _onRotateBegin(rotateGestureDetector);
  }

  void onRotate(jni.JObject rotateGestureDetector) {
    return _onRotate(rotateGestureDetector);
  }

  void onRotateEnd(jni.JObject rotateGestureDetector) {
    return _onRotateEnd(rotateGestureDetector);
  }
}

final class $MapLibreMap_OnRotateListenerType
    extends jni.JObjType<MapLibreMap_OnRotateListener> {
  const $MapLibreMap_OnRotateListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;';

  @override
  MapLibreMap_OnRotateListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnRotateListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnRotateListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnRotateListenerType) &&
        other is $MapLibreMap_OnRotateListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnScaleListener`
class MapLibreMap_OnScaleListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnScaleListener> $type = type;

  MapLibreMap_OnScaleListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnScaleListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnScaleListenerType();
  static final _id_onScaleBegin = _class.instanceMethodId(
    r'onScaleBegin',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScaleBegin = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onScaleBegin(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScaleBegin(
    jni.JObject standardScaleGestureDetector,
  ) {
    _onScaleBegin(reference.pointer, _id_onScaleBegin as jni.JMethodIDPtr,
            standardScaleGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onScale = _class.instanceMethodId(
    r'onScale',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScale = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onScale(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScale(
    jni.JObject standardScaleGestureDetector,
  ) {
    _onScale(reference.pointer, _id_onScale as jni.JMethodIDPtr,
            standardScaleGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onScaleEnd = _class.instanceMethodId(
    r'onScaleEnd',
    r'(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V',
  );

  static final _onScaleEnd = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onScaleEnd(org.maplibre.android.gestures.StandardScaleGestureDetector standardScaleGestureDetector)`
  void onScaleEnd(
    jni.JObject standardScaleGestureDetector,
  ) {
    _onScaleEnd(reference.pointer, _id_onScaleEnd as jni.JMethodIDPtr,
            standardScaleGestureDetector.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnScaleListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onScaleBegin(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScaleBegin(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onScale(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScale(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onScaleEnd(Lorg/maplibre/android/gestures/StandardScaleGestureDetector;)V') {
        _$impls[$p]!.onScaleEnd(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnScaleListener.implement(
    $MapLibreMap_OnScaleListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnScaleListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnScaleListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnScaleListenerImpl {
  factory $MapLibreMap_OnScaleListenerImpl({
    required void Function(jni.JObject standardScaleGestureDetector)
        onScaleBegin,
    required void Function(jni.JObject standardScaleGestureDetector) onScale,
    required void Function(jni.JObject standardScaleGestureDetector) onScaleEnd,
  }) = _$MapLibreMap_OnScaleListenerImpl;

  void onScaleBegin(jni.JObject standardScaleGestureDetector);
  void onScale(jni.JObject standardScaleGestureDetector);
  void onScaleEnd(jni.JObject standardScaleGestureDetector);
}

class _$MapLibreMap_OnScaleListenerImpl
    implements $MapLibreMap_OnScaleListenerImpl {
  _$MapLibreMap_OnScaleListenerImpl({
    required void Function(jni.JObject standardScaleGestureDetector)
        onScaleBegin,
    required void Function(jni.JObject standardScaleGestureDetector) onScale,
    required void Function(jni.JObject standardScaleGestureDetector) onScaleEnd,
  })  : _onScaleBegin = onScaleBegin,
        _onScale = onScale,
        _onScaleEnd = onScaleEnd;

  final void Function(jni.JObject standardScaleGestureDetector) _onScaleBegin;
  final void Function(jni.JObject standardScaleGestureDetector) _onScale;
  final void Function(jni.JObject standardScaleGestureDetector) _onScaleEnd;

  void onScaleBegin(jni.JObject standardScaleGestureDetector) {
    return _onScaleBegin(standardScaleGestureDetector);
  }

  void onScale(jni.JObject standardScaleGestureDetector) {
    return _onScale(standardScaleGestureDetector);
  }

  void onScaleEnd(jni.JObject standardScaleGestureDetector) {
    return _onScaleEnd(standardScaleGestureDetector);
  }
}

final class $MapLibreMap_OnScaleListenerType
    extends jni.JObjType<MapLibreMap_OnScaleListener> {
  const $MapLibreMap_OnScaleListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;';

  @override
  MapLibreMap_OnScaleListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnScaleListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnScaleListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnScaleListenerType) &&
        other is $MapLibreMap_OnScaleListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$OnShoveListener`
class MapLibreMap_OnShoveListener extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_OnShoveListener> $type = type;

  MapLibreMap_OnShoveListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$OnShoveListener');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_OnShoveListenerType();
  static final _id_onShoveBegin = _class.instanceMethodId(
    r'onShoveBegin',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShoveBegin = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onShoveBegin(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShoveBegin(
    jni.JObject shoveGestureDetector,
  ) {
    _onShoveBegin(reference.pointer, _id_onShoveBegin as jni.JMethodIDPtr,
            shoveGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onShove = _class.instanceMethodId(
    r'onShove',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShove = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onShove(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShove(
    jni.JObject shoveGestureDetector,
  ) {
    _onShove(reference.pointer, _id_onShove as jni.JMethodIDPtr,
            shoveGestureDetector.reference.pointer)
        .check();
  }

  static final _id_onShoveEnd = _class.instanceMethodId(
    r'onShoveEnd',
    r'(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V',
  );

  static final _onShoveEnd = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onShoveEnd(org.maplibre.android.gestures.ShoveGestureDetector shoveGestureDetector)`
  void onShoveEnd(
    jni.JObject shoveGestureDetector,
  ) {
    _onShoveEnd(reference.pointer, _id_onShoveEnd as jni.JMethodIDPtr,
            shoveGestureDetector.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_OnShoveListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onShoveBegin(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShoveBegin(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onShove(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShove(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onShoveEnd(Lorg/maplibre/android/gestures/ShoveGestureDetector;)V') {
        _$impls[$p]!.onShoveEnd(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_OnShoveListener.implement(
    $MapLibreMap_OnShoveListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_OnShoveListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$OnShoveListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_OnShoveListenerImpl {
  factory $MapLibreMap_OnShoveListenerImpl({
    required void Function(jni.JObject shoveGestureDetector) onShoveBegin,
    required void Function(jni.JObject shoveGestureDetector) onShove,
    required void Function(jni.JObject shoveGestureDetector) onShoveEnd,
  }) = _$MapLibreMap_OnShoveListenerImpl;

  void onShoveBegin(jni.JObject shoveGestureDetector);
  void onShove(jni.JObject shoveGestureDetector);
  void onShoveEnd(jni.JObject shoveGestureDetector);
}

class _$MapLibreMap_OnShoveListenerImpl
    implements $MapLibreMap_OnShoveListenerImpl {
  _$MapLibreMap_OnShoveListenerImpl({
    required void Function(jni.JObject shoveGestureDetector) onShoveBegin,
    required void Function(jni.JObject shoveGestureDetector) onShove,
    required void Function(jni.JObject shoveGestureDetector) onShoveEnd,
  })  : _onShoveBegin = onShoveBegin,
        _onShove = onShove,
        _onShoveEnd = onShoveEnd;

  final void Function(jni.JObject shoveGestureDetector) _onShoveBegin;
  final void Function(jni.JObject shoveGestureDetector) _onShove;
  final void Function(jni.JObject shoveGestureDetector) _onShoveEnd;

  void onShoveBegin(jni.JObject shoveGestureDetector) {
    return _onShoveBegin(shoveGestureDetector);
  }

  void onShove(jni.JObject shoveGestureDetector) {
    return _onShove(shoveGestureDetector);
  }

  void onShoveEnd(jni.JObject shoveGestureDetector) {
    return _onShoveEnd(shoveGestureDetector);
  }
}

final class $MapLibreMap_OnShoveListenerType
    extends jni.JObjType<MapLibreMap_OnShoveListener> {
  const $MapLibreMap_OnShoveListenerType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;';

  @override
  MapLibreMap_OnShoveListener fromReference(jni.JReference reference) =>
      MapLibreMap_OnShoveListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_OnShoveListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_OnShoveListenerType) &&
        other is $MapLibreMap_OnShoveListenerType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback`
class MapLibreMap_SnapshotReadyCallback extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap_SnapshotReadyCallback> $type = type;

  MapLibreMap_SnapshotReadyCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMap_SnapshotReadyCallbackType();
  static final _id_onSnapshotReady = _class.instanceMethodId(
    r'onSnapshotReady',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onSnapshotReady = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onSnapshotReady(android.graphics.Bitmap bitmap)`
  void onSnapshotReady(
    jni.JObject bitmap,
  ) {
    _onSnapshotReady(reference.pointer, _id_onSnapshotReady as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MapLibreMap_SnapshotReadyCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSnapshotReady(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onSnapshotReady(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MapLibreMap_SnapshotReadyCallback.implement(
    $MapLibreMap_SnapshotReadyCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MapLibreMap_SnapshotReadyCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MapLibreMap_SnapshotReadyCallbackImpl {
  factory $MapLibreMap_SnapshotReadyCallbackImpl({
    required void Function(jni.JObject bitmap) onSnapshotReady,
  }) = _$MapLibreMap_SnapshotReadyCallbackImpl;

  void onSnapshotReady(jni.JObject bitmap);
}

class _$MapLibreMap_SnapshotReadyCallbackImpl
    implements $MapLibreMap_SnapshotReadyCallbackImpl {
  _$MapLibreMap_SnapshotReadyCallbackImpl({
    required void Function(jni.JObject bitmap) onSnapshotReady,
  }) : _onSnapshotReady = onSnapshotReady;

  final void Function(jni.JObject bitmap) _onSnapshotReady;

  void onSnapshotReady(jni.JObject bitmap) {
    return _onSnapshotReady(bitmap);
  }
}

final class $MapLibreMap_SnapshotReadyCallbackType
    extends jni.JObjType<MapLibreMap_SnapshotReadyCallback> {
  const $MapLibreMap_SnapshotReadyCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback;';

  @override
  MapLibreMap_SnapshotReadyCallback fromReference(jni.JReference reference) =>
      MapLibreMap_SnapshotReadyCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMap_SnapshotReadyCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMap_SnapshotReadyCallbackType) &&
        other is $MapLibreMap_SnapshotReadyCallbackType;
  }
}

/// from: `org.maplibre.android.maps.MapLibreMap`
class MapLibreMap extends jni.JObject {
  @override
  late final jni.JObjType<MapLibreMap> $type = type;

  MapLibreMap.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/maps/MapLibreMap');

  /// The type which includes information such as the signature of this class.
  static const type = $MapLibreMapType();
  static final _id_triggerRepaint = _class.instanceMethodId(
    r'triggerRepaint',
    r'()V',
  );

  static final _triggerRepaint = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void triggerRepaint()`
  void triggerRepaint() {
    _triggerRepaint(reference.pointer, _id_triggerRepaint as jni.JMethodIDPtr)
        .check();
  }

  static final _id_setSwapBehaviorFlush = _class.instanceMethodId(
    r'setSwapBehaviorFlush',
    r'(Z)V',
  );

  static final _setSwapBehaviorFlush = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setSwapBehaviorFlush(boolean z)`
  void setSwapBehaviorFlush(
    bool z,
  ) {
    _setSwapBehaviorFlush(reference.pointer,
            _id_setSwapBehaviorFlush as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getStyle = _class.instanceMethodId(
    r'getStyle',
    r'(Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _getStyle = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void getStyle(org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void getStyle(
    style_.Style_OnStyleLoaded onStyleLoaded,
  ) {
    _getStyle(reference.pointer, _id_getStyle as jni.JMethodIDPtr,
            onStyleLoaded.reference.pointer)
        .check();
  }

  static final _id_getStyle1 = _class.instanceMethodId(
    r'getStyle',
    r'()Lorg/maplibre/android/maps/Style;',
  );

  static final _getStyle1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.Style getStyle()`
  /// The returned object must be released after use, by calling the [release] method.
  style_.Style getStyle1() {
    return _getStyle1(reference.pointer, _id_getStyle1 as jni.JMethodIDPtr)
        .object(const style_.$StyleType());
  }

  static final _id_setPrefetchesTiles = _class.instanceMethodId(
    r'setPrefetchesTiles',
    r'(Z)V',
  );

  static final _setPrefetchesTiles = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setPrefetchesTiles(boolean z)`
  void setPrefetchesTiles(
    bool z,
  ) {
    _setPrefetchesTiles(reference.pointer,
            _id_setPrefetchesTiles as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getPrefetchesTiles = _class.instanceMethodId(
    r'getPrefetchesTiles',
    r'()Z',
  );

  static final _getPrefetchesTiles = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getPrefetchesTiles()`
  bool getPrefetchesTiles() {
    return _getPrefetchesTiles(
            reference.pointer, _id_getPrefetchesTiles as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPrefetchZoomDelta = _class.instanceMethodId(
    r'setPrefetchZoomDelta',
    r'(I)V',
  );

  static final _setPrefetchZoomDelta = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setPrefetchZoomDelta(int i)`
  void setPrefetchZoomDelta(
    int i,
  ) {
    _setPrefetchZoomDelta(
            reference.pointer, _id_setPrefetchZoomDelta as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getPrefetchZoomDelta = _class.instanceMethodId(
    r'getPrefetchZoomDelta',
    r'()I',
  );

  static final _getPrefetchZoomDelta = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getPrefetchZoomDelta()`
  int getPrefetchZoomDelta() {
    return _getPrefetchZoomDelta(
            reference.pointer, _id_getPrefetchZoomDelta as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setTileCacheEnabled = _class.instanceMethodId(
    r'setTileCacheEnabled',
    r'(Z)V',
  );

  static final _setTileCacheEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setTileCacheEnabled(boolean z)`
  void setTileCacheEnabled(
    bool z,
  ) {
    _setTileCacheEnabled(reference.pointer,
            _id_setTileCacheEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getTileCacheEnabled = _class.instanceMethodId(
    r'getTileCacheEnabled',
    r'()Z',
  );

  static final _getTileCacheEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getTileCacheEnabled()`
  bool getTileCacheEnabled() {
    return _getTileCacheEnabled(
            reference.pointer, _id_getTileCacheEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setMinZoomPreference = _class.instanceMethodId(
    r'setMinZoomPreference',
    r'(D)V',
  );

  static final _setMinZoomPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void setMinZoomPreference(double d)`
  void setMinZoomPreference(
    double d,
  ) {
    _setMinZoomPreference(
            reference.pointer, _id_setMinZoomPreference as jni.JMethodIDPtr, d)
        .check();
  }

  static final _id_getMinZoomLevel = _class.instanceMethodId(
    r'getMinZoomLevel',
    r'()D',
  );

  static final _getMinZoomLevel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public double getMinZoomLevel()`
  double getMinZoomLevel() {
    return _getMinZoomLevel(
            reference.pointer, _id_getMinZoomLevel as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_setMaxZoomPreference = _class.instanceMethodId(
    r'setMaxZoomPreference',
    r'(D)V',
  );

  static final _setMaxZoomPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void setMaxZoomPreference(double d)`
  void setMaxZoomPreference(
    double d,
  ) {
    _setMaxZoomPreference(
            reference.pointer, _id_setMaxZoomPreference as jni.JMethodIDPtr, d)
        .check();
  }

  static final _id_getMaxZoomLevel = _class.instanceMethodId(
    r'getMaxZoomLevel',
    r'()D',
  );

  static final _getMaxZoomLevel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public double getMaxZoomLevel()`
  double getMaxZoomLevel() {
    return _getMaxZoomLevel(
            reference.pointer, _id_getMaxZoomLevel as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_setMinPitchPreference = _class.instanceMethodId(
    r'setMinPitchPreference',
    r'(D)V',
  );

  static final _setMinPitchPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void setMinPitchPreference(double d)`
  void setMinPitchPreference(
    double d,
  ) {
    _setMinPitchPreference(
            reference.pointer, _id_setMinPitchPreference as jni.JMethodIDPtr, d)
        .check();
  }

  static final _id_getMinPitch = _class.instanceMethodId(
    r'getMinPitch',
    r'()D',
  );

  static final _getMinPitch = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public double getMinPitch()`
  double getMinPitch() {
    return _getMinPitch(reference.pointer, _id_getMinPitch as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_setMaxPitchPreference = _class.instanceMethodId(
    r'setMaxPitchPreference',
    r'(D)V',
  );

  static final _setMaxPitchPreference = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void setMaxPitchPreference(double d)`
  void setMaxPitchPreference(
    double d,
  ) {
    _setMaxPitchPreference(
            reference.pointer, _id_setMaxPitchPreference as jni.JMethodIDPtr, d)
        .check();
  }

  static final _id_getMaxPitch = _class.instanceMethodId(
    r'getMaxPitch',
    r'()D',
  );

  static final _getMaxPitch = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public double getMaxPitch()`
  double getMaxPitch() {
    return _getMaxPitch(reference.pointer, _id_getMaxPitch as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getUiSettings = _class.instanceMethodId(
    r'getUiSettings',
    r'()Lorg/maplibre/android/maps/UiSettings;',
  );

  static final _getUiSettings = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.UiSettings getUiSettings()`
  /// The returned object must be released after use, by calling the [release] method.
  uisettings_.UiSettings getUiSettings() {
    return _getUiSettings(
            reference.pointer, _id_getUiSettings as jni.JMethodIDPtr)
        .object(const uisettings_.$UiSettingsType());
  }

  static final _id_getProjection = _class.instanceMethodId(
    r'getProjection',
    r'()Lorg/maplibre/android/maps/Projection;',
  );

  static final _getProjection = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.Projection getProjection()`
  /// The returned object must be released after use, by calling the [release] method.
  projection_.Projection getProjection() {
    return _getProjection(
            reference.pointer, _id_getProjection as jni.JMethodIDPtr)
        .object(const projection_.$ProjectionType());
  }

  static final _id_cancelTransitions = _class.instanceMethodId(
    r'cancelTransitions',
    r'()V',
  );

  static final _cancelTransitions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void cancelTransitions()`
  void cancelTransitions() {
    _cancelTransitions(
            reference.pointer, _id_cancelTransitions as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getCameraPosition = _class.instanceMethodId(
    r'getCameraPosition',
    r'()Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraPosition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final org.maplibre.android.camera.CameraPosition getCameraPosition()`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraPosition() {
    return _getCameraPosition(
            reference.pointer, _id_getCameraPosition as jni.JMethodIDPtr)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_setCameraPosition = _class.instanceMethodId(
    r'setCameraPosition',
    r'(Lorg/maplibre/android/camera/CameraPosition;)V',
  );

  static final _setCameraPosition = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setCameraPosition(org.maplibre.android.camera.CameraPosition cameraPosition)`
  void setCameraPosition(
    cameraposition_.CameraPosition cameraPosition,
  ) {
    _setCameraPosition(
            reference.pointer,
            _id_setCameraPosition as jni.JMethodIDPtr,
            cameraPosition.reference.pointer)
        .check();
  }

  static final _id_moveCamera = _class.instanceMethodId(
    r'moveCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _moveCamera = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void moveCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void moveCamera(
    cameraupdate_.CameraUpdate cameraUpdate,
  ) {
    _moveCamera(reference.pointer, _id_moveCamera as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer)
        .check();
  }

  static final _id_moveCamera1 = _class.instanceMethodId(
    r'moveCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _moveCamera1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void moveCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void moveCamera1(
    cameraupdate_.CameraUpdate cameraUpdate,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _moveCamera1(
            reference.pointer,
            _id_moveCamera1 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_easeCamera = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _easeCamera = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void easeCamera(
    cameraupdate_.CameraUpdate cameraUpdate,
  ) {
    _easeCamera(reference.pointer, _id_easeCamera as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer)
        .check();
  }

  static final _id_easeCamera1 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera1(
    cameraupdate_.CameraUpdate cameraUpdate,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _easeCamera1(
            reference.pointer,
            _id_easeCamera1 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_easeCamera2 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;I)V',
  );

  static final _easeCamera2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i)`
  void easeCamera2(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
  ) {
    _easeCamera2(reference.pointer, _id_easeCamera2 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer, i)
        .check();
  }

  static final _id_easeCamera3 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;ILorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera3(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _easeCamera3(
            reference.pointer,
            _id_easeCamera3 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            i,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_easeCamera4 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;IZ)V',
  );

  static final _easeCamera4 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, boolean z)`
  void easeCamera4(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
    bool z,
  ) {
    _easeCamera4(reference.pointer, _id_easeCamera4 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer, i, z ? 1 : 0)
        .check();
  }

  static final _id_easeCamera5 = _class.instanceMethodId(
    r'easeCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;IZLorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _easeCamera5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void easeCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, boolean z, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void easeCamera5(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
    bool z,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _easeCamera5(
            reference.pointer,
            _id_easeCamera5 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            i,
            z ? 1 : 0,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_animateCamera = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;)V',
  );

  static final _animateCamera = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate)`
  void animateCamera(
    cameraupdate_.CameraUpdate cameraUpdate,
  ) {
    _animateCamera(reference.pointer, _id_animateCamera as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer)
        .check();
  }

  static final _id_animateCamera1 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;Lorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _animateCamera1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void animateCamera1(
    cameraupdate_.CameraUpdate cameraUpdate,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _animateCamera1(
            reference.pointer,
            _id_animateCamera1 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_animateCamera2 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;I)V',
  );

  static final _animateCamera2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i)`
  void animateCamera2(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
  ) {
    _animateCamera2(reference.pointer, _id_animateCamera2 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer, i)
        .check();
  }

  static final _id_animateCamera3 = _class.instanceMethodId(
    r'animateCamera',
    r'(Lorg/maplibre/android/camera/CameraUpdate;ILorg/maplibre/android/maps/MapLibreMap$CancelableCallback;)V',
  );

  static final _animateCamera3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void animateCamera(org.maplibre.android.camera.CameraUpdate cameraUpdate, int i, org.maplibre.android.maps.MapLibreMap$CancelableCallback cancelableCallback)`
  void animateCamera3(
    cameraupdate_.CameraUpdate cameraUpdate,
    int i,
    MapLibreMap_CancelableCallback cancelableCallback,
  ) {
    _animateCamera3(
            reference.pointer,
            _id_animateCamera3 as jni.JMethodIDPtr,
            cameraUpdate.reference.pointer,
            i,
            cancelableCallback.reference.pointer)
        .check();
  }

  static final _id_scrollBy = _class.instanceMethodId(
    r'scrollBy',
    r'(FF)V',
  );

  static final _scrollBy = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Double, ffi.Double)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double, double)>();

  /// from: `public void scrollBy(float f, float f1)`
  void scrollBy(
    double f,
    double f1,
  ) {
    _scrollBy(reference.pointer, _id_scrollBy as jni.JMethodIDPtr, f, f1)
        .check();
  }

  static final _id_scrollBy1 = _class.instanceMethodId(
    r'scrollBy',
    r'(FFJ)V',
  );

  static final _scrollBy1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Double, ffi.Double, ffi.Int64)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double, double, int)>();

  /// from: `public void scrollBy(float f, float f1, long j)`
  void scrollBy1(
    double f,
    double f1,
    int j,
  ) {
    _scrollBy1(reference.pointer, _id_scrollBy1 as jni.JMethodIDPtr, f, f1, j)
        .check();
  }

  static final _id_resetNorth = _class.instanceMethodId(
    r'resetNorth',
    r'()V',
  );

  static final _resetNorth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void resetNorth()`
  void resetNorth() {
    _resetNorth(reference.pointer, _id_resetNorth as jni.JMethodIDPtr).check();
  }

  static final _id_setFocalBearing = _class.instanceMethodId(
    r'setFocalBearing',
    r'(DFFJ)V',
  );

  static final _setFocalBearing = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Double,
                        ffi.Double,
                        ffi.Double,
                        ffi.Int64
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              double, double, double, int)>();

  /// from: `public void setFocalBearing(double d, float f, float f1, long j)`
  void setFocalBearing(
    double d,
    double f,
    double f1,
    int j,
  ) {
    _setFocalBearing(reference.pointer, _id_setFocalBearing as jni.JMethodIDPtr,
            d, f, f1, j)
        .check();
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()F',
  );

  static final _getHeight = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getHeight()`
  double getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()F',
  );

  static final _getWidth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getWidth()`
  double getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni.JMethodIDPtr).float;
  }

  static final _id_setOfflineRegionDefinition = _class.instanceMethodId(
    r'setOfflineRegionDefinition',
    r'(Lorg/maplibre/android/offline/OfflineRegionDefinition;)V',
  );

  static final _setOfflineRegionDefinition = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOfflineRegionDefinition(org.maplibre.android.offline.OfflineRegionDefinition offlineRegionDefinition)`
  void setOfflineRegionDefinition(
    offlineregiondefinition_.OfflineRegionDefinition offlineRegionDefinition,
  ) {
    _setOfflineRegionDefinition(
            reference.pointer,
            _id_setOfflineRegionDefinition as jni.JMethodIDPtr,
            offlineRegionDefinition.reference.pointer)
        .check();
  }

  static final _id_setOfflineRegionDefinition1 = _class.instanceMethodId(
    r'setOfflineRegionDefinition',
    r'(Lorg/maplibre/android/offline/OfflineRegionDefinition;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setOfflineRegionDefinition1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOfflineRegionDefinition(org.maplibre.android.offline.OfflineRegionDefinition offlineRegionDefinition, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setOfflineRegionDefinition1(
    offlineregiondefinition_.OfflineRegionDefinition offlineRegionDefinition,
    style_.Style_OnStyleLoaded onStyleLoaded,
  ) {
    _setOfflineRegionDefinition1(
            reference.pointer,
            _id_setOfflineRegionDefinition1 as jni.JMethodIDPtr,
            offlineRegionDefinition.reference.pointer,
            onStyleLoaded.reference.pointer)
        .check();
  }

  static final _id_isDebugActive = _class.instanceMethodId(
    r'isDebugActive',
    r'()Z',
  );

  static final _isDebugActive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isDebugActive()`
  bool isDebugActive() {
    return _isDebugActive(
            reference.pointer, _id_isDebugActive as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setDebugActive = _class.instanceMethodId(
    r'setDebugActive',
    r'(Z)V',
  );

  static final _setDebugActive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setDebugActive(boolean z)`
  void setDebugActive(
    bool z,
  ) {
    _setDebugActive(reference.pointer, _id_setDebugActive as jni.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_cycleDebugOptions = _class.instanceMethodId(
    r'cycleDebugOptions',
    r'()V',
  );

  static final _cycleDebugOptions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void cycleDebugOptions()`
  void cycleDebugOptions() {
    _cycleDebugOptions(
            reference.pointer, _id_cycleDebugOptions as jni.JMethodIDPtr)
        .check();
  }

  static final _id_setStyle = _class.instanceMethodId(
    r'setStyle',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyle = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setStyle(java.lang.String string)`
  void setStyle(
    jni.JString string,
  ) {
    _setStyle(reference.pointer, _id_setStyle as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_setStyle1 = _class.instanceMethodId(
    r'setStyle',
    r'(Ljava/lang/String;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setStyle1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void setStyle(java.lang.String string, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setStyle1(
    jni.JString string,
    style_.Style_OnStyleLoaded onStyleLoaded,
  ) {
    _setStyle1(reference.pointer, _id_setStyle1 as jni.JMethodIDPtr,
            string.reference.pointer, onStyleLoaded.reference.pointer)
        .check();
  }

  static final _id_setStyle2 = _class.instanceMethodId(
    r'setStyle',
    r'(Lorg/maplibre/android/maps/Style$Builder;)V',
  );

  static final _setStyle2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setStyle(org.maplibre.android.maps.Style$Builder builder)`
  void setStyle2(
    style_.Style_Builder builder,
  ) {
    _setStyle2(reference.pointer, _id_setStyle2 as jni.JMethodIDPtr,
            builder.reference.pointer)
        .check();
  }

  static final _id_setStyle3 = _class.instanceMethodId(
    r'setStyle',
    r'(Lorg/maplibre/android/maps/Style$Builder;Lorg/maplibre/android/maps/Style$OnStyleLoaded;)V',
  );

  static final _setStyle3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void setStyle(org.maplibre.android.maps.Style$Builder builder, org.maplibre.android.maps.Style$OnStyleLoaded onStyleLoaded)`
  void setStyle3(
    style_.Style_Builder builder,
    style_.Style_OnStyleLoaded onStyleLoaded,
  ) {
    _setStyle3(reference.pointer, _id_setStyle3 as jni.JMethodIDPtr,
            builder.reference.pointer, onStyleLoaded.reference.pointer)
        .check();
  }

  static final _id_addMarker = _class.instanceMethodId(
    r'addMarker',
    r'(Lorg/maplibre/android/annotations/MarkerOptions;)Lorg/maplibre/android/annotations/Marker;',
  );

  static final _addMarker = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.annotations.Marker addMarker(org.maplibre.android.annotations.MarkerOptions markerOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject addMarker(
    jni.JObject markerOptions,
  ) {
    return _addMarker(reference.pointer, _id_addMarker as jni.JMethodIDPtr,
            markerOptions.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_addMarker1 = _class.instanceMethodId(
    r'addMarker',
    r'(Lorg/maplibre/android/annotations/BaseMarkerOptions;)Lorg/maplibre/android/annotations/Marker;',
  );

  static final _addMarker1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.annotations.Marker addMarker(org.maplibre.android.annotations.BaseMarkerOptions baseMarkerOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject addMarker1(
    jni.JObject baseMarkerOptions,
  ) {
    return _addMarker1(reference.pointer, _id_addMarker1 as jni.JMethodIDPtr,
            baseMarkerOptions.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_addMarkers = _class.instanceMethodId(
    r'addMarkers',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addMarkers = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public java.util.List addMarkers(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> addMarkers(
    jni.JList<jni.JObject> list,
  ) {
    return _addMarkers(reference.pointer, _id_addMarkers as jni.JMethodIDPtr,
            list.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_updateMarker = _class.instanceMethodId(
    r'updateMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _updateMarker = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void updateMarker(org.maplibre.android.annotations.Marker marker)`
  void updateMarker(
    jni.JObject marker,
  ) {
    _updateMarker(reference.pointer, _id_updateMarker as jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  static final _id_addPolyline = _class.instanceMethodId(
    r'addPolyline',
    r'(Lorg/maplibre/android/annotations/PolylineOptions;)Lorg/maplibre/android/annotations/Polyline;',
  );

  static final _addPolyline = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.annotations.Polyline addPolyline(org.maplibre.android.annotations.PolylineOptions polylineOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject addPolyline(
    jni.JObject polylineOptions,
  ) {
    return _addPolyline(reference.pointer, _id_addPolyline as jni.JMethodIDPtr,
            polylineOptions.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_addPolylines = _class.instanceMethodId(
    r'addPolylines',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addPolylines = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public java.util.List addPolylines(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> addPolylines(
    jni.JList<jni.JObject> list,
  ) {
    return _addPolylines(reference.pointer,
            _id_addPolylines as jni.JMethodIDPtr, list.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_updatePolyline = _class.instanceMethodId(
    r'updatePolyline',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _updatePolyline = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void updatePolyline(org.maplibre.android.annotations.Polyline polyline)`
  void updatePolyline(
    jni.JObject polyline,
  ) {
    _updatePolyline(reference.pointer, _id_updatePolyline as jni.JMethodIDPtr,
            polyline.reference.pointer)
        .check();
  }

  static final _id_addPolygon = _class.instanceMethodId(
    r'addPolygon',
    r'(Lorg/maplibre/android/annotations/PolygonOptions;)Lorg/maplibre/android/annotations/Polygon;',
  );

  static final _addPolygon = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.annotations.Polygon addPolygon(org.maplibre.android.annotations.PolygonOptions polygonOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject addPolygon(
    jni.JObject polygonOptions,
  ) {
    return _addPolygon(reference.pointer, _id_addPolygon as jni.JMethodIDPtr,
            polygonOptions.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_addPolygons = _class.instanceMethodId(
    r'addPolygons',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _addPolygons = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public java.util.List addPolygons(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> addPolygons(
    jni.JList<jni.JObject> list,
  ) {
    return _addPolygons(reference.pointer, _id_addPolygons as jni.JMethodIDPtr,
            list.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_updatePolygon = _class.instanceMethodId(
    r'updatePolygon',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _updatePolygon = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void updatePolygon(org.maplibre.android.annotations.Polygon polygon)`
  void updatePolygon(
    jni.JObject polygon,
  ) {
    _updatePolygon(reference.pointer, _id_updatePolygon as jni.JMethodIDPtr,
            polygon.reference.pointer)
        .check();
  }

  static final _id_removeMarker = _class.instanceMethodId(
    r'removeMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _removeMarker = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeMarker(org.maplibre.android.annotations.Marker marker)`
  void removeMarker(
    jni.JObject marker,
  ) {
    _removeMarker(reference.pointer, _id_removeMarker as jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  static final _id_removePolyline = _class.instanceMethodId(
    r'removePolyline',
    r'(Lorg/maplibre/android/annotations/Polyline;)V',
  );

  static final _removePolyline = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removePolyline(org.maplibre.android.annotations.Polyline polyline)`
  void removePolyline(
    jni.JObject polyline,
  ) {
    _removePolyline(reference.pointer, _id_removePolyline as jni.JMethodIDPtr,
            polyline.reference.pointer)
        .check();
  }

  static final _id_removePolygon = _class.instanceMethodId(
    r'removePolygon',
    r'(Lorg/maplibre/android/annotations/Polygon;)V',
  );

  static final _removePolygon = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removePolygon(org.maplibre.android.annotations.Polygon polygon)`
  void removePolygon(
    jni.JObject polygon,
  ) {
    _removePolygon(reference.pointer, _id_removePolygon as jni.JMethodIDPtr,
            polygon.reference.pointer)
        .check();
  }

  static final _id_removeAnnotation = _class.instanceMethodId(
    r'removeAnnotation',
    r'(Lorg/maplibre/android/annotations/Annotation;)V',
  );

  static final _removeAnnotation = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeAnnotation(org.maplibre.android.annotations.Annotation annotation)`
  void removeAnnotation(
    jni.JObject annotation,
  ) {
    _removeAnnotation(
            reference.pointer,
            _id_removeAnnotation as jni.JMethodIDPtr,
            annotation.reference.pointer)
        .check();
  }

  static final _id_removeAnnotation1 = _class.instanceMethodId(
    r'removeAnnotation',
    r'(J)V',
  );

  static final _removeAnnotation1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void removeAnnotation(long j)`
  void removeAnnotation1(
    int j,
  ) {
    _removeAnnotation1(
            reference.pointer, _id_removeAnnotation1 as jni.JMethodIDPtr, j)
        .check();
  }

  static final _id_removeAnnotations = _class.instanceMethodId(
    r'removeAnnotations',
    r'(Ljava/util/List;)V',
  );

  static final _removeAnnotations = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeAnnotations(java.util.List list)`
  void removeAnnotations(
    jni.JList<jni.JObject> list,
  ) {
    _removeAnnotations(reference.pointer,
            _id_removeAnnotations as jni.JMethodIDPtr, list.reference.pointer)
        .check();
  }

  static final _id_removeAnnotations1 = _class.instanceMethodId(
    r'removeAnnotations',
    r'()V',
  );

  static final _removeAnnotations1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void removeAnnotations()`
  void removeAnnotations1() {
    _removeAnnotations1(
            reference.pointer, _id_removeAnnotations1 as jni.JMethodIDPtr)
        .check();
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni.JMethodIDPtr).check();
  }

  static final _id_getAnnotation = _class.instanceMethodId(
    r'getAnnotation',
    r'(J)Lorg/maplibre/android/annotations/Annotation;',
  );

  static final _getAnnotation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public org.maplibre.android.annotations.Annotation getAnnotation(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAnnotation(
    int j,
  ) {
    return _getAnnotation(
            reference.pointer, _id_getAnnotation as jni.JMethodIDPtr, j)
        .object(const jni.JObjectType());
  }

  static final _id_getAnnotations = _class.instanceMethodId(
    r'getAnnotations',
    r'()Ljava/util/List;',
  );

  static final _getAnnotations = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getAnnotations()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getAnnotations() {
    return _getAnnotations(
            reference.pointer, _id_getAnnotations as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_getMarkers = _class.instanceMethodId(
    r'getMarkers',
    r'()Ljava/util/List;',
  );

  static final _getMarkers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getMarkers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getMarkers() {
    return _getMarkers(reference.pointer, _id_getMarkers as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_getPolygons = _class.instanceMethodId(
    r'getPolygons',
    r'()Ljava/util/List;',
  );

  static final _getPolygons = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getPolygons()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getPolygons() {
    return _getPolygons(reference.pointer, _id_getPolygons as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_getPolylines = _class.instanceMethodId(
    r'getPolylines',
    r'()Ljava/util/List;',
  );

  static final _getPolylines = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getPolylines()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getPolylines() {
    return _getPolylines(
            reference.pointer, _id_getPolylines as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_setOnMarkerClickListener = _class.instanceMethodId(
    r'setOnMarkerClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMarkerClickListener;)V',
  );

  static final _setOnMarkerClickListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOnMarkerClickListener(org.maplibre.android.maps.MapLibreMap$OnMarkerClickListener onMarkerClickListener)`
  void setOnMarkerClickListener(
    MapLibreMap_OnMarkerClickListener onMarkerClickListener,
  ) {
    _setOnMarkerClickListener(
            reference.pointer,
            _id_setOnMarkerClickListener as jni.JMethodIDPtr,
            onMarkerClickListener.reference.pointer)
        .check();
  }

  static final _id_setOnPolygonClickListener = _class.instanceMethodId(
    r'setOnPolygonClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnPolygonClickListener;)V',
  );

  static final _setOnPolygonClickListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOnPolygonClickListener(org.maplibre.android.maps.MapLibreMap$OnPolygonClickListener onPolygonClickListener)`
  void setOnPolygonClickListener(
    MapLibreMap_OnPolygonClickListener onPolygonClickListener,
  ) {
    _setOnPolygonClickListener(
            reference.pointer,
            _id_setOnPolygonClickListener as jni.JMethodIDPtr,
            onPolygonClickListener.reference.pointer)
        .check();
  }

  static final _id_setOnPolylineClickListener = _class.instanceMethodId(
    r'setOnPolylineClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnPolylineClickListener;)V',
  );

  static final _setOnPolylineClickListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOnPolylineClickListener(org.maplibre.android.maps.MapLibreMap$OnPolylineClickListener onPolylineClickListener)`
  void setOnPolylineClickListener(
    MapLibreMap_OnPolylineClickListener onPolylineClickListener,
  ) {
    _setOnPolylineClickListener(
            reference.pointer,
            _id_setOnPolylineClickListener as jni.JMethodIDPtr,
            onPolylineClickListener.reference.pointer)
        .check();
  }

  static final _id_selectMarker = _class.instanceMethodId(
    r'selectMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _selectMarker = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void selectMarker(org.maplibre.android.annotations.Marker marker)`
  void selectMarker(
    jni.JObject marker,
  ) {
    _selectMarker(reference.pointer, _id_selectMarker as jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  static final _id_deselectMarkers = _class.instanceMethodId(
    r'deselectMarkers',
    r'()V',
  );

  static final _deselectMarkers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void deselectMarkers()`
  void deselectMarkers() {
    _deselectMarkers(reference.pointer, _id_deselectMarkers as jni.JMethodIDPtr)
        .check();
  }

  static final _id_deselectMarker = _class.instanceMethodId(
    r'deselectMarker',
    r'(Lorg/maplibre/android/annotations/Marker;)V',
  );

  static final _deselectMarker = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void deselectMarker(org.maplibre.android.annotations.Marker marker)`
  void deselectMarker(
    jni.JObject marker,
  ) {
    _deselectMarker(reference.pointer, _id_deselectMarker as jni.JMethodIDPtr,
            marker.reference.pointer)
        .check();
  }

  static final _id_getSelectedMarkers = _class.instanceMethodId(
    r'getSelectedMarkers',
    r'()Ljava/util/List;',
  );

  static final _getSelectedMarkers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getSelectedMarkers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getSelectedMarkers() {
    return _getSelectedMarkers(
            reference.pointer, _id_getSelectedMarkers as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_setInfoWindowAdapter = _class.instanceMethodId(
    r'setInfoWindowAdapter',
    r'(Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;)V',
  );

  static final _setInfoWindowAdapter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setInfoWindowAdapter(org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter infoWindowAdapter)`
  void setInfoWindowAdapter(
    MapLibreMap_InfoWindowAdapter infoWindowAdapter,
  ) {
    _setInfoWindowAdapter(
            reference.pointer,
            _id_setInfoWindowAdapter as jni.JMethodIDPtr,
            infoWindowAdapter.reference.pointer)
        .check();
  }

  static final _id_getInfoWindowAdapter = _class.instanceMethodId(
    r'getInfoWindowAdapter',
    r'()Lorg/maplibre/android/maps/MapLibreMap$InfoWindowAdapter;',
  );

  static final _getInfoWindowAdapter = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.MapLibreMap$InfoWindowAdapter getInfoWindowAdapter()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap_InfoWindowAdapter getInfoWindowAdapter() {
    return _getInfoWindowAdapter(
            reference.pointer, _id_getInfoWindowAdapter as jni.JMethodIDPtr)
        .object(const $MapLibreMap_InfoWindowAdapterType());
  }

  static final _id_setAllowConcurrentMultipleOpenInfoWindows =
      _class.instanceMethodId(
    r'setAllowConcurrentMultipleOpenInfoWindows',
    r'(Z)V',
  );

  static final _setAllowConcurrentMultipleOpenInfoWindows =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setAllowConcurrentMultipleOpenInfoWindows(boolean z)`
  void setAllowConcurrentMultipleOpenInfoWindows(
    bool z,
  ) {
    _setAllowConcurrentMultipleOpenInfoWindows(
            reference.pointer,
            _id_setAllowConcurrentMultipleOpenInfoWindows as jni.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isAllowConcurrentMultipleOpenInfoWindows =
      _class.instanceMethodId(
    r'isAllowConcurrentMultipleOpenInfoWindows',
    r'()Z',
  );

  static final _isAllowConcurrentMultipleOpenInfoWindows =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `public boolean isAllowConcurrentMultipleOpenInfoWindows()`
  bool isAllowConcurrentMultipleOpenInfoWindows() {
    return _isAllowConcurrentMultipleOpenInfoWindows(reference.pointer,
            _id_isAllowConcurrentMultipleOpenInfoWindows as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setLatLngBoundsForCameraTarget = _class.instanceMethodId(
    r'setLatLngBoundsForCameraTarget',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;)V',
  );

  static final _setLatLngBoundsForCameraTarget = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setLatLngBoundsForCameraTarget(org.maplibre.android.geometry.LatLngBounds latLngBounds)`
  void setLatLngBoundsForCameraTarget(
    latlngbounds_.LatLngBounds latLngBounds,
  ) {
    _setLatLngBoundsForCameraTarget(
            reference.pointer,
            _id_setLatLngBoundsForCameraTarget as jni.JMethodIDPtr,
            latLngBounds.reference.pointer)
        .check();
  }

  static final _id_getCameraForLatLngBounds = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForLatLngBounds(
    latlngbounds_.LatLngBounds latLngBounds,
  ) {
    return _getCameraForLatLngBounds(
            reference.pointer,
            _id_getCameraForLatLngBounds as jni.JMethodIDPtr,
            latLngBounds.reference.pointer)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_getCameraForLatLngBounds1 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;[I)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForLatLngBounds1(
    latlngbounds_.LatLngBounds latLngBounds,
    jni.JArray<jni.jint> is0,
  ) {
    return _getCameraForLatLngBounds1(
            reference.pointer,
            _id_getCameraForLatLngBounds1 as jni.JMethodIDPtr,
            latLngBounds.reference.pointer,
            is0.reference.pointer)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_getCameraForLatLngBounds2 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;DD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Double,
                        ffi.Double
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, double, double)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForLatLngBounds2(
    latlngbounds_.LatLngBounds latLngBounds,
    double d,
    double d1,
  ) {
    return _getCameraForLatLngBounds2(
            reference.pointer,
            _id_getCameraForLatLngBounds2 as jni.JMethodIDPtr,
            latLngBounds.reference.pointer,
            d,
            d1)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_getCameraForLatLngBounds3 = _class.instanceMethodId(
    r'getCameraForLatLngBounds',
    r'(Lorg/maplibre/android/geometry/LatLngBounds;[IDD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForLatLngBounds3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Double,
                        ffi.Double
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double, double)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForLatLngBounds(org.maplibre.android.geometry.LatLngBounds latLngBounds, int[] is, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForLatLngBounds3(
    latlngbounds_.LatLngBounds latLngBounds,
    jni.JArray<jni.jint> is0,
    double d,
    double d1,
  ) {
    return _getCameraForLatLngBounds3(
            reference.pointer,
            _id_getCameraForLatLngBounds3 as jni.JMethodIDPtr,
            latLngBounds.reference.pointer,
            is0.reference.pointer,
            d,
            d1)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_getCameraForGeometry = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForGeometry(
    jni.JObject geometry,
  ) {
    return _getCameraForGeometry(
            reference.pointer,
            _id_getCameraForGeometry as jni.JMethodIDPtr,
            geometry.reference.pointer)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_getCameraForGeometry1 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;[I)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForGeometry1(
    jni.JObject geometry,
    jni.JArray<jni.jint> is0,
  ) {
    return _getCameraForGeometry1(
            reference.pointer,
            _id_getCameraForGeometry1 as jni.JMethodIDPtr,
            geometry.reference.pointer,
            is0.reference.pointer)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_getCameraForGeometry2 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;DD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Double,
                        ffi.Double
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, double, double)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForGeometry2(
    jni.JObject geometry,
    double d,
    double d1,
  ) {
    return _getCameraForGeometry2(
            reference.pointer,
            _id_getCameraForGeometry2 as jni.JMethodIDPtr,
            geometry.reference.pointer,
            d,
            d1)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_getCameraForGeometry3 = _class.instanceMethodId(
    r'getCameraForGeometry',
    r'(Lorg/maplibre/geojson/Geometry;[IDD)Lorg/maplibre/android/camera/CameraPosition;',
  );

  static final _getCameraForGeometry3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Double,
                        ffi.Double
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double, double)>();

  /// from: `public org.maplibre.android.camera.CameraPosition getCameraForGeometry(org.maplibre.geojson.Geometry geometry, int[] is, double d, double d1)`
  /// The returned object must be released after use, by calling the [release] method.
  cameraposition_.CameraPosition getCameraForGeometry3(
    jni.JObject geometry,
    jni.JArray<jni.jint> is0,
    double d,
    double d1,
  ) {
    return _getCameraForGeometry3(
            reference.pointer,
            _id_getCameraForGeometry3 as jni.JMethodIDPtr,
            geometry.reference.pointer,
            is0.reference.pointer,
            d,
            d1)
        .object(const cameraposition_.$CameraPositionType());
  }

  static final _id_setPadding = _class.instanceMethodId(
    r'setPadding',
    r'(IIII)V',
  );

  static final _setPadding = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: `public void setPadding(int i, int i1, int i2, int i3)`
  void setPadding(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _setPadding(reference.pointer, _id_setPadding as jni.JMethodIDPtr, i, i1,
            i2, i3)
        .check();
  }

  static final _id_getPadding = _class.instanceMethodId(
    r'getPadding',
    r'()[I',
  );

  static final _getPadding = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int[] getPadding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getPadding() {
    return _getPadding(reference.pointer, _id_getPadding as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_addOnCameraIdleListener = _class.instanceMethodId(
    r'addOnCameraIdleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;)V',
  );

  static final _addOnCameraIdleListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnCameraIdleListener(org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener onCameraIdleListener)`
  void addOnCameraIdleListener(
    MapLibreMap_OnCameraIdleListener onCameraIdleListener,
  ) {
    _addOnCameraIdleListener(
            reference.pointer,
            _id_addOnCameraIdleListener as jni.JMethodIDPtr,
            onCameraIdleListener.reference.pointer)
        .check();
  }

  static final _id_removeOnCameraIdleListener = _class.instanceMethodId(
    r'removeOnCameraIdleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraIdleListener;)V',
  );

  static final _removeOnCameraIdleListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnCameraIdleListener(org.maplibre.android.maps.MapLibreMap$OnCameraIdleListener onCameraIdleListener)`
  void removeOnCameraIdleListener(
    MapLibreMap_OnCameraIdleListener onCameraIdleListener,
  ) {
    _removeOnCameraIdleListener(
            reference.pointer,
            _id_removeOnCameraIdleListener as jni.JMethodIDPtr,
            onCameraIdleListener.reference.pointer)
        .check();
  }

  static final _id_addOnCameraMoveCancelListener = _class.instanceMethodId(
    r'addOnCameraMoveCancelListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;)V',
  );

  static final _addOnCameraMoveCancelListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnCameraMoveCancelListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener onCameraMoveCanceledListener)`
  void addOnCameraMoveCancelListener(
    MapLibreMap_OnCameraMoveCanceledListener onCameraMoveCanceledListener,
  ) {
    _addOnCameraMoveCancelListener(
            reference.pointer,
            _id_addOnCameraMoveCancelListener as jni.JMethodIDPtr,
            onCameraMoveCanceledListener.reference.pointer)
        .check();
  }

  static final _id_removeOnCameraMoveCancelListener = _class.instanceMethodId(
    r'removeOnCameraMoveCancelListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveCanceledListener;)V',
  );

  static final _removeOnCameraMoveCancelListener =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnCameraMoveCancelListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveCanceledListener onCameraMoveCanceledListener)`
  void removeOnCameraMoveCancelListener(
    MapLibreMap_OnCameraMoveCanceledListener onCameraMoveCanceledListener,
  ) {
    _removeOnCameraMoveCancelListener(
            reference.pointer,
            _id_removeOnCameraMoveCancelListener as jni.JMethodIDPtr,
            onCameraMoveCanceledListener.reference.pointer)
        .check();
  }

  static final _id_addOnCameraMoveStartedListener = _class.instanceMethodId(
    r'addOnCameraMoveStartedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;)V',
  );

  static final _addOnCameraMoveStartedListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnCameraMoveStartedListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener onCameraMoveStartedListener)`
  void addOnCameraMoveStartedListener(
    MapLibreMap_OnCameraMoveStartedListener onCameraMoveStartedListener,
  ) {
    _addOnCameraMoveStartedListener(
            reference.pointer,
            _id_addOnCameraMoveStartedListener as jni.JMethodIDPtr,
            onCameraMoveStartedListener.reference.pointer)
        .check();
  }

  static final _id_removeOnCameraMoveStartedListener = _class.instanceMethodId(
    r'removeOnCameraMoveStartedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveStartedListener;)V',
  );

  static final _removeOnCameraMoveStartedListener =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnCameraMoveStartedListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveStartedListener onCameraMoveStartedListener)`
  void removeOnCameraMoveStartedListener(
    MapLibreMap_OnCameraMoveStartedListener onCameraMoveStartedListener,
  ) {
    _removeOnCameraMoveStartedListener(
            reference.pointer,
            _id_removeOnCameraMoveStartedListener as jni.JMethodIDPtr,
            onCameraMoveStartedListener.reference.pointer)
        .check();
  }

  static final _id_addOnCameraMoveListener = _class.instanceMethodId(
    r'addOnCameraMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;)V',
  );

  static final _addOnCameraMoveListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnCameraMoveListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener onCameraMoveListener)`
  void addOnCameraMoveListener(
    MapLibreMap_OnCameraMoveListener onCameraMoveListener,
  ) {
    _addOnCameraMoveListener(
            reference.pointer,
            _id_addOnCameraMoveListener as jni.JMethodIDPtr,
            onCameraMoveListener.reference.pointer)
        .check();
  }

  static final _id_removeOnCameraMoveListener = _class.instanceMethodId(
    r'removeOnCameraMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnCameraMoveListener;)V',
  );

  static final _removeOnCameraMoveListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnCameraMoveListener(org.maplibre.android.maps.MapLibreMap$OnCameraMoveListener onCameraMoveListener)`
  void removeOnCameraMoveListener(
    MapLibreMap_OnCameraMoveListener onCameraMoveListener,
  ) {
    _removeOnCameraMoveListener(
            reference.pointer,
            _id_removeOnCameraMoveListener as jni.JMethodIDPtr,
            onCameraMoveListener.reference.pointer)
        .check();
  }

  static final _id_setOnFpsChangedListener = _class.instanceMethodId(
    r'setOnFpsChangedListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFpsChangedListener;)V',
  );

  static final _setOnFpsChangedListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOnFpsChangedListener(org.maplibre.android.maps.MapLibreMap$OnFpsChangedListener onFpsChangedListener)`
  void setOnFpsChangedListener(
    MapLibreMap_OnFpsChangedListener onFpsChangedListener,
  ) {
    _setOnFpsChangedListener(
            reference.pointer,
            _id_setOnFpsChangedListener as jni.JMethodIDPtr,
            onFpsChangedListener.reference.pointer)
        .check();
  }

  static final _id_addOnFlingListener = _class.instanceMethodId(
    r'addOnFlingListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;)V',
  );

  static final _addOnFlingListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnFlingListener(org.maplibre.android.maps.MapLibreMap$OnFlingListener onFlingListener)`
  void addOnFlingListener(
    MapLibreMap_OnFlingListener onFlingListener,
  ) {
    _addOnFlingListener(
            reference.pointer,
            _id_addOnFlingListener as jni.JMethodIDPtr,
            onFlingListener.reference.pointer)
        .check();
  }

  static final _id_removeOnFlingListener = _class.instanceMethodId(
    r'removeOnFlingListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnFlingListener;)V',
  );

  static final _removeOnFlingListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnFlingListener(org.maplibre.android.maps.MapLibreMap$OnFlingListener onFlingListener)`
  void removeOnFlingListener(
    MapLibreMap_OnFlingListener onFlingListener,
  ) {
    _removeOnFlingListener(
            reference.pointer,
            _id_removeOnFlingListener as jni.JMethodIDPtr,
            onFlingListener.reference.pointer)
        .check();
  }

  static final _id_addOnMoveListener = _class.instanceMethodId(
    r'addOnMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;)V',
  );

  static final _addOnMoveListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnMoveListener(org.maplibre.android.maps.MapLibreMap$OnMoveListener onMoveListener)`
  void addOnMoveListener(
    MapLibreMap_OnMoveListener onMoveListener,
  ) {
    _addOnMoveListener(
            reference.pointer,
            _id_addOnMoveListener as jni.JMethodIDPtr,
            onMoveListener.reference.pointer)
        .check();
  }

  static final _id_removeOnMoveListener = _class.instanceMethodId(
    r'removeOnMoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMoveListener;)V',
  );

  static final _removeOnMoveListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnMoveListener(org.maplibre.android.maps.MapLibreMap$OnMoveListener onMoveListener)`
  void removeOnMoveListener(
    MapLibreMap_OnMoveListener onMoveListener,
  ) {
    _removeOnMoveListener(
            reference.pointer,
            _id_removeOnMoveListener as jni.JMethodIDPtr,
            onMoveListener.reference.pointer)
        .check();
  }

  static final _id_addOnRotateListener = _class.instanceMethodId(
    r'addOnRotateListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;)V',
  );

  static final _addOnRotateListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnRotateListener(org.maplibre.android.maps.MapLibreMap$OnRotateListener onRotateListener)`
  void addOnRotateListener(
    MapLibreMap_OnRotateListener onRotateListener,
  ) {
    _addOnRotateListener(
            reference.pointer,
            _id_addOnRotateListener as jni.JMethodIDPtr,
            onRotateListener.reference.pointer)
        .check();
  }

  static final _id_removeOnRotateListener = _class.instanceMethodId(
    r'removeOnRotateListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnRotateListener;)V',
  );

  static final _removeOnRotateListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnRotateListener(org.maplibre.android.maps.MapLibreMap$OnRotateListener onRotateListener)`
  void removeOnRotateListener(
    MapLibreMap_OnRotateListener onRotateListener,
  ) {
    _removeOnRotateListener(
            reference.pointer,
            _id_removeOnRotateListener as jni.JMethodIDPtr,
            onRotateListener.reference.pointer)
        .check();
  }

  static final _id_addOnScaleListener = _class.instanceMethodId(
    r'addOnScaleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;)V',
  );

  static final _addOnScaleListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnScaleListener(org.maplibre.android.maps.MapLibreMap$OnScaleListener onScaleListener)`
  void addOnScaleListener(
    MapLibreMap_OnScaleListener onScaleListener,
  ) {
    _addOnScaleListener(
            reference.pointer,
            _id_addOnScaleListener as jni.JMethodIDPtr,
            onScaleListener.reference.pointer)
        .check();
  }

  static final _id_removeOnScaleListener = _class.instanceMethodId(
    r'removeOnScaleListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnScaleListener;)V',
  );

  static final _removeOnScaleListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnScaleListener(org.maplibre.android.maps.MapLibreMap$OnScaleListener onScaleListener)`
  void removeOnScaleListener(
    MapLibreMap_OnScaleListener onScaleListener,
  ) {
    _removeOnScaleListener(
            reference.pointer,
            _id_removeOnScaleListener as jni.JMethodIDPtr,
            onScaleListener.reference.pointer)
        .check();
  }

  static final _id_addOnShoveListener = _class.instanceMethodId(
    r'addOnShoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;)V',
  );

  static final _addOnShoveListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnShoveListener(org.maplibre.android.maps.MapLibreMap$OnShoveListener onShoveListener)`
  void addOnShoveListener(
    MapLibreMap_OnShoveListener onShoveListener,
  ) {
    _addOnShoveListener(
            reference.pointer,
            _id_addOnShoveListener as jni.JMethodIDPtr,
            onShoveListener.reference.pointer)
        .check();
  }

  static final _id_removeOnShoveListener = _class.instanceMethodId(
    r'removeOnShoveListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnShoveListener;)V',
  );

  static final _removeOnShoveListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnShoveListener(org.maplibre.android.maps.MapLibreMap$OnShoveListener onShoveListener)`
  void removeOnShoveListener(
    MapLibreMap_OnShoveListener onShoveListener,
  ) {
    _removeOnShoveListener(
            reference.pointer,
            _id_removeOnShoveListener as jni.JMethodIDPtr,
            onShoveListener.reference.pointer)
        .check();
  }

  static final _id_setGesturesManager = _class.instanceMethodId(
    r'setGesturesManager',
    r'(Lorg/maplibre/android/gestures/AndroidGesturesManager;ZZ)V',
  );

  static final _setGesturesManager = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: `public void setGesturesManager(org.maplibre.android.gestures.AndroidGesturesManager androidGesturesManager, boolean z, boolean z1)`
  void setGesturesManager(
    jni.JObject androidGesturesManager,
    bool z,
    bool z1,
  ) {
    _setGesturesManager(
            reference.pointer,
            _id_setGesturesManager as jni.JMethodIDPtr,
            androidGesturesManager.reference.pointer,
            z ? 1 : 0,
            z1 ? 1 : 0)
        .check();
  }

  static final _id_getGesturesManager = _class.instanceMethodId(
    r'getGesturesManager',
    r'()Lorg/maplibre/android/gestures/AndroidGesturesManager;',
  );

  static final _getGesturesManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.gestures.AndroidGesturesManager getGesturesManager()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getGesturesManager() {
    return _getGesturesManager(
            reference.pointer, _id_getGesturesManager as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_cancelAllVelocityAnimations = _class.instanceMethodId(
    r'cancelAllVelocityAnimations',
    r'()V',
  );

  static final _cancelAllVelocityAnimations = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void cancelAllVelocityAnimations()`
  void cancelAllVelocityAnimations() {
    _cancelAllVelocityAnimations(reference.pointer,
            _id_cancelAllVelocityAnimations as jni.JMethodIDPtr)
        .check();
  }

  static final _id_addOnMapClickListener = _class.instanceMethodId(
    r'addOnMapClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;)V',
  );

  static final _addOnMapClickListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnMapClickListener(org.maplibre.android.maps.MapLibreMap$OnMapClickListener onMapClickListener)`
  void addOnMapClickListener(
    MapLibreMap_OnMapClickListener onMapClickListener,
  ) {
    _addOnMapClickListener(
            reference.pointer,
            _id_addOnMapClickListener as jni.JMethodIDPtr,
            onMapClickListener.reference.pointer)
        .check();
  }

  static final _id_removeOnMapClickListener = _class.instanceMethodId(
    r'removeOnMapClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapClickListener;)V',
  );

  static final _removeOnMapClickListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnMapClickListener(org.maplibre.android.maps.MapLibreMap$OnMapClickListener onMapClickListener)`
  void removeOnMapClickListener(
    MapLibreMap_OnMapClickListener onMapClickListener,
  ) {
    _removeOnMapClickListener(
            reference.pointer,
            _id_removeOnMapClickListener as jni.JMethodIDPtr,
            onMapClickListener.reference.pointer)
        .check();
  }

  static final _id_addOnMapLongClickListener = _class.instanceMethodId(
    r'addOnMapLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;)V',
  );

  static final _addOnMapLongClickListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void addOnMapLongClickListener(org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener onMapLongClickListener)`
  void addOnMapLongClickListener(
    MapLibreMap_OnMapLongClickListener onMapLongClickListener,
  ) {
    _addOnMapLongClickListener(
            reference.pointer,
            _id_addOnMapLongClickListener as jni.JMethodIDPtr,
            onMapLongClickListener.reference.pointer)
        .check();
  }

  static final _id_removeOnMapLongClickListener = _class.instanceMethodId(
    r'removeOnMapLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnMapLongClickListener;)V',
  );

  static final _removeOnMapLongClickListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void removeOnMapLongClickListener(org.maplibre.android.maps.MapLibreMap$OnMapLongClickListener onMapLongClickListener)`
  void removeOnMapLongClickListener(
    MapLibreMap_OnMapLongClickListener onMapLongClickListener,
  ) {
    _removeOnMapLongClickListener(
            reference.pointer,
            _id_removeOnMapLongClickListener as jni.JMethodIDPtr,
            onMapLongClickListener.reference.pointer)
        .check();
  }

  static final _id_setOnInfoWindowClickListener = _class.instanceMethodId(
    r'setOnInfoWindowClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;)V',
  );

  static final _setOnInfoWindowClickListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOnInfoWindowClickListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener onInfoWindowClickListener)`
  void setOnInfoWindowClickListener(
    MapLibreMap_OnInfoWindowClickListener onInfoWindowClickListener,
  ) {
    _setOnInfoWindowClickListener(
            reference.pointer,
            _id_setOnInfoWindowClickListener as jni.JMethodIDPtr,
            onInfoWindowClickListener.reference.pointer)
        .check();
  }

  static final _id_getOnInfoWindowClickListener = _class.instanceMethodId(
    r'getOnInfoWindowClickListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowClickListener;',
  );

  static final _getOnInfoWindowClickListener = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowClickListener getOnInfoWindowClickListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap_OnInfoWindowClickListener getOnInfoWindowClickListener() {
    return _getOnInfoWindowClickListener(reference.pointer,
            _id_getOnInfoWindowClickListener as jni.JMethodIDPtr)
        .object(const $MapLibreMap_OnInfoWindowClickListenerType());
  }

  static final _id_setOnInfoWindowLongClickListener = _class.instanceMethodId(
    r'setOnInfoWindowLongClickListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;)V',
  );

  static final _setOnInfoWindowLongClickListener =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOnInfoWindowLongClickListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener onInfoWindowLongClickListener)`
  void setOnInfoWindowLongClickListener(
    MapLibreMap_OnInfoWindowLongClickListener onInfoWindowLongClickListener,
  ) {
    _setOnInfoWindowLongClickListener(
            reference.pointer,
            _id_setOnInfoWindowLongClickListener as jni.JMethodIDPtr,
            onInfoWindowLongClickListener.reference.pointer)
        .check();
  }

  static final _id_getOnInfoWindowLongClickListener = _class.instanceMethodId(
    r'getOnInfoWindowLongClickListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowLongClickListener;',
  );

  static final _getOnInfoWindowLongClickListener =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowLongClickListener getOnInfoWindowLongClickListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap_OnInfoWindowLongClickListener getOnInfoWindowLongClickListener() {
    return _getOnInfoWindowLongClickListener(reference.pointer,
            _id_getOnInfoWindowLongClickListener as jni.JMethodIDPtr)
        .object(const $MapLibreMap_OnInfoWindowLongClickListenerType());
  }

  static final _id_setOnInfoWindowCloseListener = _class.instanceMethodId(
    r'setOnInfoWindowCloseListener',
    r'(Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;)V',
  );

  static final _setOnInfoWindowCloseListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setOnInfoWindowCloseListener(org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener onInfoWindowCloseListener)`
  void setOnInfoWindowCloseListener(
    MapLibreMap_OnInfoWindowCloseListener onInfoWindowCloseListener,
  ) {
    _setOnInfoWindowCloseListener(
            reference.pointer,
            _id_setOnInfoWindowCloseListener as jni.JMethodIDPtr,
            onInfoWindowCloseListener.reference.pointer)
        .check();
  }

  static final _id_getOnInfoWindowCloseListener = _class.instanceMethodId(
    r'getOnInfoWindowCloseListener',
    r'()Lorg/maplibre/android/maps/MapLibreMap$OnInfoWindowCloseListener;',
  );

  static final _getOnInfoWindowCloseListener = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.maps.MapLibreMap$OnInfoWindowCloseListener getOnInfoWindowCloseListener()`
  /// The returned object must be released after use, by calling the [release] method.
  MapLibreMap_OnInfoWindowCloseListener getOnInfoWindowCloseListener() {
    return _getOnInfoWindowCloseListener(reference.pointer,
            _id_getOnInfoWindowCloseListener as jni.JMethodIDPtr)
        .object(const $MapLibreMap_OnInfoWindowCloseListenerType());
  }

  static final _id_snapshot = _class.instanceMethodId(
    r'snapshot',
    r'(Lorg/maplibre/android/maps/MapLibreMap$SnapshotReadyCallback;)V',
  );

  static final _snapshot = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void snapshot(org.maplibre.android.maps.MapLibreMap$SnapshotReadyCallback snapshotReadyCallback)`
  void snapshot(
    MapLibreMap_SnapshotReadyCallback snapshotReadyCallback,
  ) {
    _snapshot(reference.pointer, _id_snapshot as jni.JMethodIDPtr,
            snapshotReadyCallback.reference.pointer)
        .check();
  }

  static final _id_queryRenderedFeatures = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/PointF;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.PointF pointF, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> queryRenderedFeatures(
    pointf_.PointF pointF,
    jni.JArray<jni.JString> strings,
  ) {
    return _queryRenderedFeatures(
            reference.pointer,
            _id_queryRenderedFeatures as jni.JMethodIDPtr,
            pointF.reference.pointer,
            strings.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_queryRenderedFeatures1 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/PointF;Lorg/maplibre/android/style/expressions/Expression;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.PointF pointF, org.maplibre.android.style.expressions.Expression expression, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> queryRenderedFeatures1(
    pointf_.PointF pointF,
    jni.JObject expression,
    jni.JArray<jni.JString> strings,
  ) {
    return _queryRenderedFeatures1(
            reference.pointer,
            _id_queryRenderedFeatures1 as jni.JMethodIDPtr,
            pointF.reference.pointer,
            expression.reference.pointer,
            strings.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_queryRenderedFeatures2 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/RectF;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.RectF rectF, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> queryRenderedFeatures2(
    jni.JObject rectF,
    jni.JArray<jni.JString> strings,
  ) {
    return _queryRenderedFeatures2(
            reference.pointer,
            _id_queryRenderedFeatures2 as jni.JMethodIDPtr,
            rectF.reference.pointer,
            strings.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_queryRenderedFeatures3 = _class.instanceMethodId(
    r'queryRenderedFeatures',
    r'(Landroid/graphics/RectF;Lorg/maplibre/android/style/expressions/Expression;[Ljava/lang/String;)Ljava/util/List;',
  );

  static final _queryRenderedFeatures3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public java.util.List queryRenderedFeatures(android.graphics.RectF rectF, org.maplibre.android.style.expressions.Expression expression, java.lang.Object[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> queryRenderedFeatures3(
    jni.JObject rectF,
    jni.JObject expression,
    jni.JArray<jni.JString> strings,
  ) {
    return _queryRenderedFeatures3(
            reference.pointer,
            _id_queryRenderedFeatures3 as jni.JMethodIDPtr,
            rectF.reference.pointer,
            expression.reference.pointer,
            strings.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_getLocationComponent = _class.instanceMethodId(
    r'getLocationComponent',
    r'()Lorg/maplibre/android/location/LocationComponent;',
  );

  static final _getLocationComponent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.location.LocationComponent getLocationComponent()`
  /// The returned object must be released after use, by calling the [release] method.
  locationcomponent_.LocationComponent getLocationComponent() {
    return _getLocationComponent(
            reference.pointer, _id_getLocationComponent as jni.JMethodIDPtr)
        .object(const locationcomponent_.$LocationComponentType());
  }
}

final class $MapLibreMapType extends jni.JObjType<MapLibreMap> {
  const $MapLibreMapType();

  @override
  String get signature => r'Lorg/maplibre/android/maps/MapLibreMap;';

  @override
  MapLibreMap fromReference(jni.JReference reference) =>
      MapLibreMap.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MapLibreMapType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MapLibreMapType) && other is $MapLibreMapType;
  }
}
