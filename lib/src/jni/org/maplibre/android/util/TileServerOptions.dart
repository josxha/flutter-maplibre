// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import 'DefaultStyle.dart' as defaultstyle_;

/// from: `org.maplibre.android.util.TileServerOptions`
class TileServerOptions extends jni.JObject {
  @override
  late final jni.JObjType<TileServerOptions> $type = type;

  TileServerOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/util/TileServerOptions');

  /// The type which includes information such as the signature of this class.
  static const type = $TileServerOptionsType();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;[Lorg/maplibre/android/util/DefaultStyle;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6, java.lang.String string7, java.lang.String string8, java.lang.String string9, java.lang.String string10, java.lang.String string11, java.lang.String string12, java.lang.String string13, java.lang.String string14, java.lang.String string15, java.lang.String string16, java.lang.String string17, boolean z, java.lang.String string18, org.maplibre.android.util.DefaultStyle[] defaultStyles)`
  /// The returned object must be released after use, by calling the [release] method.
  factory TileServerOptions(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
    jni.JString string7,
    jni.JString string8,
    jni.JString string9,
    jni.JString string10,
    jni.JString string11,
    jni.JString string12,
    jni.JString string13,
    jni.JString string14,
    jni.JString string15,
    jni.JString string16,
    jni.JString string17,
    bool z,
    jni.JString string18,
    jni.JArray<defaultstyle_.DefaultStyle> defaultStyles,
  ) {
    return TileServerOptions.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            string5.reference.pointer,
            string6.reference.pointer,
            string7.reference.pointer,
            string8.reference.pointer,
            string9.reference.pointer,
            string10.reference.pointer,
            string11.reference.pointer,
            string12.reference.pointer,
            string13.reference.pointer,
            string14.reference.pointer,
            string15.reference.pointer,
            string16.reference.pointer,
            string17.reference.pointer,
            z ? 1 : 0,
            string18.reference.pointer,
            defaultStyles.reference.pointer)
        .reference);
  }

  static final _id_setBaseURL = _class.instanceMethodId(
    r'setBaseURL',
    r'(Ljava/lang/String;)V',
  );

  static final _setBaseURL = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setBaseURL(java.lang.String string)`
  void setBaseURL(
    jni.JString string,
  ) {
    _setBaseURL(reference.pointer, _id_setBaseURL as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getBaseURL = _class.instanceMethodId(
    r'getBaseURL',
    r'()Ljava/lang/String;',
  );

  static final _getBaseURL = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getBaseURL()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBaseURL() {
    return _getBaseURL(reference.pointer, _id_getBaseURL as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setUriSchemeAlias = _class.instanceMethodId(
    r'setUriSchemeAlias',
    r'(Ljava/lang/String;)V',
  );

  static final _setUriSchemeAlias = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setUriSchemeAlias(java.lang.String string)`
  void setUriSchemeAlias(
    jni.JString string,
  ) {
    _setUriSchemeAlias(reference.pointer,
            _id_setUriSchemeAlias as jni.JMethodIDPtr, string.reference.pointer)
        .check();
  }

  static final _id_getUriSchemeAlias = _class.instanceMethodId(
    r'getUriSchemeAlias',
    r'()Ljava/lang/String;',
  );

  static final _getUriSchemeAlias = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getUriSchemeAlias()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUriSchemeAlias() {
    return _getUriSchemeAlias(
            reference.pointer, _id_getUriSchemeAlias as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setSourceTemplate = _class.instanceMethodId(
    r'setSourceTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setSourceTemplate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setSourceTemplate(java.lang.String string)`
  void setSourceTemplate(
    jni.JString string,
  ) {
    _setSourceTemplate(reference.pointer,
            _id_setSourceTemplate as jni.JMethodIDPtr, string.reference.pointer)
        .check();
  }

  static final _id_getSourceTemplate = _class.instanceMethodId(
    r'getSourceTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getSourceTemplate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getSourceTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSourceTemplate() {
    return _getSourceTemplate(
            reference.pointer, _id_getSourceTemplate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setSourceDomainName = _class.instanceMethodId(
    r'setSourceDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setSourceDomainName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setSourceDomainName(java.lang.String string)`
  void setSourceDomainName(
    jni.JString string,
  ) {
    _setSourceDomainName(
            reference.pointer,
            _id_setSourceDomainName as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getSourceDomainName = _class.instanceMethodId(
    r'getSourceDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getSourceDomainName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getSourceDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSourceDomainName() {
    return _getSourceDomainName(
            reference.pointer, _id_getSourceDomainName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setSourceVersionPrefix = _class.instanceMethodId(
    r'setSourceVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setSourceVersionPrefix = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setSourceVersionPrefix(java.lang.String string)`
  void setSourceVersionPrefix(
    jni.JString string,
  ) {
    _setSourceVersionPrefix(
            reference.pointer,
            _id_setSourceVersionPrefix as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getSourceVersionPrefix = _class.instanceMethodId(
    r'getSourceVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getSourceVersionPrefix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getSourceVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSourceVersionPrefix() {
    return _getSourceVersionPrefix(
            reference.pointer, _id_getSourceVersionPrefix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setStyleTemplate = _class.instanceMethodId(
    r'setStyleTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyleTemplate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setStyleTemplate(java.lang.String string)`
  void setStyleTemplate(
    jni.JString string,
  ) {
    _setStyleTemplate(reference.pointer,
            _id_setStyleTemplate as jni.JMethodIDPtr, string.reference.pointer)
        .check();
  }

  static final _id_getStyleTemplate = _class.instanceMethodId(
    r'getStyleTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getStyleTemplate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getStyleTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getStyleTemplate() {
    return _getStyleTemplate(
            reference.pointer, _id_getStyleTemplate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setStyleDomainName = _class.instanceMethodId(
    r'setStyleDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyleDomainName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setStyleDomainName(java.lang.String string)`
  void setStyleDomainName(
    jni.JString string,
  ) {
    _setStyleDomainName(
            reference.pointer,
            _id_setStyleDomainName as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getStyleDomainName = _class.instanceMethodId(
    r'getStyleDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getStyleDomainName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getStyleDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getStyleDomainName() {
    return _getStyleDomainName(
            reference.pointer, _id_getStyleDomainName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setStyleVersionPrefix = _class.instanceMethodId(
    r'setStyleVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setStyleVersionPrefix = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setStyleVersionPrefix(java.lang.String string)`
  void setStyleVersionPrefix(
    jni.JString string,
  ) {
    _setStyleVersionPrefix(
            reference.pointer,
            _id_setStyleVersionPrefix as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getStyleVersionPrefix = _class.instanceMethodId(
    r'getStyleVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getStyleVersionPrefix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getStyleVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getStyleVersionPrefix() {
    return _getStyleVersionPrefix(
            reference.pointer, _id_getStyleVersionPrefix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setSpritesTemplate = _class.instanceMethodId(
    r'setSpritesTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setSpritesTemplate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setSpritesTemplate(java.lang.String string)`
  void setSpritesTemplate(
    jni.JString string,
  ) {
    _setSpritesTemplate(
            reference.pointer,
            _id_setSpritesTemplate as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getSpritesTemplate = _class.instanceMethodId(
    r'getSpritesTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getSpritesTemplate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getSpritesTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSpritesTemplate() {
    return _getSpritesTemplate(
            reference.pointer, _id_getSpritesTemplate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setSpritesDomainName = _class.instanceMethodId(
    r'setSpritesDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setSpritesDomainName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setSpritesDomainName(java.lang.String string)`
  void setSpritesDomainName(
    jni.JString string,
  ) {
    _setSpritesDomainName(
            reference.pointer,
            _id_setSpritesDomainName as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getSpritesDomainName = _class.instanceMethodId(
    r'getSpritesDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getSpritesDomainName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getSpritesDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSpritesDomainName() {
    return _getSpritesDomainName(
            reference.pointer, _id_getSpritesDomainName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setSpritesVersionPrefix = _class.instanceMethodId(
    r'setSpritesVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setSpritesVersionPrefix = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setSpritesVersionPrefix(java.lang.String string)`
  void setSpritesVersionPrefix(
    jni.JString string,
  ) {
    _setSpritesVersionPrefix(
            reference.pointer,
            _id_setSpritesVersionPrefix as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getSpritesVersionPrefix = _class.instanceMethodId(
    r'getSpritesVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getSpritesVersionPrefix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getSpritesVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSpritesVersionPrefix() {
    return _getSpritesVersionPrefix(
            reference.pointer, _id_getSpritesVersionPrefix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setGlyphsTemplate = _class.instanceMethodId(
    r'setGlyphsTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setGlyphsTemplate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setGlyphsTemplate(java.lang.String string)`
  void setGlyphsTemplate(
    jni.JString string,
  ) {
    _setGlyphsTemplate(reference.pointer,
            _id_setGlyphsTemplate as jni.JMethodIDPtr, string.reference.pointer)
        .check();
  }

  static final _id_getGlyphsTemplate = _class.instanceMethodId(
    r'getGlyphsTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getGlyphsTemplate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getGlyphsTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getGlyphsTemplate() {
    return _getGlyphsTemplate(
            reference.pointer, _id_getGlyphsTemplate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setGlyphsDomainName = _class.instanceMethodId(
    r'setGlyphsDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setGlyphsDomainName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setGlyphsDomainName(java.lang.String string)`
  void setGlyphsDomainName(
    jni.JString string,
  ) {
    _setGlyphsDomainName(
            reference.pointer,
            _id_setGlyphsDomainName as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getGlyphsDomainName = _class.instanceMethodId(
    r'getGlyphsDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getGlyphsDomainName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getGlyphsDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getGlyphsDomainName() {
    return _getGlyphsDomainName(
            reference.pointer, _id_getGlyphsDomainName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setGlyphsVersionPrefix = _class.instanceMethodId(
    r'setGlyphsVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setGlyphsVersionPrefix = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setGlyphsVersionPrefix(java.lang.String string)`
  void setGlyphsVersionPrefix(
    jni.JString string,
  ) {
    _setGlyphsVersionPrefix(
            reference.pointer,
            _id_setGlyphsVersionPrefix as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getGlyphsVersionPrefix = _class.instanceMethodId(
    r'getGlyphsVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getGlyphsVersionPrefix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getGlyphsVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getGlyphsVersionPrefix() {
    return _getGlyphsVersionPrefix(
            reference.pointer, _id_getGlyphsVersionPrefix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setTileTemplate = _class.instanceMethodId(
    r'setTileTemplate',
    r'(Ljava/lang/String;)V',
  );

  static final _setTileTemplate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setTileTemplate(java.lang.String string)`
  void setTileTemplate(
    jni.JString string,
  ) {
    _setTileTemplate(reference.pointer, _id_setTileTemplate as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getTileTemplate = _class.instanceMethodId(
    r'getTileTemplate',
    r'()Ljava/lang/String;',
  );

  static final _getTileTemplate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTileTemplate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTileTemplate() {
    return _getTileTemplate(
            reference.pointer, _id_getTileTemplate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setTileDomainName = _class.instanceMethodId(
    r'setTileDomainName',
    r'(Ljava/lang/String;)V',
  );

  static final _setTileDomainName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setTileDomainName(java.lang.String string)`
  void setTileDomainName(
    jni.JString string,
  ) {
    _setTileDomainName(reference.pointer,
            _id_setTileDomainName as jni.JMethodIDPtr, string.reference.pointer)
        .check();
  }

  static final _id_getTileDomainName = _class.instanceMethodId(
    r'getTileDomainName',
    r'()Ljava/lang/String;',
  );

  static final _getTileDomainName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTileDomainName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTileDomainName() {
    return _getTileDomainName(
            reference.pointer, _id_getTileDomainName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setTileVersionPrefix = _class.instanceMethodId(
    r'setTileVersionPrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setTileVersionPrefix = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setTileVersionPrefix(java.lang.String string)`
  void setTileVersionPrefix(
    jni.JString string,
  ) {
    _setTileVersionPrefix(
            reference.pointer,
            _id_setTileVersionPrefix as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getTileVersionPrefix = _class.instanceMethodId(
    r'getTileVersionPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getTileVersionPrefix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTileVersionPrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTileVersionPrefix() {
    return _getTileVersionPrefix(
            reference.pointer, _id_getTileVersionPrefix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setApiKeyParameterName = _class.instanceMethodId(
    r'setApiKeyParameterName',
    r'(Ljava/lang/String;)V',
  );

  static final _setApiKeyParameterName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setApiKeyParameterName(java.lang.String string)`
  void setApiKeyParameterName(
    jni.JString string,
  ) {
    _setApiKeyParameterName(
            reference.pointer,
            _id_setApiKeyParameterName as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getApiKeyParameterName = _class.instanceMethodId(
    r'getApiKeyParameterName',
    r'()Ljava/lang/String;',
  );

  static final _getApiKeyParameterName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getApiKeyParameterName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getApiKeyParameterName() {
    return _getApiKeyParameterName(
            reference.pointer, _id_getApiKeyParameterName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setApiKeyRequired = _class.instanceMethodId(
    r'setApiKeyRequired',
    r'(Z)V',
  );

  static final _setApiKeyRequired = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setApiKeyRequired(boolean z)`
  void setApiKeyRequired(
    bool z,
  ) {
    _setApiKeyRequired(reference.pointer,
            _id_setApiKeyRequired as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getApiKeyRequired = _class.instanceMethodId(
    r'getApiKeyRequired',
    r'()Z',
  );

  static final _getApiKeyRequired = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getApiKeyRequired()`
  bool getApiKeyRequired() {
    return _getApiKeyRequired(
            reference.pointer, _id_getApiKeyRequired as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setDefaultStyles = _class.instanceMethodId(
    r'setDefaultStyles',
    r'([Lorg/maplibre/android/util/DefaultStyle;)V',
  );

  static final _setDefaultStyles = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setDefaultStyles(org.maplibre.android.util.DefaultStyle[] defaultStyles)`
  void setDefaultStyles(
    jni.JArray<defaultstyle_.DefaultStyle> defaultStyles,
  ) {
    _setDefaultStyles(
            reference.pointer,
            _id_setDefaultStyles as jni.JMethodIDPtr,
            defaultStyles.reference.pointer)
        .check();
  }

  static final _id_getDefaultStyles = _class.instanceMethodId(
    r'getDefaultStyles',
    r'()[Lorg/maplibre/android/util/DefaultStyle;',
  );

  static final _getDefaultStyles = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.maplibre.android.util.DefaultStyle[] getDefaultStyles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<defaultstyle_.DefaultStyle> getDefaultStyles() {
    return _getDefaultStyles(
            reference.pointer, _id_getDefaultStyles as jni.JMethodIDPtr)
        .object(const jni.JArrayType(defaultstyle_.$DefaultStyleType()));
  }

  static final _id_setDefaultStyle = _class.instanceMethodId(
    r'setDefaultStyle',
    r'(Ljava/lang/String;)V',
  );

  static final _setDefaultStyle = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setDefaultStyle(java.lang.String string)`
  void setDefaultStyle(
    jni.JString string,
  ) {
    _setDefaultStyle(reference.pointer, _id_setDefaultStyle as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_getDefaultStyle = _class.instanceMethodId(
    r'getDefaultStyle',
    r'()Ljava/lang/String;',
  );

  static final _getDefaultStyle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDefaultStyle()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDefaultStyle() {
    return _getDefaultStyle(
            reference.pointer, _id_getDefaultStyle as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_new1 = _class.constructorId(
    r'(Landroid/os/Parcel;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `protected void <init>(android.os.Parcel parcel)`
  /// The returned object must be released after use, by calling the [release] method.
  factory TileServerOptions.new1(
    jni.JObject parcel,
  ) {
    return TileServerOptions.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, parcel.reference.pointer)
        .reference);
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, _id_writeToParcel as jni.JMethodIDPtr,
            parcel.reference.pointer, i)
        .check();
  }

  static final _id_get0 = _class.staticMethodId(
    r'get',
    r'(Lorg/maplibre/android/WellKnownTileServer;)Lorg/maplibre/android/util/TileServerOptions;',
  );

  static final _get0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public org.maplibre.android.util.TileServerOptions get(org.maplibre.android.WellKnownTileServer wellKnownTileServer)`
  /// The returned object must be released after use, by calling the [release] method.
  static TileServerOptions get0(
    jni.JObject wellKnownTileServer,
  ) {
    return _get0(_class.reference.pointer, _id_get0 as jni.JMethodIDPtr,
            wellKnownTileServer.reference.pointer)
        .object(const $TileServerOptionsType());
  }
}

final class $TileServerOptionsType extends jni.JObjType<TileServerOptions> {
  const $TileServerOptionsType();

  @override
  String get signature => r'Lorg/maplibre/android/util/TileServerOptions;';

  @override
  TileServerOptions fromReference(jni.JReference reference) =>
      TileServerOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($TileServerOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TileServerOptionsType) &&
        other is $TileServerOptionsType;
  }
}
