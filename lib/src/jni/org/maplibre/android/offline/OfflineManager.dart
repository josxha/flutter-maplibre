// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import 'OfflineRegion.dart' as offlineregion_;

import 'OfflineRegionDefinition.dart' as offlineregiondefinition_;

/// from: `org.maplibre.android.offline.OfflineManager$Companion`
class OfflineManager_Companion extends jni.JObject {
  @override
  late final jni.JObjType<OfflineManager_Companion> $type = type;

  OfflineManager_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineManager$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineManager_CompanionType();
  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Landroid/content/Context;)Lorg/maplibre/android/offline/OfflineManager;',
  );

  static final _getInstance = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final org.maplibre.android.offline.OfflineManager getInstance(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  OfflineManager getInstance(
    jni.JObject context,
  ) {
    return _getInstance(reference.pointer, _id_getInstance as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const $OfflineManagerType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OfflineManager_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return OfflineManager_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $OfflineManager_CompanionType
    extends jni.JObjType<OfflineManager_Companion> {
  const $OfflineManager_CompanionType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineManager$Companion;';

  @override
  OfflineManager_Companion fromReference(jni.JReference reference) =>
      OfflineManager_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineManager_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineManager_CompanionType) &&
        other is $OfflineManager_CompanionType;
  }
}

/// from: `org.maplibre.android.offline.OfflineManager$CreateOfflineRegionCallback`
class OfflineManager_CreateOfflineRegionCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineManager_CreateOfflineRegionCallback> $type =
      type;

  OfflineManager_CreateOfflineRegionCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineManager$CreateOfflineRegionCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineManager_CreateOfflineRegionCallbackType();
  static final _id_onCreate = _class.instanceMethodId(
    r'onCreate',
    r'(Lorg/maplibre/android/offline/OfflineRegion;)V',
  );

  static final _onCreate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onCreate(org.maplibre.android.offline.OfflineRegion offlineRegion)`
  void onCreate(
    offlineregion_.OfflineRegion offlineRegion,
  ) {
    _onCreate(reference.pointer, _id_onCreate as jni.JMethodIDPtr,
            offlineRegion.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineManager_CreateOfflineRegionCallbackImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCreate(Lorg/maplibre/android/offline/OfflineRegion;)V') {
        _$impls[$p]!.onCreate(
          $a[0].castTo(const offlineregion_.$OfflineRegionType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineManager_CreateOfflineRegionCallback.implement(
    $OfflineManager_CreateOfflineRegionCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineManager_CreateOfflineRegionCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineManager$CreateOfflineRegionCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineManager_CreateOfflineRegionCallbackImpl {
  factory $OfflineManager_CreateOfflineRegionCallbackImpl({
    required void Function(offlineregion_.OfflineRegion offlineRegion) onCreate,
    required void Function(jni.JString string) onError,
  }) = _$OfflineManager_CreateOfflineRegionCallbackImpl;

  void onCreate(offlineregion_.OfflineRegion offlineRegion);
  void onError(jni.JString string);
}

class _$OfflineManager_CreateOfflineRegionCallbackImpl
    implements $OfflineManager_CreateOfflineRegionCallbackImpl {
  _$OfflineManager_CreateOfflineRegionCallbackImpl({
    required void Function(offlineregion_.OfflineRegion offlineRegion) onCreate,
    required void Function(jni.JString string) onError,
  })  : _onCreate = onCreate,
        _onError = onError;

  final void Function(offlineregion_.OfflineRegion offlineRegion) _onCreate;
  final void Function(jni.JString string) _onError;

  void onCreate(offlineregion_.OfflineRegion offlineRegion) {
    return _onCreate(offlineRegion);
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineManager_CreateOfflineRegionCallbackType
    extends jni.JObjType<OfflineManager_CreateOfflineRegionCallback> {
  const $OfflineManager_CreateOfflineRegionCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineManager$CreateOfflineRegionCallback;';

  @override
  OfflineManager_CreateOfflineRegionCallback fromReference(
          jni.JReference reference) =>
      OfflineManager_CreateOfflineRegionCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($OfflineManager_CreateOfflineRegionCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineManager_CreateOfflineRegionCallbackType) &&
        other is $OfflineManager_CreateOfflineRegionCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineManager$FileSourceCallback`
class OfflineManager_FileSourceCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineManager_FileSourceCallback> $type = type;

  OfflineManager_FileSourceCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineManager$FileSourceCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineManager_FileSourceCallbackType();
  static final _id_onSuccess = _class.instanceMethodId(
    r'onSuccess',
    r'()V',
  );

  static final _onSuccess = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onSuccess()`
  void onSuccess() {
    _onSuccess(reference.pointer, _id_onSuccess as jni.JMethodIDPtr).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineManager_FileSourceCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSuccess()V') {
        _$impls[$p]!.onSuccess();
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineManager_FileSourceCallback.implement(
    $OfflineManager_FileSourceCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineManager_FileSourceCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineManager$FileSourceCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineManager_FileSourceCallbackImpl {
  factory $OfflineManager_FileSourceCallbackImpl({
    required void Function() onSuccess,
    required void Function(jni.JString string) onError,
  }) = _$OfflineManager_FileSourceCallbackImpl;

  void onSuccess();
  void onError(jni.JString string);
}

class _$OfflineManager_FileSourceCallbackImpl
    implements $OfflineManager_FileSourceCallbackImpl {
  _$OfflineManager_FileSourceCallbackImpl({
    required void Function() onSuccess,
    required void Function(jni.JString string) onError,
  })  : _onSuccess = onSuccess,
        _onError = onError;

  final void Function() _onSuccess;
  final void Function(jni.JString string) _onError;

  void onSuccess() {
    return _onSuccess();
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineManager_FileSourceCallbackType
    extends jni.JObjType<OfflineManager_FileSourceCallback> {
  const $OfflineManager_FileSourceCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineManager$FileSourceCallback;';

  @override
  OfflineManager_FileSourceCallback fromReference(jni.JReference reference) =>
      OfflineManager_FileSourceCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineManager_FileSourceCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineManager_FileSourceCallbackType) &&
        other is $OfflineManager_FileSourceCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineManager$GetOfflineRegionCallback`
class OfflineManager_GetOfflineRegionCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineManager_GetOfflineRegionCallback> $type = type;

  OfflineManager_GetOfflineRegionCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineManager$GetOfflineRegionCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineManager_GetOfflineRegionCallbackType();
  static final _id_onRegion = _class.instanceMethodId(
    r'onRegion',
    r'(Lorg/maplibre/android/offline/OfflineRegion;)V',
  );

  static final _onRegion = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onRegion(org.maplibre.android.offline.OfflineRegion offlineRegion)`
  void onRegion(
    offlineregion_.OfflineRegion offlineRegion,
  ) {
    _onRegion(reference.pointer, _id_onRegion as jni.JMethodIDPtr,
            offlineRegion.reference.pointer)
        .check();
  }

  static final _id_onRegionNotFound = _class.instanceMethodId(
    r'onRegionNotFound',
    r'()V',
  );

  static final _onRegionNotFound = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onRegionNotFound()`
  void onRegionNotFound() {
    _onRegionNotFound(
            reference.pointer, _id_onRegionNotFound as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineManager_GetOfflineRegionCallbackImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onRegion(Lorg/maplibre/android/offline/OfflineRegion;)V') {
        _$impls[$p]!.onRegion(
          $a[0].castTo(const offlineregion_.$OfflineRegionType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onRegionNotFound()V') {
        _$impls[$p]!.onRegionNotFound();
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineManager_GetOfflineRegionCallback.implement(
    $OfflineManager_GetOfflineRegionCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineManager_GetOfflineRegionCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineManager$GetOfflineRegionCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineManager_GetOfflineRegionCallbackImpl {
  factory $OfflineManager_GetOfflineRegionCallbackImpl({
    required void Function(offlineregion_.OfflineRegion offlineRegion) onRegion,
    required void Function() onRegionNotFound,
    required void Function(jni.JString string) onError,
  }) = _$OfflineManager_GetOfflineRegionCallbackImpl;

  void onRegion(offlineregion_.OfflineRegion offlineRegion);
  void onRegionNotFound();
  void onError(jni.JString string);
}

class _$OfflineManager_GetOfflineRegionCallbackImpl
    implements $OfflineManager_GetOfflineRegionCallbackImpl {
  _$OfflineManager_GetOfflineRegionCallbackImpl({
    required void Function(offlineregion_.OfflineRegion offlineRegion) onRegion,
    required void Function() onRegionNotFound,
    required void Function(jni.JString string) onError,
  })  : _onRegion = onRegion,
        _onRegionNotFound = onRegionNotFound,
        _onError = onError;

  final void Function(offlineregion_.OfflineRegion offlineRegion) _onRegion;
  final void Function() _onRegionNotFound;
  final void Function(jni.JString string) _onError;

  void onRegion(offlineregion_.OfflineRegion offlineRegion) {
    return _onRegion(offlineRegion);
  }

  void onRegionNotFound() {
    return _onRegionNotFound();
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineManager_GetOfflineRegionCallbackType
    extends jni.JObjType<OfflineManager_GetOfflineRegionCallback> {
  const $OfflineManager_GetOfflineRegionCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineManager$GetOfflineRegionCallback;';

  @override
  OfflineManager_GetOfflineRegionCallback fromReference(
          jni.JReference reference) =>
      OfflineManager_GetOfflineRegionCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineManager_GetOfflineRegionCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineManager_GetOfflineRegionCallbackType) &&
        other is $OfflineManager_GetOfflineRegionCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineManager$ListOfflineRegionsCallback`
class OfflineManager_ListOfflineRegionsCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineManager_ListOfflineRegionsCallback> $type =
      type;

  OfflineManager_ListOfflineRegionsCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineManager$ListOfflineRegionsCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineManager_ListOfflineRegionsCallbackType();
  static final _id_onList = _class.instanceMethodId(
    r'onList',
    r'([Lorg/maplibre/android/offline/OfflineRegion;)V',
  );

  static final _onList = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onList(org.maplibre.android.offline.OfflineRegion[] offlineRegions)`
  void onList(
    jni.JArray<offlineregion_.OfflineRegion> offlineRegions,
  ) {
    _onList(reference.pointer, _id_onList as jni.JMethodIDPtr,
            offlineRegions.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineManager_ListOfflineRegionsCallbackImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onList([Lorg/maplibre/android/offline/OfflineRegion;)V') {
        _$impls[$p]!.onList(
          $a[0].castTo(
              const jni.JArrayType(offlineregion_.$OfflineRegionType()),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineManager_ListOfflineRegionsCallback.implement(
    $OfflineManager_ListOfflineRegionsCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineManager_ListOfflineRegionsCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineManager$ListOfflineRegionsCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineManager_ListOfflineRegionsCallbackImpl {
  factory $OfflineManager_ListOfflineRegionsCallbackImpl({
    required void Function(
            jni.JArray<offlineregion_.OfflineRegion> offlineRegions)
        onList,
    required void Function(jni.JString string) onError,
  }) = _$OfflineManager_ListOfflineRegionsCallbackImpl;

  void onList(jni.JArray<offlineregion_.OfflineRegion> offlineRegions);
  void onError(jni.JString string);
}

class _$OfflineManager_ListOfflineRegionsCallbackImpl
    implements $OfflineManager_ListOfflineRegionsCallbackImpl {
  _$OfflineManager_ListOfflineRegionsCallbackImpl({
    required void Function(
            jni.JArray<offlineregion_.OfflineRegion> offlineRegions)
        onList,
    required void Function(jni.JString string) onError,
  })  : _onList = onList,
        _onError = onError;

  final void Function(jni.JArray<offlineregion_.OfflineRegion> offlineRegions)
      _onList;
  final void Function(jni.JString string) _onError;

  void onList(jni.JArray<offlineregion_.OfflineRegion> offlineRegions) {
    return _onList(offlineRegions);
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineManager_ListOfflineRegionsCallbackType
    extends jni.JObjType<OfflineManager_ListOfflineRegionsCallback> {
  const $OfflineManager_ListOfflineRegionsCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineManager$ListOfflineRegionsCallback;';

  @override
  OfflineManager_ListOfflineRegionsCallback fromReference(
          jni.JReference reference) =>
      OfflineManager_ListOfflineRegionsCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineManager_ListOfflineRegionsCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineManager_ListOfflineRegionsCallbackType) &&
        other is $OfflineManager_ListOfflineRegionsCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineManager$MergeOfflineRegionsCallback`
class OfflineManager_MergeOfflineRegionsCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineManager_MergeOfflineRegionsCallback> $type =
      type;

  OfflineManager_MergeOfflineRegionsCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineManager$MergeOfflineRegionsCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineManager_MergeOfflineRegionsCallbackType();
  static final _id_onMerge = _class.instanceMethodId(
    r'onMerge',
    r'([Lorg/maplibre/android/offline/OfflineRegion;)V',
  );

  static final _onMerge = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onMerge(org.maplibre.android.offline.OfflineRegion[] offlineRegions)`
  void onMerge(
    jni.JArray<offlineregion_.OfflineRegion> offlineRegions,
  ) {
    _onMerge(reference.pointer, _id_onMerge as jni.JMethodIDPtr,
            offlineRegions.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineManager_MergeOfflineRegionsCallbackImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onMerge([Lorg/maplibre/android/offline/OfflineRegion;)V') {
        _$impls[$p]!.onMerge(
          $a[0].castTo(
              const jni.JArrayType(offlineregion_.$OfflineRegionType()),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineManager_MergeOfflineRegionsCallback.implement(
    $OfflineManager_MergeOfflineRegionsCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineManager_MergeOfflineRegionsCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineManager$MergeOfflineRegionsCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineManager_MergeOfflineRegionsCallbackImpl {
  factory $OfflineManager_MergeOfflineRegionsCallbackImpl({
    required void Function(
            jni.JArray<offlineregion_.OfflineRegion> offlineRegions)
        onMerge,
    required void Function(jni.JString string) onError,
  }) = _$OfflineManager_MergeOfflineRegionsCallbackImpl;

  void onMerge(jni.JArray<offlineregion_.OfflineRegion> offlineRegions);
  void onError(jni.JString string);
}

class _$OfflineManager_MergeOfflineRegionsCallbackImpl
    implements $OfflineManager_MergeOfflineRegionsCallbackImpl {
  _$OfflineManager_MergeOfflineRegionsCallbackImpl({
    required void Function(
            jni.JArray<offlineregion_.OfflineRegion> offlineRegions)
        onMerge,
    required void Function(jni.JString string) onError,
  })  : _onMerge = onMerge,
        _onError = onError;

  final void Function(jni.JArray<offlineregion_.OfflineRegion> offlineRegions)
      _onMerge;
  final void Function(jni.JString string) _onError;

  void onMerge(jni.JArray<offlineregion_.OfflineRegion> offlineRegions) {
    return _onMerge(offlineRegions);
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineManager_MergeOfflineRegionsCallbackType
    extends jni.JObjType<OfflineManager_MergeOfflineRegionsCallback> {
  const $OfflineManager_MergeOfflineRegionsCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineManager$MergeOfflineRegionsCallback;';

  @override
  OfflineManager_MergeOfflineRegionsCallback fromReference(
          jni.JReference reference) =>
      OfflineManager_MergeOfflineRegionsCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($OfflineManager_MergeOfflineRegionsCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineManager_MergeOfflineRegionsCallbackType) &&
        other is $OfflineManager_MergeOfflineRegionsCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineManager`
class OfflineManager extends jni.JObject {
  @override
  late final jni.JObjType<OfflineManager> $type = type;

  OfflineManager.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/offline/OfflineManager');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineManagerType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lorg/maplibre/android/offline/OfflineManager$Companion;',
  );

  /// from: `static public final org.maplibre.android.offline.OfflineManager$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static OfflineManager_Companion get Companion =>
      _id_Companion.get(_class, const $OfflineManager_CompanionType());

  static final _id_listOfflineRegions = _class.instanceMethodId(
    r'listOfflineRegions',
    r'(Lorg/maplibre/android/offline/OfflineManager$ListOfflineRegionsCallback;)V',
  );

  static final _listOfflineRegions = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void listOfflineRegions(org.maplibre.android.offline.OfflineManager$ListOfflineRegionsCallback listOfflineRegionsCallback)`
  void listOfflineRegions(
    OfflineManager_ListOfflineRegionsCallback listOfflineRegionsCallback,
  ) {
    _listOfflineRegions(
            reference.pointer,
            _id_listOfflineRegions as jni.JMethodIDPtr,
            listOfflineRegionsCallback.reference.pointer)
        .check();
  }

  static final _id_getOfflineRegion = _class.instanceMethodId(
    r'getOfflineRegion',
    r'(JLorg/maplibre/android/offline/OfflineManager$GetOfflineRegionCallback;)V',
  );

  static final _getOfflineRegion = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void getOfflineRegion(long j, org.maplibre.android.offline.OfflineManager$GetOfflineRegionCallback getOfflineRegionCallback)`
  void getOfflineRegion(
    int j,
    OfflineManager_GetOfflineRegionCallback getOfflineRegionCallback,
  ) {
    _getOfflineRegion(
            reference.pointer,
            _id_getOfflineRegion as jni.JMethodIDPtr,
            j,
            getOfflineRegionCallback.reference.pointer)
        .check();
  }

  static final _id_mergeOfflineRegions = _class.instanceMethodId(
    r'mergeOfflineRegions',
    r'(Ljava/lang/String;Lorg/maplibre/android/offline/OfflineManager$MergeOfflineRegionsCallback;)V',
  );

  static final _mergeOfflineRegions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void mergeOfflineRegions(java.lang.String string, org.maplibre.android.offline.OfflineManager$MergeOfflineRegionsCallback mergeOfflineRegionsCallback)`
  void mergeOfflineRegions(
    jni.JString string,
    OfflineManager_MergeOfflineRegionsCallback mergeOfflineRegionsCallback,
  ) {
    _mergeOfflineRegions(
            reference.pointer,
            _id_mergeOfflineRegions as jni.JMethodIDPtr,
            string.reference.pointer,
            mergeOfflineRegionsCallback.reference.pointer)
        .check();
  }

  static final _id_resetDatabase = _class.instanceMethodId(
    r'resetDatabase',
    r'(Lorg/maplibre/android/offline/OfflineManager$FileSourceCallback;)V',
  );

  static final _resetDatabase = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void resetDatabase(org.maplibre.android.offline.OfflineManager$FileSourceCallback fileSourceCallback)`
  void resetDatabase(
    OfflineManager_FileSourceCallback fileSourceCallback,
  ) {
    _resetDatabase(reference.pointer, _id_resetDatabase as jni.JMethodIDPtr,
            fileSourceCallback.reference.pointer)
        .check();
  }

  static final _id_packDatabase = _class.instanceMethodId(
    r'packDatabase',
    r'(Lorg/maplibre/android/offline/OfflineManager$FileSourceCallback;)V',
  );

  static final _packDatabase = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void packDatabase(org.maplibre.android.offline.OfflineManager$FileSourceCallback fileSourceCallback)`
  void packDatabase(
    OfflineManager_FileSourceCallback fileSourceCallback,
  ) {
    _packDatabase(reference.pointer, _id_packDatabase as jni.JMethodIDPtr,
            fileSourceCallback.reference.pointer)
        .check();
  }

  static final _id_invalidateAmbientCache = _class.instanceMethodId(
    r'invalidateAmbientCache',
    r'(Lorg/maplibre/android/offline/OfflineManager$FileSourceCallback;)V',
  );

  static final _invalidateAmbientCache = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void invalidateAmbientCache(org.maplibre.android.offline.OfflineManager$FileSourceCallback fileSourceCallback)`
  void invalidateAmbientCache(
    OfflineManager_FileSourceCallback fileSourceCallback,
  ) {
    _invalidateAmbientCache(
            reference.pointer,
            _id_invalidateAmbientCache as jni.JMethodIDPtr,
            fileSourceCallback.reference.pointer)
        .check();
  }

  static final _id_clearAmbientCache = _class.instanceMethodId(
    r'clearAmbientCache',
    r'(Lorg/maplibre/android/offline/OfflineManager$FileSourceCallback;)V',
  );

  static final _clearAmbientCache = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void clearAmbientCache(org.maplibre.android.offline.OfflineManager$FileSourceCallback fileSourceCallback)`
  void clearAmbientCache(
    OfflineManager_FileSourceCallback fileSourceCallback,
  ) {
    _clearAmbientCache(
            reference.pointer,
            _id_clearAmbientCache as jni.JMethodIDPtr,
            fileSourceCallback.reference.pointer)
        .check();
  }

  static final _id_setMaximumAmbientCacheSize = _class.instanceMethodId(
    r'setMaximumAmbientCacheSize',
    r'(JLorg/maplibre/android/offline/OfflineManager$FileSourceCallback;)V',
  );

  static final _setMaximumAmbientCacheSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void setMaximumAmbientCacheSize(long j, org.maplibre.android.offline.OfflineManager$FileSourceCallback fileSourceCallback)`
  void setMaximumAmbientCacheSize(
    int j,
    OfflineManager_FileSourceCallback fileSourceCallback,
  ) {
    _setMaximumAmbientCacheSize(
            reference.pointer,
            _id_setMaximumAmbientCacheSize as jni.JMethodIDPtr,
            j,
            fileSourceCallback.reference.pointer)
        .check();
  }

  static final _id_createOfflineRegion = _class.instanceMethodId(
    r'createOfflineRegion',
    r'(Lorg/maplibre/android/offline/OfflineRegionDefinition;[BLorg/maplibre/android/offline/OfflineManager$CreateOfflineRegionCallback;)V',
  );

  static final _createOfflineRegion = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void createOfflineRegion(org.maplibre.android.offline.OfflineRegionDefinition offlineRegionDefinition, byte[] bs, org.maplibre.android.offline.OfflineManager$CreateOfflineRegionCallback createOfflineRegionCallback)`
  void createOfflineRegion(
    offlineregiondefinition_.OfflineRegionDefinition offlineRegionDefinition,
    jni.JArray<jni.jbyte> bs,
    OfflineManager_CreateOfflineRegionCallback createOfflineRegionCallback,
  ) {
    _createOfflineRegion(
            reference.pointer,
            _id_createOfflineRegion as jni.JMethodIDPtr,
            offlineRegionDefinition.reference.pointer,
            bs.reference.pointer,
            createOfflineRegionCallback.reference.pointer)
        .check();
  }

  static final _id_setOfflineMapboxTileCountLimit = _class.instanceMethodId(
    r'setOfflineMapboxTileCountLimit',
    r'(J)V',
  );

  static final _setOfflineMapboxTileCountLimit = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public native final void setOfflineMapboxTileCountLimit(long j)`
  void setOfflineMapboxTileCountLimit(
    int j,
  ) {
    _setOfflineMapboxTileCountLimit(reference.pointer,
            _id_setOfflineMapboxTileCountLimit as jni.JMethodIDPtr, j)
        .check();
  }

  static final _id_runPackDatabaseAutomatically = _class.instanceMethodId(
    r'runPackDatabaseAutomatically',
    r'(Z)V',
  );

  static final _runPackDatabaseAutomatically = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public native final void runPackDatabaseAutomatically(boolean z)`
  void runPackDatabaseAutomatically(
    bool z,
  ) {
    _runPackDatabaseAutomatically(reference.pointer,
            _id_runPackDatabaseAutomatically as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_finalize = _class.instanceMethodId(
    r'finalize',
    r'()V',
  );

  static final _finalize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `protected native final void finalize()`
  void finalize() {
    _finalize(reference.pointer, _id_finalize as jni.JMethodIDPtr).check();
  }

  static final _id_putResourceWithUrl = _class.instanceMethodId(
    r'putResourceWithUrl',
    r'(Ljava/lang/String;[BJJLjava/lang/String;Z)V',
  );

  static final _putResourceWithUrl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: `public native final void putResourceWithUrl(java.lang.String string, byte[] bs, long j, long j1, java.lang.String string1, boolean z)`
  void putResourceWithUrl(
    jni.JString string,
    jni.JArray<jni.jbyte> bs,
    int j,
    int j1,
    jni.JString string1,
    bool z,
  ) {
    _putResourceWithUrl(
            reference.pointer,
            _id_putResourceWithUrl as jni.JMethodIDPtr,
            string.reference.pointer,
            bs.reference.pointer,
            j,
            j1,
            string1.reference.pointer,
            z ? 1 : 0)
        .check();
  }

  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'(Landroid/content/Context;)Lorg/maplibre/android/offline/OfflineManager;',
  );

  static final _getInstance = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public final org.maplibre.android.offline.OfflineManager getInstance(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static OfflineManager getInstance(
    jni.JObject context,
  ) {
    return _getInstance(_class.reference.pointer,
            _id_getInstance as jni.JMethodIDPtr, context.reference.pointer)
        .object(const $OfflineManagerType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Landroid/content/Context;Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(android.content.Context context, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OfflineManager(
    jni.JObject context,
    jni.JObject defaultConstructorMarker,
  ) {
    return OfflineManager.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            context.reference.pointer,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $OfflineManagerType extends jni.JObjType<OfflineManager> {
  const $OfflineManagerType();

  @override
  String get signature => r'Lorg/maplibre/android/offline/OfflineManager;';

  @override
  OfflineManager fromReference(jni.JReference reference) =>
      OfflineManager.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineManagerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineManagerType) &&
        other is $OfflineManagerType;
  }
}
