// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import 'OfflineRegionDefinition.dart' as offlineregiondefinition_;

import 'OfflineRegionError.dart' as offlineregionerror_;

import 'OfflineRegionStatus.dart' as offlineregionstatus_;

/// from: `org.maplibre.android.offline.OfflineRegion$Companion`
class OfflineRegion_Companion extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_Companion> $type = type;

  OfflineRegion_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_CompanionType();
  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OfflineRegion_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return OfflineRegion_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $OfflineRegion_CompanionType
    extends jni.JObjType<OfflineRegion_Companion> {
  const $OfflineRegion_CompanionType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$Companion;';

  @override
  OfflineRegion_Companion fromReference(jni.JReference reference) =>
      OfflineRegion_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_CompanionType) &&
        other is $OfflineRegion_CompanionType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$DownloadState`
class OfflineRegion_DownloadState extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_DownloadState> $type = type;

  OfflineRegion_DownloadState.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$DownloadState');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_DownloadStateType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineRegion_DownloadStateImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineRegion_DownloadState.implement(
    $OfflineRegion_DownloadStateImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineRegion_DownloadState.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineRegion$DownloadState',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineRegion_DownloadStateImpl {
  factory $OfflineRegion_DownloadStateImpl() =
      _$OfflineRegion_DownloadStateImpl;
}

class _$OfflineRegion_DownloadStateImpl
    implements $OfflineRegion_DownloadStateImpl {
  _$OfflineRegion_DownloadStateImpl();
}

final class $OfflineRegion_DownloadStateType
    extends jni.JObjType<OfflineRegion_DownloadState> {
  const $OfflineRegion_DownloadStateType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$DownloadState;';

  @override
  OfflineRegion_DownloadState fromReference(jni.JReference reference) =>
      OfflineRegion_DownloadState.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_DownloadStateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_DownloadStateType) &&
        other is $OfflineRegion_DownloadStateType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback`
class OfflineRegion_OfflineRegionDeleteCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionDeleteCallback> $type =
      type;

  OfflineRegion_OfflineRegionDeleteCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionDeleteCallbackType();
  static final _id_onDelete = _class.instanceMethodId(
    r'onDelete',
    r'()V',
  );

  static final _onDelete = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onDelete()`
  void onDelete() {
    _onDelete(reference.pointer, _id_onDelete as jni.JMethodIDPtr).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineRegion_OfflineRegionDeleteCallbackImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDelete()V') {
        _$impls[$p]!.onDelete();
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineRegion_OfflineRegionDeleteCallback.implement(
    $OfflineRegion_OfflineRegionDeleteCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineRegion_OfflineRegionDeleteCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineRegion_OfflineRegionDeleteCallbackImpl {
  factory $OfflineRegion_OfflineRegionDeleteCallbackImpl({
    required void Function() onDelete,
    required void Function(jni.JString string) onError,
  }) = _$OfflineRegion_OfflineRegionDeleteCallbackImpl;

  void onDelete();
  void onError(jni.JString string);
}

class _$OfflineRegion_OfflineRegionDeleteCallbackImpl
    implements $OfflineRegion_OfflineRegionDeleteCallbackImpl {
  _$OfflineRegion_OfflineRegionDeleteCallbackImpl({
    required void Function() onDelete,
    required void Function(jni.JString string) onError,
  })  : _onDelete = onDelete,
        _onError = onError;

  final void Function() _onDelete;
  final void Function(jni.JString string) _onError;

  void onDelete() {
    return _onDelete();
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion_OfflineRegionDeleteCallbackType
    extends jni.JObjType<OfflineRegion_OfflineRegionDeleteCallback> {
  const $OfflineRegion_OfflineRegionDeleteCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;';

  @override
  OfflineRegion_OfflineRegionDeleteCallback fromReference(
          jni.JReference reference) =>
      OfflineRegion_OfflineRegionDeleteCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_OfflineRegionDeleteCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionDeleteCallbackType) &&
        other is $OfflineRegion_OfflineRegionDeleteCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback`
class OfflineRegion_OfflineRegionInvalidateCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionInvalidateCallback> $type =
      type;

  OfflineRegion_OfflineRegionInvalidateCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionInvalidateCallbackType();
  static final _id_onInvalidate = _class.instanceMethodId(
    r'onInvalidate',
    r'()V',
  );

  static final _onInvalidate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onInvalidate()`
  void onInvalidate() {
    _onInvalidate(reference.pointer, _id_onInvalidate as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineRegion_OfflineRegionInvalidateCallbackImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onInvalidate()V') {
        _$impls[$p]!.onInvalidate();
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineRegion_OfflineRegionInvalidateCallback.implement(
    $OfflineRegion_OfflineRegionInvalidateCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineRegion_OfflineRegionInvalidateCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineRegion_OfflineRegionInvalidateCallbackImpl {
  factory $OfflineRegion_OfflineRegionInvalidateCallbackImpl({
    required void Function() onInvalidate,
    required void Function(jni.JString string) onError,
  }) = _$OfflineRegion_OfflineRegionInvalidateCallbackImpl;

  void onInvalidate();
  void onError(jni.JString string);
}

class _$OfflineRegion_OfflineRegionInvalidateCallbackImpl
    implements $OfflineRegion_OfflineRegionInvalidateCallbackImpl {
  _$OfflineRegion_OfflineRegionInvalidateCallbackImpl({
    required void Function() onInvalidate,
    required void Function(jni.JString string) onError,
  })  : _onInvalidate = onInvalidate,
        _onError = onError;

  final void Function() _onInvalidate;
  final void Function(jni.JString string) _onError;

  void onInvalidate() {
    return _onInvalidate();
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion_OfflineRegionInvalidateCallbackType
    extends jni.JObjType<OfflineRegion_OfflineRegionInvalidateCallback> {
  const $OfflineRegion_OfflineRegionInvalidateCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;';

  @override
  OfflineRegion_OfflineRegionInvalidateCallback fromReference(
          jni.JReference reference) =>
      OfflineRegion_OfflineRegionInvalidateCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($OfflineRegion_OfflineRegionInvalidateCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionInvalidateCallbackType) &&
        other is $OfflineRegion_OfflineRegionInvalidateCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver`
class OfflineRegion_OfflineRegionObserver extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionObserver> $type = type;

  OfflineRegion_OfflineRegionObserver.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionObserver');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionObserverType();
  static final _id_onStatusChanged = _class.instanceMethodId(
    r'onStatusChanged',
    r'(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
  );

  static final _onStatusChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onStatusChanged(org.maplibre.android.offline.OfflineRegionStatus offlineRegionStatus)`
  void onStatusChanged(
    offlineregionstatus_.OfflineRegionStatus offlineRegionStatus,
  ) {
    _onStatusChanged(reference.pointer, _id_onStatusChanged as jni.JMethodIDPtr,
            offlineRegionStatus.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Lorg/maplibre/android/offline/OfflineRegionError;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(org.maplibre.android.offline.OfflineRegionError offlineRegionError)`
  void onError(
    offlineregionerror_.OfflineRegionError offlineRegionError,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            offlineRegionError.reference.pointer)
        .check();
  }

  static final _id_mapboxTileCountLimitExceeded = _class.instanceMethodId(
    r'mapboxTileCountLimitExceeded',
    r'(J)V',
  );

  static final _mapboxTileCountLimitExceeded = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public abstract void mapboxTileCountLimitExceeded(long j)`
  void mapboxTileCountLimitExceeded(
    int j,
  ) {
    _mapboxTileCountLimitExceeded(reference.pointer,
            _id_mapboxTileCountLimitExceeded as jni.JMethodIDPtr, j)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineRegion_OfflineRegionObserverImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onStatusChanged(Lorg/maplibre/android/offline/OfflineRegionStatus;)V') {
        _$impls[$p]!.onStatusChanged(
          $a[0].castTo(const offlineregionstatus_.$OfflineRegionStatusType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onError(Lorg/maplibre/android/offline/OfflineRegionError;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const offlineregionerror_.$OfflineRegionErrorType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'mapboxTileCountLimitExceeded(J)V') {
        _$impls[$p]!.mapboxTileCountLimitExceeded(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineRegion_OfflineRegionObserver.implement(
    $OfflineRegion_OfflineRegionObserverImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineRegion_OfflineRegionObserver.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineRegion_OfflineRegionObserverImpl {
  factory $OfflineRegion_OfflineRegionObserverImpl({
    required void Function(
            offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
        onStatusChanged,
    required void Function(
            offlineregionerror_.OfflineRegionError offlineRegionError)
        onError,
    required void Function(int j) mapboxTileCountLimitExceeded,
  }) = _$OfflineRegion_OfflineRegionObserverImpl;

  void onStatusChanged(
      offlineregionstatus_.OfflineRegionStatus offlineRegionStatus);
  void onError(offlineregionerror_.OfflineRegionError offlineRegionError);
  void mapboxTileCountLimitExceeded(int j);
}

class _$OfflineRegion_OfflineRegionObserverImpl
    implements $OfflineRegion_OfflineRegionObserverImpl {
  _$OfflineRegion_OfflineRegionObserverImpl({
    required void Function(
            offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
        onStatusChanged,
    required void Function(
            offlineregionerror_.OfflineRegionError offlineRegionError)
        onError,
    required void Function(int j) mapboxTileCountLimitExceeded,
  })  : _onStatusChanged = onStatusChanged,
        _onError = onError,
        _mapboxTileCountLimitExceeded = mapboxTileCountLimitExceeded;

  final void Function(
          offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
      _onStatusChanged;
  final void Function(offlineregionerror_.OfflineRegionError offlineRegionError)
      _onError;
  final void Function(int j) _mapboxTileCountLimitExceeded;

  void onStatusChanged(
      offlineregionstatus_.OfflineRegionStatus offlineRegionStatus) {
    return _onStatusChanged(offlineRegionStatus);
  }

  void onError(offlineregionerror_.OfflineRegionError offlineRegionError) {
    return _onError(offlineRegionError);
  }

  void mapboxTileCountLimitExceeded(int j) {
    return _mapboxTileCountLimitExceeded(j);
  }
}

final class $OfflineRegion_OfflineRegionObserverType
    extends jni.JObjType<OfflineRegion_OfflineRegionObserver> {
  const $OfflineRegion_OfflineRegionObserverType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;';

  @override
  OfflineRegion_OfflineRegionObserver fromReference(jni.JReference reference) =>
      OfflineRegion_OfflineRegionObserver.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_OfflineRegionObserverType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_OfflineRegionObserverType) &&
        other is $OfflineRegion_OfflineRegionObserverType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback`
class OfflineRegion_OfflineRegionStatusCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionStatusCallback> $type =
      type;

  OfflineRegion_OfflineRegionStatusCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionStatusCallbackType();
  static final _id_onStatus = _class.instanceMethodId(
    r'onStatus',
    r'(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
  );

  static final _onStatus = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onStatus(org.maplibre.android.offline.OfflineRegionStatus offlineRegionStatus)`
  void onStatus(
    offlineregionstatus_.OfflineRegionStatus offlineRegionStatus,
  ) {
    _onStatus(reference.pointer, _id_onStatus as jni.JMethodIDPtr,
            offlineRegionStatus.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineRegion_OfflineRegionStatusCallbackImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onStatus(Lorg/maplibre/android/offline/OfflineRegionStatus;)V') {
        _$impls[$p]!.onStatus(
          $a[0].castTo(const offlineregionstatus_.$OfflineRegionStatusType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineRegion_OfflineRegionStatusCallback.implement(
    $OfflineRegion_OfflineRegionStatusCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineRegion_OfflineRegionStatusCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineRegion_OfflineRegionStatusCallbackImpl {
  factory $OfflineRegion_OfflineRegionStatusCallbackImpl({
    required void Function(
            offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
        onStatus,
    required void Function(jni.JString string) onError,
  }) = _$OfflineRegion_OfflineRegionStatusCallbackImpl;

  void onStatus(offlineregionstatus_.OfflineRegionStatus offlineRegionStatus);
  void onError(jni.JString string);
}

class _$OfflineRegion_OfflineRegionStatusCallbackImpl
    implements $OfflineRegion_OfflineRegionStatusCallbackImpl {
  _$OfflineRegion_OfflineRegionStatusCallbackImpl({
    required void Function(
            offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
        onStatus,
    required void Function(jni.JString string) onError,
  })  : _onStatus = onStatus,
        _onError = onError;

  final void Function(
      offlineregionstatus_.OfflineRegionStatus offlineRegionStatus) _onStatus;
  final void Function(jni.JString string) _onError;

  void onStatus(offlineregionstatus_.OfflineRegionStatus offlineRegionStatus) {
    return _onStatus(offlineRegionStatus);
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion_OfflineRegionStatusCallbackType
    extends jni.JObjType<OfflineRegion_OfflineRegionStatusCallback> {
  const $OfflineRegion_OfflineRegionStatusCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;';

  @override
  OfflineRegion_OfflineRegionStatusCallback fromReference(
          jni.JReference reference) =>
      OfflineRegion_OfflineRegionStatusCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_OfflineRegionStatusCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionStatusCallbackType) &&
        other is $OfflineRegion_OfflineRegionStatusCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback`
class OfflineRegion_OfflineRegionUpdateMetadataCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionUpdateMetadataCallback>
      $type = type;

  OfflineRegion_OfflineRegionUpdateMetadataCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionUpdateMetadataCallbackType();
  static final _id_onUpdate = _class.instanceMethodId(
    r'onUpdate',
    r'([B)V',
  );

  static final _onUpdate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onUpdate(byte[] bs)`
  void onUpdate(
    jni.JArray<jni.jbyte> bs,
  ) {
    _onUpdate(reference.pointer, _id_onUpdate as jni.JMethodIDPtr,
            bs.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OfflineRegion_OfflineRegionUpdateMetadataCallbackImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onUpdate([B)V') {
        _$impls[$p]!.onUpdate(
          $a[0].castTo(const jni.JArrayType(jni.jbyteType()),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OfflineRegion_OfflineRegionUpdateMetadataCallback.implement(
    $OfflineRegion_OfflineRegionUpdateMetadataCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OfflineRegion_OfflineRegionUpdateMetadataCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OfflineRegion_OfflineRegionUpdateMetadataCallbackImpl {
  factory $OfflineRegion_OfflineRegionUpdateMetadataCallbackImpl({
    required void Function(jni.JArray<jni.jbyte> bs) onUpdate,
    required void Function(jni.JString string) onError,
  }) = _$OfflineRegion_OfflineRegionUpdateMetadataCallbackImpl;

  void onUpdate(jni.JArray<jni.jbyte> bs);
  void onError(jni.JString string);
}

class _$OfflineRegion_OfflineRegionUpdateMetadataCallbackImpl
    implements $OfflineRegion_OfflineRegionUpdateMetadataCallbackImpl {
  _$OfflineRegion_OfflineRegionUpdateMetadataCallbackImpl({
    required void Function(jni.JArray<jni.jbyte> bs) onUpdate,
    required void Function(jni.JString string) onError,
  })  : _onUpdate = onUpdate,
        _onError = onError;

  final void Function(jni.JArray<jni.jbyte> bs) _onUpdate;
  final void Function(jni.JString string) _onError;

  void onUpdate(jni.JArray<jni.jbyte> bs) {
    return _onUpdate(bs);
  }

  void onError(jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion_OfflineRegionUpdateMetadataCallbackType
    extends jni.JObjType<OfflineRegion_OfflineRegionUpdateMetadataCallback> {
  const $OfflineRegion_OfflineRegionUpdateMetadataCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;';

  @override
  OfflineRegion_OfflineRegionUpdateMetadataCallback fromReference(
          jni.JReference reference) =>
      OfflineRegion_OfflineRegionUpdateMetadataCallback.fromReference(
          reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($OfflineRegion_OfflineRegionUpdateMetadataCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionUpdateMetadataCallbackType) &&
        other is $OfflineRegion_OfflineRegionUpdateMetadataCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion`
class OfflineRegion extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion> $type = type;

  OfflineRegion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/offline/OfflineRegion');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegionType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lorg/maplibre/android/offline/OfflineRegion$Companion;',
  );

  /// from: `static public final org.maplibre.android.offline.OfflineRegion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static OfflineRegion_Companion get Companion =>
      _id_Companion.get(_class, const $OfflineRegion_CompanionType());

  /// from: `static public final int STATE_INACTIVE`
  static const STATE_INACTIVE = 0;

  /// from: `static public final int STATE_ACTIVE`
  static const STATE_ACTIVE = 1;
  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()J',
  );

  static final _getId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final long getId()`
  int getId() {
    return _getId(reference.pointer, _id_getId as jni.JMethodIDPtr).long;
  }

  static final _id_getDefinition = _class.instanceMethodId(
    r'getDefinition',
    r'()Lorg/maplibre/android/offline/OfflineRegionDefinition;',
  );

  static final _getDefinition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final org.maplibre.android.offline.OfflineRegionDefinition getDefinition()`
  /// The returned object must be released after use, by calling the [release] method.
  offlineregiondefinition_.OfflineRegionDefinition getDefinition() {
    return _getDefinition(
            reference.pointer, _id_getDefinition as jni.JMethodIDPtr)
        .object(const offlineregiondefinition_.$OfflineRegionDefinitionType());
  }

  static final _id_getMetadata = _class.instanceMethodId(
    r'getMetadata',
    r'()[B',
  );

  static final _getMetadata = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getMetadata()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getMetadata() {
    return _getMetadata(reference.pointer, _id_getMetadata as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_isDeliveringInactiveMessages = _class.instanceMethodId(
    r'isDeliveringInactiveMessages',
    r'()Z',
  );

  static final _isDeliveringInactiveMessages = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final boolean isDeliveringInactiveMessages()`
  bool isDeliveringInactiveMessages() {
    return _isDeliveringInactiveMessages(reference.pointer,
            _id_isDeliveringInactiveMessages as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setDeliverInactiveMessages = _class.instanceMethodId(
    r'setDeliverInactiveMessages',
    r'(Z)V',
  );

  static final _setDeliverInactiveMessages = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public final void setDeliverInactiveMessages(boolean z)`
  void setDeliverInactiveMessages(
    bool z,
  ) {
    _setDeliverInactiveMessages(reference.pointer,
            _id_setDeliverInactiveMessages as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setObserver = _class.instanceMethodId(
    r'setObserver',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;)V',
  );

  static final _setObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void setObserver(org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver offlineRegionObserver)`
  void setObserver(
    OfflineRegion_OfflineRegionObserver offlineRegionObserver,
  ) {
    _setObserver(reference.pointer, _id_setObserver as jni.JMethodIDPtr,
            offlineRegionObserver.reference.pointer)
        .check();
  }

  static final _id_setDownloadState = _class.instanceMethodId(
    r'setDownloadState',
    r'(I)V',
  );

  static final _setDownloadState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public final void setDownloadState(int i)`
  void setDownloadState(
    int i,
  ) {
    _setDownloadState(
            reference.pointer, _id_setDownloadState as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getStatus = _class.instanceMethodId(
    r'getStatus',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;)V',
  );

  static final _getStatus = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void getStatus(org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback offlineRegionStatusCallback)`
  void getStatus(
    OfflineRegion_OfflineRegionStatusCallback offlineRegionStatusCallback,
  ) {
    _getStatus(reference.pointer, _id_getStatus as jni.JMethodIDPtr,
            offlineRegionStatusCallback.reference.pointer)
        .check();
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;)V',
  );

  static final _delete = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void delete(org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback offlineRegionDeleteCallback)`
  void delete(
    OfflineRegion_OfflineRegionDeleteCallback offlineRegionDeleteCallback,
  ) {
    _delete(reference.pointer, _id_delete as jni.JMethodIDPtr,
            offlineRegionDeleteCallback.reference.pointer)
        .check();
  }

  static final _id_invalidate = _class.instanceMethodId(
    r'invalidate',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;)V',
  );

  static final _invalidate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void invalidate(org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback offlineRegionInvalidateCallback)`
  void invalidate(
    OfflineRegion_OfflineRegionInvalidateCallback
        offlineRegionInvalidateCallback,
  ) {
    _invalidate(reference.pointer, _id_invalidate as jni.JMethodIDPtr,
            offlineRegionInvalidateCallback.reference.pointer)
        .check();
  }

  static final _id_updateMetadata = _class.instanceMethodId(
    r'updateMetadata',
    r'([BLorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;)V',
  );

  static final _updateMetadata = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void updateMetadata(byte[] bs, org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback offlineRegionUpdateMetadataCallback)`
  void updateMetadata(
    jni.JArray<jni.jbyte> bs,
    OfflineRegion_OfflineRegionUpdateMetadataCallback
        offlineRegionUpdateMetadataCallback,
  ) {
    _updateMetadata(
            reference.pointer,
            _id_updateMetadata as jni.JMethodIDPtr,
            bs.reference.pointer,
            offlineRegionUpdateMetadataCallback.reference.pointer)
        .check();
  }

  static final _id_finalize = _class.instanceMethodId(
    r'finalize',
    r'()V',
  );

  static final _finalize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `protected native final void finalize()`
  void finalize() {
    _finalize(reference.pointer, _id_finalize as jni.JMethodIDPtr).check();
  }
}

final class $OfflineRegionType extends jni.JObjType<OfflineRegion> {
  const $OfflineRegionType();

  @override
  String get signature => r'Lorg/maplibre/android/offline/OfflineRegion;';

  @override
  OfflineRegion fromReference(jni.JReference reference) =>
      OfflineRegion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegionType) &&
        other is $OfflineRegionType;
  }
}
