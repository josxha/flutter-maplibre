// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: public_member_api_docs
// ignore_for_file: require_trailing_commas
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: avoid_field_initializers_in_const_classes
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: sort_constructors_first
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: always_use_package_imports
// ignore_for_file: use_late_for_private_fields_and_variables
// ignore_for_file: one_member_abstracts
// ignore_for_file: always_put_required_named_parameters_first

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;

import 'OfflineRegionDefinition.dart' as offlineregiondefinition_;

import 'OfflineRegionError.dart' as offlineregionerror_;

import 'OfflineRegionStatus.dart' as offlineregionstatus_;

/// from: `org.maplibre.android.offline.OfflineRegion$Companion`
class OfflineRegion_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OfflineRegion_Companion> $type;

  @_$jni.internal
  OfflineRegion_Companion.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_Companion$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OfflineRegion_Companion(
    _$jni.JObject defaultConstructorMarker,
  ) {
    return OfflineRegion_Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as _$jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $OfflineRegion_Companion$Type
    extends _$jni.JObjType<OfflineRegion_Companion> {
  @_$jni.internal
  const $OfflineRegion_Companion$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$Companion;';

  @_$jni.internal
  @_$core.override
  OfflineRegion_Companion fromReference(_$jni.JReference reference) =>
      OfflineRegion_Companion.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($OfflineRegion_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_Companion$Type) &&
        other is $OfflineRegion_Companion$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$DownloadState`
class OfflineRegion_DownloadState extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OfflineRegion_DownloadState> $type;

  @_$jni.internal
  OfflineRegion_DownloadState.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$DownloadState');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_DownloadState$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $OfflineRegion_DownloadState> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $OfflineRegion_DownloadState $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$DownloadState',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion_DownloadState.implement(
    $OfflineRegion_DownloadState $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion_DownloadState.fromReference(
      $i.implementReference(),
    );
  }
}

abstract mixin class $OfflineRegion_DownloadState {
  factory $OfflineRegion_DownloadState() = _$OfflineRegion_DownloadState;
}

class _$OfflineRegion_DownloadState implements $OfflineRegion_DownloadState {
  _$OfflineRegion_DownloadState();
}

final class $OfflineRegion_DownloadState$Type
    extends _$jni.JObjType<OfflineRegion_DownloadState> {
  @_$jni.internal
  const $OfflineRegion_DownloadState$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$DownloadState;';

  @_$jni.internal
  @_$core.override
  OfflineRegion_DownloadState fromReference(_$jni.JReference reference) =>
      OfflineRegion_DownloadState.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($OfflineRegion_DownloadState$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_DownloadState$Type) &&
        other is $OfflineRegion_DownloadState$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback`
class OfflineRegion_OfflineRegionDeleteCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OfflineRegion_OfflineRegionDeleteCallback> $type;

  @_$jni.internal
  OfflineRegion_OfflineRegionDeleteCallback.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionDeleteCallback$Type();
  static final _id_onDelete = _class.instanceMethodId(
    r'onDelete',
    r'()V',
  );

  static final _onDelete = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onDelete()`
  void onDelete() {
    _onDelete(reference.pointer, _id_onDelete as _$jni.JMethodIDPtr).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    _$jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as _$jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $OfflineRegion_OfflineRegionDeleteCallback>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDelete()V') {
        _$impls[$p]!.onDelete();
        return _$jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].as(const _$jni.JStringType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $OfflineRegion_OfflineRegionDeleteCallback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onDelete$async) r'onDelete()V',
        if ($impl.onError$async) r'onError(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion_OfflineRegionDeleteCallback.implement(
    $OfflineRegion_OfflineRegionDeleteCallback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion_OfflineRegionDeleteCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract mixin class $OfflineRegion_OfflineRegionDeleteCallback {
  factory $OfflineRegion_OfflineRegionDeleteCallback({
    required void Function() onDelete,
    bool onDelete$async,
    required void Function(_$jni.JString string) onError,
    bool onError$async,
  }) = _$OfflineRegion_OfflineRegionDeleteCallback;

  void onDelete();
  bool get onDelete$async => false;
  void onError(_$jni.JString string);
  bool get onError$async => false;
}

class _$OfflineRegion_OfflineRegionDeleteCallback
    implements $OfflineRegion_OfflineRegionDeleteCallback {
  _$OfflineRegion_OfflineRegionDeleteCallback({
    required void Function() onDelete,
    this.onDelete$async = false,
    required void Function(_$jni.JString string) onError,
    this.onError$async = false,
  })  : _onDelete = onDelete,
        _onError = onError;

  final void Function() _onDelete;
  final bool onDelete$async;
  final void Function(_$jni.JString string) _onError;
  final bool onError$async;

  void onDelete() {
    return _onDelete();
  }

  void onError(_$jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion_OfflineRegionDeleteCallback$Type
    extends _$jni.JObjType<OfflineRegion_OfflineRegionDeleteCallback> {
  @_$jni.internal
  const $OfflineRegion_OfflineRegionDeleteCallback$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;';

  @_$jni.internal
  @_$core.override
  OfflineRegion_OfflineRegionDeleteCallback fromReference(
          _$jni.JReference reference) =>
      OfflineRegion_OfflineRegionDeleteCallback.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode =>
      ($OfflineRegion_OfflineRegionDeleteCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionDeleteCallback$Type) &&
        other is $OfflineRegion_OfflineRegionDeleteCallback$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback`
class OfflineRegion_OfflineRegionInvalidateCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OfflineRegion_OfflineRegionInvalidateCallback> $type;

  @_$jni.internal
  OfflineRegion_OfflineRegionInvalidateCallback.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionInvalidateCallback$Type();
  static final _id_onInvalidate = _class.instanceMethodId(
    r'onInvalidate',
    r'()V',
  );

  static final _onInvalidate = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onInvalidate()`
  void onInvalidate() {
    _onInvalidate(reference.pointer, _id_onInvalidate as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    _$jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as _$jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $OfflineRegion_OfflineRegionInvalidateCallback>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onInvalidate()V') {
        _$impls[$p]!.onInvalidate();
        return _$jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].as(const _$jni.JStringType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $OfflineRegion_OfflineRegionInvalidateCallback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onInvalidate$async) r'onInvalidate()V',
        if ($impl.onError$async) r'onError(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion_OfflineRegionInvalidateCallback.implement(
    $OfflineRegion_OfflineRegionInvalidateCallback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion_OfflineRegionInvalidateCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract mixin class $OfflineRegion_OfflineRegionInvalidateCallback {
  factory $OfflineRegion_OfflineRegionInvalidateCallback({
    required void Function() onInvalidate,
    bool onInvalidate$async,
    required void Function(_$jni.JString string) onError,
    bool onError$async,
  }) = _$OfflineRegion_OfflineRegionInvalidateCallback;

  void onInvalidate();
  bool get onInvalidate$async => false;
  void onError(_$jni.JString string);
  bool get onError$async => false;
}

class _$OfflineRegion_OfflineRegionInvalidateCallback
    implements $OfflineRegion_OfflineRegionInvalidateCallback {
  _$OfflineRegion_OfflineRegionInvalidateCallback({
    required void Function() onInvalidate,
    this.onInvalidate$async = false,
    required void Function(_$jni.JString string) onError,
    this.onError$async = false,
  })  : _onInvalidate = onInvalidate,
        _onError = onError;

  final void Function() _onInvalidate;
  final bool onInvalidate$async;
  final void Function(_$jni.JString string) _onError;
  final bool onError$async;

  void onInvalidate() {
    return _onInvalidate();
  }

  void onError(_$jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion_OfflineRegionInvalidateCallback$Type
    extends _$jni.JObjType<OfflineRegion_OfflineRegionInvalidateCallback> {
  @_$jni.internal
  const $OfflineRegion_OfflineRegionInvalidateCallback$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;';

  @_$jni.internal
  @_$core.override
  OfflineRegion_OfflineRegionInvalidateCallback fromReference(
          _$jni.JReference reference) =>
      OfflineRegion_OfflineRegionInvalidateCallback.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode =>
      ($OfflineRegion_OfflineRegionInvalidateCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionInvalidateCallback$Type) &&
        other is $OfflineRegion_OfflineRegionInvalidateCallback$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver`
class OfflineRegion_OfflineRegionObserver extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OfflineRegion_OfflineRegionObserver> $type;

  @_$jni.internal
  OfflineRegion_OfflineRegionObserver.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionObserver');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionObserver$Type();
  static final _id_onStatusChanged = _class.instanceMethodId(
    r'onStatusChanged',
    r'(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
  );

  static final _onStatusChanged = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onStatusChanged(org.maplibre.android.offline.OfflineRegionStatus offlineRegionStatus)`
  void onStatusChanged(
    offlineregionstatus_.OfflineRegionStatus offlineRegionStatus,
  ) {
    _onStatusChanged(
            reference.pointer,
            _id_onStatusChanged as _$jni.JMethodIDPtr,
            offlineRegionStatus.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Lorg/maplibre/android/offline/OfflineRegionError;)V',
  );

  static final _onError = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onError(org.maplibre.android.offline.OfflineRegionError offlineRegionError)`
  void onError(
    offlineregionerror_.OfflineRegionError offlineRegionError,
  ) {
    _onError(reference.pointer, _id_onError as _$jni.JMethodIDPtr,
            offlineRegionError.reference.pointer)
        .check();
  }

  static final _id_mapboxTileCountLimitExceeded = _class.instanceMethodId(
    r'mapboxTileCountLimitExceeded',
    r'(J)V',
  );

  static final _mapboxTileCountLimitExceeded =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int64,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public abstract void mapboxTileCountLimitExceeded(long j)`
  void mapboxTileCountLimitExceeded(
    int j,
  ) {
    _mapboxTileCountLimitExceeded(reference.pointer,
            _id_mapboxTileCountLimitExceeded as _$jni.JMethodIDPtr, j)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $OfflineRegion_OfflineRegionObserver> _$impls =
      {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onStatusChanged(Lorg/maplibre/android/offline/OfflineRegionStatus;)V') {
        _$impls[$p]!.onStatusChanged(
          $a[0].as(const offlineregionstatus_.$OfflineRegionStatus$Type(),
              releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d ==
          r'onError(Lorg/maplibre/android/offline/OfflineRegionError;)V') {
        _$impls[$p]!.onError(
          $a[0].as(const offlineregionerror_.$OfflineRegionError$Type(),
              releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d == r'mapboxTileCountLimitExceeded(J)V') {
        _$impls[$p]!.mapboxTileCountLimitExceeded(
          $a[0]
              .as(const _$jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $OfflineRegion_OfflineRegionObserver $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver',
      $p,
      _$invokePointer,
      [
        if ($impl.onStatusChanged$async)
          r'onStatusChanged(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
        if ($impl.onError$async)
          r'onError(Lorg/maplibre/android/offline/OfflineRegionError;)V',
        if ($impl.mapboxTileCountLimitExceeded$async)
          r'mapboxTileCountLimitExceeded(J)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion_OfflineRegionObserver.implement(
    $OfflineRegion_OfflineRegionObserver $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion_OfflineRegionObserver.fromReference(
      $i.implementReference(),
    );
  }
}

abstract mixin class $OfflineRegion_OfflineRegionObserver {
  factory $OfflineRegion_OfflineRegionObserver({
    required void Function(
            offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
        onStatusChanged,
    bool onStatusChanged$async,
    required void Function(
            offlineregionerror_.OfflineRegionError offlineRegionError)
        onError,
    bool onError$async,
    required void Function(int j) mapboxTileCountLimitExceeded,
    bool mapboxTileCountLimitExceeded$async,
  }) = _$OfflineRegion_OfflineRegionObserver;

  void onStatusChanged(
      offlineregionstatus_.OfflineRegionStatus offlineRegionStatus);
  bool get onStatusChanged$async => false;
  void onError(offlineregionerror_.OfflineRegionError offlineRegionError);
  bool get onError$async => false;
  void mapboxTileCountLimitExceeded(int j);
  bool get mapboxTileCountLimitExceeded$async => false;
}

class _$OfflineRegion_OfflineRegionObserver
    implements $OfflineRegion_OfflineRegionObserver {
  _$OfflineRegion_OfflineRegionObserver({
    required void Function(
            offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
        onStatusChanged,
    this.onStatusChanged$async = false,
    required void Function(
            offlineregionerror_.OfflineRegionError offlineRegionError)
        onError,
    this.onError$async = false,
    required void Function(int j) mapboxTileCountLimitExceeded,
    this.mapboxTileCountLimitExceeded$async = false,
  })  : _onStatusChanged = onStatusChanged,
        _onError = onError,
        _mapboxTileCountLimitExceeded = mapboxTileCountLimitExceeded;

  final void Function(
          offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
      _onStatusChanged;
  final bool onStatusChanged$async;
  final void Function(offlineregionerror_.OfflineRegionError offlineRegionError)
      _onError;
  final bool onError$async;
  final void Function(int j) _mapboxTileCountLimitExceeded;
  final bool mapboxTileCountLimitExceeded$async;

  void onStatusChanged(
      offlineregionstatus_.OfflineRegionStatus offlineRegionStatus) {
    return _onStatusChanged(offlineRegionStatus);
  }

  void onError(offlineregionerror_.OfflineRegionError offlineRegionError) {
    return _onError(offlineRegionError);
  }

  void mapboxTileCountLimitExceeded(int j) {
    return _mapboxTileCountLimitExceeded(j);
  }
}

final class $OfflineRegion_OfflineRegionObserver$Type
    extends _$jni.JObjType<OfflineRegion_OfflineRegionObserver> {
  @_$jni.internal
  const $OfflineRegion_OfflineRegionObserver$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;';

  @_$jni.internal
  @_$core.override
  OfflineRegion_OfflineRegionObserver fromReference(
          _$jni.JReference reference) =>
      OfflineRegion_OfflineRegionObserver.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($OfflineRegion_OfflineRegionObserver$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_OfflineRegionObserver$Type) &&
        other is $OfflineRegion_OfflineRegionObserver$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback`
class OfflineRegion_OfflineRegionStatusCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OfflineRegion_OfflineRegionStatusCallback> $type;

  @_$jni.internal
  OfflineRegion_OfflineRegionStatusCallback.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionStatusCallback$Type();
  static final _id_onStatus = _class.instanceMethodId(
    r'onStatus',
    r'(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
  );

  static final _onStatus = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onStatus(org.maplibre.android.offline.OfflineRegionStatus offlineRegionStatus)`
  void onStatus(
    offlineregionstatus_.OfflineRegionStatus offlineRegionStatus,
  ) {
    _onStatus(reference.pointer, _id_onStatus as _$jni.JMethodIDPtr,
            offlineRegionStatus.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    _$jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as _$jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $OfflineRegion_OfflineRegionStatusCallback>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onStatus(Lorg/maplibre/android/offline/OfflineRegionStatus;)V') {
        _$impls[$p]!.onStatus(
          $a[0].as(const offlineregionstatus_.$OfflineRegionStatus$Type(),
              releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].as(const _$jni.JStringType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $OfflineRegion_OfflineRegionStatusCallback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onStatus$async)
          r'onStatus(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
        if ($impl.onError$async) r'onError(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion_OfflineRegionStatusCallback.implement(
    $OfflineRegion_OfflineRegionStatusCallback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion_OfflineRegionStatusCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract mixin class $OfflineRegion_OfflineRegionStatusCallback {
  factory $OfflineRegion_OfflineRegionStatusCallback({
    required void Function(
            offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
        onStatus,
    bool onStatus$async,
    required void Function(_$jni.JString string) onError,
    bool onError$async,
  }) = _$OfflineRegion_OfflineRegionStatusCallback;

  void onStatus(offlineregionstatus_.OfflineRegionStatus offlineRegionStatus);
  bool get onStatus$async => false;
  void onError(_$jni.JString string);
  bool get onError$async => false;
}

class _$OfflineRegion_OfflineRegionStatusCallback
    implements $OfflineRegion_OfflineRegionStatusCallback {
  _$OfflineRegion_OfflineRegionStatusCallback({
    required void Function(
            offlineregionstatus_.OfflineRegionStatus offlineRegionStatus)
        onStatus,
    this.onStatus$async = false,
    required void Function(_$jni.JString string) onError,
    this.onError$async = false,
  })  : _onStatus = onStatus,
        _onError = onError;

  final void Function(
      offlineregionstatus_.OfflineRegionStatus offlineRegionStatus) _onStatus;
  final bool onStatus$async;
  final void Function(_$jni.JString string) _onError;
  final bool onError$async;

  void onStatus(offlineregionstatus_.OfflineRegionStatus offlineRegionStatus) {
    return _onStatus(offlineRegionStatus);
  }

  void onError(_$jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion_OfflineRegionStatusCallback$Type
    extends _$jni.JObjType<OfflineRegion_OfflineRegionStatusCallback> {
  @_$jni.internal
  const $OfflineRegion_OfflineRegionStatusCallback$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;';

  @_$jni.internal
  @_$core.override
  OfflineRegion_OfflineRegionStatusCallback fromReference(
          _$jni.JReference reference) =>
      OfflineRegion_OfflineRegionStatusCallback.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode =>
      ($OfflineRegion_OfflineRegionStatusCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionStatusCallback$Type) &&
        other is $OfflineRegion_OfflineRegionStatusCallback$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback`
class OfflineRegion_OfflineRegionUpdateMetadataCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OfflineRegion_OfflineRegionUpdateMetadataCallback> $type;

  @_$jni.internal
  OfflineRegion_OfflineRegionUpdateMetadataCallback.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionUpdateMetadataCallback$Type();
  static final _id_onUpdate = _class.instanceMethodId(
    r'onUpdate',
    r'([B)V',
  );

  static final _onUpdate = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onUpdate(byte[] bs)`
  void onUpdate(
    _$jni.JArray<_$jni.jbyte> bs,
  ) {
    _onUpdate(reference.pointer, _id_onUpdate as _$jni.JMethodIDPtr,
            bs.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    _$jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as _$jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core
      .Map<int, $OfflineRegion_OfflineRegionUpdateMetadataCallback>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onUpdate([B)V') {
        _$impls[$p]!.onUpdate(
          $a[0].as(const _$jni.JArrayType(_$jni.jbyteType()),
              releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d == r'onError(Ljava/lang/String;)V') {
        _$impls[$p]!.onError(
          $a[0].as(const _$jni.JStringType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $OfflineRegion_OfflineRegionUpdateMetadataCallback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onUpdate$async) r'onUpdate([B)V',
        if ($impl.onError$async) r'onError(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OfflineRegion_OfflineRegionUpdateMetadataCallback.implement(
    $OfflineRegion_OfflineRegionUpdateMetadataCallback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return OfflineRegion_OfflineRegionUpdateMetadataCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract mixin class $OfflineRegion_OfflineRegionUpdateMetadataCallback {
  factory $OfflineRegion_OfflineRegionUpdateMetadataCallback({
    required void Function(_$jni.JArray<_$jni.jbyte> bs) onUpdate,
    bool onUpdate$async,
    required void Function(_$jni.JString string) onError,
    bool onError$async,
  }) = _$OfflineRegion_OfflineRegionUpdateMetadataCallback;

  void onUpdate(_$jni.JArray<_$jni.jbyte> bs);
  bool get onUpdate$async => false;
  void onError(_$jni.JString string);
  bool get onError$async => false;
}

class _$OfflineRegion_OfflineRegionUpdateMetadataCallback
    implements $OfflineRegion_OfflineRegionUpdateMetadataCallback {
  _$OfflineRegion_OfflineRegionUpdateMetadataCallback({
    required void Function(_$jni.JArray<_$jni.jbyte> bs) onUpdate,
    this.onUpdate$async = false,
    required void Function(_$jni.JString string) onError,
    this.onError$async = false,
  })  : _onUpdate = onUpdate,
        _onError = onError;

  final void Function(_$jni.JArray<_$jni.jbyte> bs) _onUpdate;
  final bool onUpdate$async;
  final void Function(_$jni.JString string) _onError;
  final bool onError$async;

  void onUpdate(_$jni.JArray<_$jni.jbyte> bs) {
    return _onUpdate(bs);
  }

  void onError(_$jni.JString string) {
    return _onError(string);
  }
}

final class $OfflineRegion_OfflineRegionUpdateMetadataCallback$Type
    extends _$jni.JObjType<OfflineRegion_OfflineRegionUpdateMetadataCallback> {
  @_$jni.internal
  const $OfflineRegion_OfflineRegionUpdateMetadataCallback$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;';

  @_$jni.internal
  @_$core.override
  OfflineRegion_OfflineRegionUpdateMetadataCallback fromReference(
          _$jni.JReference reference) =>
      OfflineRegion_OfflineRegionUpdateMetadataCallback.fromReference(
          reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode =>
      ($OfflineRegion_OfflineRegionUpdateMetadataCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionUpdateMetadataCallback$Type) &&
        other is $OfflineRegion_OfflineRegionUpdateMetadataCallback$Type;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion`
class OfflineRegion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OfflineRegion> $type;

  @_$jni.internal
  OfflineRegion.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'org/maplibre/android/offline/OfflineRegion');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lorg/maplibre/android/offline/OfflineRegion$Companion;',
  );

  /// from: `static public final org.maplibre.android.offline.OfflineRegion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static OfflineRegion_Companion get Companion =>
      _id_Companion.get(_class, const $OfflineRegion_Companion$Type());

  /// from: `static public final int STATE_INACTIVE`
  static const STATE_INACTIVE = 0;

  /// from: `static public final int STATE_ACTIVE`
  static const STATE_ACTIVE = 1;
  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()J',
  );

  static final _getId = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public final long getId()`
  int getId() {
    return _getId(reference.pointer, _id_getId as _$jni.JMethodIDPtr).long;
  }

  static final _id_getDefinition = _class.instanceMethodId(
    r'getDefinition',
    r'()Lorg/maplibre/android/offline/OfflineRegionDefinition;',
  );

  static final _getDefinition = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public final org.maplibre.android.offline.OfflineRegionDefinition getDefinition()`
  /// The returned object must be released after use, by calling the [release] method.
  offlineregiondefinition_.OfflineRegionDefinition getDefinition() {
    return _getDefinition(
            reference.pointer, _id_getDefinition as _$jni.JMethodIDPtr)
        .object(const offlineregiondefinition_.$OfflineRegionDefinition$Type());
  }

  static final _id_getMetadata = _class.instanceMethodId(
    r'getMetadata',
    r'()[B',
  );

  static final _getMetadata = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getMetadata()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.jbyte> getMetadata() {
    return _getMetadata(
            reference.pointer, _id_getMetadata as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.jbyteType()));
  }

  static final _id_isDeliveringInactiveMessages = _class.instanceMethodId(
    r'isDeliveringInactiveMessages',
    r'()Z',
  );

  static final _isDeliveringInactiveMessages =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public final boolean isDeliveringInactiveMessages()`
  bool isDeliveringInactiveMessages() {
    return _isDeliveringInactiveMessages(reference.pointer,
            _id_isDeliveringInactiveMessages as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setDeliverInactiveMessages = _class.instanceMethodId(
    r'setDeliverInactiveMessages',
    r'(Z)V',
  );

  static final _setDeliverInactiveMessages =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public final void setDeliverInactiveMessages(boolean z)`
  void setDeliverInactiveMessages(
    bool z,
  ) {
    _setDeliverInactiveMessages(reference.pointer,
            _id_setDeliverInactiveMessages as _$jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setObserver = _class.instanceMethodId(
    r'setObserver',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;)V',
  );

  static final _setObserver = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void setObserver(org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver offlineRegionObserver)`
  void setObserver(
    OfflineRegion_OfflineRegionObserver offlineRegionObserver,
  ) {
    _setObserver(reference.pointer, _id_setObserver as _$jni.JMethodIDPtr,
            offlineRegionObserver.reference.pointer)
        .check();
  }

  static final _id_setDownloadState = _class.instanceMethodId(
    r'setDownloadState',
    r'(I)V',
  );

  static final _setDownloadState = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public final void setDownloadState(int i)`
  void setDownloadState(
    int i,
  ) {
    _setDownloadState(
            reference.pointer, _id_setDownloadState as _$jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getStatus = _class.instanceMethodId(
    r'getStatus',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;)V',
  );

  static final _getStatus = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void getStatus(org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback offlineRegionStatusCallback)`
  void getStatus(
    OfflineRegion_OfflineRegionStatusCallback offlineRegionStatusCallback,
  ) {
    _getStatus(reference.pointer, _id_getStatus as _$jni.JMethodIDPtr,
            offlineRegionStatusCallback.reference.pointer)
        .check();
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;)V',
  );

  static final _delete = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void delete(org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback offlineRegionDeleteCallback)`
  void delete(
    OfflineRegion_OfflineRegionDeleteCallback offlineRegionDeleteCallback,
  ) {
    _delete(reference.pointer, _id_delete as _$jni.JMethodIDPtr,
            offlineRegionDeleteCallback.reference.pointer)
        .check();
  }

  static final _id_invalidate = _class.instanceMethodId(
    r'invalidate',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;)V',
  );

  static final _invalidate = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void invalidate(org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback offlineRegionInvalidateCallback)`
  void invalidate(
    OfflineRegion_OfflineRegionInvalidateCallback
        offlineRegionInvalidateCallback,
  ) {
    _invalidate(reference.pointer, _id_invalidate as _$jni.JMethodIDPtr,
            offlineRegionInvalidateCallback.reference.pointer)
        .check();
  }

  static final _id_updateMetadata = _class.instanceMethodId(
    r'updateMetadata',
    r'([BLorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;)V',
  );

  static final _updateMetadata = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public final void updateMetadata(byte[] bs, org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback offlineRegionUpdateMetadataCallback)`
  void updateMetadata(
    _$jni.JArray<_$jni.jbyte> bs,
    OfflineRegion_OfflineRegionUpdateMetadataCallback
        offlineRegionUpdateMetadataCallback,
  ) {
    _updateMetadata(
            reference.pointer,
            _id_updateMetadata as _$jni.JMethodIDPtr,
            bs.reference.pointer,
            offlineRegionUpdateMetadataCallback.reference.pointer)
        .check();
  }
}

final class $OfflineRegion$Type extends _$jni.JObjType<OfflineRegion> {
  @_$jni.internal
  const $OfflineRegion$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lorg/maplibre/android/offline/OfflineRegion;';

  @_$jni.internal
  @_$core.override
  OfflineRegion fromReference(_$jni.JReference reference) =>
      OfflineRegion.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($OfflineRegion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion$Type) &&
        other is $OfflineRegion$Type;
  }
}
