// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import 'OfflineRegionDefinition.dart' as offlineregiondefinition_;

import 'OfflineRegionError.dart' as offlineregionerror_;

import 'OfflineRegionStatus.dart' as offlineregionstatus_;

/// from: `org.maplibre.android.offline.OfflineRegion$Companion`
class OfflineRegion_Companion extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_Companion> $type = type;

  OfflineRegion_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_CompanionType();
  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OfflineRegion_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return OfflineRegion_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $OfflineRegion_CompanionType
    extends jni.JObjType<OfflineRegion_Companion> {
  const $OfflineRegion_CompanionType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$Companion;';

  @override
  OfflineRegion_Companion fromReference(jni.JReference reference) =>
      OfflineRegion_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_CompanionType) &&
        other is $OfflineRegion_CompanionType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$DownloadState`
class OfflineRegion_DownloadState extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_DownloadState> $type = type;

  OfflineRegion_DownloadState.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$DownloadState');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_DownloadStateType();
}

final class $OfflineRegion_DownloadStateType
    extends jni.JObjType<OfflineRegion_DownloadState> {
  const $OfflineRegion_DownloadStateType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$DownloadState;';

  @override
  OfflineRegion_DownloadState fromReference(jni.JReference reference) =>
      OfflineRegion_DownloadState.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_DownloadStateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_DownloadStateType) &&
        other is $OfflineRegion_DownloadStateType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback`
class OfflineRegion_OfflineRegionDeleteCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionDeleteCallback> $type =
      type;

  OfflineRegion_OfflineRegionDeleteCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionDeleteCallbackType();
  static final _id_onDelete = _class.instanceMethodId(
    r'onDelete',
    r'()V',
  );

  static final _onDelete = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onDelete()`
  void onDelete() {
    _onDelete(reference.pointer, _id_onDelete as jni.JMethodIDPtr).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }
}

final class $OfflineRegion_OfflineRegionDeleteCallbackType
    extends jni.JObjType<OfflineRegion_OfflineRegionDeleteCallback> {
  const $OfflineRegion_OfflineRegionDeleteCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;';

  @override
  OfflineRegion_OfflineRegionDeleteCallback fromReference(
          jni.JReference reference) =>
      OfflineRegion_OfflineRegionDeleteCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_OfflineRegionDeleteCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionDeleteCallbackType) &&
        other is $OfflineRegion_OfflineRegionDeleteCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback`
class OfflineRegion_OfflineRegionInvalidateCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionInvalidateCallback> $type =
      type;

  OfflineRegion_OfflineRegionInvalidateCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionInvalidateCallbackType();
  static final _id_onInvalidate = _class.instanceMethodId(
    r'onInvalidate',
    r'()V',
  );

  static final _onInvalidate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void onInvalidate()`
  void onInvalidate() {
    _onInvalidate(reference.pointer, _id_onInvalidate as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }
}

final class $OfflineRegion_OfflineRegionInvalidateCallbackType
    extends jni.JObjType<OfflineRegion_OfflineRegionInvalidateCallback> {
  const $OfflineRegion_OfflineRegionInvalidateCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;';

  @override
  OfflineRegion_OfflineRegionInvalidateCallback fromReference(
          jni.JReference reference) =>
      OfflineRegion_OfflineRegionInvalidateCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($OfflineRegion_OfflineRegionInvalidateCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionInvalidateCallbackType) &&
        other is $OfflineRegion_OfflineRegionInvalidateCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver`
class OfflineRegion_OfflineRegionObserver extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionObserver> $type = type;

  OfflineRegion_OfflineRegionObserver.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionObserver');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionObserverType();
  static final _id_onStatusChanged = _class.instanceMethodId(
    r'onStatusChanged',
    r'(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
  );

  static final _onStatusChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onStatusChanged(org.maplibre.android.offline.OfflineRegionStatus offlineRegionStatus)`
  void onStatusChanged(
    offlineregionstatus_.OfflineRegionStatus offlineRegionStatus,
  ) {
    _onStatusChanged(reference.pointer, _id_onStatusChanged as jni.JMethodIDPtr,
            offlineRegionStatus.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Lorg/maplibre/android/offline/OfflineRegionError;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(org.maplibre.android.offline.OfflineRegionError offlineRegionError)`
  void onError(
    offlineregionerror_.OfflineRegionError offlineRegionError,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            offlineRegionError.reference.pointer)
        .check();
  }

  static final _id_mapboxTileCountLimitExceeded = _class.instanceMethodId(
    r'mapboxTileCountLimitExceeded',
    r'(J)V',
  );

  static final _mapboxTileCountLimitExceeded = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public abstract void mapboxTileCountLimitExceeded(long j)`
  void mapboxTileCountLimitExceeded(
    int j,
  ) {
    _mapboxTileCountLimitExceeded(reference.pointer,
            _id_mapboxTileCountLimitExceeded as jni.JMethodIDPtr, j)
        .check();
  }
}

final class $OfflineRegion_OfflineRegionObserverType
    extends jni.JObjType<OfflineRegion_OfflineRegionObserver> {
  const $OfflineRegion_OfflineRegionObserverType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;';

  @override
  OfflineRegion_OfflineRegionObserver fromReference(jni.JReference reference) =>
      OfflineRegion_OfflineRegionObserver.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_OfflineRegionObserverType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegion_OfflineRegionObserverType) &&
        other is $OfflineRegion_OfflineRegionObserverType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback`
class OfflineRegion_OfflineRegionStatusCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionStatusCallback> $type =
      type;

  OfflineRegion_OfflineRegionStatusCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionStatusCallbackType();
  static final _id_onStatus = _class.instanceMethodId(
    r'onStatus',
    r'(Lorg/maplibre/android/offline/OfflineRegionStatus;)V',
  );

  static final _onStatus = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onStatus(org.maplibre.android.offline.OfflineRegionStatus offlineRegionStatus)`
  void onStatus(
    offlineregionstatus_.OfflineRegionStatus offlineRegionStatus,
  ) {
    _onStatus(reference.pointer, _id_onStatus as jni.JMethodIDPtr,
            offlineRegionStatus.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }
}

final class $OfflineRegion_OfflineRegionStatusCallbackType
    extends jni.JObjType<OfflineRegion_OfflineRegionStatusCallback> {
  const $OfflineRegion_OfflineRegionStatusCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;';

  @override
  OfflineRegion_OfflineRegionStatusCallback fromReference(
          jni.JReference reference) =>
      OfflineRegion_OfflineRegionStatusCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegion_OfflineRegionStatusCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionStatusCallbackType) &&
        other is $OfflineRegion_OfflineRegionStatusCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback`
class OfflineRegion_OfflineRegionUpdateMetadataCallback extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion_OfflineRegionUpdateMetadataCallback>
      $type = type;

  OfflineRegion_OfflineRegionUpdateMetadataCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'org/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegion_OfflineRegionUpdateMetadataCallbackType();
  static final _id_onUpdate = _class.instanceMethodId(
    r'onUpdate',
    r'([B)V',
  );

  static final _onUpdate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onUpdate(byte[] bs)`
  void onUpdate(
    jni.JArray<jni.jbyte> bs,
  ) {
    _onUpdate(reference.pointer, _id_onUpdate as jni.JMethodIDPtr,
            bs.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/String;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onError(java.lang.String string)`
  void onError(
    jni.JString string,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }
}

final class $OfflineRegion_OfflineRegionUpdateMetadataCallbackType
    extends jni.JObjType<OfflineRegion_OfflineRegionUpdateMetadataCallback> {
  const $OfflineRegion_OfflineRegionUpdateMetadataCallbackType();

  @override
  String get signature =>
      r'Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;';

  @override
  OfflineRegion_OfflineRegionUpdateMetadataCallback fromReference(
          jni.JReference reference) =>
      OfflineRegion_OfflineRegionUpdateMetadataCallback.fromReference(
          reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($OfflineRegion_OfflineRegionUpdateMetadataCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($OfflineRegion_OfflineRegionUpdateMetadataCallbackType) &&
        other is $OfflineRegion_OfflineRegionUpdateMetadataCallbackType;
  }
}

/// from: `org.maplibre.android.offline.OfflineRegion`
class OfflineRegion extends jni.JObject {
  @override
  late final jni.JObjType<OfflineRegion> $type = type;

  OfflineRegion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/maplibre/android/offline/OfflineRegion');

  /// The type which includes information such as the signature of this class.
  static const type = $OfflineRegionType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lorg/maplibre/android/offline/OfflineRegion$Companion;',
  );

  /// from: `static public final org.maplibre.android.offline.OfflineRegion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static OfflineRegion_Companion get Companion =>
      _id_Companion.get(_class, const $OfflineRegion_CompanionType());

  /// from: `static public final int STATE_INACTIVE`
  static const STATE_INACTIVE = 0;

  /// from: `static public final int STATE_ACTIVE`
  static const STATE_ACTIVE = 1;
  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()J',
  );

  static final _getId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final long getId()`
  int getId() {
    return _getId(reference.pointer, _id_getId as jni.JMethodIDPtr).long;
  }

  static final _id_getDefinition = _class.instanceMethodId(
    r'getDefinition',
    r'()Lorg/maplibre/android/offline/OfflineRegionDefinition;',
  );

  static final _getDefinition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final org.maplibre.android.offline.OfflineRegionDefinition getDefinition()`
  /// The returned object must be released after use, by calling the [release] method.
  offlineregiondefinition_.OfflineRegionDefinition getDefinition() {
    return _getDefinition(
            reference.pointer, _id_getDefinition as jni.JMethodIDPtr)
        .object(const offlineregiondefinition_.$OfflineRegionDefinitionType());
  }

  static final _id_getMetadata = _class.instanceMethodId(
    r'getMetadata',
    r'()[B',
  );

  static final _getMetadata = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getMetadata()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getMetadata() {
    return _getMetadata(reference.pointer, _id_getMetadata as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_isDeliveringInactiveMessages = _class.instanceMethodId(
    r'isDeliveringInactiveMessages',
    r'()Z',
  );

  static final _isDeliveringInactiveMessages = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final boolean isDeliveringInactiveMessages()`
  bool isDeliveringInactiveMessages() {
    return _isDeliveringInactiveMessages(reference.pointer,
            _id_isDeliveringInactiveMessages as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setDeliverInactiveMessages = _class.instanceMethodId(
    r'setDeliverInactiveMessages',
    r'(Z)V',
  );

  static final _setDeliverInactiveMessages = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public final void setDeliverInactiveMessages(boolean z)`
  void setDeliverInactiveMessages(
    bool z,
  ) {
    _setDeliverInactiveMessages(reference.pointer,
            _id_setDeliverInactiveMessages as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setObserver = _class.instanceMethodId(
    r'setObserver',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionObserver;)V',
  );

  static final _setObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void setObserver(org.maplibre.android.offline.OfflineRegion$OfflineRegionObserver offlineRegionObserver)`
  void setObserver(
    OfflineRegion_OfflineRegionObserver offlineRegionObserver,
  ) {
    _setObserver(reference.pointer, _id_setObserver as jni.JMethodIDPtr,
            offlineRegionObserver.reference.pointer)
        .check();
  }

  static final _id_setDownloadState = _class.instanceMethodId(
    r'setDownloadState',
    r'(I)V',
  );

  static final _setDownloadState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public final void setDownloadState(int i)`
  void setDownloadState(
    int i,
  ) {
    _setDownloadState(
            reference.pointer, _id_setDownloadState as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getStatus = _class.instanceMethodId(
    r'getStatus',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionStatusCallback;)V',
  );

  static final _getStatus = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void getStatus(org.maplibre.android.offline.OfflineRegion$OfflineRegionStatusCallback offlineRegionStatusCallback)`
  void getStatus(
    OfflineRegion_OfflineRegionStatusCallback offlineRegionStatusCallback,
  ) {
    _getStatus(reference.pointer, _id_getStatus as jni.JMethodIDPtr,
            offlineRegionStatusCallback.reference.pointer)
        .check();
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionDeleteCallback;)V',
  );

  static final _delete = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void delete(org.maplibre.android.offline.OfflineRegion$OfflineRegionDeleteCallback offlineRegionDeleteCallback)`
  void delete(
    OfflineRegion_OfflineRegionDeleteCallback offlineRegionDeleteCallback,
  ) {
    _delete(reference.pointer, _id_delete as jni.JMethodIDPtr,
            offlineRegionDeleteCallback.reference.pointer)
        .check();
  }

  static final _id_invalidate = _class.instanceMethodId(
    r'invalidate',
    r'(Lorg/maplibre/android/offline/OfflineRegion$OfflineRegionInvalidateCallback;)V',
  );

  static final _invalidate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public final void invalidate(org.maplibre.android.offline.OfflineRegion$OfflineRegionInvalidateCallback offlineRegionInvalidateCallback)`
  void invalidate(
    OfflineRegion_OfflineRegionInvalidateCallback
        offlineRegionInvalidateCallback,
  ) {
    _invalidate(reference.pointer, _id_invalidate as jni.JMethodIDPtr,
            offlineRegionInvalidateCallback.reference.pointer)
        .check();
  }

  static final _id_updateMetadata = _class.instanceMethodId(
    r'updateMetadata',
    r'([BLorg/maplibre/android/offline/OfflineRegion$OfflineRegionUpdateMetadataCallback;)V',
  );

  static final _updateMetadata = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public final void updateMetadata(byte[] bs, org.maplibre.android.offline.OfflineRegion$OfflineRegionUpdateMetadataCallback offlineRegionUpdateMetadataCallback)`
  void updateMetadata(
    jni.JArray<jni.jbyte> bs,
    OfflineRegion_OfflineRegionUpdateMetadataCallback
        offlineRegionUpdateMetadataCallback,
  ) {
    _updateMetadata(
            reference.pointer,
            _id_updateMetadata as jni.JMethodIDPtr,
            bs.reference.pointer,
            offlineRegionUpdateMetadataCallback.reference.pointer)
        .check();
  }

  static final _id_finalize = _class.instanceMethodId(
    r'finalize',
    r'()V',
  );

  static final _finalize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `protected native final void finalize()`
  void finalize() {
    _finalize(reference.pointer, _id_finalize as jni.JMethodIDPtr).check();
  }
}

final class $OfflineRegionType extends jni.JObjType<OfflineRegion> {
  const $OfflineRegionType();

  @override
  String get signature => r'Lorg/maplibre/android/offline/OfflineRegion;';

  @override
  OfflineRegion fromReference(jni.JReference reference) =>
      OfflineRegion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OfflineRegionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OfflineRegionType) &&
        other is $OfflineRegionType;
  }
}
