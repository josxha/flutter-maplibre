// Autogenerated from Pigeon (v22.4.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#include "pigeon.g.h"

struct _MaplibreLngLat {
  GObject parent_instance;

  double lng;
  double lat;
};

G_DEFINE_TYPE(MaplibreLngLat, maplibre_lng_lat, G_TYPE_OBJECT)

static void maplibre_lng_lat_dispose(GObject* object) {
  G_OBJECT_CLASS(maplibre_lng_lat_parent_class)->dispose(object);
}

static void maplibre_lng_lat_init(MaplibreLngLat* self) {
}

static void maplibre_lng_lat_class_init(MaplibreLngLatClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = maplibre_lng_lat_dispose;
}

MaplibreLngLat* maplibre_lng_lat_new(double lng, double lat) {
  MaplibreLngLat* self = MAPLIBRE_LNG_LAT(g_object_new(maplibre_lng_lat_get_type(), nullptr));
  self->lng = lng;
  self->lat = lat;
  return self;
}

double maplibre_lng_lat_get_lng(MaplibreLngLat* self) {
  g_return_val_if_fail(MAPLIBRE_IS_LNG_LAT(self), 0.0);
  return self->lng;
}

double maplibre_lng_lat_get_lat(MaplibreLngLat* self) {
  g_return_val_if_fail(MAPLIBRE_IS_LNG_LAT(self), 0.0);
  return self->lat;
}

static FlValue* maplibre_lng_lat_to_list(MaplibreLngLat* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_float(self->lng));
  fl_value_append_take(values, fl_value_new_float(self->lat));
  return values;
}

static MaplibreLngLat* maplibre_lng_lat_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  double lng = fl_value_get_float(value0);
  FlValue* value1 = fl_value_get_list_value(values, 1);
  double lat = fl_value_get_float(value1);
  return maplibre_lng_lat_new(lng, lat);
}

struct _MaplibreScreenLocation {
  GObject parent_instance;

  double x;
  double y;
};

G_DEFINE_TYPE(MaplibreScreenLocation, maplibre_screen_location, G_TYPE_OBJECT)

static void maplibre_screen_location_dispose(GObject* object) {
  G_OBJECT_CLASS(maplibre_screen_location_parent_class)->dispose(object);
}

static void maplibre_screen_location_init(MaplibreScreenLocation* self) {
}

static void maplibre_screen_location_class_init(MaplibreScreenLocationClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = maplibre_screen_location_dispose;
}

MaplibreScreenLocation* maplibre_screen_location_new(double x, double y) {
  MaplibreScreenLocation* self = MAPLIBRE_SCREEN_LOCATION(g_object_new(maplibre_screen_location_get_type(), nullptr));
  self->x = x;
  self->y = y;
  return self;
}

double maplibre_screen_location_get_x(MaplibreScreenLocation* self) {
  g_return_val_if_fail(MAPLIBRE_IS_SCREEN_LOCATION(self), 0.0);
  return self->x;
}

double maplibre_screen_location_get_y(MaplibreScreenLocation* self) {
  g_return_val_if_fail(MAPLIBRE_IS_SCREEN_LOCATION(self), 0.0);
  return self->y;
}

static FlValue* maplibre_screen_location_to_list(MaplibreScreenLocation* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_float(self->x));
  fl_value_append_take(values, fl_value_new_float(self->y));
  return values;
}

static MaplibreScreenLocation* maplibre_screen_location_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  double x = fl_value_get_float(value0);
  FlValue* value1 = fl_value_get_list_value(values, 1);
  double y = fl_value_get_float(value1);
  return maplibre_screen_location_new(x, y);
}

struct _MaplibreMapCamera {
  GObject parent_instance;

  MaplibreLngLat* center;
  double zoom;
  double tilt;
  double bearing;
};

G_DEFINE_TYPE(MaplibreMapCamera, maplibre_map_camera, G_TYPE_OBJECT)

static void maplibre_map_camera_dispose(GObject* object) {
  MaplibreMapCamera* self = MAPLIBRE_MAP_CAMERA(object);
  g_clear_object(&self->center);
  G_OBJECT_CLASS(maplibre_map_camera_parent_class)->dispose(object);
}

static void maplibre_map_camera_init(MaplibreMapCamera* self) {
}

static void maplibre_map_camera_class_init(MaplibreMapCameraClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = maplibre_map_camera_dispose;
}

MaplibreMapCamera* maplibre_map_camera_new(MaplibreLngLat* center, double zoom, double tilt, double bearing) {
  MaplibreMapCamera* self = MAPLIBRE_MAP_CAMERA(g_object_new(maplibre_map_camera_get_type(), nullptr));
  self->center = MAPLIBRE_LNG_LAT(g_object_ref(center));
  self->zoom = zoom;
  self->tilt = tilt;
  self->bearing = bearing;
  return self;
}

MaplibreLngLat* maplibre_map_camera_get_center(MaplibreMapCamera* self) {
  g_return_val_if_fail(MAPLIBRE_IS_MAP_CAMERA(self), nullptr);
  return self->center;
}

double maplibre_map_camera_get_zoom(MaplibreMapCamera* self) {
  g_return_val_if_fail(MAPLIBRE_IS_MAP_CAMERA(self), 0.0);
  return self->zoom;
}

double maplibre_map_camera_get_tilt(MaplibreMapCamera* self) {
  g_return_val_if_fail(MAPLIBRE_IS_MAP_CAMERA(self), 0.0);
  return self->tilt;
}

double maplibre_map_camera_get_bearing(MaplibreMapCamera* self) {
  g_return_val_if_fail(MAPLIBRE_IS_MAP_CAMERA(self), 0.0);
  return self->bearing;
}

static FlValue* maplibre_map_camera_to_list(MaplibreMapCamera* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_custom_object(131, G_OBJECT(self->center)));
  fl_value_append_take(values, fl_value_new_float(self->zoom));
  fl_value_append_take(values, fl_value_new_float(self->tilt));
  fl_value_append_take(values, fl_value_new_float(self->bearing));
  return values;
}

static MaplibreMapCamera* maplibre_map_camera_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  MaplibreLngLat* center = MAPLIBRE_LNG_LAT(fl_value_get_custom_value_object(value0));
  FlValue* value1 = fl_value_get_list_value(values, 1);
  double zoom = fl_value_get_float(value1);
  FlValue* value2 = fl_value_get_list_value(values, 2);
  double tilt = fl_value_get_float(value2);
  FlValue* value3 = fl_value_get_list_value(values, 3);
  double bearing = fl_value_get_float(value3);
  return maplibre_map_camera_new(center, zoom, tilt, bearing);
}

struct _MaplibreLngLatBounds {
  GObject parent_instance;

  double longitude_west;
  double longitude_east;
  double latitude_south;
  double latitude_north;
};

G_DEFINE_TYPE(MaplibreLngLatBounds, maplibre_lng_lat_bounds, G_TYPE_OBJECT)

static void maplibre_lng_lat_bounds_dispose(GObject* object) {
  G_OBJECT_CLASS(maplibre_lng_lat_bounds_parent_class)->dispose(object);
}

static void maplibre_lng_lat_bounds_init(MaplibreLngLatBounds* self) {
}

static void maplibre_lng_lat_bounds_class_init(MaplibreLngLatBoundsClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = maplibre_lng_lat_bounds_dispose;
}

MaplibreLngLatBounds* maplibre_lng_lat_bounds_new(double longitude_west, double longitude_east, double latitude_south, double latitude_north) {
  MaplibreLngLatBounds* self = MAPLIBRE_LNG_LAT_BOUNDS(g_object_new(maplibre_lng_lat_bounds_get_type(), nullptr));
  self->longitude_west = longitude_west;
  self->longitude_east = longitude_east;
  self->latitude_south = latitude_south;
  self->latitude_north = latitude_north;
  return self;
}

double maplibre_lng_lat_bounds_get_longitude_west(MaplibreLngLatBounds* self) {
  g_return_val_if_fail(MAPLIBRE_IS_LNG_LAT_BOUNDS(self), 0.0);
  return self->longitude_west;
}

double maplibre_lng_lat_bounds_get_longitude_east(MaplibreLngLatBounds* self) {
  g_return_val_if_fail(MAPLIBRE_IS_LNG_LAT_BOUNDS(self), 0.0);
  return self->longitude_east;
}

double maplibre_lng_lat_bounds_get_latitude_south(MaplibreLngLatBounds* self) {
  g_return_val_if_fail(MAPLIBRE_IS_LNG_LAT_BOUNDS(self), 0.0);
  return self->latitude_south;
}

double maplibre_lng_lat_bounds_get_latitude_north(MaplibreLngLatBounds* self) {
  g_return_val_if_fail(MAPLIBRE_IS_LNG_LAT_BOUNDS(self), 0.0);
  return self->latitude_north;
}

static FlValue* maplibre_lng_lat_bounds_to_list(MaplibreLngLatBounds* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_float(self->longitude_west));
  fl_value_append_take(values, fl_value_new_float(self->longitude_east));
  fl_value_append_take(values, fl_value_new_float(self->latitude_south));
  fl_value_append_take(values, fl_value_new_float(self->latitude_north));
  return values;
}

static MaplibreLngLatBounds* maplibre_lng_lat_bounds_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  double longitude_west = fl_value_get_float(value0);
  FlValue* value1 = fl_value_get_list_value(values, 1);
  double longitude_east = fl_value_get_float(value1);
  FlValue* value2 = fl_value_get_list_value(values, 2);
  double latitude_south = fl_value_get_float(value2);
  FlValue* value3 = fl_value_get_list_value(values, 3);
  double latitude_north = fl_value_get_float(value3);
  return maplibre_lng_lat_bounds_new(longitude_west, longitude_east, latitude_south, latitude_north);
}

G_DECLARE_FINAL_TYPE(MaplibreMessageCodec, maplibre_message_codec, MAPLIBRE, MESSAGE_CODEC, FlStandardMessageCodec)

struct _MaplibreMessageCodec {
  FlStandardMessageCodec parent_instance;

};

G_DEFINE_TYPE(MaplibreMessageCodec, maplibre_message_codec, fl_standard_message_codec_get_type())

static gboolean maplibre_message_codec_write_maplibre_tile_scheme(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 129;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean maplibre_message_codec_write_maplibre_raster_dem_encoding(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 130;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean maplibre_message_codec_write_maplibre_lng_lat(FlStandardMessageCodec* codec, GByteArray* buffer, MaplibreLngLat* value, GError** error) {
  uint8_t type = 131;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = maplibre_lng_lat_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean maplibre_message_codec_write_maplibre_screen_location(FlStandardMessageCodec* codec, GByteArray* buffer, MaplibreScreenLocation* value, GError** error) {
  uint8_t type = 132;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = maplibre_screen_location_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean maplibre_message_codec_write_maplibre_map_camera(FlStandardMessageCodec* codec, GByteArray* buffer, MaplibreMapCamera* value, GError** error) {
  uint8_t type = 133;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = maplibre_map_camera_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean maplibre_message_codec_write_maplibre_lng_lat_bounds(FlStandardMessageCodec* codec, GByteArray* buffer, MaplibreLngLatBounds* value, GError** error) {
  uint8_t type = 134;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = maplibre_lng_lat_bounds_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean maplibre_message_codec_write_value(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  if (fl_value_get_type(value) == FL_VALUE_TYPE_CUSTOM) {
    switch (fl_value_get_custom_type(value)) {
      case 129:
        return maplibre_message_codec_write_maplibre_tile_scheme(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 130:
        return maplibre_message_codec_write_maplibre_raster_dem_encoding(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 131:
        return maplibre_message_codec_write_maplibre_lng_lat(codec, buffer, MAPLIBRE_LNG_LAT(fl_value_get_custom_value_object(value)), error);
      case 132:
        return maplibre_message_codec_write_maplibre_screen_location(codec, buffer, MAPLIBRE_SCREEN_LOCATION(fl_value_get_custom_value_object(value)), error);
      case 133:
        return maplibre_message_codec_write_maplibre_map_camera(codec, buffer, MAPLIBRE_MAP_CAMERA(fl_value_get_custom_value_object(value)), error);
      case 134:
        return maplibre_message_codec_write_maplibre_lng_lat_bounds(codec, buffer, MAPLIBRE_LNG_LAT_BOUNDS(fl_value_get_custom_value_object(value)), error);
    }
  }

  return FL_STANDARD_MESSAGE_CODEC_CLASS(maplibre_message_codec_parent_class)->write_value(codec, buffer, value, error);
}

static FlValue* maplibre_message_codec_read_maplibre_tile_scheme(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(129, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* maplibre_message_codec_read_maplibre_raster_dem_encoding(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(130, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* maplibre_message_codec_read_maplibre_lng_lat(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(MaplibreLngLat) value = maplibre_lng_lat_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(131, G_OBJECT(value));
}

static FlValue* maplibre_message_codec_read_maplibre_screen_location(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(MaplibreScreenLocation) value = maplibre_screen_location_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(132, G_OBJECT(value));
}

static FlValue* maplibre_message_codec_read_maplibre_map_camera(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(MaplibreMapCamera) value = maplibre_map_camera_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(133, G_OBJECT(value));
}

static FlValue* maplibre_message_codec_read_maplibre_lng_lat_bounds(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(MaplibreLngLatBounds) value = maplibre_lng_lat_bounds_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(134, G_OBJECT(value));
}

static FlValue* maplibre_message_codec_read_value_of_type(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, int type, GError** error) {
  switch (type) {
    case 129:
      return maplibre_message_codec_read_maplibre_tile_scheme(codec, buffer, offset, error);
    case 130:
      return maplibre_message_codec_read_maplibre_raster_dem_encoding(codec, buffer, offset, error);
    case 131:
      return maplibre_message_codec_read_maplibre_lng_lat(codec, buffer, offset, error);
    case 132:
      return maplibre_message_codec_read_maplibre_screen_location(codec, buffer, offset, error);
    case 133:
      return maplibre_message_codec_read_maplibre_map_camera(codec, buffer, offset, error);
    case 134:
      return maplibre_message_codec_read_maplibre_lng_lat_bounds(codec, buffer, offset, error);
    default:
      return FL_STANDARD_MESSAGE_CODEC_CLASS(maplibre_message_codec_parent_class)->read_value_of_type(codec, buffer, offset, type, error);
  }
}

static void maplibre_message_codec_init(MaplibreMessageCodec* self) {
}

static void maplibre_message_codec_class_init(MaplibreMessageCodecClass* klass) {
  FL_STANDARD_MESSAGE_CODEC_CLASS(klass)->write_value = maplibre_message_codec_write_value;
  FL_STANDARD_MESSAGE_CODEC_CLASS(klass)->read_value_of_type = maplibre_message_codec_read_value_of_type;
}

static MaplibreMessageCodec* maplibre_message_codec_new() {
  MaplibreMessageCodec* self = MAPLIBRE_MESSAGE_CODEC(g_object_new(maplibre_message_codec_get_type(), nullptr));
  return self;
}
